!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.7	//
ALIAS	.\FastMalloc.cpp	4276;"	d	file:
ALIAS	.\FastMalloc.cpp	4286;"	d	file:
ALLOW_HEX	.\dtoa\double-conversion.h	/^            ALLOW_HEX = 1,$/;"	e	enum:WTF::double_conversion::StringToDoubleConverter::Flags
ALLOW_LEADING_SPACES	.\dtoa\double-conversion.h	/^            ALLOW_LEADING_SPACES = 8,$/;"	e	enum:WTF::double_conversion::StringToDoubleConverter::Flags
ALLOW_OCTALS	.\dtoa\double-conversion.h	/^            ALLOW_OCTALS = 2,$/;"	e	enum:WTF::double_conversion::StringToDoubleConverter::Flags
ALLOW_SPACES_AFTER_SIGN	.\dtoa\double-conversion.h	/^            ALLOW_SPACES_AFTER_SIGN = 32$/;"	e	enum:WTF::double_conversion::StringToDoubleConverter::Flags
ALLOW_TRAILING_JUNK	.\dtoa\double-conversion.h	/^            ALLOW_TRAILING_JUNK = 4,$/;"	e	enum:WTF::double_conversion::StringToDoubleConverter::Flags
ALLOW_TRAILING_SPACES	.\dtoa\double-conversion.h	/^            ALLOW_TRAILING_SPACES = 16,$/;"	e	enum:WTF::double_conversion::StringToDoubleConverter::Flags
ALWAYS_INLINE	.\Compiler.h	136;"	d
ALWAYS_INLINE	.\Compiler.h	138;"	d
ALWAYS_INLINE	.\Compiler.h	140;"	d
ARC4RandomNumberGenerator	.\CryptographicallyRandomNumber.cpp	/^    ARC4RandomNumberGenerator();$/;"	p	class:WTF::__anon3::ARC4RandomNumberGenerator	file:	access:public	signature:()
ARC4RandomNumberGenerator	.\CryptographicallyRandomNumber.cpp	/^ARC4RandomNumberGenerator::ARC4RandomNumberGenerator()$/;"	f	class:WTF::__anon3::ARC4RandomNumberGenerator	signature:()
ARC4RandomNumberGenerator	.\CryptographicallyRandomNumber.cpp	/^class ARC4RandomNumberGenerator {$/;"	c	namespace:WTF::__anon3	file:
ARC4Stream	.\CryptographicallyRandomNumber.cpp	/^    ARC4Stream();$/;"	p	class:WTF::__anon3::ARC4Stream	file:	access:public	signature:()
ARC4Stream	.\CryptographicallyRandomNumber.cpp	/^ARC4Stream::ARC4Stream()$/;"	f	class:WTF::__anon3::ARC4Stream	signature:()
ARC4Stream	.\CryptographicallyRandomNumber.cpp	/^class ARC4Stream {$/;"	c	namespace:WTF::__anon3	file:
ARRAY_SIZE	.\dtoa\utils.h	94;"	d
ASCIIFastPath_h	.\text\ASCIIFastPath.h	23;"	d
ASSERT	.\Assertions.h	225;"	d
ASSERT	.\Assertions.h	230;"	d
ASSERT	.\Assertions.h	245;"	d
ASSERTIONS_DISABLED_DEFAULT	.\Assertions.h	55;"	d
ASSERTIONS_DISABLED_DEFAULT	.\Assertions.h	57;"	d
ASSERT_ARG	.\Assertions.h	311;"	d
ASSERT_ARG	.\Assertions.h	315;"	d
ASSERT_ARG_DISABLED	.\Assertions.h	83;"	d
ASSERT_AT	.\Assertions.h	231;"	d
ASSERT_AT	.\Assertions.h	252;"	d
ASSERT_DISABLED	.\Assertions.h	71;"	d
ASSERT_MSG_DISABLED	.\Assertions.h	76;"	d
ASSERT_MSG_DISABLED	.\Assertions.h	78;"	d
ASSERT_NOT_REACHED	.\Assertions.h	232;"	d
ASSERT_NOT_REACHED	.\Assertions.h	259;"	d
ASSERT_SPAN_COMMITTED	.\FastMalloc.cpp	1133;"	d	file:
ASSERT_UNUSED	.\Assertions.h	238;"	d
ASSERT_UNUSED	.\Assertions.h	240;"	d
ASSERT_UNUSED	.\Assertions.h	264;"	d
ASSERT_WITH_MESSAGE	.\Assertions.h	273;"	d
ASSERT_WITH_MESSAGE	.\Assertions.h	275;"	d
ASSERT_WITH_MESSAGE	.\Assertions.h	277;"	d
ASSERT_WITH_MESSAGE_UNUSED	.\Assertions.h	288;"	d
ASSERT_WITH_MESSAGE_UNUSED	.\Assertions.h	293;"	d
ASSERT_WITH_MESSAGE_UNUSED	.\Assertions.h	295;"	d
ASSERT_WITH_MESSAGE_UNUSED	.\Assertions.h	298;"	d
ATOMICSTRING_CONVERSION	.\text\AtomicString.h	30;"	d
ATOMICSTRING_CONVERSION	.\text\AtomicString.h	32;"	d
ATOMICSTRING_HIDE_GLOBALS	.\text\StringStatics.cpp	29;"	d	file:
AVLTree	.\AVLTree.h	/^    AVLTree() { abs.root = null(); }$/;"	f	class:WTF::AVLTree	access:public	signature:()
AVLTree	.\AVLTree.h	/^class AVLTree {$/;"	c	namespace:WTF
AVLTreeDefaultBSet	.\AVLTree.h	/^class AVLTreeDefaultBSet {$/;"	c	namespace:WTF
AVL_TREE_H_	.\AVLTree.h	33;"	d
AddBignum	.\dtoa\bignum.cc	/^    void Bignum::AddBignum(const Bignum& other) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(const Bignum& other)
AddBignum	.\dtoa\bignum.h	/^        void AddBignum(const Bignum& other);$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(const Bignum& other)
AddCharacter	.\dtoa\utils.h	/^        void AddCharacter(char c) {$/;"	f	class:WTF::double_conversion::StringBuilder	access:public	signature:(char c)
AddPadding	.\dtoa\utils.h	/^        void AddPadding(char c, int count) {$/;"	f	class:WTF::double_conversion::StringBuilder	access:public	signature:(char c, int count)
AddString	.\dtoa\utils.h	/^        void AddString(const char* s) {$/;"	f	class:WTF::double_conversion::StringBuilder	access:public	signature:(const char* s)
AddSubstring	.\dtoa\utils.h	/^        void AddSubstring(const char* s, int n) {$/;"	f	class:WTF::double_conversion::StringBuilder	access:public	signature:(const char* s, int n)
AddUInt16	.\dtoa\bignum.h	/^        void AddUInt16(uint16_t operand);$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(uint16_t operand)
AddUInt64	.\dtoa\bignum.cc	/^    void Bignum::AddUInt64(uint64_t operand) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(uint64_t operand)
AddUInt64	.\dtoa\bignum.h	/^        void AddUInt64(uint64_t operand);$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(uint64_t operand)
AdjustmentPowerOfTen	.\dtoa\strtod.cc	/^    static DiyFp AdjustmentPowerOfTen(int exponent) {$/;"	f	namespace:WTF::double_conversion	file:	signature:(int exponent)
AdminRegionRecorder	.\FastMalloc.cpp	/^    AdminRegionRecorder(task_t task, void* context, unsigned typeMask, vm_range_recorder_t* recorder, const RemoteMemoryReader& reader)$/;"	f	class:WTF::AdminRegionRecorder	access:public	signature:(task_t task, void* context, unsigned typeMask, vm_range_recorder_t* recorder, const RemoteMemoryReader& reader)
AdminRegionRecorder	.\FastMalloc.cpp	/^class AdminRegionRecorder {$/;"	c	namespace:WTF	file:
AdoptCF	.\RetainPtr.h	/^    enum AdoptCFTag { AdoptCF };$/;"	e	enum:WTF::AdoptCFTag
AdoptCFTag	.\RetainPtr.h	/^    enum AdoptCFTag { AdoptCF };$/;"	g	namespace:WTF
AdoptNS	.\RetainPtr.h	/^    enum AdoptNSTag { AdoptNS };$/;"	e	enum:WTF::AdoptNSTag
AdoptNSTag	.\RetainPtr.h	/^    enum AdoptNSTag { AdoptNS };$/;"	g	namespace:WTF
AdvanceToNonspace	.\dtoa\double-conversion.cc	/^    static inline bool AdvanceToNonspace(const char** current, const char* end) {$/;"	f	namespace:WTF::double_conversion	file:	signature:(const char** current, const char* end)
Align	.\dtoa\bignum.cc	/^    void Bignum::Align(const Bignum& other) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(const Bignum& other)
Align	.\dtoa\bignum.h	/^        void Align(const Bignum& other);$/;"	p	class:WTF::double_conversion::Bignum	access:private	signature:(const Bignum& other)
AlignedBuffer	.\Alignment.h	/^    template<size_t size> struct AlignedBuffer<size, 16> { WTF_ALIGNED(AlignedBufferChar, buffer[size], 16); };$/;"	s	namespace:WTF
AlignedBuffer	.\Alignment.h	/^    template<size_t size> struct AlignedBuffer<size, 1> { AlignedBufferChar buffer[size]; };$/;"	s	namespace:WTF
AlignedBuffer	.\Alignment.h	/^    template<size_t size> struct AlignedBuffer<size, 2> { WTF_ALIGNED(AlignedBufferChar, buffer[size], 2);  };$/;"	s	namespace:WTF
AlignedBuffer	.\Alignment.h	/^    template<size_t size> struct AlignedBuffer<size, 32> { WTF_ALIGNED(AlignedBufferChar, buffer[size], 32); };$/;"	s	namespace:WTF
AlignedBuffer	.\Alignment.h	/^    template<size_t size> struct AlignedBuffer<size, 4> { WTF_ALIGNED(AlignedBufferChar, buffer[size], 4);  };$/;"	s	namespace:WTF
AlignedBuffer	.\Alignment.h	/^    template<size_t size> struct AlignedBuffer<size, 64> { WTF_ALIGNED(AlignedBufferChar, buffer[size], 64); };$/;"	s	namespace:WTF
AlignedBuffer	.\Alignment.h	/^    template<size_t size> struct AlignedBuffer<size, 8> { WTF_ALIGNED(AlignedBufferChar, buffer[size], 8);  };$/;"	s	namespace:WTF
AlignedBufferChar	.\Alignment.h	/^    typedef char __attribute__((__may_alias__)) AlignedBufferChar; $/;"	t	namespace:WTF
AllocAlignmentInteger	.\FastMalloc.h	/^    typedef unsigned long long AllocAlignmentInteger;$/;"	t	namespace:WTF
AllocAlignmentInteger	.\wince\FastMallocWinCE.h	/^    typedef unsigned long long AllocAlignmentInteger;$/;"	t	namespace:WTF
AllocLarge	.\FastMalloc.cpp	/^  Span* AllocLarge(Length n);$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:private	signature:(Length n)
AllocLarge	.\FastMalloc.cpp	/^Span* TCMalloc_PageHeap::AllocLarge(Length n) {$/;"	f	class:WTF::TCMalloc_PageHeap	signature:(Length n)
AllocType	.\FastMalloc.h	/^        enum AllocType {                    \/\/ Start with an unusual number instead of zero, because zero is common.$/;"	g	namespace:WTF::Internal
AllocType	.\wince\FastMallocWinCE.h	/^        enum AllocType {                    \/\/ Start with an unusual number instead of zero, because zero is common.$/;"	g	namespace:WTF::Internal
AllocTypeClassNew	.\FastMalloc.h	/^            AllocTypeClassNew,              \/\/ Encompasses class operator new from FastAllocBase.$/;"	e	enum:WTF::Internal::AllocType
AllocTypeClassNew	.\wince\FastMallocWinCE.h	/^            AllocTypeClassNew,              \/\/ Encompasses class operator new from FastAllocBase.$/;"	e	enum:WTF::Internal::AllocType
AllocTypeClassNewArray	.\FastMalloc.h	/^            AllocTypeClassNewArray,         \/\/ Encompasses class operator new[] from FastAllocBase.$/;"	e	enum:WTF::Internal::AllocType
AllocTypeClassNewArray	.\wince\FastMallocWinCE.h	/^            AllocTypeClassNewArray,         \/\/ Encompasses class operator new[] from FastAllocBase.$/;"	e	enum:WTF::Internal::AllocType
AllocTypeFastNew	.\FastMalloc.h	/^            AllocTypeFastNew,               \/\/ Encompasses fastNew.$/;"	e	enum:WTF::Internal::AllocType
AllocTypeFastNew	.\wince\FastMallocWinCE.h	/^            AllocTypeFastNew,               \/\/ Encompasses fastNew.$/;"	e	enum:WTF::Internal::AllocType
AllocTypeFastNewArray	.\FastMalloc.h	/^            AllocTypeFastNewArray,          \/\/ Encompasses fastNewArray.$/;"	e	enum:WTF::Internal::AllocType
AllocTypeFastNewArray	.\wince\FastMallocWinCE.h	/^            AllocTypeFastNewArray,          \/\/ Encompasses fastNewArray.$/;"	e	enum:WTF::Internal::AllocType
AllocTypeMalloc	.\FastMalloc.h	/^            AllocTypeMalloc = 0x375d6750,   \/\/ Encompasses fastMalloc, fastZeroedMalloc, fastCalloc, fastRealloc.$/;"	e	enum:WTF::Internal::AllocType
AllocTypeMalloc	.\wince\FastMallocWinCE.h	/^            AllocTypeMalloc = 0x375d6750,   \/\/ Encompasses fastMalloc, fastZeroedMalloc, fastCalloc, fastRealloc.$/;"	e	enum:WTF::Internal::AllocType
AllocTypeNew	.\FastMalloc.h	/^            AllocTypeNew,                   \/\/ Encompasses global operator new.$/;"	e	enum:WTF::Internal::AllocType
AllocTypeNew	.\wince\FastMallocWinCE.h	/^            AllocTypeNew,                   \/\/ Encompasses global operator new.$/;"	e	enum:WTF::Internal::AllocType
AllocTypeNewArray	.\FastMalloc.h	/^            AllocTypeNewArray               \/\/ Encompasses global operator new[].$/;"	e	enum:WTF::Internal::AllocType
AllocTypeNewArray	.\wince\FastMallocWinCE.h	/^            AllocTypeNewArray               \/\/ Encompasses global operator new[].$/;"	e	enum:WTF::Internal::AllocType
Allocate	.\FastMalloc.cpp	/^  ALWAYS_INLINE void* Allocate(size_t size);$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:(size_t size)
Allocate	.\FastMalloc.cpp	/^ALWAYS_INLINE void* TCMalloc_ThreadCache::Allocate(size_t size) {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:(size_t size)
AllocationSize	.\FastMalloc.cpp	/^static size_t AllocationSize(size_t bytes) {$/;"	f	namespace:WTF	file:	signature:(size_t bytes)
AllowTrailingJunk	.\dtoa.h	/^enum AllowTrailingJunkTag { DisallowTrailingJunk = 0, AllowTrailingJunk };$/;"	e	enum:WTF::AllowTrailingJunkTag
AllowTrailingJunkTag	.\dtoa.h	/^enum AllowTrailingJunkTag { DisallowTrailingJunk = 0, AllowTrailingJunk };$/;"	g	namespace:WTF
AllowTrailingSpaces	.\dtoa.h	/^enum AllowTrailingSpacesTag { DisallowTrailingSpaces = 0, AllowTrailingSpaces };$/;"	e	enum:WTF::AllowTrailingSpacesTag
AllowTrailingSpacesTag	.\dtoa.h	/^enum AllowTrailingSpacesTag { DisallowTrailingSpaces = 0, AllowTrailingSpaces };$/;"	g	namespace:WTF
AlreadyHashed	.\text\StringHash.h	/^    struct AlreadyHashed : IntHash<unsigned> {$/;"	s	namespace:WTF	inherits:IntHash
ArabicNumber	.\unicode\glib\UnicodeGLib.h	/^    ArabicNumber,$/;"	e	enum:WTF::Unicode::Direction
ArabicNumber	.\unicode\icu\UnicodeIcu.h	/^    ArabicNumber = U_ARABIC_NUMBER,$/;"	e	enum:WTF::Unicode::Direction
ArabicNumber	.\unicode\qt4\UnicodeQt4.h	/^    ArabicNumber = QChar::DirAN,$/;"	e	enum:WTF::Unicode::Direction
ArabicNumber	.\unicode\wince\UnicodeWinCE.h	/^    ArabicNumber = UnicodeCE::U_ARABIC_NUMBER,$/;"	e	enum:WTF::Unicode::Direction
ArithmeticOperations	.\CheckedArithmetic.h	/^template <typename LHS, typename RHS, typename ResultType> struct ArithmeticOperations<LHS, RHS, ResultType, false, false> {$/;"	s	namespace:WTF
ArithmeticOperations	.\CheckedArithmetic.h	/^template <typename LHS, typename RHS, typename ResultType> struct ArithmeticOperations<LHS, RHS, ResultType, true, true> {$/;"	s	namespace:WTF
ArithmeticOperations	.\CheckedArithmetic.h	/^template <typename ResultType> struct ArithmeticOperations<int, unsigned, ResultType, true, false> {$/;"	s	namespace:WTF
ArithmeticOperations	.\CheckedArithmetic.h	/^template <typename ResultType> struct ArithmeticOperations<unsigned, int, ResultType, false, true> {$/;"	s	namespace:WTF
ArrayBuffer	.\ArrayBuffer.h	/^    inline ArrayBuffer(ArrayBufferContents&);$/;"	p	class:WTF::ArrayBuffer	access:private	signature:(ArrayBufferContents&)
ArrayBuffer	.\ArrayBuffer.h	/^ArrayBuffer::ArrayBuffer(ArrayBufferContents& contents)$/;"	f	class:WTF::ArrayBuffer	signature:(ArrayBufferContents& contents)
ArrayBuffer	.\ArrayBuffer.h	/^class ArrayBuffer : public RefCounted<ArrayBuffer> {$/;"	c	namespace:WTF	inherits:RefCounted
ArrayBufferContents	.\ArrayBuffer.h	/^    ArrayBufferContents() $/;"	f	class:WTF::ArrayBufferContents	access:public	signature:()
ArrayBufferContents	.\ArrayBuffer.h	/^    ArrayBufferContents(void* data, unsigned sizeInBytes) $/;"	f	class:WTF::ArrayBufferContents	access:private	signature:(void* data, unsigned sizeInBytes)
ArrayBufferContents	.\ArrayBuffer.h	/^class ArrayBufferContents {$/;"	c	namespace:WTF
ArrayBufferView	.\ArrayBufferView.cpp	/^ArrayBufferView::ArrayBufferView(PassRefPtr<ArrayBuffer> buffer,$/;"	f	class:WTF::ArrayBufferView	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset)
ArrayBufferView	.\ArrayBufferView.h	/^    WTF_EXPORT_PRIVATE ArrayBufferView(PassRefPtr<ArrayBuffer>, unsigned byteOffset);$/;"	p	class:WTF::ArrayBufferView	access:protected	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset)
ArrayBufferView	.\ArrayBufferView.h	/^class WTF_EXPORT_PRIVATE_RTTI ArrayBufferView : public RefCounted<ArrayBufferView> {$/;"	c	namespace:WTF	inherits:RefCounted
ArrayBufferView_h	.\ArrayBufferView.h	27;"	d
ArrayBuffer_h	.\ArrayBuffer.h	27;"	d
ArrayLengthHelperFunction	.\StdLibExtras.h	/^template<typename T, size_t Size> char (&ArrayLengthHelperFunction(T (&)[Size]))[Size];$/;"	p	namespace:WTF	signature:(T (
ArraySize	.\FastAllocBase.h	/^        union ArraySize {$/;"	u	namespace:WTF::Internal
AsDiyFp	.\dtoa\double.h	/^        DiyFp AsDiyFp() const {$/;"	f	class:WTF::double_conversion::Double	access:public	signature:() const
AsNormalizedDiyFp	.\dtoa\double.h	/^        DiyFp AsNormalizedDiyFp() const {$/;"	f	class:WTF::double_conversion::Double	access:public	signature:() const
AsUint64	.\dtoa\double.h	/^        uint64_t AsUint64() const {$/;"	f	class:WTF::double_conversion::Double	access:public	signature:() const
AssignBignum	.\dtoa\bignum.cc	/^    void Bignum::AssignBignum(const Bignum& other) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(const Bignum& other)
AssignBignum	.\dtoa\bignum.h	/^        void AssignBignum(const Bignum& other);$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(const Bignum& other)
AssignDecimalString	.\dtoa\bignum.cc	/^    void Bignum::AssignDecimalString(Vector<const char> value) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(Vector<const char> value)
AssignDecimalString	.\dtoa\bignum.h	/^        void AssignDecimalString(Vector<const char> value);$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(Vector<const char> value)
AssignHexString	.\dtoa\bignum.cc	/^    void Bignum::AssignHexString(Vector<const char> value) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(Vector<const char> value)
AssignHexString	.\dtoa\bignum.h	/^        void AssignHexString(Vector<const char> value);$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(Vector<const char> value)
AssignPowerUInt16	.\dtoa\bignum.cc	/^    void Bignum::AssignPowerUInt16(uint16_t base, int power_exponent) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(uint16_t base, int power_exponent)
AssignPowerUInt16	.\dtoa\bignum.h	/^        void AssignPowerUInt16(uint16_t base, int exponent);$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(uint16_t base, int exponent)
AssignUInt16	.\dtoa\bignum.cc	/^    void Bignum::AssignUInt16(uint16_t value) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(uint16_t value)
AssignUInt16	.\dtoa\bignum.h	/^        void AssignUInt16(uint16_t value);$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(uint16_t value)
AssignUInt64	.\dtoa\bignum.cc	/^    void Bignum::AssignUInt64(uint64_t value) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(uint64_t value)
AssignUInt64	.\dtoa\bignum.h	/^        void AssignUInt64(uint64_t value);$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(uint64_t value)
AtomicString	.\text\AtomicString.h	/^    ATOMICSTRING_CONVERSION AtomicString(StringImpl* imp) : m_string(add(imp)) { }$/;"	f	class:WTF::AtomicString	access:public	signature:(StringImpl* imp)
AtomicString	.\text\AtomicString.h	/^    ATOMICSTRING_CONVERSION AtomicString(const String& s) : m_string(add(s.impl())) { }$/;"	f	class:WTF::AtomicString	access:public	signature:(const String& s)
AtomicString	.\text\AtomicString.h	/^    AtomicString() { }$/;"	f	class:WTF::AtomicString	access:public	signature:()
AtomicString	.\text\AtomicString.h	/^    AtomicString(AtomicStringImpl* imp) : m_string(imp) { }$/;"	f	class:WTF::AtomicString	access:public	signature:(AtomicStringImpl* imp)
AtomicString	.\text\AtomicString.h	/^    AtomicString(CFStringRef s) :  m_string(add(String(s).impl())) { }$/;"	f	class:WTF::AtomicString	access:public	signature:(CFStringRef s)
AtomicString	.\text\AtomicString.h	/^    AtomicString(NSString* s) : m_string(add(String(s).impl())) { }$/;"	f	class:WTF::AtomicString	access:public	signature:(NSString* s)
AtomicString	.\text\AtomicString.h	/^    AtomicString(StringImpl* baseString, unsigned start, unsigned length) : m_string(add(baseString, start, length)) { }$/;"	f	class:WTF::AtomicString	access:public	signature:(StringImpl* baseString, unsigned start, unsigned length)
AtomicString	.\text\AtomicString.h	/^    AtomicString(WTF::HashTableDeletedValueType) : m_string(WTF::HashTableDeletedValue) { }$/;"	f	class:WTF::AtomicString	access:public	signature:(WTF::HashTableDeletedValueType)
AtomicString	.\text\AtomicString.h	/^    AtomicString(const LChar* s) : m_string(add(s)) { }$/;"	f	class:WTF::AtomicString	access:public	signature:(const LChar* s)
AtomicString	.\text\AtomicString.h	/^    AtomicString(const QString& s) : m_string(add(String(s).impl())) { }$/;"	f	class:WTF::AtomicString	access:public	signature:(const QString& s)
AtomicString	.\text\AtomicString.h	/^    AtomicString(const UChar* s) : m_string(add(s)) { }$/;"	f	class:WTF::AtomicString	access:public	signature:(const UChar* s)
AtomicString	.\text\AtomicString.h	/^    AtomicString(const UChar* s, unsigned length) : m_string(add(s, length)) { }$/;"	f	class:WTF::AtomicString	access:public	signature:(const UChar* s, unsigned length)
AtomicString	.\text\AtomicString.h	/^    AtomicString(const UChar* s, unsigned length, unsigned existingHash) : m_string(add(s, length, existingHash)) { }$/;"	f	class:WTF::AtomicString	access:public	signature:(const UChar* s, unsigned length, unsigned existingHash)
AtomicString	.\text\AtomicString.h	/^    AtomicString(const char* s) : m_string(add(s)) { }$/;"	f	class:WTF::AtomicString	access:public	signature:(const char* s)
AtomicString	.\text\AtomicString.h	/^class AtomicString {$/;"	c	namespace:WTF
AtomicStringHash	.\text\AtomicStringHash.h	/^    struct AtomicStringHash {$/;"	s	namespace:WTF
AtomicStringHash_h	.\text\AtomicStringHash.h	30;"	d
AtomicStringImpl	.\text\AtomicStringImpl.h	/^    AtomicStringImpl() : StringImpl(0) {}$/;"	f	class:WTF::AtomicStringImpl	access:public	signature:()
AtomicStringImpl	.\text\AtomicStringImpl.h	/^class AtomicStringImpl : public StringImpl$/;"	c	namespace:WTF	inherits:StringImpl
AtomicStringImpl_h	.\text\AtomicStringImpl.h	22;"	d
AtomicStringTable	.\text\AtomicString.cpp	/^class AtomicStringTable {$/;"	c	namespace:WTF	file:
AtomicStringTableDestructor	.\WTFThreadData.h	/^typedef void (*AtomicStringTableDestructor)(AtomicStringTable*);$/;"	t	namespace:WTF
AtomicString_h	.\text\AtomicString.h	22;"	d
AtomicallyInitializedStatic	.\Threading.h	73;"	d
Atomics_h	.\Atomics.h	60;"	d
BACKTRACE	.\Assertions.h	199;"	d
BACKTRACE	.\Assertions.h	203;"	d
BACKTRACE_DISABLED	.\Assertions.h	67;"	d
BIGNUM_DTOA_FIXED	.\dtoa\bignum-dtoa.h	/^        BIGNUM_DTOA_FIXED,$/;"	e	enum:WTF::double_conversion::BignumDtoaMode
BIGNUM_DTOA_PRECISION	.\dtoa\bignum-dtoa.h	/^        BIGNUM_DTOA_PRECISION$/;"	e	enum:WTF::double_conversion::BignumDtoaMode
BIGNUM_DTOA_SHORTEST	.\dtoa\bignum-dtoa.h	/^        BIGNUM_DTOA_SHORTEST,$/;"	e	enum:WTF::double_conversion::BignumDtoaMode
BITMAPINFO	.\wince\MemoryManager.h	/^typedef struct tagBITMAPINFO BITMAPINFO;$/;"	t	typeref:struct:tagBITMAPINFO
BUILDING_ON_LEOPARD	.\Platform.h	334;"	d
BUILDING_ON_LION	.\Platform.h	338;"	d
BUILDING_ON_SNOW_LEOPARD	.\Platform.h	336;"	d
Base	.\Deque.h	/^        typedef DequeIteratorBase<T, inlineCapacity> Base;$/;"	t	class:WTF::DequeConstIterator	access:private
Base	.\Deque.h	/^        typedef DequeIteratorBase<T, inlineCapacity> Base;$/;"	t	class:WTF::DequeConstReverseIterator	access:private
Base	.\Deque.h	/^        typedef DequeIteratorBase<T, inlineCapacity> Base;$/;"	t	class:WTF::DequeIterator	access:private
Base	.\Deque.h	/^        typedef DequeIteratorBase<T, inlineCapacity> Base;$/;"	t	class:WTF::DequeIteratorBase	access:private
Base	.\Deque.h	/^        typedef DequeIteratorBase<T, inlineCapacity> Base;$/;"	t	class:WTF::DequeReverseIterator	access:private
Base	.\Functional.h	/^    struct Base : public T, public BaseMixin { };$/;"	s	class:WTF::HasRefAndDeref	inherits:T,BaseMixin	access:private
Base	.\Vector.h	/^        typedef VectorBufferBase<T> Base;$/;"	t	class:WTF::VectorBuffer	access:private
BaseMixin	.\Functional.h	/^    struct BaseMixin {$/;"	s	class:WTF::HasRefAndDeref	access:private
BaseTranslator	.\ListHashSet.h	/^        typedef ListHashSetTranslator<HashArg> BaseTranslator;$/;"	t	class:WTF::ListHashSet	access:private
BasicRawSentinelNode	.\SentinelLinkedList.h	/^    BasicRawSentinelNode()$/;"	f	class:WTF::BasicRawSentinelNode	access:public	signature:()
BasicRawSentinelNode	.\SentinelLinkedList.h	/^    BasicRawSentinelNode(SentinelTag)$/;"	f	class:WTF::BasicRawSentinelNode	access:public	signature:(SentinelTag)
BasicRawSentinelNode	.\SentinelLinkedList.h	/^class BasicRawSentinelNode {$/;"	c	namespace:WTF
BecomeIdle	.\FastMalloc.cpp	/^  static void                  BecomeIdle();$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:()
BecomeIdle	.\FastMalloc.cpp	/^void TCMalloc_ThreadCache::BecomeIdle() {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:()
Bias	.\dtoa.cpp	132;"	d	file:
Big0	.\dtoa.cpp	154;"	d	file:
Big1	.\dtoa.cpp	155;"	d	file:
BigInt	.\dtoa.cpp	/^    BigInt() : sign(0) { }$/;"	f	struct:WTF::BigInt	access:public	signature:()
BigInt	.\dtoa.cpp	/^struct BigInt {$/;"	s	namespace:WTF	file:
BiggestPowerTen	.\dtoa\fast-dtoa.cc	/^    static void BiggestPowerTen(uint32_t number,$/;"	f	namespace:WTF::double_conversion	file:	signature:(uint32_t number, int number_bits, uint32_t* power, int* exponent)
BigitAt	.\dtoa\bignum.cc	/^    Bignum::Chunk Bignum::BigitAt(int index) const {$/;"	f	class:WTF::double_conversion::Bignum	signature:(int index) const
BigitAt	.\dtoa\bignum.h	/^        Chunk BigitAt(int index) const;$/;"	p	class:WTF::double_conversion::Bignum	access:private	signature:(int index) const
BigitLength	.\dtoa\bignum.h	/^        int BigitLength() const { return used_digits_ + exponent_; }$/;"	f	class:WTF::double_conversion::Bignum	access:private	signature:() const
BigitsShiftLeft	.\dtoa\bignum.cc	/^    void Bignum::BigitsShiftLeft(int shift_amount) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(int shift_amount)
BigitsShiftLeft	.\dtoa\bignum.h	/^        void BigitsShiftLeft(int shift_amount);$/;"	p	class:WTF::double_conversion::Bignum	access:private	signature:(int shift_amount)
Bignum	.\dtoa\bignum.cc	/^    Bignum::Bignum()$/;"	f	class:WTF::double_conversion::Bignum	signature:()
Bignum	.\dtoa\bignum.h	/^        Bignum();$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:()
Bignum	.\dtoa\bignum.h	/^    class Bignum {$/;"	c	namespace:WTF::double_conversion
BignumDtoa	.\dtoa\bignum-dtoa.cc	/^    void BignumDtoa(double v, BignumDtoaMode mode, int requested_digits,$/;"	f	namespace:WTF::double_conversion	signature:(double v, BignumDtoaMode mode, int requested_digits, Vector<char> buffer, int* length, int* decimal_point)
BignumDtoa	.\dtoa\bignum-dtoa.h	/^    void BignumDtoa(double v, BignumDtoaMode mode, int requested_digits,$/;"	p	namespace:WTF::double_conversion	signature:(double v, BignumDtoaMode mode, int requested_digits, Vector<char> buffer, int* length, int* point)
BignumDtoaMode	.\dtoa\bignum-dtoa.h	/^    enum BignumDtoaMode {$/;"	g	namespace:WTF::double_conversion
BignumStrtod	.\dtoa\strtod.cc	/^    static double BignumStrtod(Vector<const char> buffer,$/;"	f	namespace:WTF::double_conversion	file:	signature:(Vector<const char> buffer, int exponent, double guess)
BignumToFixed	.\dtoa\bignum-dtoa.cc	/^    static void BignumToFixed(int requested_digits, int* decimal_point,$/;"	f	namespace:WTF::double_conversion	file:	signature:(int requested_digits, int* decimal_point, Bignum* numerator, Bignum* denominator, Vector<char>(buffer), int* length)
BignumToFixed	.\dtoa\bignum-dtoa.cc	/^    static void BignumToFixed(int requested_digits, int* decimal_point,$/;"	p	namespace:WTF::double_conversion	file:	signature:(int requested_digits, int* decimal_point, Bignum* numerator, Bignum* denominator, Vector<char>(buffer), int* length)
BinarySearchMode	.\StdLibExtras.h	/^enum BinarySearchMode {$/;"	g	namespace:WTF
BinarySemaphore	.\threads\BinarySemaphore.cpp	/^BinarySemaphore::BinarySemaphore()$/;"	f	class:WTF::BinarySemaphore	signature:()
BinarySemaphore	.\threads\BinarySemaphore.h	/^    BinarySemaphore();$/;"	p	class:WTF::BinarySemaphore	access:public	signature:()
BinarySemaphore	.\threads\BinarySemaphore.h	/^class BinarySemaphore {$/;"	c	namespace:WTF
BinarySemaphore	.\threads\win\BinarySemaphoreWin.cpp	/^BinarySemaphore::BinarySemaphore()$/;"	f	class:WTF::BinarySemaphore	signature:()
BinarySemaphore_h	.\threads\BinarySemaphore.h	27;"	d
BitAt	.\dtoa\fixed-dtoa.cc	/^        int BitAt(int position) {$/;"	f	class:WTF::double_conversion::UInt128	access:public	signature:(int position)
BitCast	.\dtoa\utils.h	/^    inline Dest BitCast(Source* source) {$/;"	f	namespace:WTF::double_conversion	signature:(Source* source)
BitCast	.\dtoa\utils.h	/^    inline Dest BitCast(const Source& source) {$/;"	f	namespace:WTF::double_conversion	signature:(const Source& source)
BitSize	.\dtoa\bignum.cc	/^    static int BitSize(S value) {$/;"	f	namespace:WTF::double_conversion	file:	signature:(S value)
BitVector	.\BitVector.h	/^    BitVector()$/;"	f	class:WTF::BitVector	access:public	signature:()
BitVector	.\BitVector.h	/^    BitVector(const BitVector& other)$/;"	f	class:WTF::BitVector	access:public	signature:(const BitVector& other)
BitVector	.\BitVector.h	/^    explicit BitVector(size_t numBits)$/;"	f	class:WTF::BitVector	access:public	signature:(size_t numBits)
BitVector	.\BitVector.h	/^class BitVector {$/;"	c	namespace:WTF
BitVector_h	.\BitVector.h	27;"	d
Bitmap	.\Bitmap.h	/^    Bitmap();$/;"	p	class:WTF::Bitmap	access:public	signature:()
Bitmap	.\Bitmap.h	/^class Bitmap {$/;"	c	namespace:WTF
Bitmap	.\Bitmap.h	/^inline Bitmap<size, atomicMode>::Bitmap()$/;"	f	class:WTF::Bitmap	signature:()
BitmapAtomic	.\Bitmap.h	/^    BitmapAtomic$/;"	e	enum:WTF::BitmapAtomicMode
BitmapAtomicMode	.\Bitmap.h	/^enum BitmapAtomicMode {$/;"	g	namespace:WTF
BitmapNotAtomic	.\Bitmap.h	/^    BitmapNotAtomic,$/;"	e	enum:WTF::BitmapAtomicMode
Bitmap_h	.\Bitmap.h	20;"	d
Black	.\RedBlackTree.h	/^        Black$/;"	e	enum:WTF::RedBlackTree::Color
BlackBerry	.\text\WTFString.h	/^namespace BlackBerry {$/;"	n
BlackBerry::WebKit	.\text\WTFString.h	/^namespace WebKit {$/;"	n	namespace:BlackBerry
Bletch	.\dtoa.cpp	140;"	d	file:
BlockSeparator	.\unicode\glib\UnicodeGLib.h	/^    BlockSeparator,$/;"	e	enum:WTF::Unicode::Direction
BlockSeparator	.\unicode\icu\UnicodeIcu.h	/^    BlockSeparator = U_BLOCK_SEPARATOR,$/;"	e	enum:WTF::Unicode::Direction
BlockSeparator	.\unicode\qt4\UnicodeQt4.h	/^    BlockSeparator = QChar::DirB,$/;"	e	enum:WTF::Unicode::Direction
BlockSeparator	.\unicode\wince\UnicodeWinCE.h	/^    BlockSeparator = UnicodeCE::U_BLOCK_SEPARATOR,$/;"	e	enum:WTF::Unicode::Direction
BlockStack	.\BlockStack.h	/^    BlockStack();$/;"	p	class:WTF::BlockStack	access:public	signature:()
BlockStack	.\BlockStack.h	/^template <typename T> BlockStack<T>::BlockStack()$/;"	f	class:WTF::BlockStack	signature:()
BlockStack	.\BlockStack.h	/^template <typename T> class BlockStack {$/;"	c	namespace:WTF
BlockStack_h	.\BlockStack.h	27;"	d
BloomFilter	.\BloomFilter.h	/^    BloomFilter() { clear(); }$/;"	f	class:WTF::BloomFilter	access:public	signature:()
BloomFilter	.\BloomFilter.h	/^class BloomFilter {$/;"	c	namespace:WTF
BloomFilter_h	.\BloomFilter.h	27;"	d
Bndry_mask	.\dtoa.cpp	141;"	d	file:
Bndry_mask1	.\dtoa.cpp	142;"	d	file:
BoundFunctionImpl	.\Functional.h	/^    BoundFunctionImpl(FunctionWrapper functionWrapper, const P1& p1)$/;"	f	class:WTF::BoundFunctionImpl	access:public	signature:(FunctionWrapper functionWrapper, const P1& p1)
BoundFunctionImpl	.\Functional.h	/^    BoundFunctionImpl(FunctionWrapper functionWrapper, const P1& p1, const P2& p2)$/;"	f	class:WTF::BoundFunctionImpl	access:public	signature:(FunctionWrapper functionWrapper, const P1& p1, const P2& p2)
BoundFunctionImpl	.\Functional.h	/^    BoundFunctionImpl(FunctionWrapper functionWrapper, const P1& p1, const P2& p2, const P3& p3)$/;"	f	class:WTF::BoundFunctionImpl	access:public	signature:(FunctionWrapper functionWrapper, const P1& p1, const P2& p2, const P3& p3)
BoundFunctionImpl	.\Functional.h	/^    BoundFunctionImpl(FunctionWrapper functionWrapper, const P1& p1, const P2& p2, const P3& p3, const P4& p4)$/;"	f	class:WTF::BoundFunctionImpl	access:public	signature:(FunctionWrapper functionWrapper, const P1& p1, const P2& p2, const P3& p3, const P4& p4)
BoundFunctionImpl	.\Functional.h	/^    BoundFunctionImpl(FunctionWrapper functionWrapper, const P1& p1, const P2& p2, const P3& p3, const P4& p4, const P5& p5)$/;"	f	class:WTF::BoundFunctionImpl	access:public	signature:(FunctionWrapper functionWrapper, const P1& p1, const P2& p2, const P3& p3, const P4& p4, const P5& p5)
BoundFunctionImpl	.\Functional.h	/^    BoundFunctionImpl(FunctionWrapper functionWrapper, const P1& p1, const P2& p2, const P3& p3, const P4& p4, const P5& p5, const P6& p6)$/;"	f	class:WTF::BoundFunctionImpl	access:public	signature:(FunctionWrapper functionWrapper, const P1& p1, const P2& p2, const P3& p3, const P4& p4, const P5& p5, const P6& p6)
BoundFunctionImpl	.\Functional.h	/^    explicit BoundFunctionImpl(FunctionWrapper functionWrapper)$/;"	f	class:WTF::BoundFunctionImpl	access:public	signature:(FunctionWrapper functionWrapper)
BoundFunctionImpl	.\Functional.h	/^class BoundFunctionImpl<FunctionWrapper, R ()> : public FunctionImpl<typename FunctionWrapper::ResultType ()> {$/;"	c	namespace:WTF	inherits:FunctionImpl
BoundFunctionImpl	.\Functional.h	/^class BoundFunctionImpl<FunctionWrapper, R (P1)> : public FunctionImpl<typename FunctionWrapper::ResultType ()> {$/;"	c	namespace:WTF	inherits:FunctionImpl
BoundFunctionImpl	.\Functional.h	/^class BoundFunctionImpl<FunctionWrapper, R (P1, P2)> : public FunctionImpl<typename FunctionWrapper::ResultType ()> {$/;"	c	namespace:WTF	inherits:FunctionImpl
BoundFunctionImpl	.\Functional.h	/^class BoundFunctionImpl<FunctionWrapper, R (P1, P2, P3)> : public FunctionImpl<typename FunctionWrapper::ResultType ()> {$/;"	c	namespace:WTF	inherits:FunctionImpl
BoundFunctionImpl	.\Functional.h	/^class BoundFunctionImpl<FunctionWrapper, R (P1, P2, P3, P4)> : public FunctionImpl<typename FunctionWrapper::ResultType ()> {$/;"	c	namespace:WTF	inherits:FunctionImpl
BoundFunctionImpl	.\Functional.h	/^class BoundFunctionImpl<FunctionWrapper, R (P1, P2, P3, P4, P5)> : public FunctionImpl<typename FunctionWrapper::ResultType ()> {$/;"	c	namespace:WTF	inherits:FunctionImpl
BoundFunctionImpl	.\Functional.h	/^class BoundFunctionImpl<FunctionWrapper, R (P1, P2, P3, P4, P5, P6)> : public FunctionImpl<typename FunctionWrapper::ResultType ()> {$/;"	c	namespace:WTF	inherits:FunctionImpl
BoundaryNeutral	.\unicode\glib\UnicodeGLib.h	/^    BoundaryNeutral$/;"	e	enum:WTF::Unicode::Direction
BoundaryNeutral	.\unicode\icu\UnicodeIcu.h	/^    BoundaryNeutral = U_BOUNDARY_NEUTRAL$/;"	e	enum:WTF::Unicode::Direction
BoundaryNeutral	.\unicode\qt4\UnicodeQt4.h	/^    BoundaryNeutral = QChar::DirBN$/;"	e	enum:WTF::Unicode::Direction
BoundaryNeutral	.\unicode\wince\UnicodeWinCE.h	/^    BoundaryNeutral = UnicodeCE::U_BOUNDARY_NEUTRAL$/;"	e	enum:WTF::Unicode::Direction
BoundsCheckElider	.\CheckedArithmetic.h	/^template <typename Target, typename Source> struct BoundsCheckElider<Target, Source, false> : public BoundsChecker<Target, Source> {$/;"	s	namespace:WTF	inherits:BoundsChecker
BoundsCheckElider	.\CheckedArithmetic.h	/^template <typename Target, typename Source> struct BoundsCheckElider<Target, Source, true> {$/;"	s	namespace:WTF
BoundsCheckedPointer	.\BoundsCheckedPointer.h	/^    BoundsCheckedPointer()$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:()
BoundsCheckedPointer	.\BoundsCheckedPointer.h	/^    BoundsCheckedPointer(T* pointer, T* begin, T* end)$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(T* pointer, T* begin, T* end)
BoundsCheckedPointer	.\BoundsCheckedPointer.h	/^    BoundsCheckedPointer(T* pointer, T* begin, size_t numElements)$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(T* pointer, T* begin, size_t numElements)
BoundsCheckedPointer	.\BoundsCheckedPointer.h	/^    BoundsCheckedPointer(T* pointer, T* end)$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(T* pointer, T* end)
BoundsCheckedPointer	.\BoundsCheckedPointer.h	/^    BoundsCheckedPointer(T* pointer, size_t numElements)$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(T* pointer, size_t numElements)
BoundsCheckedPointer	.\BoundsCheckedPointer.h	/^class BoundsCheckedPointer {$/;"	c	namespace:WTF
BoundsChecker	.\CheckedArithmetic.h	/^template <typename Target, typename Source> struct BoundsChecker<Target, Source, false, false> {$/;"	s	namespace:WTF
BoundsChecker	.\CheckedArithmetic.h	/^template <typename Target, typename Source> struct BoundsChecker<Target, Source, false, true> {$/;"	s	namespace:WTF
BoundsChecker	.\CheckedArithmetic.h	/^template <typename Target, typename Source> struct BoundsChecker<Target, Source, true, false> {$/;"	s	namespace:WTF
BoundsChecker	.\CheckedArithmetic.h	/^template <typename Target, typename Source> struct BoundsChecker<Target, Source, true, true> {$/;"	s	namespace:WTF
Buffer	.\Deque.h	/^        typedef VectorBuffer<T, inlineCapacity> Buffer;$/;"	t	class:WTF::Deque	access:private
Buffer	.\Vector.h	/^        typedef VectorBuffer<T, inlineCapacity> Buffer;$/;"	t	class:WTF::Vector	access:private
BufferInternal	.\text\StringImpl.h	/^        BufferInternal,$/;"	e	enum:WTF::StringImpl::BufferOwnership
BufferOwned	.\text\StringImpl.h	/^        BufferOwned,$/;"	e	enum:WTF::StringImpl::BufferOwnership
BufferOwnership	.\text\StringImpl.h	/^    enum BufferOwnership {$/;"	g	class:WTF::StringImpl	access:private
BufferSubstring	.\text\StringImpl.h	/^        BufferSubstring,$/;"	e	enum:WTF::StringImpl::BufferOwnership
BumpPointerAllocator	.\BumpPointerAllocator.h	/^    BumpPointerAllocator()$/;"	f	class:WTF::BumpPointerAllocator	access:public	signature:()
BumpPointerAllocator	.\BumpPointerAllocator.h	/^class BumpPointerAllocator {$/;"	c	namespace:WTF
BumpPointerAllocator_h	.\BumpPointerAllocator.h	27;"	d
BumpPointerPool	.\BumpPointerAllocator.h	/^    BumpPointerPool(const PageAllocation& allocation)$/;"	f	class:WTF::BumpPointerPool	access:private	signature:(const PageAllocation& allocation)
BumpPointerPool	.\BumpPointerAllocator.h	/^class BumpPointerPool {$/;"	c	namespace:WTF
ByteArray	.\ByteArray.h	/^        ByteArray(size_t size)$/;"	f	class:WTF::ByteArray	access:private	signature:(size_t size)
ByteArray	.\ByteArray.h	/^    class ByteArray : public RefCountedBase {$/;"	c	namespace:WTF	inherits:RefCountedBase
ByteArray_h	.\ByteArray.h	27;"	d
ByteSizeForClass	.\FastMalloc.cpp	/^static ALWAYS_INLINE size_t ByteSizeForClass(size_t cl) {$/;"	f	namespace:WTF	file:	signature:(size_t cl)
CFStringRef	.\text\StringImpl.h	/^typedef const struct __CFString * CFStringRef;$/;"	t	typeref:struct:__CFString
CFStringRef	.\text\WTFString.h	/^typedef const struct __CFString * CFStringRef;$/;"	t	typeref:struct:__CFString
CHECK_CONDITION	.\FastMalloc.cpp	504;"	d	file:
CHECK_HASHTABLE_CONSISTENCY	.\HashTable.h	38;"	d
CHECK_HASHTABLE_ITERATORS	.\HashTable.h	41;"	d
CHECK_HASHTABLE_USE_AFTER_DESTRUCTION	.\HashTable.h	42;"	d
COMPILER	.\Compiler.h	30;"	d
COMPILER_SUPPORTS	.\Compiler.h	33;"	d
COMPILE_ASSERT	.\Assertions.h	327;"	d
COMPILE_ASSERT	.\Assertions.h	329;"	d
COMPILE_ASSERT	.\BloomFilter.h	/^    COMPILE_ASSERT(keyBits <= 16, bloom_filter_key_size);$/;"	p	class:WTF::BloomFilter	access:public	signature:(keyBits <= 16, bloom_filter_key_size)
COMPILE_ASSERT	.\text\StringImpl.h	/^    COMPILE_ASSERT(s_flagCount == StringHasher::flagCount, StringHasher_reserves_enough_bits_for_StringImpl_flags);$/;"	p	class:WTF::StringImpl	access:private	signature:(s_flagCount == StringHasher::flagCount, StringHasher_reserves_enough_bits_for_StringImpl_flags)
CPU	.\Platform.h	43;"	d
CRASH	.\Assertions.h	169;"	d
CRASH	.\Assertions.h	176;"	d
CString	.\text\CString.cpp	/^CString::CString(const char* str)$/;"	f	class:WTF::CString	signature:(const char* str)
CString	.\text\CString.cpp	/^CString::CString(const char* str, size_t length)$/;"	f	class:WTF::CString	signature:(const char* str, size_t length)
CString	.\text\CString.h	/^    CString() { }$/;"	f	class:WTF::CString	access:public	signature:()
CString	.\text\CString.h	/^    CString(CStringBuffer* buffer) : m_buffer(buffer) { }$/;"	f	class:WTF::CString	access:public	signature:(CStringBuffer* buffer)
CString	.\text\CString.h	/^    WTF_EXPORT_PRIVATE CString(const char*);$/;"	p	class:WTF::CString	access:public	signature:(const char*)
CString	.\text\CString.h	/^    WTF_EXPORT_PRIVATE CString(const char*, size_t length);$/;"	p	class:WTF::CString	access:public	signature:(const char*, size_t length)
CString	.\text\CString.h	/^class CString {$/;"	c	namespace:WTF
CStringBuffer	.\text\CString.h	/^    CStringBuffer(size_t length) : m_vector(length) { }$/;"	f	class:WTF::CStringBuffer	access:private	signature:(size_t length)
CStringBuffer	.\text\CString.h	/^class CStringBuffer : public RefCounted<CStringBuffer> {$/;"	c	namespace:WTF	inherits:RefCounted
CStringTranslator	.\text\AtomicString.cpp	/^struct CStringTranslator {$/;"	s	namespace:WTF	file:
CString_h	.\text\CString.h	27;"	d
CacheSizeClass	.\FastMalloc.cpp	/^  void CacheSizeClass(PageID p, size_t cl) const { pagemap_cache_.Put(p, cl); }$/;"	f	class:WTF::TCMalloc_PageHeap	access:public	signature:(PageID p, size_t cl) const
CacheType	.\FastMalloc.cpp	/^  typedef PackedCache<32 - kPageShift, uint16_t> CacheType;$/;"	t	class:WTF::MapSelector	file:	access:public
CacheType	.\FastMalloc.cpp	/^  typedef PackedCache<64, uint64_t> CacheType;$/;"	t	class:WTF::MapSelector	file:	access:public
CacheType	.\FastMalloc.cpp	/^  typedef PackedCache<BITS, uint64_t> CacheType;$/;"	t	class:WTF::MapSelector	file:	access:public
CachedPower	.\dtoa\cached-powers.cc	/^    struct CachedPower {$/;"	s	namespace:WTF::double_conversion	file:
Carve	.\FastMalloc.cpp	/^  void Carve(Span* span, Length n, bool released);$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:private	signature:(Span* span, Length n, bool released)
Carve	.\FastMalloc.cpp	/^inline void TCMalloc_PageHeap::Carve(Span* span, Length n, bool released) {$/;"	f	class:WTF::TCMalloc_PageHeap	signature:(Span* span, Length n, bool released)
CaseFoldingHash	.\text\StringHash.h	/^    class CaseFoldingHash {$/;"	c	namespace:WTF
CharCategory	.\unicode\glib\UnicodeGLib.h	/^enum CharCategory {$/;"	g	namespace:WTF::Unicode
CharCategory	.\unicode\icu\UnicodeIcu.h	/^enum CharCategory {$/;"	g	namespace:WTF::Unicode
CharCategory	.\unicode\qt4\UnicodeQt4.h	/^enum CharCategory {$/;"	g	namespace:WTF::Unicode
CharCategory	.\unicode\wince\UnicodeWinCE.h	/^enum CharCategory {$/;"	g	namespace:WTF::Unicode
CharTypes	.\url\src\URLCharacterTypes.h	/^    enum CharTypes {$/;"	g	class:WTF::URLCharacterTypes	access:private
CharacterMatchFunctionPtr	.\text\StringImpl.h	/^typedef bool (*CharacterMatchFunctionPtr)(UChar);$/;"	t	namespace:WTF
CharacterNames_h	.\unicode\CharacterNames.h	27;"	d
Check	.\FastMalloc.cpp	/^  bool Check();$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:public	signature:()
Check	.\FastMalloc.cpp	/^bool TCMalloc_PageHeap::Check() {$/;"	f	class:WTF::TCMalloc_PageHeap	signature:()
CheckCachedSizeClass	.\FastMalloc.cpp	/^static inline bool CheckCachedSizeClass(void *ptr) {$/;"	f	namespace:WTF	file:	signature:(void *ptr)
CheckIfKernelSupportsTLS	.\FastMalloc.cpp	/^    static void CheckIfKernelSupportsTLS() {$/;"	f	namespace:WTF	file:	signature:()
CheckList	.\FastMalloc.cpp	/^  size_t CheckList(Span* list, Length min_pages, Length max_pages, bool decommitted);$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:public	signature:(Span* list, Length min_pages, Length max_pages, bool decommitted)
CheckList	.\FastMalloc.cpp	/^size_t TCMalloc_PageHeap::CheckList(Span* list, Length min_pages, Length max_pages, bool decommitted) {$/;"	f	class:WTF::TCMalloc_PageHeap	signature:(Span* list, Length min_pages, Length max_pages, bool decommitted)
CheckList	.\FastMalloc.cpp	/^size_t TCMalloc_PageHeap::CheckList(Span*, Length, Length, bool) {$/;"	f	class:WTF::TCMalloc_PageHeap	signature:(Span*, Length, Length, bool)
Checked	.\CheckedArithmetic.h	/^    Checked()$/;"	f	class:WTF::Checked	access:public	signature:()
Checked	.\CheckedArithmetic.h	/^    Checked(ResultOverflowedTag)$/;"	f	class:WTF::Checked	access:public	signature:(ResultOverflowedTag)
Checked	.\CheckedArithmetic.h	/^    Checked(double);$/;"	p	class:WTF::Checked	access:private	signature:(double)
Checked	.\CheckedArithmetic.h	/^    Checked(float);$/;"	p	class:WTF::Checked	access:private	signature:(float)
Checked	.\CheckedArithmetic.h	/^    template <typename U, typename V> Checked(const Checked<U, V>& rhs)$/;"	f	class:WTF::Checked	access:public	signature:(const Checked<U, V>& rhs)
Checked	.\CheckedArithmetic.h	/^    template <typename U> Checked(U value)$/;"	f	class:WTF::Checked	access:public	signature:(U value)
Checked	.\CheckedArithmetic.h	/^    template <typename U> Checked(const Checked<U, OverflowHandler>& rhs)$/;"	f	class:WTF::Checked	access:public	signature:(const Checked<U, OverflowHandler>& rhs)
Checked	.\CheckedArithmetic.h	/^    template <typename V> Checked(const Checked<T, V>& rhs)$/;"	f	class:WTF::Checked	access:public	signature:(const Checked<T, V>& rhs)
Checked	.\CheckedArithmetic.h	/^template <typename T, class OverflowHandler> class Checked : public OverflowHandler {$/;"	c	namespace:WTF	inherits:OverflowHandler
CheckedArithmetic_h	.\CheckedArithmetic.h	27;"	d
CheckedBoolean	.\CheckedBoolean.h	/^    CheckedBoolean(bool value)$/;"	f	class:CheckedBoolean	access:public	signature:(bool value)
CheckedBoolean	.\CheckedBoolean.h	/^class CheckedBoolean {$/;"	c
CheckedBoolean::CheckedBoolean	.\CheckedBoolean.h	/^    CheckedBoolean(bool value)$/;"	f	class:CheckedBoolean	access:public	signature:(bool value)
CheckedBoolean::m_checked	.\CheckedBoolean.h	/^    bool m_checked;$/;"	m	class:CheckedBoolean	access:private
CheckedBoolean::m_value	.\CheckedBoolean.h	/^    bool m_value;$/;"	m	class:CheckedBoolean	access:private
CheckedBoolean::operator bool	.\CheckedBoolean.h	/^    operator bool()$/;"	f	class:CheckedBoolean	access:public	signature:()
CheckedBoolean::~CheckedBoolean	.\CheckedBoolean.h	/^    ~CheckedBoolean()$/;"	f	class:CheckedBoolean	access:public	signature:()
CheckedBoolean_h	.\CheckedBoolean.h	27;"	d
CheckedMallocResult	.\FastMalloc.cpp	/^static inline void* CheckedMallocResult(void *result)$/;"	f	namespace:WTF	file:	signature:(void *result)
ChromiumThreading	.\chromium\ChromiumThreading.h	/^class ChromiumThreading {$/;"	c	namespace:WTF
ChromiumThreading_h	.\chromium\ChromiumThreading.h	32;"	d
Chunk	.\dtoa\bignum.h	/^        typedef uint32_t Chunk;$/;"	t	class:WTF::double_conversion::Bignum	access:private
Clamp	.\dtoa\bignum.cc	/^    void Bignum::Clamp() {$/;"	f	class:WTF::double_conversion::Bignum	signature:()
Clamp	.\dtoa\bignum.h	/^        void Clamp();$/;"	p	class:WTF::double_conversion::Bignum	access:private	signature:()
ClassIndex	.\FastMalloc.cpp	/^static inline int ClassIndex(size_t s) {$/;"	f	namespace:WTF	file:	signature:(size_t s)
CleanType	.\CheckedArithmetic.h	/^    typedef T CleanType;$/;"	t	struct:WTF::RemoveChecked	access:public
CleanType	.\CheckedArithmetic.h	/^    typedef typename RemoveChecked<T>::CleanType CleanType;$/;"	t	struct:WTF::RemoveChecked	access:public
Cleanup	.\FastMalloc.cpp	/^  void Cleanup();$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:()
Cleanup	.\FastMalloc.cpp	/^void TCMalloc_ThreadCache::Cleanup() {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:()
Clear	.\TCPackedCache.h	/^  void Clear(V value) {$/;"	f	class:PackedCache	access:public	signature:(V value)
Collator	.\unicode\Collator.h	/^        WTF_EXPORT_PRIVATE Collator(const char* locale); \/\/ Parsing is lenient; e.g. language identifiers (such as "en-US") are accepted, too.$/;"	p	class:WTF::Collator	access:public	signature:(const char* locale)
Collator	.\unicode\Collator.h	/^    class Collator {$/;"	c	namespace:WTF
Collator	.\unicode\CollatorDefault.cpp	/^Collator::Collator(const char*)$/;"	f	class:WTF::Collator	signature:(const char*)
Collator	.\unicode\icu\CollatorICU.cpp	/^Collator::Collator(const char* locale)$/;"	f	class:WTF::Collator	signature:(const char* locale)
Color	.\RedBlackTree.h	/^    enum Color {$/;"	g	class:WTF::RedBlackTree	access:private
CommonNumberSeparator	.\unicode\glib\UnicodeGLib.h	/^    CommonNumberSeparator,$/;"	e	enum:WTF::Unicode::Direction
CommonNumberSeparator	.\unicode\icu\UnicodeIcu.h	/^    CommonNumberSeparator = U_COMMON_NUMBER_SEPARATOR,$/;"	e	enum:WTF::Unicode::Direction
CommonNumberSeparator	.\unicode\qt4\UnicodeQt4.h	/^    CommonNumberSeparator = QChar::DirCS,$/;"	e	enum:WTF::Unicode::Direction
CommonNumberSeparator	.\unicode\wince\UnicodeWinCE.h	/^    CommonNumberSeparator = UnicodeCE::U_COMMON_NUMBER_SEPARATOR,$/;"	e	enum:WTF::Unicode::Direction
Compare	.\dtoa\bignum.cc	/^    int Bignum::Compare(const Bignum& a, const Bignum& b) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(const Bignum& a, const Bignum& b)
Compare	.\dtoa\bignum.h	/^        static int Compare(const Bignum& a, const Bignum& b);$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(const Bignum& a, const Bignum& b)
Complex	.\Complex.h	/^typedef std::complex<double> Complex;$/;"	t	namespace:WTF
ComponentType	.\url\src\URLSegments.h	/^    enum ComponentType {$/;"	g	class:WTF::URLSegments	access:public
Conditional	.\TypeTraits.h	/^    template <bool Predicate, class If, class Then> struct Conditional  { typedef If Type; };$/;"	s	namespace:WTF
Conditional	.\TypeTraits.h	/^    template <class If, class Then> struct Conditional<false, If, Then> { typedef Then Type; };$/;"	s	namespace:WTF
ConstIterator	.\HashIterators.h	/^        typedef HashTableConstIteratorAdapter<HashTableType, std::pair<KeyType, MappedType> > ConstIterator;$/;"	t	struct:WTF::HashTableConstKeysIterator	access:private
ConstIterator	.\HashIterators.h	/^        typedef HashTableConstIteratorAdapter<HashTableType, std::pair<KeyType, MappedType> > ConstIterator;$/;"	t	struct:WTF::HashTableConstValuesIterator	access:private
ConstIterator	.\HashIterators.h	/^        typedef HashTableConstIteratorAdapter<HashTableType, std::pair<KeyType, MappedType> > ConstIterator;$/;"	t	struct:WTF::HashTableKeysIterator	access:private
ConstIterator	.\HashIterators.h	/^        typedef HashTableConstIteratorAdapter<HashTableType, std::pair<KeyType, MappedType> > ConstIterator;$/;"	t	struct:WTF::HashTableValuesIterator	access:private
ConstructStaticString	.\text\StringImpl.h	/^    enum ConstructStaticStringTag { ConstructStaticString };$/;"	e	enum:WTF::StringImpl::ConstructStaticStringTag
ConstructStaticStringTag	.\text\StringImpl.h	/^    enum ConstructStaticStringTag { ConstructStaticString };$/;"	g	class:WTF::StringImpl	access:private
ConsumeSubString	.\dtoa\double-conversion.cc	/^    static bool ConsumeSubString(const char** current,$/;"	f	namespace:WTF::double_conversion	file:	signature:(const char** current, const char* end, const char* substring)
ConversionResult	.\unicode\UTF8.h	/^    } ConversionResult;$/;"	t	namespace:WTF::Unicode	typeref:enum:WTF::Unicode::__anon13
CrashOnOverflow	.\CheckedArithmetic.h	/^class CrashOnOverflow {$/;"	c	namespace:WTF
CreateCacheIfNecessary	.\FastMalloc.cpp	/^  static TCMalloc_ThreadCache* CreateCacheIfNecessary();$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:()
CreateCacheIfNecessary	.\FastMalloc.cpp	/^TCMalloc_ThreadCache* TCMalloc_ThreadCache::CreateCacheIfNecessary() {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:()
CreateDecimalRepresentation	.\dtoa\double-conversion.cc	/^    void DoubleToStringConverter::CreateDecimalRepresentation($/;"	f	class:WTF::double_conversion::DoubleToStringConverter	signature:( const char* decimal_digits, int length, int decimal_point, int digits_after_point, StringBuilder* result_builder) const
CreateDecimalRepresentation	.\dtoa\double-conversion.h	/^        void CreateDecimalRepresentation(const char* decimal_digits,$/;"	p	class:WTF::double_conversion::DoubleToStringConverter	access:private	signature:(const char* decimal_digits, int length, int decimal_point, int digits_after_point, StringBuilder* result_builder) const
CreateExponentialRepresentation	.\dtoa\double-conversion.cc	/^    void DoubleToStringConverter::CreateExponentialRepresentation($/;"	f	class:WTF::double_conversion::DoubleToStringConverter	signature:( const char* decimal_digits, int length, int exponent, StringBuilder* result_builder) const
CreateExponentialRepresentation	.\dtoa\double-conversion.h	/^        void CreateExponentialRepresentation(const char* decimal_digits,$/;"	p	class:WTF::double_conversion::DoubleToStringConverter	access:private	signature:(const char* decimal_digits, int length, int exponent, StringBuilder* result_builder) const
CurrentTime_h	.\CurrentTime.h	33;"	d
DATA_LOG_TO_FILE	.\DataLog.cpp	31;"	d	file:
DCHECK_EQ	.\TCPackedCache.h	120;"	d
DEFINE_DEBUG_ONLY_GLOBAL	.\StdLibExtras.h	51;"	d
DEFINE_DEBUG_ONLY_GLOBAL	.\StdLibExtras.h	58;"	d
DEFINE_DEBUG_ONLY_GLOBAL	.\StdLibExtras.h	62;"	d
DEFINE_GLOBAL	.\StaticConstructors.h	55;"	d
DEFINE_GLOBAL	.\StaticConstructors.h	58;"	d
DEFINE_GLOBAL	.\StaticConstructors.h	66;"	d
DEFINE_GLOBAL	.\StaticConstructors.h	69;"	d
DEFINE_STATIC_LOCAL	.\StdLibExtras.h	37;"	d
DEFINE_STATIC_LOCAL	.\StdLibExtras.h	41;"	d
DEFINE_VARIABLE	.\FastMalloc.cpp	483;"	d	file:
DEFINE_double	.\FastMalloc.cpp	493;"	d	file:
DEFINE_int64	.\FastMalloc.cpp	490;"	d	file:
DISALLOW_COPY_AND_ASSIGN	.\dtoa\bignum.h	/^        DISALLOW_COPY_AND_ASSIGN(Bignum);$/;"	p	class:WTF::double_conversion::Bignum	access:private	signature:(Bignum)
DISALLOW_COPY_AND_ASSIGN	.\dtoa\utils.h	100;"	d
DISALLOW_IMPLICIT_CONSTRUCTORS	.\dtoa\double-conversion.h	/^        DISALLOW_IMPLICIT_CONSTRUCTORS(DoubleToStringConverter);$/;"	p	class:WTF::double_conversion::DoubleToStringConverter	access:private	signature:(DoubleToStringConverter)
DISALLOW_IMPLICIT_CONSTRUCTORS	.\dtoa\double-conversion.h	/^        DISALLOW_IMPLICIT_CONSTRUCTORS(StringToDoubleConverter);$/;"	p	class:WTF::double_conversion::StringToDoubleConverter	access:private	signature:(StringToDoubleConverter)
DISALLOW_IMPLICIT_CONSTRUCTORS	.\dtoa\utils.h	/^        DISALLOW_IMPLICIT_CONSTRUCTORS(StringBuilder);$/;"	p	class:WTF::double_conversion::StringBuilder	access:private	signature:(StringBuilder)
DISALLOW_IMPLICIT_CONSTRUCTORS	.\dtoa\utils.h	110;"	d
DLL_Init	.\FastMalloc.cpp	/^static inline void DLL_Init(Span* list) {$/;"	f	namespace:WTF	file:	signature:(Span* list)
DLL_IsEmpty	.\FastMalloc.cpp	/^static ALWAYS_INLINE bool DLL_IsEmpty(const Span* list) {$/;"	f	namespace:WTF	file:	signature:(const Span* list)
DLL_Length	.\FastMalloc.cpp	/^static int DLL_Length(const Span* list) {$/;"	f	namespace:WTF	file:	signature:(const Span* list)
DLL_Prepend	.\FastMalloc.cpp	/^static inline void DLL_Prepend(Span* list, Span* span) {$/;"	f	namespace:WTF	file:	signature:(Span* list, Span* span)
DLL_Remove	.\FastMalloc.cpp	/^static inline void DLL_Remove(Span* span) {$/;"	f	namespace:WTF	file:	signature:(Span* span)
DONT_FINALIZE_ON_MAIN_THREAD	.\Platform.h	575;"	d
DOUBLE_CONVERSION_BIGNUM_DTOA_H_	.\dtoa\bignum-dtoa.h	29;"	d
DOUBLE_CONVERSION_BIGNUM_H_	.\dtoa\bignum.h	29;"	d
DOUBLE_CONVERSION_CACHED_POWERS_H_	.\dtoa\cached-powers.h	29;"	d
DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS	.\dtoa\utils.h	51;"	d
DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS	.\dtoa\utils.h	53;"	d
DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS	.\dtoa\utils.h	57;"	d
DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS	.\dtoa\utils.h	59;"	d
DOUBLE_CONVERSION_DIY_FP_H_	.\dtoa\diy-fp.h	29;"	d
DOUBLE_CONVERSION_DOUBLE_CONVERSION_H_	.\dtoa\double-conversion.h	29;"	d
DOUBLE_CONVERSION_DOUBLE_H_	.\dtoa\double.h	29;"	d
DOUBLE_CONVERSION_FAST_DTOA_H_	.\dtoa\fast-dtoa.h	29;"	d
DOUBLE_CONVERSION_FIXED_DTOA_H_	.\dtoa\fixed-dtoa.h	29;"	d
DOUBLE_CONVERSION_STRTOD_H_	.\dtoa\strtod.h	29;"	d
DOUBLE_CONVERSION_UTILS_H_	.\dtoa\utils.h	29;"	d
DUMP_HASHTABLE_STATS	.\HashTable.h	35;"	d
DYNAMIC_ANNOTATIONS_IMPL	.\DynamicAnnotations.cpp	37;"	d	file:
DYNAMIC_ANNOTATIONS_IMPL	.\DynamicAnnotations.cpp	41;"	d	file:
Data	.\ThreadSpecific.h	/^        Data(T* value, ThreadSpecific<T>* owner) : value(value), owner(owner) {}$/;"	f	struct:WTF::ThreadSpecific::Data	access:public	signature:(T* value, ThreadSpecific<T>* owner)
Data	.\ThreadSpecific.h	/^    struct Data {$/;"	s	class:WTF::ThreadSpecific	access:private
DataLog_h	.\DataLog.h	27;"	d
DateMath_h	.\DateMath.h	44;"	d
Deallocate	.\FastMalloc.cpp	/^  void Deallocate(void* ptr, size_t size_class);$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:(void* ptr, size_t size_class)
Deallocate	.\FastMalloc.cpp	/^inline void TCMalloc_ThreadCache::Deallocate(void* ptr, size_t cl) {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:(void* ptr, size_t cl)
DecayArray	.\TypeTraits.h	/^    template <class T> struct DecayArray {$/;"	s	namespace:WTF
DecimalCharacter	.\url\src\URLCharacterTypes.h	/^        DecimalCharacter = 1 << 4,$/;"	e	enum:WTF::URLCharacterTypes::CharTypes
DecimalNumber	.\DecimalNumber.h	/^    DecimalNumber(double d)$/;"	f	class:WTF::DecimalNumber	access:public	signature:(double d)
DecimalNumber	.\DecimalNumber.h	/^    DecimalNumber(double d, RoundingDecimalPlacesType, unsigned decimalPlaces)$/;"	f	class:WTF::DecimalNumber	access:public	signature:(double d, RoundingDecimalPlacesType, unsigned decimalPlaces)
DecimalNumber	.\DecimalNumber.h	/^    DecimalNumber(double d, RoundingSignificantFiguresType, unsigned significantFigures)$/;"	f	class:WTF::DecimalNumber	access:public	signature:(double d, RoundingSignificantFiguresType, unsigned significantFigures)
DecimalNumber	.\DecimalNumber.h	/^class DecimalNumber {$/;"	c	namespace:WTF
DecimalNumber_h	.\DecimalNumber.h	27;"	d
Decoder	.\Decoder.h	/^    Decoder() { }$/;"	f	class:WTF::Decoder	access:protected	signature:()
Decoder	.\Decoder.h	/^class Decoder {$/;"	c	namespace:WTF
Decoder_h	.\Decoder.h	27;"	d
DecompositionCanonical	.\unicode\glib\UnicodeGLib.h	/^    DecompositionCanonical,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionCanonical	.\unicode\icu\UnicodeIcu.h	/^    DecompositionCanonical = U_DT_CANONICAL,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionCanonical	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionCanonical = QChar::Canonical,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionCanonical	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionCanonical = UnicodeCE::U_DT_CANONICAL,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionCircle	.\unicode\glib\UnicodeGLib.h	/^    DecompositionCircle,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionCircle	.\unicode\icu\UnicodeIcu.h	/^    DecompositionCircle = U_DT_CIRCLE,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionCircle	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionCircle = QChar::Circle,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionCircle	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionCircle = UnicodeCE::U_DT_CIRCLE,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionCompat	.\unicode\glib\UnicodeGLib.h	/^    DecompositionCompat,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionCompat	.\unicode\icu\UnicodeIcu.h	/^    DecompositionCompat = U_DT_COMPAT,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionCompat	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionCompat = QChar::Compat,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionCompat	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionCompat = UnicodeCE::U_DT_COMPAT,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionFinal	.\unicode\glib\UnicodeGLib.h	/^    DecompositionFinal,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionFinal	.\unicode\icu\UnicodeIcu.h	/^    DecompositionFinal = U_DT_FINAL,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionFinal	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionFinal = QChar::Final,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionFinal	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionFinal = UnicodeCE::U_DT_FINAL,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionFont	.\unicode\glib\UnicodeGLib.h	/^    DecompositionFont,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionFont	.\unicode\icu\UnicodeIcu.h	/^    DecompositionFont = U_DT_FONT,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionFont	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionFont = QChar::Font,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionFont	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionFont = UnicodeCE::U_DT_FONT,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionFraction	.\unicode\glib\UnicodeGLib.h	/^    DecompositionFraction,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionFraction	.\unicode\icu\UnicodeIcu.h	/^    DecompositionFraction = U_DT_FRACTION,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionFraction	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionFraction = QChar::Fraction,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionFraction	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionFraction = UnicodeCE::U_DT_FRACTION,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionInitial	.\unicode\glib\UnicodeGLib.h	/^    DecompositionInitial,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionInitial	.\unicode\icu\UnicodeIcu.h	/^    DecompositionInitial = U_DT_INITIAL,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionInitial	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionInitial = QChar::Initial,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionInitial	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionInitial = UnicodeCE::U_DT_INITIAL,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionIsolated	.\unicode\glib\UnicodeGLib.h	/^    DecompositionIsolated,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionIsolated	.\unicode\icu\UnicodeIcu.h	/^    DecompositionIsolated = U_DT_ISOLATED,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionIsolated	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionIsolated = QChar::Isolated,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionIsolated	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionIsolated = UnicodeCE::U_DT_ISOLATED,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionMedial	.\unicode\glib\UnicodeGLib.h	/^    DecompositionMedial,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionMedial	.\unicode\icu\UnicodeIcu.h	/^    DecompositionMedial = U_DT_MEDIAL,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionMedial	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionMedial = QChar::Medial,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionMedial	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionMedial = UnicodeCE::U_DT_MEDIAL,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionNarrow	.\unicode\glib\UnicodeGLib.h	/^    DecompositionNarrow,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionNarrow	.\unicode\icu\UnicodeIcu.h	/^    DecompositionNarrow = U_DT_NARROW,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionNarrow	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionNarrow = QChar::Narrow,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionNarrow	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionNarrow = UnicodeCE::U_DT_NARROW,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionNoBreak	.\unicode\glib\UnicodeGLib.h	/^    DecompositionNoBreak,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionNoBreak	.\unicode\icu\UnicodeIcu.h	/^    DecompositionNoBreak = U_DT_NOBREAK,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionNoBreak	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionNoBreak = QChar::NoBreak,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionNoBreak	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionNoBreak = UnicodeCE::U_DT_NOBREAK,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionNone	.\unicode\glib\UnicodeGLib.h	/^    DecompositionNone,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionNone	.\unicode\icu\UnicodeIcu.h	/^    DecompositionNone = U_DT_NONE,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionNone	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionNone = QChar::NoDecomposition,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionNone	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionNone = UnicodeCE::U_DT_NONE,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionSmall	.\unicode\glib\UnicodeGLib.h	/^    DecompositionSmall,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionSmall	.\unicode\icu\UnicodeIcu.h	/^    DecompositionSmall = U_DT_SMALL,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionSmall	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionSmall = QChar::Small,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionSmall	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionSmall = UnicodeCE::U_DT_SMALL,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionSquare	.\unicode\glib\UnicodeGLib.h	/^    DecompositionSquare,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionSquare	.\unicode\icu\UnicodeIcu.h	/^    DecompositionSquare = U_DT_SQUARE,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionSquare	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionSquare = QChar::Square,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionSquare	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionSquare = UnicodeCE::U_DT_SQUARE,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionSub	.\unicode\glib\UnicodeGLib.h	/^    DecompositionSub,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionSub	.\unicode\icu\UnicodeIcu.h	/^    DecompositionSub = U_DT_SUB,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionSub	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionSub = QChar::Sub,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionSub	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionSub = UnicodeCE::U_DT_SUB,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionSuper	.\unicode\glib\UnicodeGLib.h	/^    DecompositionSuper,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionSuper	.\unicode\icu\UnicodeIcu.h	/^    DecompositionSuper = U_DT_SUPER,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionSuper	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionSuper = QChar::Super,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionSuper	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionSuper = UnicodeCE::U_DT_SUPER,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionType	.\unicode\glib\UnicodeGLib.h	/^enum DecompositionType {$/;"	g	namespace:WTF::Unicode
DecompositionType	.\unicode\icu\UnicodeIcu.h	/^enum DecompositionType {$/;"	g	namespace:WTF::Unicode
DecompositionType	.\unicode\qt4\UnicodeQt4.h	/^enum DecompositionType {$/;"	g	namespace:WTF::Unicode
DecompositionType	.\unicode\wince\UnicodeWinCE.h	/^enum DecompositionType {$/;"	g	namespace:WTF::Unicode
DecompositionVertical	.\unicode\glib\UnicodeGLib.h	/^    DecompositionVertical,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionVertical	.\unicode\icu\UnicodeIcu.h	/^    DecompositionVertical = U_DT_VERTICAL,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionVertical	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionVertical = QChar::Vertical,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionVertical	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionVertical = UnicodeCE::U_DT_VERTICAL,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionWide	.\unicode\glib\UnicodeGLib.h	/^    DecompositionWide,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionWide	.\unicode\icu\UnicodeIcu.h	/^    DecompositionWide = U_DT_WIDE,$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionWide	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionWide = QChar::Wide$/;"	e	enum:WTF::Unicode::DecompositionType
DecompositionWide	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionWide = UnicodeCE::U_DT_WIDE$/;"	e	enum:WTF::Unicode::DecompositionType
DefaultHash	.\HashFunctions.h	/^    template<> struct DefaultHash<double> { typedef FloatHash<double> Hash; };$/;"	s	namespace:WTF
DefaultHash	.\HashFunctions.h	/^    template<> struct DefaultHash<float> { typedef FloatHash<float> Hash; };$/;"	s	namespace:WTF
DefaultHash	.\HashFunctions.h	/^    template<> struct DefaultHash<int> { typedef IntHash<unsigned> Hash; };$/;"	s	namespace:WTF
DefaultHash	.\HashFunctions.h	/^    template<> struct DefaultHash<long long> { typedef IntHash<unsigned long long> Hash; };$/;"	s	namespace:WTF
DefaultHash	.\HashFunctions.h	/^    template<> struct DefaultHash<long> { typedef IntHash<unsigned long> Hash; };$/;"	s	namespace:WTF
DefaultHash	.\HashFunctions.h	/^    template<> struct DefaultHash<short> { typedef IntHash<unsigned> Hash; };$/;"	s	namespace:WTF
DefaultHash	.\HashFunctions.h	/^    template<> struct DefaultHash<unsigned long long> { typedef IntHash<unsigned long long> Hash; };$/;"	s	namespace:WTF
DefaultHash	.\HashFunctions.h	/^    template<> struct DefaultHash<unsigned long> { typedef IntHash<unsigned long> Hash; };$/;"	s	namespace:WTF
DefaultHash	.\HashFunctions.h	/^    template<> struct DefaultHash<unsigned short> { typedef IntHash<unsigned> Hash; };$/;"	s	namespace:WTF
DefaultHash	.\HashFunctions.h	/^    template<> struct DefaultHash<unsigned> { typedef IntHash<unsigned> Hash; };$/;"	s	namespace:WTF
DefaultHash	.\HashFunctions.h	/^    template<> struct DefaultHash<wchar_t> { typedef IntHash<wchar_t> Hash; };$/;"	s	namespace:WTF
DefaultHash	.\HashFunctions.h	/^    template<typename P> struct DefaultHash<P*> { typedef PtrHash<P*> Hash; };$/;"	s	namespace:WTF
DefaultHash	.\HashFunctions.h	/^    template<typename P> struct DefaultHash<RefPtr<P> > { typedef PtrHash<RefPtr<P> > Hash; };$/;"	s	namespace:WTF
DefaultHash	.\HashFunctions.h	/^    template<typename T, typename U> struct DefaultHash<std::pair<T, U> > { typedef PairHash<T, U> Hash; };$/;"	s	namespace:WTF
DefaultHash	.\RetainPtr.h	/^    template<typename P> struct DefaultHash<RetainPtr<P> > { typedef PtrHash<RetainPtr<P> > Hash; };$/;"	s	namespace:WTF
DefaultHash	.\text\AtomicString.h	/^template<> struct DefaultHash<AtomicString> {$/;"	s	namespace:WTF
DefaultHash	.\text\StringImpl.h	/^template<> struct DefaultHash<RefPtr<StringImpl> > {$/;"	s	namespace:WTF
DefaultHash	.\text\StringImpl.h	/^template<> struct DefaultHash<StringImpl*> {$/;"	s	namespace:WTF
DefaultHash	.\text\WTFString.h	/^template<> struct DefaultHash<String> {$/;"	s	namespace:WTF
DefaultValue	.\CheckedArithmetic.h	/^    static const CleanType DefaultValue = 0;    $/;"	m	struct:WTF::RemoveChecked	access:public
DefaultValue	.\CheckedArithmetic.h	/^    static const CleanType DefaultValue = 0;$/;"	m	struct:WTF::RemoveChecked	access:public
Delete	.\FastMalloc.cpp	/^  void Delete(Span* span);$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:public	signature:(Span* span)
Delete	.\FastMalloc.cpp	/^  void Delete(T* p) {$/;"	f	class:WTF::PageHeapAllocator	access:public	signature:(T* p)
Delete	.\FastMalloc.cpp	/^inline void TCMalloc_PageHeap::Delete(Span* span) {$/;"	f	class:WTF::TCMalloc_PageHeap	signature:(Span* span)
DeleteArrayImpl	.\FastAllocBase.h	/^        struct DeleteArrayImpl {$/;"	s	namespace:WTF::Internal
DeleteArrayImpl	.\FastAllocBase.h	/^        struct DeleteArrayImpl<T, false> {$/;"	s	namespace:WTF::Internal
DeleteCache	.\FastMalloc.cpp	/^  static void                  DeleteCache(TCMalloc_ThreadCache* heap);$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:(TCMalloc_ThreadCache* heap)
DeleteCache	.\FastMalloc.cpp	/^void TCMalloc_ThreadCache::DeleteCache(TCMalloc_ThreadCache* heap) {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:(TCMalloc_ThreadCache* heap)
DeleteSpan	.\FastMalloc.cpp	/^static inline void DeleteSpan(Span* span) {$/;"	f	namespace:WTF	file:	signature:(Span* span)
Deque	.\Deque.h	/^        Deque();$/;"	p	class:WTF::Deque	access:public	signature:()
Deque	.\Deque.h	/^        Deque(const Deque<T, inlineCapacity>&);$/;"	p	class:WTF::Deque	access:public	signature:(const Deque<T, inlineCapacity>&)
Deque	.\Deque.h	/^    class Deque {$/;"	c	namespace:WTF
Deque	.\Deque.h	/^    inline Deque<T, inlineCapacity>::Deque()$/;"	f	class:WTF::Deque	signature:()
Deque	.\Deque.h	/^    inline Deque<T, inlineCapacity>::Deque(const Deque<T, inlineCapacity>& other)$/;"	f	class:WTF::Deque	signature:(const Deque<T, inlineCapacity>& other)
DequeConstIterator	.\Deque.h	/^        DequeConstIterator(const Deque<T, inlineCapacity>* deque, size_t index) : Base(deque, index) { }$/;"	f	class:WTF::DequeConstIterator	access:public	signature:(const Deque<T, inlineCapacity>* deque, size_t index)
DequeConstIterator	.\Deque.h	/^        DequeConstIterator(const Iterator& other) : Base(other) { }$/;"	f	class:WTF::DequeConstIterator	access:public	signature:(const Iterator& other)
DequeConstIterator	.\Deque.h	/^        DequeConstIterator(const NonConstIterator& other) : Base(other) { }$/;"	f	class:WTF::DequeConstIterator	access:public	signature:(const NonConstIterator& other)
DequeConstIterator	.\Deque.h	/^    class DequeConstIterator : public DequeIteratorBase<T, inlineCapacity> {$/;"	c	namespace:WTF	inherits:DequeIteratorBase
DequeConstReverseIterator	.\Deque.h	/^        DequeConstReverseIterator(const Deque<T, inlineCapacity>* deque, size_t index) : Base(deque, index) { }$/;"	f	class:WTF::DequeConstReverseIterator	access:public	signature:(const Deque<T, inlineCapacity>* deque, size_t index)
DequeConstReverseIterator	.\Deque.h	/^        DequeConstReverseIterator(const Iterator& other) : Base(other) { }$/;"	f	class:WTF::DequeConstReverseIterator	access:public	signature:(const Iterator& other)
DequeConstReverseIterator	.\Deque.h	/^        DequeConstReverseIterator(const NonConstIterator& other) : Base(other) { }$/;"	f	class:WTF::DequeConstReverseIterator	access:public	signature:(const NonConstIterator& other)
DequeConstReverseIterator	.\Deque.h	/^    class DequeConstReverseIterator : public DequeIteratorBase<T, inlineCapacity> {$/;"	c	namespace:WTF	inherits:DequeIteratorBase
DequeIterator	.\Deque.h	/^        DequeIterator(Deque<T, inlineCapacity>* deque, size_t index) : Base(deque, index) { }$/;"	f	class:WTF::DequeIterator	access:public	signature:(Deque<T, inlineCapacity>* deque, size_t index)
DequeIterator	.\Deque.h	/^        DequeIterator(const Iterator& other) : Base(other) { }$/;"	f	class:WTF::DequeIterator	access:public	signature:(const Iterator& other)
DequeIterator	.\Deque.h	/^    class DequeIterator : public DequeIteratorBase<T, inlineCapacity> {$/;"	c	namespace:WTF	inherits:DequeIteratorBase
DequeIteratorBase	.\Deque.h	/^        DequeIteratorBase();$/;"	p	class:WTF::DequeIteratorBase	access:protected	signature:()
DequeIteratorBase	.\Deque.h	/^        DequeIteratorBase(const Base&);$/;"	p	class:WTF::DequeIteratorBase	access:protected	signature:(const Base&)
DequeIteratorBase	.\Deque.h	/^        DequeIteratorBase(const Deque<T, inlineCapacity>*, size_t);$/;"	p	class:WTF::DequeIteratorBase	access:protected	signature:(const Deque<T, inlineCapacity>*, size_t)
DequeIteratorBase	.\Deque.h	/^    class DequeIteratorBase {$/;"	c	namespace:WTF
DequeIteratorBase	.\Deque.h	/^    inline DequeIteratorBase<T, inlineCapacity>::DequeIteratorBase()$/;"	f	class:WTF::DequeIteratorBase	signature:()
DequeIteratorBase	.\Deque.h	/^    inline DequeIteratorBase<T, inlineCapacity>::DequeIteratorBase(const Base& other)$/;"	f	class:WTF::DequeIteratorBase	signature:(const Base& other)
DequeIteratorBase	.\Deque.h	/^    inline DequeIteratorBase<T, inlineCapacity>::DequeIteratorBase(const Deque<T, inlineCapacity>* deque, size_t index)$/;"	f	class:WTF::DequeIteratorBase	signature:(const Deque<T, inlineCapacity>* deque, size_t index)
DequeReverseIterator	.\Deque.h	/^        DequeReverseIterator(const Deque<T, inlineCapacity>* deque, size_t index) : Base(deque, index) { }$/;"	f	class:WTF::DequeReverseIterator	access:public	signature:(const Deque<T, inlineCapacity>* deque, size_t index)
DequeReverseIterator	.\Deque.h	/^        DequeReverseIterator(const Iterator& other) : Base(other) { }$/;"	f	class:WTF::DequeReverseIterator	access:public	signature:(const Iterator& other)
DequeReverseIterator	.\Deque.h	/^    class DequeReverseIterator : public DequeIteratorBase<T, inlineCapacity> {$/;"	c	namespace:WTF	inherits:DequeIteratorBase
DestroyThreadCache	.\FastMalloc.cpp	/^  static void DestroyThreadCache(void* ptr);$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:private	signature:(void* ptr)
DestroyThreadCache	.\FastMalloc.cpp	/^void TCMalloc_ThreadCache::DestroyThreadCache(void* ptr) {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:(void* ptr)
DigitGen	.\dtoa\fast-dtoa.cc	/^    static bool DigitGen(DiyFp low,$/;"	f	namespace:WTF::double_conversion	file:	signature:(DiyFp low, DiyFp w, DiyFp high, Vector<char> buffer, int* length, int* kappa)
DigitGenCounted	.\dtoa\fast-dtoa.cc	/^    static bool DigitGenCounted(DiyFp w,$/;"	f	namespace:WTF::double_conversion	file:	signature:(DiyFp w, int requested_digits, Vector<char> buffer, int* length, int* kappa)
Direction	.\unicode\glib\UnicodeGLib.h	/^enum Direction {$/;"	g	namespace:WTF::Unicode
Direction	.\unicode\icu\UnicodeIcu.h	/^enum Direction {$/;"	g	namespace:WTF::Unicode
Direction	.\unicode\qt4\UnicodeQt4.h	/^enum Direction {$/;"	g	namespace:WTF::Unicode
Direction	.\unicode\wince\UnicodeWinCE.h	/^enum Direction {$/;"	g	namespace:WTF::Unicode
DisallowTrailingJunk	.\dtoa.h	/^enum AllowTrailingJunkTag { DisallowTrailingJunk = 0, AllowTrailingJunk };$/;"	e	enum:WTF::AllowTrailingJunkTag
DisallowTrailingSpaces	.\dtoa.h	/^enum AllowTrailingSpacesTag { DisallowTrailingSpaces = 0, AllowTrailingSpaces };$/;"	e	enum:WTF::AllowTrailingSpacesTag
DivModPowerOf2	.\dtoa\fixed-dtoa.cc	/^        int DivModPowerOf2(int power) {$/;"	f	class:WTF::double_conversion::UInt128	access:public	signature:(int power)
DivideModuloIntBignum	.\dtoa\bignum.cc	/^    uint16_t Bignum::DivideModuloIntBignum(const Bignum& other) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(const Bignum& other)
DivideModuloIntBignum	.\dtoa\bignum.h	/^        uint16_t DivideModuloIntBignum(const Bignum& other);$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(const Bignum& other)
DiyFp	.\dtoa\diy-fp.h	/^        DiyFp() : f_(0), e_(0) {}$/;"	f	class:WTF::double_conversion::DiyFp	access:public	signature:()
DiyFp	.\dtoa\diy-fp.h	/^        DiyFp(uint64_t f, int e) : f_(f), e_(e) {}$/;"	f	class:WTF::double_conversion::DiyFp	access:public	signature:(uint64_t f, int e)
DiyFp	.\dtoa\diy-fp.h	/^    class DiyFp {$/;"	c	namespace:WTF::double_conversion
DiyFpStrtod	.\dtoa\strtod.cc	/^    static bool DiyFpStrtod(Vector<const char> buffer,$/;"	f	namespace:WTF::double_conversion	file:	signature:(Vector<const char> buffer, int exponent, double* result)
DiyFpToUint64	.\dtoa\double.h	/^        static uint64_t DiyFpToUint64(DiyFp diy_fp) {$/;"	f	class:WTF::double_conversion::Double	access:private	signature:(DiyFp diy_fp)
DoSampledAllocation	.\FastMalloc.cpp	/^static Span* DoSampledAllocation(size_t size) {$/;"	f	namespace:WTF	file:	signature:(size_t size)
Double	.\dtoa\double.h	/^        Double() : d64_(0) {}$/;"	f	class:WTF::double_conversion::Double	access:public	signature:()
Double	.\dtoa\double.h	/^        explicit Double(DiyFp diy_fp)$/;"	f	class:WTF::double_conversion::Double	access:public	signature:(DiyFp diy_fp)
Double	.\dtoa\double.h	/^        explicit Double(double d) : d64_(double_to_uint64(d)) {}$/;"	f	class:WTF::double_conversion::Double	access:public	signature:(double d)
Double	.\dtoa\double.h	/^        explicit Double(uint64_t d64) : d64_(d64) {}$/;"	f	class:WTF::double_conversion::Double	access:public	signature:(uint64_t d64)
Double	.\dtoa\double.h	/^    class Double {$/;"	c	namespace:WTF::double_conversion
DoubleChunk	.\dtoa\bignum.h	/^        typedef uint64_t DoubleChunk;$/;"	t	class:WTF::double_conversion::Bignum	access:private
DoubleStrtod	.\dtoa\strtod.cc	/^    static bool DoubleStrtod(Vector<const char> trimmed,$/;"	f	namespace:WTF::double_conversion	file:	signature:(Vector<const char> trimmed, int exponent, double* result)
DoubleToAscii	.\dtoa\double-conversion.cc	/^    void DoubleToStringConverter::DoubleToAscii(double v,$/;"	f	class:WTF::double_conversion::DoubleToStringConverter	signature:(double v, DtoaMode mode, int requested_digits, char* buffer, int buffer_length, bool* sign, int* length, int* point)
DoubleToAscii	.\dtoa\double-conversion.h	/^        static void DoubleToAscii(double v,$/;"	p	class:WTF::double_conversion::DoubleToStringConverter	access:public	signature:(double v, DtoaMode mode, int requested_digits, char* buffer, int buffer_length, bool* sign, int* length, int* point)
DoubleToStringConverter	.\dtoa\double-conversion.h	/^        DoubleToStringConverter(int flags,$/;"	f	class:WTF::double_conversion::DoubleToStringConverter	access:public	signature:(int flags, const char* infinity_symbol, const char* nan_symbol, char exponent_character, int decimal_in_shortest_low, int decimal_in_shortest_high, int max_leading_padding_zeroes_in_precision_mode, int max_trailing_padding_zeroes_in_precision_mode)
DoubleToStringConverter	.\dtoa\double-conversion.h	/^    class DoubleToStringConverter {$/;"	c	namespace:WTF::double_conversion
DoublyLinkedList	.\DoublyLinkedList.h	/^    DoublyLinkedList();$/;"	p	class:WTF::DoublyLinkedList	access:public	signature:()
DoublyLinkedList	.\DoublyLinkedList.h	/^template<typename T> class DoublyLinkedList {$/;"	c	namespace:WTF
DoublyLinkedList	.\DoublyLinkedList.h	/^template<typename T> inline DoublyLinkedList<T>::DoublyLinkedList()$/;"	f	class:WTF::DoublyLinkedList	signature:()
DoublyLinkedListNode	.\DoublyLinkedList.h	/^    DoublyLinkedListNode();$/;"	p	class:WTF::DoublyLinkedListNode	access:public	signature:()
DoublyLinkedListNode	.\DoublyLinkedList.h	/^template<typename T> class DoublyLinkedListNode {$/;"	c	namespace:WTF
DoublyLinkedListNode	.\DoublyLinkedList.h	/^template<typename T> inline DoublyLinkedListNode<T>::DoublyLinkedListNode()$/;"	f	class:WTF::DoublyLinkedListNode	signature:()
DoublyLinkedList_h	.\DoublyLinkedList.h	27;"	d
DtoaBuffer	.\dtoa.h	/^typedef char DtoaBuffer[80];$/;"	t	namespace:WTF
DtoaMode	.\dtoa\double-conversion.h	/^        enum DtoaMode {$/;"	g	class:WTF::double_conversion::DoubleToStringConverter	access:public
DtoaToBignumDtoaMode	.\dtoa\double-conversion.cc	/^    static BignumDtoaMode DtoaToBignumDtoaMode($/;"	f	namespace:WTF::double_conversion	file:	signature:( DoubleToStringConverter::DtoaMode dtoa_mode)
Dump	.\FastMalloc.cpp	/^  void Dump(TCMalloc_Printer* out);$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:public	signature:(TCMalloc_Printer* out)
Dump	.\FastMalloc.cpp	/^void TCMalloc_PageHeap::Dump(TCMalloc_Printer* out) {$/;"	f	class:WTF::TCMalloc_PageHeap	signature:(TCMalloc_Printer* out)
DumpStackTraces	.\FastMalloc.cpp	/^static void** DumpStackTraces() {$/;"	f	namespace:WTF	file:	signature:()
DumpStats	.\FastMalloc.cpp	/^static void DumpStats(TCMalloc_Printer* out, int level) {$/;"	f	namespace:WTF	file:	signature:(TCMalloc_Printer* out, int level)
EMIT_POSITIVE_EXPONENT_SIGN	.\dtoa\double-conversion.h	/^            EMIT_POSITIVE_EXPONENT_SIGN = 1,$/;"	e	enum:WTF::double_conversion::DoubleToStringConverter::Flags
EMIT_TRAILING_DECIMAL_POINT	.\dtoa\double-conversion.h	/^            EMIT_TRAILING_DECIMAL_POINT = 2,$/;"	e	enum:WTF::double_conversion::DoubleToStringConverter::Flags
EMIT_TRAILING_ZERO_AFTER_POINT	.\dtoa\double-conversion.h	/^            EMIT_TRAILING_ZERO_AFTER_POINT = 4,$/;"	e	enum:WTF::double_conversion::DoubleToStringConverter::Flags
ENABLE	.\Platform.h	56;"	d
ENABLE_ASSEMBLER	.\Platform.h	1031;"	d
ENABLE_ASSEMBLER	.\Platform.h	645;"	d
ENABLE_BRANCH_COMPACTION	.\Platform.h	1118;"	d
ENABLE_CLASSIC_INTERPRETER	.\Platform.h	609;"	d
ENABLE_CLASSIC_INTERPRETER	.\Platform.h	613;"	d
ENABLE_CLASSIC_INTERPRETER	.\Platform.h	977;"	d
ENABLE_CODEBLOCK_SAMPLING	.\Platform.h	864;"	d
ENABLE_COMPARE_AND_SWAP	.\Platform.h	1148;"	d
ENABLE_COMPUTED_GOTO_CLASSIC_INTERPRETER	.\Platform.h	1013;"	d
ENABLE_CONTEXT_MENUS	.\Platform.h	588;"	d
ENABLE_CONTEXT_MENUS	.\Platform.h	808;"	d
ENABLE_DASHBOARD_SUPPORT	.\Platform.h	547;"	d
ENABLE_DASHBOARD_SUPPORT	.\Platform.h	820;"	d
ENABLE_DATA_TRANSFER_ITEMS	.\Platform.h	590;"	d
ENABLE_DATA_TRANSFER_ITEMS	.\Platform.h	816;"	d
ENABLE_DEBUG_WITH_BREAKPOINT	.\Platform.h	859;"	d
ENABLE_DFG_JIT	.\Platform.h	945;"	d
ENABLE_DFG_JIT	.\Platform.h	949;"	d
ENABLE_DRAG_SUPPORT	.\Platform.h	489;"	d
ENABLE_DRAG_SUPPORT	.\Platform.h	589;"	d
ENABLE_DRAG_SUPPORT	.\Platform.h	812;"	d
ENABLE_EXECUTABLE_ALLOCATOR_DEMAND	.\Platform.h	1040;"	d
ENABLE_EXECUTABLE_ALLOCATOR_FIXED	.\Platform.h	1038;"	d
ENABLE_FAST_MALLOC_MATCH_VALIDATION	.\Platform.h	788;"	d
ENABLE_FTPDIR	.\Platform.h	591;"	d
ENABLE_FTPDIR	.\Platform.h	804;"	d
ENABLE_FULLSCREEN_API	.\Platform.h	554;"	d
ENABLE_FULLSCREEN_API	.\Platform.h	640;"	d
ENABLE_FULLSCREEN_API	.\Platform.h	893;"	d
ENABLE_GC_VALIDATION	.\Platform.h	1157;"	d
ENABLE_GEOLOCATION	.\Platform.h	592;"	d
ENABLE_GEOLOCATION	.\Platform.h	873;"	d
ENABLE_GESTURE_EVENTS	.\Platform.h	539;"	d
ENABLE_GLOBAL_FASTMALLOC_NEW	.\Platform.h	648;"	d
ENABLE_GLOBAL_FASTMALLOC_NEW	.\Platform.h	779;"	d
ENABLE_GLOBAL_FASTMALLOC_NEW	.\Platform.h	856;"	d
ENABLE_ICONDATABASE	.\Platform.h	593;"	d
ENABLE_ICONDATABASE	.\Platform.h	792;"	d
ENABLE_INSPECTOR	.\Platform.h	594;"	d
ENABLE_INSPECTOR	.\Platform.h	824;"	d
ENABLE_JAVASCRIPT_DEBUGGER	.\Platform.h	800;"	d
ENABLE_JAVA_BRIDGE	.\Platform.h	544;"	d
ENABLE_JAVA_BRIDGE	.\Platform.h	595;"	d
ENABLE_JAVA_BRIDGE	.\Platform.h	828;"	d
ENABLE_JIT	.\Platform.h	610;"	d
ENABLE_JIT	.\Platform.h	614;"	d
ENABLE_JIT	.\Platform.h	646;"	d
ENABLE_JIT	.\Platform.h	919;"	d
ENABLE_JIT	.\Platform.h	924;"	d
ENABLE_JIT	.\Platform.h	933;"	d
ENABLE_JIT	.\Platform.h	984;"	d
ENABLE_JIT_USE_SOFT_MODULO	.\Platform.h	990;"	d
ENABLE_JIT_USE_SOFT_MODULO	.\Platform.h	996;"	d
ENABLE_LLINT	.\Platform.h	615;"	d
ENABLE_LLINT	.\Platform.h	649;"	d
ENABLE_LLINT	.\Platform.h	939;"	d
ENABLE_META_ALLOCATOR_PROFILE	.\MetaAllocator.h	44;"	d
ENABLE_NETSCAPE_PLUGIN_API	.\Platform.h	596;"	d
ENABLE_NETSCAPE_PLUGIN_API	.\Platform.h	832;"	d
ENABLE_NETSCAPE_PLUGIN_METADATA_CACHE	.\Platform.h	836;"	d
ENABLE_NOTIFICATIONS	.\Platform.h	881;"	d
ENABLE_OPCODE_SAMPLING	.\Platform.h	863;"	d
ENABLE_OPCODE_STATS	.\Platform.h	852;"	d
ENABLE_ORIENTATION_EVENTS	.\Platform.h	597;"	d
ENABLE_ORIENTATION_EVENTS	.\Platform.h	848;"	d
ENABLE_PAN_SCROLLING	.\Platform.h	1045;"	d
ENABLE_PARALLEL_GC	.\Platform.h	1152;"	d
ENABLE_PLUGIN_PACKAGE_SIMPLE_HASH	.\Platform.h	1091;"	d
ENABLE_POINTER_LOCK	.\Platform.h	897;"	d
ENABLE_PURGEABLE_MEMORY	.\Platform.h	584;"	d
ENABLE_PURGEABLE_MEMORY	.\Platform.h	840;"	d
ENABLE_REGEXP_TRACING	.\Platform.h	1017;"	d
ENABLE_REPAINT_THROTTLING	.\Platform.h	598;"	d
ENABLE_REPAINT_THROTTLING	.\Platform.h	914;"	d
ENABLE_RUBBER_BANDING	.\Platform.h	540;"	d
ENABLE_SAMPLING_COUNTERS	.\Platform.h	860;"	d
ENABLE_SAMPLING_FLAGS	.\Platform.h	861;"	d
ENABLE_SAMPLING_REGIONS	.\Platform.h	862;"	d
ENABLE_SAMPLING_THREAD	.\Platform.h	869;"	d
ENABLE_SIMPLE_HEAP_PROFILING	.\Platform.h	966;"	d
ENABLE_SMOOTH_SCROLLING	.\Platform.h	1049;"	d
ENABLE_SMOOTH_SCROLLING	.\Platform.h	555;"	d
ENABLE_SQL_DATABASE	.\Platform.h	796;"	d
ENABLE_TEXT_CARET	.\Platform.h	885;"	d
ENABLE_TEXT_CARET	.\Platform.h	889;"	d
ENABLE_TEXT_NOTIFICATIONS_ONLY	.\Platform.h	1199;"	d
ENABLE_THREADED_SCROLLING	.\Platform.h	1095;"	d
ENABLE_THREADING_GENERIC	.\Platform.h	1126;"	d
ENABLE_THREADING_LIBDISPATCH	.\Platform.h	1122;"	d
ENABLE_THREADING_OPENMP	.\Platform.h	1124;"	d
ENABLE_VALUE_PROFILER	.\Platform.h	958;"	d
ENABLE_VERBOSE_VALUE_PROFILE	.\Platform.h	962;"	d
ENABLE_VIDEO_TRACK	.\Platform.h	559;"	d
ENABLE_VIEWPORT	.\Platform.h	877;"	d
ENABLE_WEB_ARCHIVE	.\Platform.h	1053;"	d
ENABLE_WEB_ARCHIVE	.\Platform.h	556;"	d
ENABLE_WEB_ARCHIVE	.\Platform.h	599;"	d
ENABLE_WEB_ARCHIVE	.\Platform.h	636;"	d
ENABLE_WEB_ARCHIVE	.\Platform.h	653;"	d
ENABLE_WEB_AUDIO	.\Platform.h	557;"	d
ENABLE_WRITE_BARRIER_PROFILING	.\Platform.h	972;"	d
ENABLE_YARR_JIT	.\Platform.h	1021;"	d
ENABLE_YARR_JIT	.\Platform.h	1024;"	d
ENABLE_YARR_JIT	.\Platform.h	611;"	d
ENABLE_YARR_JIT	.\Platform.h	616;"	d
ENABLE_YARR_JIT_DEBUG	.\Platform.h	1027;"	d
EQUAL	.\AVLTree.h	/^        EQUAL = 1,$/;"	e	enum:WTF::AVLTree::SearchType
ERROR	.\Assertions.h	220;"	d
ERROR_DISABLED	.\Assertions.h	96;"	d
ERROR_DISABLED	.\Assertions.h	98;"	d
Ebits	.\dtoa.cpp	136;"	d	file:
EcmaScriptConverter	.\dtoa\double-conversion.cc	/^    const DoubleToStringConverter& DoubleToStringConverter::EcmaScriptConverter() {$/;"	f	class:WTF::double_conversion::DoubleToStringConverter	signature:()
EcmaScriptConverter	.\dtoa\double-conversion.h	/^        static const DoubleToStringConverter& EcmaScriptConverter();$/;"	p	class:WTF::double_conversion::DoubleToStringConverter	access:public	signature:()
Ecore_Evas	.\OwnPtrCommon.h	/^typedef struct _Ecore_Evas Ecore_Evas;$/;"	t	typeref:struct:_Ecore_Evas
Ecore_Pipe	.\OwnPtrCommon.h	/^typedef struct _Ecore_Pipe Ecore_Pipe;$/;"	t	typeref:struct:_Ecore_Pipe
Ecore_Timer	.\OwnPtrCommon.h	/^typedef struct _Ecore_Timer Ecore_Timer;$/;"	t	typeref:struct:_Ecore_Timer
Eina_Module	.\OwnPtrCommon.h	/^typedef struct _Eina_Module Eina_Module;$/;"	t	typeref:struct:_Eina_Module
Emin	.\dtoa.cpp	133;"	d	file:
EmptyValueType	.\HashTraits.h	/^        typedef T EmptyValueType;$/;"	t	struct:WTF::GenericHashTraits	access:public
EmptyValueType	.\HashTraits.h	/^        typedef pair<typename FirstTraits::EmptyValueType, typename SecondTraits::EmptyValueType> EmptyValueType;$/;"	t	struct:WTF::PairHashTraits	access:public
EmptyValueType	.\HashTraits.h	/^        typedef std::nullptr_t EmptyValueType;$/;"	t	struct:WTF::HashTraits	access:public
Encoder	.\Encoder.h	/^    Encoder() { }$/;"	f	class:WTF::Encoder	access:protected	signature:()
Encoder	.\Encoder.h	/^class Encoder {$/;"	c	namespace:WTF
Encoder_h	.\Encoder.h	27;"	d
Ensure	.\TCPageMap.h	/^  bool Ensure(Number start, size_t n) {$/;"	f	class:TCMalloc_PageMap2	access:public	signature:(Number start, size_t n)
Ensure	.\TCPageMap.h	/^  bool Ensure(Number start, size_t n) {$/;"	f	class:TCMalloc_PageMap3	access:public	signature:(Number start, size_t n)
Ensure	.\TCPageMap.h	/^  bool Ensure(Number, size_t) {$/;"	f	class:TCMalloc_PageMap1	access:public	signature:(Number, size_t)
EnsureCapacity	.\dtoa\bignum.h	/^        void EnsureCapacity(int size) {$/;"	f	class:WTF::double_conversion::Bignum	access:private	signature:(int size)
EntryToUpper	.\TCPackedCache.h	/^  static UPPER EntryToUpper(T t) { return t & kUpperMask; }$/;"	f	class:PackedCache	access:private	signature:(T t)
EntryToValue	.\TCPackedCache.h	/^  static V EntryToValue(T t) { return t & kValueMask; }$/;"	f	class:PackedCache	access:private	signature:(T t)
Equal	.\dtoa\bignum.h	/^        static bool Equal(const Bignum& a, const Bignum& b) {$/;"	f	class:WTF::double_conversion::Bignum	access:public	signature:(const Bignum& a, const Bignum& b)
Equal	.\unicode\Collator.h	/^        enum Result { Equal = 0, Greater = 1, Less = -1 };$/;"	e	enum:WTF::Collator::Result
EstimatePower	.\dtoa\bignum-dtoa.cc	/^    static int EstimatePower(int exponent) {$/;"	f	namespace:WTF::double_conversion	file:	signature:(int exponent)
EstimatePower	.\dtoa\bignum-dtoa.cc	/^    static int EstimatePower(int exponent);$/;"	p	namespace:WTF::double_conversion	file:	signature:(int exponent)
EuropeanNumber	.\unicode\glib\UnicodeGLib.h	/^    EuropeanNumber,$/;"	e	enum:WTF::Unicode::Direction
EuropeanNumber	.\unicode\icu\UnicodeIcu.h	/^    EuropeanNumber = U_EUROPEAN_NUMBER,$/;"	e	enum:WTF::Unicode::Direction
EuropeanNumber	.\unicode\qt4\UnicodeQt4.h	/^    EuropeanNumber = QChar::DirEN,$/;"	e	enum:WTF::Unicode::Direction
EuropeanNumber	.\unicode\wince\UnicodeWinCE.h	/^    EuropeanNumber = UnicodeCE::U_EUROPEAN_NUMBER,$/;"	e	enum:WTF::Unicode::Direction
EuropeanNumberSeparator	.\unicode\glib\UnicodeGLib.h	/^    EuropeanNumberSeparator,$/;"	e	enum:WTF::Unicode::Direction
EuropeanNumberSeparator	.\unicode\icu\UnicodeIcu.h	/^    EuropeanNumberSeparator = U_EUROPEAN_NUMBER_SEPARATOR,$/;"	e	enum:WTF::Unicode::Direction
EuropeanNumberSeparator	.\unicode\qt4\UnicodeQt4.h	/^    EuropeanNumberSeparator = QChar::DirES,$/;"	e	enum:WTF::Unicode::Direction
EuropeanNumberSeparator	.\unicode\wince\UnicodeWinCE.h	/^    EuropeanNumberSeparator = UnicodeCE::U_EUROPEAN_NUMBER_SEPARATOR,$/;"	e	enum:WTF::Unicode::Direction
EuropeanNumberTerminator	.\unicode\glib\UnicodeGLib.h	/^    EuropeanNumberTerminator,$/;"	e	enum:WTF::Unicode::Direction
EuropeanNumberTerminator	.\unicode\icu\UnicodeIcu.h	/^    EuropeanNumberTerminator = U_EUROPEAN_NUMBER_TERMINATOR,$/;"	e	enum:WTF::Unicode::Direction
EuropeanNumberTerminator	.\unicode\qt4\UnicodeQt4.h	/^    EuropeanNumberTerminator = QChar::DirET,$/;"	e	enum:WTF::Unicode::Direction
EuropeanNumberTerminator	.\unicode\wince\UnicodeWinCE.h	/^    EuropeanNumberTerminator = UnicodeCE::U_EUROPEAN_NUMBER_TERMINATOR,$/;"	e	enum:WTF::Unicode::Direction
Evas_Object	.\OwnPtrCommon.h	/^typedef struct _Evas_Object Evas_Object;$/;"	t	typeref:struct:_Evas_Object
Event	.\FastMalloc.cpp	/^void Event(Span* span, char op, int v = 0) {$/;"	f	namespace:WTF	signature:(Span* span, char op, int v = 0)
Event	.\FastMalloc.cpp	1143;"	d	file:
EvictRandomSizeClass	.\FastMalloc.cpp	/^  static ALWAYS_INLINE bool EvictRandomSizeClass(size_t locked_size_class, bool force);$/;"	p	class:WTF::TCMalloc_Central_FreeList	file:	access:private	signature:(size_t locked_size_class, bool force)
EvictRandomSizeClass	.\FastMalloc.cpp	/^ALWAYS_INLINE bool TCMalloc_Central_FreeList::EvictRandomSizeClass($/;"	f	class:WTF::TCMalloc_Central_FreeList	signature:( size_t locked_size_class, bool force)
Exp_1	.\dtoa.cpp	134;"	d	file:
Exp_11	.\dtoa.cpp	135;"	d	file:
Exp_mask	.\dtoa.cpp	130;"	d	file:
Exp_msk1	.\dtoa.cpp	128;"	d	file:
Exp_msk11	.\dtoa.cpp	129;"	d	file:
Exp_shift	.\dtoa.cpp	126;"	d	file:
Exp_shift1	.\dtoa.cpp	127;"	d	file:
Exponent	.\dtoa\double.h	/^        int Exponent() const {$/;"	f	class:WTF::double_conversion::Double	access:public	signature:() const
ExportMacros_h	.\ExportMacros.h	31;"	d
ExtractStats	.\FastMalloc.cpp	/^static void ExtractStats(TCMallocStats* r, uint64_t* class_count) {$/;"	f	namespace:WTF	file:	signature:(TCMallocStats* r, uint64_t* class_count)
F1	.\MD5.cpp	114;"	d	file:
F2	.\MD5.cpp	115;"	d	file:
F3	.\MD5.cpp	116;"	d	file:
F4	.\MD5.cpp	117;"	d	file:
FAST_DTOA_PRECISION	.\dtoa\fast-dtoa.h	/^        FAST_DTOA_PRECISION$/;"	e	enum:WTF::double_conversion::FastDtoaMode
FAST_DTOA_SHORTEST	.\dtoa\fast-dtoa.h	/^        FAST_DTOA_SHORTEST,$/;"	e	enum:WTF::double_conversion::FastDtoaMode
FATAL	.\Assertions.h	336;"	d
FATAL	.\Assertions.h	338;"	d
FATAL	.\Assertions.h	340;"	d
FATAL_DISABLED	.\Assertions.h	88;"	d
FATAL_DISABLED	.\Assertions.h	90;"	d
FINAL	.\Compiler.h	234;"	d
FINAL	.\Compiler.h	237;"	d
FINAL	.\Compiler.h	242;"	d
FIXED	.\dtoa\double-conversion.h	/^            FIXED,$/;"	e	enum:WTF::double_conversion::DoubleToStringConverter::DtoaMode
FLAGS_malloc_devmem_limit	.\TCSystemAlloc.cpp	/^static const int32_t FLAGS_malloc_devmem_limit = 0;$/;"	v	file:
FLAGS_malloc_devmem_start	.\TCSystemAlloc.cpp	/^static const int32_t FLAGS_malloc_devmem_start = 0;$/;"	v	file:
FORCE_SYSTEM_MALLOC	.\FastMalloc.cpp	97;"	d	file:
FORCE_SYSTEM_MALLOC	.\FastMalloc.cpp	99;"	d	file:
FastAllocBase_h	.\FastAllocBase.h	30;"	d
FastDtoa	.\dtoa\fast-dtoa.cc	/^    bool FastDtoa(double v,$/;"	f	namespace:WTF::double_conversion	signature:(double v, FastDtoaMode mode, int requested_digits, Vector<char> buffer, int* length, int* decimal_point)
FastDtoa	.\dtoa\fast-dtoa.h	/^    bool FastDtoa(double d,$/;"	p	namespace:WTF::double_conversion	signature:(double d, FastDtoaMode mode, int requested_digits, Vector<char> buffer, int* length, int* decimal_point)
FastDtoaMode	.\dtoa\fast-dtoa.h	/^    enum FastDtoaMode {$/;"	g	namespace:WTF::double_conversion
FastFixedDtoa	.\dtoa\fixed-dtoa.cc	/^    bool FastFixedDtoa(double v,$/;"	f	namespace:WTF::double_conversion	signature:(double v, int fractional_count, Vector<char> buffer, int* length, int* decimal_point)
FastFixedDtoa	.\dtoa\fixed-dtoa.h	/^    bool FastFixedDtoa(double v, int fractional_count,$/;"	p	namespace:WTF::double_conversion	signature:(double v, int fractional_count, Vector<char> buffer, int* length, int* decimal_point)
FastMallocPages	.\OSAllocator.h	/^        FastMallocPages = VM_TAG_FOR_TCMALLOC_MEMORY,$/;"	e	enum:WTF::OSAllocator::Usage
FastMallocStatistics	.\FastMalloc.h	/^    struct FastMallocStatistics {$/;"	s	namespace:WTF
FastMallocZone	.\FastMalloc.cpp	/^    FastMallocZone(TCMalloc_PageHeap*, TCMalloc_ThreadCache**, TCMalloc_Central_FreeListPadded*, PageHeapAllocator<Span>*, PageHeapAllocator<TCMalloc_ThreadCache>*);$/;"	p	class:WTF::FastMallocZone	file:	access:private	signature:(TCMalloc_PageHeap*, TCMalloc_ThreadCache**, TCMalloc_Central_FreeListPadded*, PageHeapAllocator<Span>*, PageHeapAllocator<TCMalloc_ThreadCache>*)
FastMallocZone	.\FastMalloc.cpp	/^FastMallocZone::FastMallocZone(TCMalloc_PageHeap* pageHeap, TCMalloc_ThreadCache** threadHeaps, TCMalloc_Central_FreeListPadded* centralCaches, PageHeapAllocator<Span>* spanAllocator, PageHeapAllocator<TCMalloc_ThreadCache>* pageHeapAllocator)$/;"	f	class:WTF::FastMallocZone	signature:(TCMalloc_PageHeap* pageHeap, TCMalloc_ThreadCache** threadHeaps, TCMalloc_Central_FreeListPadded* centralCaches, PageHeapAllocator<Span>* spanAllocator, PageHeapAllocator<TCMalloc_ThreadCache>* pageHeapAllocator)
FastMallocZone	.\FastMalloc.cpp	/^class FastMallocZone {$/;"	c	namespace:WTF	file:
FetchFromCentralCache	.\FastMalloc.cpp	/^  ALWAYS_INLINE void FetchFromCentralCache(size_t cl, size_t allocationSize);$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:(size_t cl, size_t allocationSize)
FetchFromCentralCache	.\FastMalloc.cpp	/^ALWAYS_INLINE void TCMalloc_ThreadCache::FetchFromCentralCache(size_t cl, size_t allocationSize) {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:(size_t cl, size_t allocationSize)
FetchFromSpans	.\FastMalloc.cpp	/^  void* FetchFromSpans();$/;"	p	class:WTF::TCMalloc_Central_FreeList	file:	access:private	signature:()
FetchFromSpans	.\FastMalloc.cpp	/^void* TCMalloc_Central_FreeList::FetchFromSpans() {$/;"	f	class:WTF::TCMalloc_Central_FreeList	signature:()
FetchFromSpansSafe	.\FastMalloc.cpp	/^  void* FetchFromSpansSafe();$/;"	p	class:WTF::TCMalloc_Central_FreeList	file:	access:private	signature:()
FetchFromSpansSafe	.\FastMalloc.cpp	/^void* TCMalloc_Central_FreeList::FetchFromSpansSafe() {$/;"	f	class:WTF::TCMalloc_Central_FreeList	signature:()
FillDigits32	.\dtoa\fixed-dtoa.cc	/^    static void FillDigits32(uint32_t number, Vector<char> buffer, int* length) {$/;"	f	namespace:WTF::double_conversion	file:	signature:(uint32_t number, Vector<char> buffer, int* length)
FillDigits32FixedLength	.\dtoa\fixed-dtoa.cc	/^    static void FillDigits32FixedLength(uint32_t number, int requested_length,$/;"	f	namespace:WTF::double_conversion	file:	signature:(uint32_t number, int requested_length, Vector<char> buffer, int* length)
FillDigits64	.\dtoa\fixed-dtoa.cc	/^    static void FillDigits64(uint64_t number, Vector<char> buffer, int* length) {$/;"	f	namespace:WTF::double_conversion	file:	signature:(uint64_t number, Vector<char> buffer, int* length)
FillDigits64FixedLength	.\dtoa\fixed-dtoa.cc	/^    static void FillDigits64FixedLength(uint64_t number, int requested_length,$/;"	f	namespace:WTF::double_conversion	file:	signature:(uint64_t number, int requested_length, Vector<char> buffer, int* length)
FillFractionals	.\dtoa\fixed-dtoa.cc	/^    static void FillFractionals(uint64_t fractionals, int exponent,$/;"	f	namespace:WTF::double_conversion	file:	signature:(uint64_t fractionals, int exponent, int fractional_count, Vector<char> buffer, int* length, int* decimal_point)
Finalize	.\TCSpinLock.h	/^    inline void Finalize() { }$/;"	f	struct:TCMalloc_SpinLock	access:public	signature:()
Finalize	.\TCSpinLock.h	/^  inline void Finalize() {$/;"	f	struct:TCMalloc_SpinLock	access:public	signature:()
Finalize	.\dtoa\utils.h	/^        char* Finalize() {$/;"	f	class:WTF::double_conversion::StringBuilder	access:public	signature:()
FirstTraits	.\HashTraits.h	/^        typedef FirstTraitsArg FirstTraits;$/;"	t	struct:WTF::PairHashTraits	access:public
FirstTraits	.\VectorTraits.h	/^        typedef VectorTraits<First> FirstTraits;$/;"	t	struct:WTF::VectorTraits	access:public
FixedArray	.\FixedArray.h	/^template <typename T, size_t Size> class FixedArray {$/;"	c	namespace:WTF
FixedArray_h	.\FixedArray.h	27;"	d
FixupMultiply10	.\dtoa\bignum-dtoa.cc	/^    static void FixupMultiply10(int estimated_power, bool is_even,$/;"	f	namespace:WTF::double_conversion	file:	signature:(int estimated_power, bool is_even, int* decimal_point, Bignum* numerator, Bignum* denominator, Bignum* delta_minus, Bignum* delta_plus)
FixupMultiply10	.\dtoa\bignum-dtoa.cc	/^    static void FixupMultiply10(int estimated_power, bool is_even,$/;"	p	namespace:WTF::double_conversion	file:	signature:(int estimated_power, bool is_even, int* decimal_point, Bignum* numerator, Bignum* denominator, Bignum* delta_minus, Bignum* delta_plus)
Flags	.\dtoa\double-conversion.h	/^        enum Flags {$/;"	g	class:WTF::double_conversion::DoubleToStringConverter	access:public
Flags	.\dtoa\double-conversion.h	/^        enum Flags {$/;"	g	class:WTF::double_conversion::StringToDoubleConverter	access:public
Float32Array	.\Float32Array.h	/^    inline Float32Array(PassRefPtr<ArrayBuffer>,$/;"	p	class:WTF::Float32Array	access:private	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
Float32Array	.\Float32Array.h	/^Float32Array::Float32Array(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Float32Array	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
Float32Array	.\Float32Array.h	/^class Float32Array : public TypedArrayBase<float> {$/;"	c	namespace:WTF	inherits:TypedArrayBase
Float32Array_h	.\Float32Array.h	28;"	d
Float64Array	.\Float64Array.h	/^    inline Float64Array(PassRefPtr<ArrayBuffer>,$/;"	p	class:WTF::Float64Array	access:private	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
Float64Array	.\Float64Array.h	/^Float64Array::Float64Array(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Float64Array	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
Float64Array	.\Float64Array.h	/^class Float64Array : public TypedArrayBase<double> {$/;"	c	namespace:WTF	inherits:TypedArrayBase
Float64Array_h	.\Float64Array.h	28;"	d
FloatConversionFlags	.\text\WTFString.h	/^enum FloatConversionFlags {$/;"	g	namespace:WTF
FloatHash	.\HashFunctions.h	/^    template<typename T> struct FloatHash {$/;"	s	namespace:WTF
FloatHashTraits	.\HashTraits.h	/^    template<typename T> struct FloatHashTraits : GenericHashTraits<T> {$/;"	s	namespace:WTF	inherits:GenericHashTraits
Force8Bit	.\text\StringImpl.h	/^    enum Force8Bit { Force8BitConstructor };$/;"	g	class:WTF::StringImpl	access:private
Force8BitConstructor	.\text\StringImpl.h	/^    enum Force8Bit { Force8BitConstructor };$/;"	e	enum:WTF::StringImpl::Force8Bit
Frac_mask	.\dtoa.cpp	137;"	d	file:
Frac_mask1	.\dtoa.cpp	138;"	d	file:
Fragment	.\url\src\URLSegments.h	/^        Fragment,$/;"	e	enum:WTF::URLSegments::ComponentType
FreeBytes	.\FastMalloc.cpp	/^  uint64_t FreeBytes() const {$/;"	f	class:WTF::TCMalloc_PageHeap	access:public	signature:() const
FreeList	.\FastMalloc.cpp	/^  typedef TCMalloc_ThreadCache_FreeList FreeList;$/;"	t	class:WTF::TCMalloc_ThreadCache	file:	access:private
FreeObjectFinder	.\FastMalloc.cpp	/^    FreeObjectFinder(const RemoteMemoryReader& reader) : m_reader(reader) { }$/;"	f	class:WTF::FreeObjectFinder	access:public	signature:(const RemoteMemoryReader& reader)
FreeObjectFinder	.\FastMalloc.cpp	/^class FreeObjectFinder {$/;"	c	namespace:WTF	file:
FreeSpaceNode	.\MetaAllocator.h	/^        FreeSpaceNode(void* start, size_t sizeInBytes)$/;"	f	class:WTF::MetaAllocator::FreeSpaceNode	access:public	signature:(void* start, size_t sizeInBytes)
FreeSpaceNode	.\MetaAllocator.h	/^    class FreeSpaceNode : public RedBlackTree<FreeSpaceNode, size_t>::Node {$/;"	c	class:WTF::MetaAllocator	inherits:RedBlackTree::Node	access:private
FullLookupType	.\HashTable.h	/^        typedef pair<LookupType, unsigned> FullLookupType;$/;"	t	class:WTF::HashTable	access:private
Function	.\Functional.h	/^    Function()$/;"	f	class:WTF::Function	access:public	signature:()
Function	.\Functional.h	/^    Function(PassRefPtr<FunctionImpl<R ()> > impl)$/;"	f	class:WTF::Function	access:public	signature:(PassRefPtr<FunctionImpl<R ()> > impl)
Function	.\Functional.h	/^class Function<R ()> : public FunctionBase {$/;"	c	namespace:WTF	inherits:FunctionBase
FunctionBase	.\Functional.h	/^    FunctionBase()$/;"	f	class:WTF::FunctionBase	access:protected	signature:()
FunctionBase	.\Functional.h	/^    explicit FunctionBase(PassRefPtr<FunctionImplBase> impl)$/;"	f	class:WTF::FunctionBase	access:protected	signature:(PassRefPtr<FunctionImplBase> impl)
FunctionBase	.\Functional.h	/^class FunctionBase {$/;"	c	namespace:WTF
FunctionImpl	.\Functional.h	/^class FunctionImpl<R ()> : public FunctionImplBase {$/;"	c	namespace:WTF	inherits:FunctionImplBase
FunctionImplBase	.\Functional.h	/^class FunctionImplBase : public ThreadSafeRefCounted<FunctionImplBase> {$/;"	c	namespace:WTF	inherits:ThreadSafeRefCounted
FunctionQueue	.\MainThread.cpp	/^typedef Deque<FunctionWithContext> FunctionQueue;$/;"	t	namespace:WTF	file:
FunctionWithContext	.\MainThread.cpp	/^    FunctionWithContext(MainThreadFunction* function = 0, void* context = 0, ThreadCondition* syncFlag = 0)$/;"	f	struct:WTF::FunctionWithContext	access:public	signature:(MainThreadFunction* function = 0, void* context = 0, ThreadCondition* syncFlag = 0)
FunctionWithContext	.\MainThread.cpp	/^struct FunctionWithContext {$/;"	s	namespace:WTF	file:
FunctionWithContextFinder	.\MainThread.cpp	/^    FunctionWithContextFinder(const FunctionWithContext& m) : m(m) {}$/;"	f	class:WTF::FunctionWithContextFinder	access:public	signature:(const FunctionWithContext& m)
FunctionWithContextFinder	.\MainThread.cpp	/^class FunctionWithContextFinder {$/;"	c	namespace:WTF	file:
FunctionWrapper	.\Functional.h	/^    explicit FunctionWrapper(R (*function)())$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(R (function)))
FunctionWrapper	.\Functional.h	/^    explicit FunctionWrapper(R (*function)(P1))$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(R (function)P1))
FunctionWrapper	.\Functional.h	/^    explicit FunctionWrapper(R (*function)(P1, P2))$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(R (function)P1, P2))
FunctionWrapper	.\Functional.h	/^    explicit FunctionWrapper(R (*function)(P1, P2, P3))$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(R (function)P1, P2, P3))
FunctionWrapper	.\Functional.h	/^class FunctionWrapper<R (*)()> {$/;"	c	namespace:WTF
FunctionWrapper	.\Functional.h	/^class FunctionWrapper<R (*)(P1)> {$/;"	c	namespace:WTF
FunctionWrapper	.\Functional.h	/^class FunctionWrapper<R (*)(P1, P2)> {$/;"	c	namespace:WTF
FunctionWrapper	.\Functional.h	/^class FunctionWrapper<R (*)(P1, P2, P3)> {$/;"	c	namespace:WTF
FunctionWrapper	.\Functional.h	/^class FunctionWrapper<R (C::*)()> {$/;"	c	namespace:WTF
FunctionWrapper	.\Functional.h	/^class FunctionWrapper<R (C::*)(P1)> {$/;"	c	namespace:WTF
FunctionWrapper	.\Functional.h	/^class FunctionWrapper<R (C::*)(P1, P2)> {$/;"	c	namespace:WTF
FunctionWrapper	.\Functional.h	/^class FunctionWrapper<R (C::*)(P1, P2, P3)> {$/;"	c	namespace:WTF
FunctionWrapper	.\Functional.h	/^class FunctionWrapper<R (C::*)(P1, P2, P3, P4)> {$/;"	c	namespace:WTF
FunctionWrapper	.\Functional.h	/^class FunctionWrapper<R (C::*)(P1, P2, P3, P4, P5)> {$/;"	c	namespace:WTF
GAsyncResult	.\gobject\GTypedefs.h	/^typedef struct _GAsyncResult GAsyncResult;$/;"	t	typeref:struct:_GAsyncResult
GCCE_VERSION	.\Compiler.h	88;"	d
GCCE_VERSION_AT_LEAST	.\Compiler.h	89;"	d
GCC_VERSION	.\Compiler.h	96;"	d
GCC_VERSION_AT_LEAST	.\Compiler.h	106;"	d
GCC_VERSION_AT_LEAST	.\Compiler.h	97;"	d
GCancellable	.\gobject\GTypedefs.h	/^typedef struct _GCancellable GCancellable;$/;"	t	typeref:struct:_GCancellable
GCharsetConverter	.\gobject\GTypedefs.h	/^typedef struct _GCharsetConverter GCharsetConverter;$/;"	t	typeref:struct:_GCharsetConverter
GDir	.\gobject\GTypedefs.h	/^typedef struct _GDir GDir;$/;"	t	typeref:struct:_GDir
GError	.\gobject\GTypedefs.h	/^typedef struct _GError GError;$/;"	t	typeref:struct:_GError
GFile	.\gobject\GTypedefs.h	/^typedef struct _GFile GFile;$/;"	t	typeref:struct:_GFile
GHashTable	.\gobject\GTypedefs.h	/^typedef struct _GHashTable GHashTable;$/;"	t	typeref:struct:_GHashTable
GInputStream	.\gobject\GTypedefs.h	/^typedef struct _GInputStream GInputStream;$/;"	t	typeref:struct:_GInputStream
GKeyFile	.\gobject\GTypedefs.h	/^typedef struct _GKeyFile GKeyFile;$/;"	t	typeref:struct:_GKeyFile
GList	.\gobject\GTypedefs.h	/^typedef struct _GList GList;$/;"	t	typeref:struct:_GList
GMainContext	.\gobject\GTypedefs.h	/^typedef struct _GMainContext GMainContext;$/;"	t	typeref:struct:_GMainContext
GMainLoop	.\gobject\GTypedefs.h	/^typedef struct _GMainLoop GMainLoop;$/;"	t	typeref:struct:_GMainLoop
GOwnPtr	.\gobject\GOwnPtr.h	/^    explicit GOwnPtr(T* ptr = 0) : m_ptr(ptr) { }$/;"	f	class:WTF::GOwnPtr	access:public	signature:(T* ptr = 0)
GOwnPtr	.\gobject\GOwnPtr.h	/^template <typename T> class GOwnPtr {$/;"	c	namespace:WTF
GOwnPtr_h	.\gobject\GOwnPtr.h	23;"	d
GPatternSpec	.\gobject\GTypedefs.h	/^typedef struct _GPatternSpec GPatternSpec;$/;"	t	typeref:struct:_GPatternSpec
GPollableOutputStream	.\gobject\GTypedefs.h	/^typedef struct _GPollableOutputStream GPollableOutputStream;$/;"	t	typeref:struct:_GPollableOutputStream
GREATER	.\AVLTree.h	/^        GREATER = 4,$/;"	e	enum:WTF::AVLTree::SearchType
GREATER_EQUAL	.\AVLTree.h	/^        GREATER_EQUAL = EQUAL | GREATER$/;"	e	enum:WTF::AVLTree::SearchType
GRefPtr	.\gobject\GRefPtr.h	/^    GRefPtr() : m_ptr(0) { }$/;"	f	class:WTF::GRefPtr	access:public	signature:()
GRefPtr	.\gobject\GRefPtr.h	/^    GRefPtr(HashTableDeletedValueType) : m_ptr(hashTableDeletedValue()) { }$/;"	f	class:WTF::GRefPtr	access:public	signature:(HashTableDeletedValueType)
GRefPtr	.\gobject\GRefPtr.h	/^    GRefPtr(T* ptr)$/;"	f	class:WTF::GRefPtr	access:public	signature:(T* ptr)
GRefPtr	.\gobject\GRefPtr.h	/^    GRefPtr(T* ptr, GRefPtrAdoptType) : m_ptr(ptr) {}$/;"	f	class:WTF::GRefPtr	access:private	signature:(T* ptr, GRefPtrAdoptType)
GRefPtr	.\gobject\GRefPtr.h	/^    GRefPtr(const GRefPtr& o)$/;"	f	class:WTF::GRefPtr	access:public	signature:(const GRefPtr& o)
GRefPtr	.\gobject\GRefPtr.h	/^    template <typename U> GRefPtr(const GRefPtr<U>& o)$/;"	f	class:WTF::GRefPtr	access:public	signature:(const GRefPtr<U>& o)
GRefPtr	.\gobject\GRefPtr.h	/^template <typename T> class GRefPtr {$/;"	c	namespace:WTF
GRefPtrAdopt	.\gobject\GRefPtr.h	/^enum GRefPtrAdoptType { GRefPtrAdopt };$/;"	e	enum:WTF::GRefPtrAdoptType
GRefPtrAdoptType	.\gobject\GRefPtr.h	/^enum GRefPtrAdoptType { GRefPtrAdopt };$/;"	g	namespace:WTF
GSList	.\gobject\GTypedefs.h	/^typedef struct _GSList GSList;$/;"	t	typeref:struct:_GSList
GSocketClient	.\gobject\GTypedefs.h	/^typedef struct _GSocketClient GSocketClient;$/;"	t	typeref:struct:_GSocketClient
GSocketConnection	.\gobject\GTypedefs.h	/^typedef struct _GSocketConnection GSocketConnection;$/;"	t	typeref:struct:_GSocketConnection
GSource	.\gobject\GTypedefs.h	/^typedef struct _GSource GSource;$/;"	t	typeref:struct:_GSource
GTimer	.\gobject\GTypedefs.h	/^typedef struct _GTimer GTimer;$/;"	t	typeref:struct:_GTimer
GVariant	.\gobject\GRefPtr.cpp	/^} GVariant; $/;"	t	namespace:WTF	typeref:struct:WTF::_GVariant	file:
GVariant	.\gobject\GTypedefs.h	/^typedef struct _GVariant GVariant;$/;"	t	typeref:struct:_GVariant
GdkAtom	.\gobject\GTypedefs.h	/^typedef struct _GdkAtom* GdkAtom;$/;"	t	typeref:struct:_GdkAtom
GdkCursor	.\gobject\GTypedefs.h	/^typedef struct _GdkCursor GdkCursor;$/;"	t	typeref:struct:_GdkCursor
GdkDragContext	.\gobject\GTypedefs.h	/^typedef struct _GdkDragContext GdkDragContext;$/;"	t	typeref:struct:_GdkDragContext
GdkEvent	.\gobject\GTypedefs.h	/^typedef union _GdkEvent GdkEvent;$/;"	t	typeref:union:_GdkEvent
GdkEventConfigure	.\gobject\GTypedefs.h	/^typedef struct _GdkEventConfigure GdkEventConfigure;$/;"	t	typeref:struct:_GdkEventConfigure
GdkEventExpose	.\gobject\GTypedefs.h	/^typedef struct _GdkEventExpose GdkEventExpose;$/;"	t	typeref:struct:_GdkEventExpose
GdkPixbuf	.\gobject\GTypedefs.h	/^typedef struct _GdkPixbuf GdkPixbuf;$/;"	t	typeref:struct:_GdkPixbuf
GdkRectangle	.\gobject\GTypedefs.h	/^typedef struct _GdkRectangle GdkRectangle;$/;"	t	typeref:struct:_GdkRectangle
GdkWindow	.\gobject\GTypedefs.h	/^typedef struct _GdkDrawable GdkWindow;$/;"	t	typeref:struct:_GdkDrawable
GdkWindow	.\gobject\GTypedefs.h	/^typedef struct _GdkWindow GdkWindow;$/;"	t	typeref:struct:_GdkWindow
GenerateCountedDigits	.\dtoa\bignum-dtoa.cc	/^    static void GenerateCountedDigits(int count, int* decimal_point,$/;"	f	namespace:WTF::double_conversion	file:	signature:(int count, int* decimal_point, Bignum* numerator, Bignum* denominator, Vector<char>(buffer), int* length)
GenerateCountedDigits	.\dtoa\bignum-dtoa.cc	/^    static void GenerateCountedDigits(int count, int* decimal_point,$/;"	p	namespace:WTF::double_conversion	file:	signature:(int count, int* decimal_point, Bignum* numerator, Bignum* denominator, Vector<char>(buffer), int* length)
GenerateShortestDigits	.\dtoa\bignum-dtoa.cc	/^    static void GenerateShortestDigits(Bignum* numerator, Bignum* denominator,$/;"	f	namespace:WTF::double_conversion	file:	signature:(Bignum* numerator, Bignum* denominator, Bignum* delta_minus, Bignum* delta_plus, bool is_even, Vector<char> buffer, int* length)
GenerateShortestDigits	.\dtoa\bignum-dtoa.cc	/^    static void GenerateShortestDigits(Bignum* numerator, Bignum* denominator,$/;"	p	namespace:WTF::double_conversion	file:	signature:(Bignum* numerator, Bignum* denominator, Bignum* delta_minus, Bignum* delta_plus, bool is_even, Vector<char> buffer, int* length)
GenericHashTraits	.\HashTraits.h	/^    template<typename T> struct GenericHashTraits : GenericHashTraitsBase<IsInteger<T>::value, T> {$/;"	s	namespace:WTF	inherits:GenericHashTraitsBase
GenericHashTraitsBase	.\HashTraits.h	/^    template<typename T> struct GenericHashTraitsBase<false, T> {$/;"	s	namespace:WTF
GenericHashTraitsBase	.\HashTraits.h	/^    template<typename T> struct GenericHashTraitsBase<true, T> : GenericHashTraitsBase<false, T> {$/;"	s	namespace:WTF	inherits:GenericHashTraitsBase
GetCache	.\FastMalloc.cpp	/^  static TCMalloc_ThreadCache* GetCache();$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:()
GetCache	.\FastMalloc.cpp	/^inline TCMalloc_ThreadCache* TCMalloc_ThreadCache::GetCache() {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:()
GetCacheIfPresent	.\FastMalloc.cpp	/^  static TCMalloc_ThreadCache* GetCacheIfPresent();$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:()
GetCacheIfPresent	.\FastMalloc.cpp	/^inline TCMalloc_ThreadCache* TCMalloc_ThreadCache::GetCacheIfPresent() {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:()
GetCachedPowerForBinaryExponentRange	.\dtoa\cached-powers.cc	/^    void PowersOfTenCache::GetCachedPowerForBinaryExponentRange($/;"	f	class:WTF::double_conversion::PowersOfTenCache	signature:( int min_exponent, int max_exponent, DiyFp* power, int* decimal_exponent)
GetCachedPowerForBinaryExponentRange	.\dtoa\cached-powers.h	/^        static void GetCachedPowerForBinaryExponentRange(int min_exponent,$/;"	p	class:WTF::double_conversion::PowersOfTenCache	access:public	signature:(int min_exponent, int max_exponent, DiyFp* power, int* decimal_exponent)
GetCachedPowerForDecimalExponent	.\dtoa\cached-powers.cc	/^    void PowersOfTenCache::GetCachedPowerForDecimalExponent(int requested_exponent,$/;"	f	class:WTF::double_conversion::PowersOfTenCache	signature:(int requested_exponent, DiyFp* power, int* found_exponent)
GetCachedPowerForDecimalExponent	.\dtoa\cached-powers.h	/^        static void GetCachedPowerForDecimalExponent(int requested_exponent,$/;"	p	class:WTF::double_conversion::PowersOfTenCache	access:public	signature:(int requested_exponent, DiyFp* power, int* found_exponent)
GetDescriptor	.\FastMalloc.cpp	/^  inline Span* GetDescriptor(PageID p) const {$/;"	f	class:WTF::TCMalloc_PageHeap	access:public	signature:(PageID p) const
GetDescriptorEnsureSafe	.\FastMalloc.cpp	/^  inline Span* GetDescriptorEnsureSafe(PageID p)$/;"	f	class:WTF::TCMalloc_PageHeap	access:public	signature:(PageID p)
GetNumericProperty	.\FastMalloc.cpp	/^  virtual bool GetNumericProperty(const char* name, size_t* value) {$/;"	f	class:WTF::TCMallocImplementation	access:public	signature:(const char* name, size_t* value)
GetOrDefault	.\TCPackedCache.h	/^  V GetOrDefault(K key, V default_value) const {$/;"	f	class:PackedCache	access:public	signature:(K key, V default_value) const
GetSizeClassIfCached	.\FastMalloc.cpp	/^  size_t GetSizeClassIfCached(PageID p) const {$/;"	f	class:WTF::TCMalloc_PageHeap	access:public	signature:(PageID p) const
GetStackTrace	.\FastMalloc.cpp	553;"	d	file:
GetStats	.\FastMalloc.cpp	/^  virtual void GetStats(char* buffer, int buffer_length) {$/;"	f	class:WTF::TCMallocImplementation	access:public	signature:(char* buffer, int buffer_length)
GetThreadHeap	.\FastMalloc.cpp	/^  static TCMalloc_ThreadCache* GetThreadHeap();$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:()
GetThreadHeap	.\FastMalloc.cpp	/^inline TCMalloc_ThreadCache* TCMalloc_ThreadCache::GetThreadHeap() {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:()
GlibUtilities_h	.\gobject\GlibUtilities.h	21;"	d
Greater	.\unicode\Collator.h	/^        enum Result { Equal = 0, Greater = 1, Less = -1 };$/;"	e	enum:WTF::Collator::Result
Grisu3	.\dtoa\fast-dtoa.cc	/^    static bool Grisu3(double v,$/;"	f	namespace:WTF::double_conversion	file:	signature:(double v, Vector<char> buffer, int* length, int* decimal_exponent)
Grisu3Counted	.\dtoa\fast-dtoa.cc	/^    static bool Grisu3Counted(double v,$/;"	f	namespace:WTF::double_conversion	file:	signature:(double v, int requested_digits, Vector<char> buffer, int* length, int* decimal_exponent)
GrowHeap	.\FastMalloc.cpp	/^  bool GrowHeap(Length n);$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:private	signature:(Length n)
GrowHeap	.\FastMalloc.cpp	/^bool TCMalloc_PageHeap::GrowHeap(Length n) {$/;"	f	class:WTF::TCMalloc_PageHeap	signature:(Length n)
GtkAction	.\gobject\GTypedefs.h	/^typedef struct _GtkAction GtkAction;$/;"	t	typeref:struct:_GtkAction
GtkAdjustment	.\gobject\GTypedefs.h	/^typedef struct _GtkAdjustment GtkAdjustment;$/;"	t	typeref:struct:_GtkAdjustment
GtkBorder	.\gobject\GTypedefs.h	/^typedef struct _GtkBorder GtkBorder;$/;"	t	typeref:struct:_GtkBorder
GtkClipboard	.\gobject\GTypedefs.h	/^typedef struct _GtkClipboard GtkClipboard;$/;"	t	typeref:struct:_GtkClipboard
GtkContainer	.\gobject\GTypedefs.h	/^typedef struct _GtkContainer GtkContainer;$/;"	t	typeref:struct:_GtkContainer
GtkIconInfo	.\gobject\GTypedefs.h	/^typedef struct _GtkIconInfo GtkIconInfo;$/;"	t	typeref:struct:_GtkIconInfo
GtkMenu	.\gobject\GTypedefs.h	/^typedef struct _GtkMenu GtkMenu;$/;"	t	typeref:struct:_GtkMenu
GtkMenuItem	.\gobject\GTypedefs.h	/^typedef struct _GtkMenuItem GtkMenuItem;$/;"	t	typeref:struct:_GtkMenuItem
GtkObject	.\gobject\GTypedefs.h	/^typedef struct _GtkObject GtkObject;$/;"	t	typeref:struct:_GtkObject
GtkSelectionData	.\gobject\GTypedefs.h	/^typedef struct _GtkSelectionData GtkSelectionData;$/;"	t	typeref:struct:_GtkSelectionData
GtkStyle	.\gobject\GTypedefs.h	/^typedef struct _GtkStyle GtkStyle;$/;"	t	typeref:struct:_GtkStyle
GtkStyleContext	.\gobject\GTypedefs.h	/^typedef struct _GtkStyleContext GtkStyleContext;$/;"	t	typeref:struct:_GtkStyleContext
GtkTargetList	.\gobject\GTypedefs.h	/^typedef struct _GtkTargetList GtkTargetList;$/;"	t	typeref:struct:_GtkTargetList
GtkThemeParts	.\gobject\GTypedefs.h	/^typedef struct _GtkThemeParts GtkThemeParts;$/;"	t	typeref:struct:_GtkThemeParts
GtkTypedefs_h	.\gobject\GTypedefs.h	21;"	d
GtkWidget	.\gobject\GTypedefs.h	/^typedef struct _GtkWidget GtkWidget;$/;"	t	typeref:struct:_GtkWidget
GtkWindow	.\gobject\GTypedefs.h	/^typedef struct _GtkWindow GtkWindow;$/;"	t	typeref:struct:_GtkWindow
HANDLE	.\wince\MemoryManager.h	/^typedef void *HANDLE;$/;"	t
HAVE	.\Platform.h	45;"	d
HAVE_ACCESSIBILITY	.\Platform.h	669;"	d
HAVE_ALIGNED_MALLOC	.\Platform.h	734;"	d
HAVE_COMPUTED_GOTO	.\Platform.h	1010;"	d
HAVE_DISPATCH_H	.\Platform.h	580;"	d
HAVE_DISPATCH_H	.\Platform.h	712;"	d
HAVE_ERRNO_H	.\Platform.h	699;"	d
HAVE_ERRNO_H	.\Platform.h	731;"	d
HAVE_ERRNO_H	.\Platform.h	741;"	d
HAVE_ERRNO_H	.\Platform.h	753;"	d
HAVE_ERRNO_H	.\Platform.h	765;"	d
HAVE_HOSTED_CORE_ANIMATION	.\Platform.h	713;"	d
HAVE_INVERTED_WHEEL_EVENTS	.\Platform.h	1178;"	d
HAVE_ISDEBUGGERPRESENT	.\Platform.h	735;"	d
HAVE_LANGINFO_H	.\Platform.h	700;"	d
HAVE_LANGINFO_H	.\Platform.h	754;"	d
HAVE_LANGINFO_H	.\Platform.h	766;"	d
HAVE_LAYER_HOSTING_IN_WINDOW_SERVER	.\Platform.h	562;"	d
HAVE_MADV_FREE	.\Platform.h	717;"	d
HAVE_MADV_FREE	.\Platform.h	724;"	d
HAVE_MADV_FREE	.\Platform.h	744;"	d
HAVE_MADV_FREE_REUSE	.\Platform.h	716;"	d
HAVE_MADV_FREE_REUSE	.\Platform.h	743;"	d
HAVE_MERGESORT	.\Platform.h	702;"	d
HAVE_MMAP	.\Platform.h	701;"	d
HAVE_MMAP	.\Platform.h	742;"	d
HAVE_MMAP	.\Platform.h	767;"	d
HAVE_NETWORK_CFDATA_ARRAY_CALLBACK	.\Platform.h	600;"	d
HAVE_NMAP	.\Platform.h	755;"	d
HAVE_PTHREAD_RWLOCK	.\Platform.h	551;"	d
HAVE_PTHREAD_RWLOCK	.\Platform.h	569;"	d
HAVE_PTHREAD_RWLOCK	.\Platform.h	601;"	d
HAVE_PTHREAD_RWLOCK	.\Platform.h	660;"	d
HAVE_PTHREAD_RWLOCK	.\Platform.h	664;"	d
HAVE_PTHREAD_SETNAME_NP	.\Platform.h	718;"	d
HAVE_PTHREAD_SETNAME_NP	.\Platform.h	725;"	d
HAVE_READLINE	.\Platform.h	552;"	d
HAVE_READLINE	.\Platform.h	602;"	d
HAVE_RUNLOOP_TIMER	.\Platform.h	553;"	d
HAVE_RUNLOOP_TIMER	.\Platform.h	603;"	d
HAVE_SBRK	.\Platform.h	703;"	d
HAVE_SBRK	.\Platform.h	745;"	d
HAVE_SBRK	.\Platform.h	756;"	d
HAVE_SBRK	.\Platform.h	768;"	d
HAVE_SIGNAL_H	.\Platform.h	674;"	d
HAVE_STRINGS_H	.\Platform.h	704;"	d
HAVE_STRINGS_H	.\Platform.h	746;"	d
HAVE_STRINGS_H	.\Platform.h	757;"	d
HAVE_STRINGS_H	.\Platform.h	769;"	d
HAVE_STRNSTR	.\Platform.h	685;"	d
HAVE_SYS_PARAM_H	.\Platform.h	705;"	d
HAVE_SYS_PARAM_H	.\Platform.h	747;"	d
HAVE_SYS_PARAM_H	.\Platform.h	758;"	d
HAVE_SYS_PARAM_H	.\Platform.h	770;"	d
HAVE_SYS_TIMEB_H	.\Platform.h	707;"	d
HAVE_SYS_TIMEB_H	.\Platform.h	733;"	d
HAVE_SYS_TIME_H	.\Platform.h	706;"	d
HAVE_SYS_TIME_H	.\Platform.h	748;"	d
HAVE_SYS_TIME_H	.\Platform.h	759;"	d
HAVE_SYS_TIME_H	.\Platform.h	771;"	d
HAVE_TIMEGM	.\Platform.h	694;"	d
HAVE_TM_GMTOFF	.\Platform.h	692;"	d
HAVE_TM_ZONE	.\Platform.h	693;"	d
HAVE_VARIADIC_MACRO	.\Assertions.h	61;"	d
HAVE_VARIADIC_MACRO	.\Assertions.h	63;"	d
HAVE_VASPRINTF	.\Platform.h	679;"	d
HAVE_VIRTUALALLOC	.\Platform.h	737;"	d
HBITMAP	.\OwnPtrCommon.h	/^typedef struct HBITMAP__* HBITMAP;$/;"	t	typeref:struct:HBITMAP__
HBITMAP	.\wince\MemoryManager.h	/^typedef struct HBITMAP__* HBITMAP;$/;"	t	typeref:struct:HBITMAP__
HBRUSH	.\OwnPtrCommon.h	/^typedef struct HBRUSH__* HBRUSH;$/;"	t	typeref:struct:HBRUSH__
HDC	.\OwnPtrCommon.h	/^typedef struct HDC__* HDC;$/;"	t	typeref:struct:HDC__
HDC	.\wince\MemoryManager.h	/^typedef struct HDC__* HDC;$/;"	t	typeref:struct:HDC__
HFONT	.\OwnPtrCommon.h	/^typedef struct HFONT__* HFONT;$/;"	t	typeref:struct:HFONT__
HIDDEN_INLINE	.\ExportMacros.h	96;"	d
HIDE_SYMBOL	.\InlineASM.h	57;"	d
HIDE_SYMBOL	.\InlineASM.h	60;"	d
HIDE_SYMBOL	.\InlineASM.h	68;"	d
HIDE_SYMBOL	.\InlineASM.h	70;"	d
HPALETTE	.\OwnPtrCommon.h	/^typedef struct HPALETTE__* HPALETTE;$/;"	t	typeref:struct:HPALETTE__
HPEN	.\OwnPtrCommon.h	/^typedef struct HPEN__* HPEN;$/;"	t	typeref:struct:HPEN__
HRGN	.\OwnPtrCommon.h	/^typedef struct HRGN__* HRGN;$/;"	t	typeref:struct:HRGN__
HandleSpecialValues	.\dtoa\double-conversion.cc	/^    bool DoubleToStringConverter::HandleSpecialValues($/;"	f	class:WTF::double_conversion::DoubleToStringConverter	signature:( double value, StringBuilder* result_builder) const
HandleSpecialValues	.\dtoa\double-conversion.h	/^        bool HandleSpecialValues(double value, StringBuilder* result_builder) const;$/;"	p	class:WTF::double_conversion::DoubleToStringConverter	access:private	signature:(double value, StringBuilder* result_builder) const
Has	.\TCPackedCache.h	/^  bool Has(K key) const {$/;"	f	class:PackedCache	access:public	signature:(K key) const
HasRefAndDeref	.\Functional.h	/^class HasRefAndDeref {$/;"	c	namespace:WTF
HasTrivialConstructor	.\TypeTraits.h	/^        template <> struct HasTrivialConstructor<const volatile wchar_t> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^        template <> struct HasTrivialConstructor<const wchar_t> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^        template <> struct HasTrivialConstructor<volatile wchar_t> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^        template <> struct HasTrivialConstructor<wchar_t> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<bool> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const bool> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const double> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const float> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const long double> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const signed char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const signed int> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const signed long long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const signed long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const signed short> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const unsigned char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const unsigned int> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const unsigned long long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const unsigned long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const unsigned short> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const volatile bool> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const volatile char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const volatile double> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const volatile float> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const volatile long double> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const volatile signed char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const volatile signed int> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const volatile signed long long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const volatile signed long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const volatile signed short> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const volatile unsigned char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const volatile unsigned int> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const volatile unsigned long long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const volatile unsigned long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const volatile unsigned short> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<double> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<float> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<long double> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<signed char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<signed int> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<signed long long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<signed long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<signed short> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<unsigned char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<unsigned int> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<unsigned long long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<unsigned long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<unsigned short> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<volatile bool> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<volatile char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<volatile double> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<volatile float> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<volatile long double> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<volatile signed char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<volatile signed int> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<volatile signed long long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<volatile signed long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<volatile signed short> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<volatile unsigned char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<volatile unsigned int> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<volatile unsigned long long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<volatile unsigned long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<volatile unsigned short> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <typename T> struct HasTrivialConstructor : public IntegralConstant<bool, __has_trivial_constructor(T)>{ };$/;"	s	namespace:WTF	inherits:IntegralConstant
HasTrivialConstructor	.\TypeTraits.h	/^    template <typename T> struct HasTrivialConstructor : public false_type{ };$/;"	s	namespace:WTF	inherits:false_type
HasTrivialConstructor	.\TypeTraits.h	/^    template <typename T> struct HasTrivialConstructor<T*> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialConstructor	.\TypeTraits.h	/^    template<typename T> struct HasTrivialConstructor : public std::tr1::has_trivial_constructor<T> { };$/;"	s	namespace:WTF	inherits:std::tr1::has_trivial_constructor
HasTrivialDestructor	.\TypeTraits.h	/^        template <> struct HasTrivialDestructor<const volatile wchar_t> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^        template <> struct HasTrivialDestructor<const wchar_t> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^        template <> struct HasTrivialDestructor<volatile wchar_t> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^        template <> struct HasTrivialDestructor<wchar_t> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<bool> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const bool> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const double> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const float> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const long double> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const signed char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const signed int> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const signed long long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const signed long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const signed short> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const unsigned char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const unsigned int> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const unsigned long long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const unsigned long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const unsigned short> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const volatile bool> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const volatile char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const volatile double> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const volatile float> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const volatile long double> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const volatile signed char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const volatile signed int> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const volatile signed long long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const volatile signed long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const volatile signed short> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const volatile unsigned char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const volatile unsigned int> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const volatile unsigned long long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const volatile unsigned long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const volatile unsigned short> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<double> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<float> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<long double> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<signed char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<signed int> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<signed long long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<signed long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<signed short> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<unsigned char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<unsigned int> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<unsigned long long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<unsigned long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<unsigned short> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<volatile bool> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<volatile char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<volatile double> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<volatile float> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<volatile long double> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<volatile signed char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<volatile signed int> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<volatile signed long long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<volatile signed long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<volatile signed short> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<volatile unsigned char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<volatile unsigned int> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<volatile unsigned long long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<volatile unsigned long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<volatile unsigned short> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <typename T> struct HasTrivialDestructor : public IntegralConstant<bool, __has_trivial_destructor(T)>{ };$/;"	s	namespace:WTF	inherits:IntegralConstant
HasTrivialDestructor	.\TypeTraits.h	/^    template <typename T> struct HasTrivialDestructor : public false_type{ };$/;"	s	namespace:WTF	inherits:false_type
HasTrivialDestructor	.\TypeTraits.h	/^    template <typename T> struct HasTrivialDestructor<T*> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
HasTrivialDestructor	.\TypeTraits.h	/^    template<typename T> struct HasTrivialDestructor : public std::tr1::has_trivial_destructor<T> { };$/;"	s	namespace:WTF	inherits:std::tr1::has_trivial_destructor
Hash	.\HashFunctions.h	/^    template<> struct DefaultHash<double> { typedef FloatHash<double> Hash; };$/;"	t	struct:WTF::DefaultHash	access:public
Hash	.\HashFunctions.h	/^    template<> struct DefaultHash<float> { typedef FloatHash<float> Hash; };$/;"	t	struct:WTF::DefaultHash	access:public
Hash	.\HashFunctions.h	/^    template<> struct DefaultHash<int> { typedef IntHash<unsigned> Hash; };$/;"	t	struct:WTF::DefaultHash	access:public
Hash	.\HashFunctions.h	/^    template<> struct DefaultHash<long long> { typedef IntHash<unsigned long long> Hash; };$/;"	t	struct:WTF::DefaultHash	access:public
Hash	.\HashFunctions.h	/^    template<> struct DefaultHash<long> { typedef IntHash<unsigned long> Hash; };$/;"	t	struct:WTF::DefaultHash	access:public
Hash	.\HashFunctions.h	/^    template<> struct DefaultHash<short> { typedef IntHash<unsigned> Hash; };$/;"	t	struct:WTF::DefaultHash	access:public
Hash	.\HashFunctions.h	/^    template<> struct DefaultHash<unsigned long long> { typedef IntHash<unsigned long long> Hash; };$/;"	t	struct:WTF::DefaultHash	access:public
Hash	.\HashFunctions.h	/^    template<> struct DefaultHash<unsigned long> { typedef IntHash<unsigned long> Hash; };$/;"	t	struct:WTF::DefaultHash	access:public
Hash	.\HashFunctions.h	/^    template<> struct DefaultHash<unsigned short> { typedef IntHash<unsigned> Hash; };$/;"	t	struct:WTF::DefaultHash	access:public
Hash	.\HashFunctions.h	/^    template<> struct DefaultHash<unsigned> { typedef IntHash<unsigned> Hash; };$/;"	t	struct:WTF::DefaultHash	access:public
Hash	.\HashFunctions.h	/^    template<> struct DefaultHash<wchar_t> { typedef IntHash<wchar_t> Hash; };$/;"	t	struct:WTF::DefaultHash	access:public
Hash	.\HashFunctions.h	/^    template<typename P> struct DefaultHash<P*> { typedef PtrHash<P*> Hash; };$/;"	t	struct:WTF::DefaultHash	access:public
Hash	.\HashFunctions.h	/^    template<typename P> struct DefaultHash<RefPtr<P> > { typedef PtrHash<RefPtr<P> > Hash; };$/;"	t	struct:WTF::DefaultHash	access:public
Hash	.\HashFunctions.h	/^    template<typename T, typename U> struct DefaultHash<std::pair<T, U> > { typedef PairHash<T, U> Hash; };$/;"	t	struct:WTF::DefaultHash	access:public
Hash	.\RetainPtr.h	/^    template<typename P> struct DefaultHash<RetainPtr<P> > { typedef PtrHash<RetainPtr<P> > Hash; };$/;"	t	struct:WTF::DefaultHash	access:public
Hash	.\TCPackedCache.h	/^  static size_t Hash(K key) {$/;"	f	class:PackedCache	access:private	signature:(K key)
Hash	.\text\AtomicString.h	/^    typedef AtomicStringHash Hash;$/;"	t	struct:WTF::DefaultHash	access:public
Hash	.\text\StringImpl.h	/^    typedef StringHash Hash;$/;"	t	struct:WTF::DefaultHash	access:public
Hash	.\text\WTFString.h	/^    typedef StringHash Hash;$/;"	t	struct:WTF::DefaultHash	access:public
HashAndCharacters	.\text\AtomicString.cpp	/^struct HashAndCharacters {$/;"	s	namespace:WTF	file:
HashAndCharactersTranslator	.\text\AtomicString.cpp	/^struct HashAndCharactersTranslator {$/;"	s	namespace:WTF	file:
HashAndUTF8Characters	.\text\AtomicString.cpp	/^struct HashAndUTF8Characters {$/;"	s	namespace:WTF	file:
HashAndUTF8CharactersTranslator	.\text\AtomicString.cpp	/^struct HashAndUTF8CharactersTranslator {$/;"	s	namespace:WTF	file:
HashCountedSet	.\HashCountedSet.h	/^        HashCountedSet() {}$/;"	f	class:WTF::HashCountedSet	access:public	signature:()
HashCountedSet	.\HashCountedSet.h	/^        typename Traits = HashTraits<Value> > class HashCountedSet {$/;"	c	namespace:WTF
HashFunctions	.\HashMap.h	/^        typedef HashArg HashFunctions;$/;"	t	class:WTF::HashMap	access:private
HashFunctions	.\HashSet.h	/^        typedef HashArg HashFunctions;$/;"	t	class:WTF::HashSet	access:private
HashFunctions	.\ListHashSet.h	/^        typedef HashArg HashFunctions;$/;"	t	class:WTF::ListHashSet	access:private
HashFunctions	.\RefPtrHashMap.h	/^        typedef HashArg HashFunctions;$/;"	t	class:WTF::HashMap	access:private
HashItemKnownGood	.\HashTable.h	/^    typedef enum { HashItemKnownGood } HashItemKnownGoodTag;$/;"	e	enum:WTF::__anon8
HashItemKnownGoodTag	.\HashTable.h	/^    typedef enum { HashItemKnownGood } HashItemKnownGoodTag;$/;"	t	namespace:WTF	typeref:enum:WTF::__anon8
HashMap	.\HashMap.h	/^    class HashMap {$/;"	c	namespace:WTF
HashMap	.\RefPtrHashMap.h	/^    class HashMap<RefPtr<T>, MappedArg, HashArg, KeyTraitsArg, MappedTraitsArg> {$/;"	c	namespace:WTF
HashMapKeysProxy	.\HashMap.h	/^            HashMapKeysProxy();$/;"	p	class:WTF::HashMap::HashMapKeysProxy	access:private	signature:()
HashMapKeysProxy	.\HashMap.h	/^            HashMapKeysProxy(const HashMapKeysProxy&);$/;"	p	class:WTF::HashMap::HashMapKeysProxy	access:private	signature:(const HashMapKeysProxy&)
HashMapKeysProxy	.\HashMap.h	/^        class HashMapKeysProxy : private HashMap {$/;"	c	class:WTF::HashMap	inherits:HashMap	access:private
HashMapTranslator	.\HashMap.h	/^    struct HashMapTranslator {$/;"	s	namespace:WTF
HashMapTranslatorAdapter	.\HashMap.h	/^    struct HashMapTranslatorAdapter {$/;"	s	namespace:WTF
HashMapValuesProxy	.\HashMap.h	/^            HashMapValuesProxy();$/;"	p	class:WTF::HashMap::HashMapValuesProxy	access:private	signature:()
HashMapValuesProxy	.\HashMap.h	/^            HashMapValuesProxy(const HashMapValuesProxy&);$/;"	p	class:WTF::HashMap::HashMapValuesProxy	access:private	signature:(const HashMapValuesProxy&)
HashMapValuesProxy	.\HashMap.h	/^        class HashMapValuesProxy : private HashMap {$/;"	c	class:WTF::HashMap	inherits:HashMap	access:private
HashSet	.\HashSet.h	/^        typename TraitsArg = HashTraits<ValueArg> > class HashSet {$/;"	c	namespace:WTF
HashSetTranslatorAdapter	.\HashSet.h	/^    struct HashSetTranslatorAdapter {$/;"	s	namespace:WTF
HashTable	.\HashTable.h	/^        HashTable();$/;"	p	class:WTF::HashTable	access:public	signature:()
HashTable	.\HashTable.h	/^        HashTable(const HashTable&);$/;"	p	class:WTF::HashTable	access:public	signature:(const HashTable&)
HashTable	.\HashTable.h	/^    HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::HashTable(const HashTable& other)$/;"	f	class:WTF::HashTable	signature:(const HashTable& other)
HashTable	.\HashTable.h	/^    class HashTable {$/;"	c	namespace:WTF
HashTable	.\HashTable.h	/^    inline HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::HashTable()$/;"	f	class:WTF::HashTable	signature:()
HashTableBucketInitializer	.\HashTable.h	/^    template<> struct HashTableBucketInitializer<false> {$/;"	s	namespace:WTF
HashTableBucketInitializer	.\HashTable.h	/^    template<> struct HashTableBucketInitializer<true> {$/;"	s	namespace:WTF
HashTableConstIterator	.\HashTable.h	/^        HashTableConstIterator()$/;"	f	class:WTF::HashTableConstIterator	access:public	signature:()
HashTableConstIterator	.\HashTable.h	/^        HashTableConstIterator(const HashTableType* table, PointerType position, PointerType endPosition)$/;"	f	class:WTF::HashTableConstIterator	access:private	signature:(const HashTableType* table, PointerType position, PointerType endPosition)
HashTableConstIterator	.\HashTable.h	/^        HashTableConstIterator(const HashTableType* table, PointerType position, PointerType endPosition, HashItemKnownGoodTag)$/;"	f	class:WTF::HashTableConstIterator	access:private	signature:(const HashTableType* table, PointerType position, PointerType endPosition, HashItemKnownGoodTag)
HashTableConstIterator	.\HashTable.h	/^        HashTableConstIterator(const const_iterator& other)$/;"	f	class:WTF::HashTableConstIterator	access:public	signature:(const const_iterator& other)
HashTableConstIterator	.\HashTable.h	/^    class HashTableConstIterator {$/;"	c	namespace:WTF
HashTableConstIteratorAdapter	.\HashIterators.h	/^        HashTableConstIteratorAdapter() {}$/;"	f	struct:WTF::HashTableConstIteratorAdapter	access:public	signature:()
HashTableConstIteratorAdapter	.\HashIterators.h	/^        HashTableConstIteratorAdapter(const typename HashTableType::const_iterator& impl) : m_impl(impl) {}$/;"	f	struct:WTF::HashTableConstIteratorAdapter	access:public	signature:(const typename HashTableType::const_iterator& impl)
HashTableConstIteratorAdapter	.\HashIterators.h	/^    template<typename HashTableType, typename KeyType, typename MappedType> struct HashTableConstIteratorAdapter<HashTableType, std::pair<KeyType, MappedType> > {$/;"	s	namespace:WTF
HashTableConstIteratorAdapter	.\HashTable.h	/^        HashTableConstIteratorAdapter() {}$/;"	f	struct:WTF::HashTableConstIteratorAdapter	access:public	signature:()
HashTableConstIteratorAdapter	.\HashTable.h	/^        HashTableConstIteratorAdapter(const typename HashTableType::const_iterator& impl) : m_impl(impl) {}$/;"	f	struct:WTF::HashTableConstIteratorAdapter	access:public	signature:(const typename HashTableType::const_iterator& impl)
HashTableConstIteratorAdapter	.\HashTable.h	/^    template<typename HashTableType, typename ValueType> struct HashTableConstIteratorAdapter {$/;"	s	namespace:WTF
HashTableConstKeysIterator	.\HashIterators.h	/^        HashTableConstKeysIterator(const ConstIterator& impl) : m_impl(impl) {}$/;"	f	struct:WTF::HashTableConstKeysIterator	access:public	signature:(const ConstIterator& impl)
HashTableConstKeysIterator	.\HashIterators.h	/^    template<typename HashTableType, typename KeyType, typename MappedType> struct HashTableConstKeysIterator {$/;"	s	namespace:WTF
HashTableConstValuesIterator	.\HashIterators.h	/^        HashTableConstValuesIterator(const ConstIterator& impl) : m_impl(impl) {}$/;"	f	struct:WTF::HashTableConstValuesIterator	access:public	signature:(const ConstIterator& impl)
HashTableConstValuesIterator	.\HashIterators.h	/^    template<typename HashTableType, typename KeyType, typename MappedType> struct HashTableConstValuesIterator {$/;"	s	namespace:WTF
HashTableDeletedValue	.\RefPtr.h	/^    enum HashTableDeletedValueType { HashTableDeletedValue };$/;"	e	enum:WTF::HashTableDeletedValueType
HashTableDeletedValueType	.\RefPtr.h	/^    enum HashTableDeletedValueType { HashTableDeletedValue };$/;"	g	namespace:WTF
HashTableIterator	.\HashTable.h	/^        HashTableIterator() { }$/;"	f	class:WTF::HashTableIterator	access:public	signature:()
HashTableIterator	.\HashTable.h	/^        HashTableIterator(HashTableType* table, PointerType pos, PointerType end) : m_iterator(table, pos, end) { }$/;"	f	class:WTF::HashTableIterator	access:private	signature:(HashTableType* table, PointerType pos, PointerType end)
HashTableIterator	.\HashTable.h	/^        HashTableIterator(HashTableType* table, PointerType pos, PointerType end, HashItemKnownGoodTag tag) : m_iterator(table, pos, end, tag) { }$/;"	f	class:WTF::HashTableIterator	access:private	signature:(HashTableType* table, PointerType pos, PointerType end, HashItemKnownGoodTag tag)
HashTableIterator	.\HashTable.h	/^    class HashTableIterator {$/;"	c	namespace:WTF
HashTableIteratorAdapter	.\HashIterators.h	/^        HashTableIteratorAdapter() {}$/;"	f	struct:WTF::HashTableIteratorAdapter	access:public	signature:()
HashTableIteratorAdapter	.\HashIterators.h	/^        HashTableIteratorAdapter(const typename HashTableType::iterator& impl) : m_impl(impl) {}$/;"	f	struct:WTF::HashTableIteratorAdapter	access:public	signature:(const typename HashTableType::iterator& impl)
HashTableIteratorAdapter	.\HashIterators.h	/^    template<typename HashTableType, typename KeyType, typename MappedType> struct HashTableIteratorAdapter<HashTableType, std::pair<KeyType, MappedType> > {$/;"	s	namespace:WTF
HashTableIteratorAdapter	.\HashTable.h	/^        HashTableIteratorAdapter() {}$/;"	f	struct:WTF::HashTableIteratorAdapter	access:public	signature:()
HashTableIteratorAdapter	.\HashTable.h	/^        HashTableIteratorAdapter(const typename HashTableType::iterator& impl) : m_impl(impl) {}$/;"	f	struct:WTF::HashTableIteratorAdapter	access:public	signature:(const typename HashTableType::iterator& impl)
HashTableIteratorAdapter	.\HashTable.h	/^    template<typename HashTableType, typename ValueType> struct HashTableIteratorAdapter {$/;"	s	namespace:WTF
HashTableKeysIterator	.\HashIterators.h	/^        HashTableKeysIterator(const Iterator& impl) : m_impl(impl) {}$/;"	f	struct:WTF::HashTableKeysIterator	access:public	signature:(const Iterator& impl)
HashTableKeysIterator	.\HashIterators.h	/^    template<typename HashTableType, typename KeyType, typename MappedType> struct HashTableKeysIterator {$/;"	s	namespace:WTF
HashTableStats	.\HashTable.h	/^    struct HashTableStats {$/;"	s	namespace:WTF
HashTableType	.\HashMap.h	/^            HashFunctions, ValueTraits, KeyTraits> HashTableType;$/;"	t	class:WTF::HashMap	access:private
HashTableType	.\HashSet.h	/^            HashFunctions, ValueTraits, ValueTraits> HashTableType;$/;"	t	class:WTF::HashSet	access:private
HashTableType	.\HashTable.h	/^        typedef HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits> HashTableType;$/;"	t	class:WTF::HashTableConstIterator	access:private
HashTableType	.\HashTable.h	/^        typedef HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits> HashTableType;$/;"	t	class:WTF::HashTableIterator	access:private
HashTableType	.\RefPtrHashMap.h	/^            HashFunctions, ValueTraits, KeyTraits> HashTableType;$/;"	t	class:WTF::HashMap	access:private
HashTableValuesIterator	.\HashIterators.h	/^        HashTableValuesIterator(const Iterator& impl) : m_impl(impl) {}$/;"	f	struct:WTF::HashTableValuesIterator	access:public	signature:(const Iterator& impl)
HashTableValuesIterator	.\HashIterators.h	/^    template<typename HashTableType, typename KeyType, typename MappedType> struct HashTableValuesIterator {$/;"	s	namespace:WTF
HashTraits	.\HashTraits.h	/^    struct HashTraits<pair<First, Second> > : public PairHashTraits<HashTraits<First>, HashTraits<Second> > { };$/;"	s	namespace:WTF	inherits:PairHashTraits
HashTraits	.\HashTraits.h	/^    template<> struct HashTraits<String> : SimpleClassHashTraits<String> { };$/;"	s	namespace:WTF	inherits:SimpleClassHashTraits
HashTraits	.\HashTraits.h	/^    template<> struct HashTraits<double> : FloatHashTraits<double> { };$/;"	s	namespace:WTF	inherits:FloatHashTraits
HashTraits	.\HashTraits.h	/^    template<> struct HashTraits<float> : FloatHashTraits<float> { };$/;"	s	namespace:WTF	inherits:FloatHashTraits
HashTraits	.\HashTraits.h	/^    template<typename P> struct HashTraits<OwnPtr<P> > : SimpleClassHashTraits<OwnPtr<P> > {$/;"	s	namespace:WTF	inherits:SimpleClassHashTraits
HashTraits	.\HashTraits.h	/^    template<typename P> struct HashTraits<P*> : GenericHashTraits<P*> {$/;"	s	namespace:WTF	inherits:GenericHashTraits
HashTraits	.\HashTraits.h	/^    template<typename P> struct HashTraits<RefPtr<P> > : SimpleClassHashTraits<RefPtr<P> > {$/;"	s	namespace:WTF	inherits:SimpleClassHashTraits
HashTraits	.\HashTraits.h	/^    template<typename T> struct HashTraits : GenericHashTraits<T> { };$/;"	s	namespace:WTF	inherits:GenericHashTraits
HashTraits	.\RetainPtr.h	/^    template<typename P> struct HashTraits<RetainPtr<P> > : SimpleClassHashTraits<RetainPtr<P> > { };$/;"	s	namespace:WTF	inherits:SimpleClassHashTraits
HashTraits	.\text\AtomicStringHash.h	/^    template<> struct HashTraits<WTF::AtomicString> : GenericHashTraits<WTF::AtomicString> {$/;"	s	namespace:WTF	inherits:GenericHashTraits
Header	.\RefCountedArray.h	/^    struct Header {$/;"	s	class:WTF::RefCountedArray	access:private
HexCharOfValue	.\dtoa\bignum.cc	/^    static char HexCharOfValue(int value) {$/;"	f	namespace:WTF::double_conversion	file:	signature:(int value)
HexCharValue	.\dtoa\bignum.cc	/^    static int HexCharValue(char c) {$/;"	f	namespace:WTF::double_conversion	file:	signature:(char c)
HexCharacter	.\url\src\URLCharacterTypes.h	/^        HexCharacter = 1 << 3,$/;"	e	enum:WTF::URLCharacterTypes::CharTypes
HexConversionMode	.\HexNumber.h	/^enum HexConversionMode {$/;"	g	namespace:WTF
HexNumber_h	.\HexNumber.h	21;"	d
Host	.\url\src\URLSegments.h	/^        Host,$/;"	e	enum:WTF::URLSegments::ComponentType
INTERIOR_BITS	.\TCPageMap.h	/^  static const int INTERIOR_BITS = (BITS + 2) \/ 3; \/\/ Round-up$/;"	m	class:TCMalloc_PageMap3	access:private
INTERIOR_LENGTH	.\TCPageMap.h	/^  static const int INTERIOR_LENGTH = 1 << INTERIOR_BITS;$/;"	m	class:TCMalloc_PageMap3	access:private
IPv4Character	.\url\src\URLCharacterTypes.h	/^        IPv4Character = 1 << 2,$/;"	e	enum:WTF::URLCharacterTypes::CharTypes
IdentifierTable	.\WTFThreadData.h	/^class IdentifierTable {$/;"	c	namespace:JSC
IdentityExtractor	.\HashSet.h	/^    struct IdentityExtractor {$/;"	s	namespace:WTF
IdentityHashTranslator	.\HashTable.h	/^    template<typename HashFunctions> class IdentityHashTranslator {$/;"	c	namespace:WTF
IdentityTranslatorType	.\HashTable.h	/^        typedef IdentityHashTranslator<HashFunctions> IdentityTranslatorType;$/;"	t	class:WTF::HashTable	access:public
ImplType	.\HashCountedSet.h	/^        typedef HashMap<Value, unsigned, HashFunctions, Traits> ImplType;$/;"	t	class:WTF::HashCountedSet	access:private
ImplType	.\ListHashSet.h	/^        typedef HashTable<Node*, Node*, IdentityExtractor, NodeHash, NodeTraits, NodeTraits> ImplType;$/;"	t	class:WTF::ListHashSet	access:private
ImplTypeConstIterator	.\ListHashSet.h	/^        typedef HashTableConstIterator<Node*, Node*, IdentityExtractor, NodeHash, NodeTraits, NodeTraits> ImplTypeConstIterator;$/;"	t	class:WTF::ListHashSet	access:private
ImplTypeIterator	.\ListHashSet.h	/^        typedef HashTableIterator<Node*, Node*, IdentityExtractor, NodeHash, NodeTraits, NodeTraits> ImplTypeIterator;$/;"	t	class:WTF::ListHashSet	access:private
IncrementalScavenge	.\FastMalloc.cpp	/^  void IncrementalScavenge(Length n);$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:private	signature:(Length n)
IncrementalScavenge	.\FastMalloc.cpp	/^void TCMalloc_PageHeap::IncrementalScavenge(Length n) {$/;"	f	class:WTF::TCMalloc_PageHeap	signature:(Length n)
Infinity	.\dtoa\double.h	/^        static double Infinity() {$/;"	f	class:WTF::double_conversion::Double	access:public	signature:()
Init	.\FastMalloc.cpp	/^  void Init() {$/;"	f	class:WTF::PageHeapAllocator	access:public	signature:()
Init	.\FastMalloc.cpp	/^  void Init() {$/;"	f	class:WTF::TCMalloc_ThreadCache_FreeList	access:public	signature:()
Init	.\FastMalloc.cpp	/^  void Init(ThreadIdentifier tid);$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:(ThreadIdentifier tid)
Init	.\FastMalloc.cpp	/^  void Init(size_t cl);$/;"	p	class:WTF::TCMalloc_Central_FreeList	file:	access:public	signature:(size_t cl)
Init	.\FastMalloc.cpp	/^void TCMalloc_Central_FreeList::Init(size_t cl) {$/;"	f	class:WTF::TCMalloc_Central_FreeList	signature:(size_t cl)
Init	.\FastMalloc.cpp	/^void TCMalloc_ThreadCache::Init(ThreadIdentifier tid) {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:(ThreadIdentifier tid)
Init	.\TCSpinLock.h	/^    inline void Init() { lockword_ = 0; }$/;"	f	struct:TCMalloc_SpinLock	access:public	signature:()
Init	.\TCSpinLock.h	/^    inline void Init() { m_lockword = 0; }$/;"	f	struct:TCMalloc_SpinLock	access:public	signature:()
Init	.\TCSpinLock.h	/^  inline void Init() {$/;"	f	struct:TCMalloc_SpinLock	access:public	signature:()
InitModule	.\FastMalloc.cpp	/^  static void                  InitModule();$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:()
InitModule	.\FastMalloc.cpp	/^void TCMalloc_ThreadCache::InitModule() {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:()
InitSizeClasses	.\FastMalloc.cpp	/^static void InitSizeClasses() {$/;"	f	namespace:WTF	file:	signature:()
InitTSD	.\FastMalloc.cpp	/^  static void                  InitTSD();$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:()
InitTSD	.\FastMalloc.cpp	/^void TCMalloc_ThreadCache::InitTSD() {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:()
InitialScaledStartValues	.\dtoa\bignum-dtoa.cc	/^    static void InitialScaledStartValues(double v,$/;"	f	namespace:WTF::double_conversion	file:	signature:(double v, int estimated_power, bool need_boundary_deltas, Bignum* numerator, Bignum* denominator, Bignum* delta_minus, Bignum* delta_plus)
InitialScaledStartValues	.\dtoa\bignum-dtoa.cc	/^    static void InitialScaledStartValues(double v,$/;"	p	namespace:WTF::double_conversion	file:	signature:(double v, int estimated_power, bool need_boundary_deltas, Bignum* numerator, Bignum* denominator, Bignum* delta_minus, Bignum* delta_plus)
InitialScaledStartValuesNegativeExponentNegativePower	.\dtoa\bignum-dtoa.cc	/^    static void InitialScaledStartValuesNegativeExponentNegativePower($/;"	f	namespace:WTF::double_conversion	file:	signature:( double v, int estimated_power, bool need_boundary_deltas, Bignum* numerator, Bignum* denominator, Bignum* delta_minus, Bignum* delta_plus)
InitialScaledStartValuesNegativeExponentPositivePower	.\dtoa\bignum-dtoa.cc	/^    static void InitialScaledStartValuesNegativeExponentPositivePower($/;"	f	namespace:WTF::double_conversion	file:	signature:( double v, int estimated_power, bool need_boundary_deltas, Bignum* numerator, Bignum* denominator, Bignum* delta_minus, Bignum* delta_plus)
InitialScaledStartValuesPositiveExponent	.\dtoa\bignum-dtoa.cc	/^    static void InitialScaledStartValuesPositiveExponent($/;"	f	namespace:WTF::double_conversion	file:	signature:( double v, int estimated_power, bool need_boundary_deltas, Bignum* numerator, Bignum* denominator, Bignum* delta_minus, Bignum* delta_plus)
InlineASM_h	.\InlineASM.h	27;"	d
InsertRange	.\FastMalloc.cpp	/^  void InsertRange(void *start, void *end, int N);$/;"	p	class:WTF::TCMalloc_Central_FreeList	file:	access:public	signature:(void *start, void *end, int N)
InsertRange	.\FastMalloc.cpp	/^void TCMalloc_Central_FreeList::InsertRange(void *start, void *end, int N) {$/;"	f	class:WTF::TCMalloc_Central_FreeList	signature:(void *start, void *end, int N)
Int16Array	.\Int16Array.h	/^    inline Int16Array(PassRefPtr<ArrayBuffer>,$/;"	p	class:WTF::Int16Array	access:private	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
Int16Array	.\Int16Array.h	/^Int16Array::Int16Array(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Int16Array	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
Int16Array	.\Int16Array.h	/^class Int16Array : public IntegralTypedArrayBase<short> {$/;"	c	namespace:WTF	inherits:IntegralTypedArrayBase
Int16Array_h	.\Int16Array.h	27;"	d
Int32Array	.\Int32Array.h	/^    inline Int32Array(PassRefPtr<ArrayBuffer>,$/;"	p	class:WTF::Int32Array	access:private	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
Int32Array	.\Int32Array.h	/^Int32Array::Int32Array(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Int32Array	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
Int32Array	.\Int32Array.h	/^class Int32Array : public IntegralTypedArrayBase<int> {$/;"	c	namespace:WTF	inherits:IntegralTypedArrayBase
Int32Array_h	.\Int32Array.h	28;"	d
Int8Array	.\Int8Array.h	/^    inline Int8Array(PassRefPtr<ArrayBuffer>,$/;"	p	class:WTF::Int8Array	access:private	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
Int8Array	.\Int8Array.h	/^Int8Array::Int8Array(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Int8Array	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
Int8Array	.\Int8Array.h	/^class Int8Array : public IntegralTypedArrayBase<signed char> {$/;"	c	namespace:WTF	inherits:IntegralTypedArrayBase
Int8Array_h	.\Int8Array.h	28;"	d
IntArray	.\TypeTraits.cpp	/^typedef int IntArray[];$/;"	t	namespace:WTF	file:
IntArraySized	.\TypeTraits.cpp	/^typedef int IntArraySized[4];$/;"	t	namespace:WTF	file:
IntHash	.\HashFunctions.h	/^    template<typename T> struct IntHash {$/;"	s	namespace:WTF
IntTypes	.\HashFunctions.h	/^    template<> struct IntTypes<1> { typedef int8_t SignedType; typedef uint8_t UnsignedType; };$/;"	s	namespace:WTF
IntTypes	.\HashFunctions.h	/^    template<> struct IntTypes<2> { typedef int16_t SignedType; typedef uint16_t UnsignedType; };$/;"	s	namespace:WTF
IntTypes	.\HashFunctions.h	/^    template<> struct IntTypes<4> { typedef int32_t SignedType; typedef uint32_t UnsignedType; };$/;"	s	namespace:WTF
IntTypes	.\HashFunctions.h	/^    template<> struct IntTypes<8> { typedef int64_t SignedType; typedef uint64_t UnsignedType; };$/;"	s	namespace:WTF
Int_max	.\dtoa.cpp	149;"	d	file:
IntegralConstant	.\TypeTraits.h	/^    struct IntegralConstant {$/;"	s	namespace:WTF
IntegralTypedArrayBase	.\IntegralTypedArrayBase.h	/^    IntegralTypedArrayBase(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::IntegralTypedArrayBase	access:protected	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
IntegralTypedArrayBase	.\IntegralTypedArrayBase.h	/^class IntegralTypedArrayBase : public TypedArrayBase<T> {$/;"	c	namespace:WTF	inherits:TypedArrayBase
IntegralTypedArrayBase_h	.\IntegralTypedArrayBase.h	28;"	d
Internal	.\FastAllocBase.h	/^    namespace Internal {$/;"	n	namespace:WTF
Internal	.\FastMalloc.cpp	/^namespace Internal {$/;"	n	namespace:WTF	file:
Internal	.\FastMalloc.h	/^    namespace Internal {$/;"	n	namespace:WTF
Internal	.\HexNumber.h	/^namespace Internal {$/;"	n	namespace:WTF
Internal	.\wince\FastMallocWinCE.h	/^    namespace Internal {$/;"	n	namespace:WTF
InvalidCharacter	.\url\src\URLCharacterTypes.h	/^        InvalidCharacter = 0,$/;"	e	enum:WTF::URLCharacterTypes::CharTypes
InvalidPort	.\url\src\URLParser.h	/^        InvalidPort = -2,$/;"	e	enum:WTF::URLParser::SpecialPort
IsArithmetic	.\TypeTraits.h	/^    template<typename T> struct IsArithmetic     { static const bool value = IsInteger<T>::value || IsFloatingPoint<T>::value; };$/;"	s	namespace:WTF
IsArray	.\TypeTraits.h	/^    template <class T, size_t N> struct IsArray<T[N]> {$/;"	s	namespace:WTF
IsArray	.\TypeTraits.h	/^    template <class T> struct IsArray {$/;"	s	namespace:WTF
IsArray	.\TypeTraits.h	/^    template <class T> struct IsArray<T[]> {$/;"	s	namespace:WTF
IsClamped	.\dtoa\bignum.cc	/^    bool Bignum::IsClamped() const {$/;"	f	class:WTF::double_conversion::Bignum	signature:() const
IsClamped	.\dtoa\bignum.h	/^        bool IsClamped() const;$/;"	p	class:WTF::double_conversion::Bignum	access:private	signature:() const
IsConvertibleToDouble	.\TypeTraits.h	/^        template<typename U> class IsConvertibleToDouble<false, U> {$/;"	c	class:WTF::IsConvertibleToInteger	access:private
IsConvertibleToDouble	.\TypeTraits.h	/^        template<typename U> class IsConvertibleToDouble<true, U> {$/;"	c	class:WTF::IsConvertibleToInteger	access:private
IsConvertibleToInteger	.\TypeTraits.h	/^    template<typename T> class IsConvertibleToInteger {$/;"	c	namespace:WTF
IsConvertibleToIntegerCheck	.\TypeTraits.cpp	/^enum IsConvertibleToIntegerCheck { };$/;"	g	namespace:WTF	file:
IsDenormal	.\dtoa\double.h	/^        bool IsDenormal() const {$/;"	f	class:WTF::double_conversion::Double	access:public	signature:() const
IsFloatingPoint	.\TypeTraits.h	/^    template<> struct IsFloatingPoint<double>       { static const bool value = true; };$/;"	s	namespace:WTF
IsFloatingPoint	.\TypeTraits.h	/^    template<> struct IsFloatingPoint<float>        { static const bool value = true; };$/;"	s	namespace:WTF
IsFloatingPoint	.\TypeTraits.h	/^    template<> struct IsFloatingPoint<long double>  { static const bool value = true; };$/;"	s	namespace:WTF
IsFloatingPoint	.\TypeTraits.h	/^    template<typename T> struct IsFloatingPoint     { static const bool value = false; };$/;"	s	namespace:WTF
IsHeld	.\TCSpinLock.h	/^    inline bool IsHeld() const {$/;"	f	struct:TCMalloc_SpinLock	access:public	signature:() const
IsHeld	.\TCSpinLock.h	/^  bool IsHeld() {$/;"	f	struct:TCMalloc_SpinLock	access:public	signature:()
IsInfinite	.\dtoa\double.h	/^        bool IsInfinite() const {$/;"	f	class:WTF::double_conversion::Double	access:public	signature:() const
IsInteger	.\TypeTraits.h	/^    template<> struct IsInteger<bool>               { static const bool value = true; };$/;"	s	namespace:WTF
IsInteger	.\TypeTraits.h	/^    template<> struct IsInteger<char>               { static const bool value = true; };$/;"	s	namespace:WTF
IsInteger	.\TypeTraits.h	/^    template<> struct IsInteger<int>                { static const bool value = true; };$/;"	s	namespace:WTF
IsInteger	.\TypeTraits.h	/^    template<> struct IsInteger<long long>          { static const bool value = true; };$/;"	s	namespace:WTF
IsInteger	.\TypeTraits.h	/^    template<> struct IsInteger<long>               { static const bool value = true; };$/;"	s	namespace:WTF
IsInteger	.\TypeTraits.h	/^    template<> struct IsInteger<short>              { static const bool value = true; };$/;"	s	namespace:WTF
IsInteger	.\TypeTraits.h	/^    template<> struct IsInteger<signed char>        { static const bool value = true; };$/;"	s	namespace:WTF
IsInteger	.\TypeTraits.h	/^    template<> struct IsInteger<unsigned char>      { static const bool value = true; };$/;"	s	namespace:WTF
IsInteger	.\TypeTraits.h	/^    template<> struct IsInteger<unsigned int>       { static const bool value = true; };$/;"	s	namespace:WTF
IsInteger	.\TypeTraits.h	/^    template<> struct IsInteger<unsigned long long> { static const bool value = true; };$/;"	s	namespace:WTF
IsInteger	.\TypeTraits.h	/^    template<> struct IsInteger<unsigned long>      { static const bool value = true; };$/;"	s	namespace:WTF
IsInteger	.\TypeTraits.h	/^    template<> struct IsInteger<unsigned short>     { static const bool value = true; };$/;"	s	namespace:WTF
IsInteger	.\TypeTraits.h	/^    template<> struct IsInteger<wchar_t>            { static const bool value = true; };$/;"	s	namespace:WTF
IsInteger	.\TypeTraits.h	/^    template<typename T> struct IsInteger           { static const bool value = false; };$/;"	s	namespace:WTF
IsNan	.\dtoa\double.h	/^        bool IsNan() const {$/;"	f	class:WTF::double_conversion::Double	access:public	signature:() const
IsPod	.\TypeTraits.h	/^    template <typename P> struct IsPod<P*>       { static const bool value = true; };$/;"	s	namespace:WTF
IsPod	.\TypeTraits.h	/^    template <typename T> struct IsPod           { static const bool value = IsArithmetic<T>::value; };$/;"	s	namespace:WTF
IsSameType	.\TypeTraits.h	/^    template <typename T, typename U> struct IsSameType {$/;"	s	namespace:WTF
IsSameType	.\TypeTraits.h	/^    template <typename T> struct IsSameType<T, T> {$/;"	s	namespace:WTF
IsSpecial	.\dtoa\double.h	/^        bool IsSpecial() const {$/;"	f	class:WTF::double_conversion::Double	access:public	signature:() const
IsSubclass	.\TypeTraits.h	/^    template <typename T, typename U> class IsSubclass {$/;"	c	namespace:WTF
IsSubclassOfTemplate	.\TypeTraits.h	/^    template <typename T, template<class V> class U> class IsSubclassOfTemplate {$/;"	c	namespace:WTF
IsWhiteSpaceFunctionPtr	.\text\StringImpl.h	/^typedef bool (*IsWhiteSpaceFunctionPtr)(UChar);$/;"	t	namespace:WTF
IsZero	.\dtoa\fixed-dtoa.cc	/^        bool IsZero() const {$/;"	f	class:WTF::double_conversion::UInt128	access:public	signature:() const
Iterator	.\AVLTree.h	/^        Iterator() { depth = ~0U; }$/;"	f	class:WTF::AVLTree::Iterator	access:public	signature:()
Iterator	.\AVLTree.h	/^    class Iterator {$/;"	c	class:WTF::AVLTree	access:public
Iterator	.\Deque.h	/^        typedef DequeConstIterator<T, inlineCapacity> Iterator;$/;"	t	class:WTF::DequeConstIterator	access:private
Iterator	.\Deque.h	/^        typedef DequeConstReverseIterator<T, inlineCapacity> Iterator;$/;"	t	class:WTF::DequeConstReverseIterator	access:private
Iterator	.\Deque.h	/^        typedef DequeIterator<T, inlineCapacity> Iterator;$/;"	t	class:WTF::DequeIterator	access:private
Iterator	.\Deque.h	/^        typedef DequeReverseIterator<T, inlineCapacity> Iterator;$/;"	t	class:WTF::DequeReverseIterator	access:private
Iterator	.\HashIterators.h	/^        typedef HashTableIteratorAdapter<HashTableType, std::pair<KeyType, MappedType> > Iterator;$/;"	t	struct:WTF::HashTableKeysIterator	access:private
Iterator	.\HashIterators.h	/^        typedef HashTableIteratorAdapter<HashTableType, std::pair<KeyType, MappedType> > Iterator;$/;"	t	struct:WTF::HashTableValuesIterator	access:private
Iterator	.\SegmentedVector.h	/^        typedef SegmentedVectorIterator<T, SegmentSize> Iterator;$/;"	t	class:WTF::SegmentedVector	access:public
Iterator	.\SegmentedVector.h	/^        typedef SegmentedVectorIterator<T, SegmentSize> Iterator;$/;"	t	class:WTF::SegmentedVectorIterator	access:public
IteratorBase	.\Deque.h	/^        typedef DequeIteratorBase<T, inlineCapacity> IteratorBase;$/;"	t	class:WTF::Deque	access:private
JOIN_LOG_CHANNEL_WITH_PREFIX	.\Assertions.h	364;"	d
JOIN_LOG_CHANNEL_WITH_PREFIX_LEVEL_2	.\Assertions.h	365;"	d
JSC	.\WTFThreadData.cpp	/^namespace JSC {$/;"	n	file:
JSC	.\WTFThreadData.h	/^namespace JSC {$/;"	n
JSC	.\text\StringImpl.h	/^namespace JSC {$/;"	n
JSC::IdentifierTable	.\WTFThreadData.h	/^class IdentifierTable {$/;"	c	namespace:JSC
JSC::IdentifierTable::WTF_MAKE_FAST_ALLOCATED	.\WTFThreadData.h	/^    WTF_MAKE_FAST_ALLOCATED;$/;"	m	class:JSC::IdentifierTable	access:private
JSC::IdentifierTable::add	.\WTFThreadData.cpp	/^std::pair<HashSet<StringImpl*>::iterator, bool> IdentifierTable::add(StringImpl* value)$/;"	f	class:JSC::IdentifierTable	signature:(StringImpl* value)
JSC::IdentifierTable::add	.\WTFThreadData.h	/^    std::pair<HashSet<StringImpl*>::iterator, bool> add(StringImpl* value);$/;"	p	class:JSC::IdentifierTable	access:public	signature:(StringImpl* value)
JSC::IdentifierTable::add	.\WTFThreadData.h	/^    std::pair<HashSet<StringImpl*>::iterator, bool> add(U value);$/;"	p	class:JSC::IdentifierTable	access:public	signature:(U value)
JSC::IdentifierTable::literalTable	.\WTFThreadData.h	/^    LiteralIdentifierTable& literalTable() { return m_literalTable; }$/;"	f	class:JSC::IdentifierTable	access:public	signature:()
JSC::IdentifierTable::m_literalTable	.\WTFThreadData.h	/^    LiteralIdentifierTable m_literalTable;$/;"	m	class:JSC::IdentifierTable	access:private
JSC::IdentifierTable::m_table	.\WTFThreadData.h	/^    HashSet<StringImpl*> m_table;$/;"	m	class:JSC::IdentifierTable	access:private
JSC::IdentifierTable::remove	.\WTFThreadData.h	/^    bool remove(StringImpl* r)$/;"	f	class:JSC::IdentifierTable	access:public	signature:(StringImpl* r)
JSC::IdentifierTable::~IdentifierTable	.\WTFThreadData.cpp	/^IdentifierTable::~IdentifierTable()$/;"	f	class:JSC::IdentifierTable	signature:()
JSC::IdentifierTable::~IdentifierTable	.\WTFThreadData.h	/^    ~IdentifierTable();$/;"	p	class:JSC::IdentifierTable	access:public	signature:()
JSC::LLInt	.\text\StringImpl.h	/^namespace LLInt { class Data; }$/;"	n	namespace:JSC
JSC::LiteralIdentifierTable	.\WTFThreadData.h	/^typedef HashMap<const char*, RefPtr<StringImpl>, PtrHash<const char*> > LiteralIdentifierTable;$/;"	t	namespace:JSC
JSC_HOST_CALL	.\Platform.h	1001;"	d
JSC_HOST_CALL	.\Platform.h	1003;"	d
JSC_HOST_CALL	.\Platform.h	1005;"	d
JSGCHeapPages	.\OSAllocator.h	/^        JSGCHeapPages = VM_TAG_FOR_COLLECTOR_MEMORY,$/;"	e	enum:WTF::OSAllocator::Usage
JSJITCodePages	.\OSAllocator.h	/^        JSJITCodePages = VM_TAG_FOR_EXECUTABLEALLOCATOR_MEMORY,$/;"	e	enum:WTF::OSAllocator::Usage
JSVMStackPages	.\OSAllocator.h	/^        JSVMStackPages = VM_TAG_FOR_REGISTERFILE_MEMORY,$/;"	e	enum:WTF::OSAllocator::Usage
K	.\TCPackedCache.h	/^  typedef uintptr_t K;$/;"	t	class:PackedCache	access:public
KB	.\StdLibExtras.h	/^static const size_t KB = 1024;$/;"	v
KernelSupportsTLS	.\FastMalloc.cpp	/^  static inline bool KernelSupportsTLS() {$/;"	f	namespace:WTF	file:	signature:()
KeyAndCount	.\Spectrum.h	/^        KeyAndCount() { }$/;"	f	struct:WTF::Spectrum::KeyAndCount	access:public	signature:()
KeyAndCount	.\Spectrum.h	/^        KeyAndCount(const T& key, unsigned long count)$/;"	f	struct:WTF::Spectrum::KeyAndCount	access:public	signature:(const T& key, unsigned long count)
KeyAndCount	.\Spectrum.h	/^    struct KeyAndCount {$/;"	s	class:WTF::Spectrum	access:public
KeyMatch	.\TCPackedCache.h	/^  static bool KeyMatch(T entry, K key) {$/;"	f	class:PackedCache	access:private	signature:(T entry, K key)
KeyMustBePresentInArray	.\StdLibExtras.h	/^    KeyMustBePresentInArray,$/;"	e	enum:WTF::BinarySearchMode
KeyMustNotBePresentInArray	.\StdLibExtras.h	/^    KeyMustNotBePresentInArray$/;"	e	enum:WTF::BinarySearchMode
KeyToUpper	.\TCPackedCache.h	/^  static UPPER KeyToUpper(K k) {$/;"	f	class:PackedCache	access:private	signature:(K k)
KeyTraits	.\HashMap.h	/^        typedef KeyTraitsArg KeyTraits;$/;"	t	class:WTF::HashMap	access:private
KeyTraits	.\RefPtrHashMap.h	/^        typedef KeyTraitsArg KeyTraits;$/;"	t	class:WTF::HashMap	access:private
KeyType	.\HashMap.h	/^        typedef typename KeyTraits::TraitType KeyType;$/;"	t	class:WTF::HashMap	access:public
KeyType	.\HashTable.h	/^        typedef Key KeyType;$/;"	t	class:WTF::HashTable	access:public
KeyType	.\RefPtrHashMap.h	/^        typedef typename KeyTraits::TraitType KeyType;$/;"	t	class:WTF::HashMap	access:public
Keys	.\HashIterators.h	/^        typedef HashTableConstKeysIterator<HashTableType, KeyType, MappedType> Keys;$/;"	t	struct:WTF::HashTableConstIteratorAdapter	access:public
Keys	.\HashIterators.h	/^        typedef HashTableKeysIterator<HashTableType, KeyType, MappedType> Keys;$/;"	t	struct:WTF::HashTableIteratorAdapter	access:public
KnownZone	.\DateMath.cpp	/^static const struct KnownZone {$/;"	s	namespace:WTF	file:
L	.\dtoa.cpp	/^    uint32_t L[2];$/;"	m	union:WTF::__anon4	file:	access:public
LChar	.\unicode\Unicode.h	/^typedef unsigned char LChar;$/;"	t
LEAF_BITS	.\TCPageMap.h	/^  static const int LEAF_BITS = BITS - 2*INTERIOR_BITS;$/;"	m	class:TCMalloc_PageMap3	access:private
LEAF_BITS	.\TCPageMap.h	/^  static const int LEAF_BITS = BITS - ROOT_BITS;$/;"	m	class:TCMalloc_PageMap2	access:private
LEAF_LENGTH	.\TCPageMap.h	/^  static const int LEAF_LENGTH = 1 << LEAF_BITS;$/;"	m	class:TCMalloc_PageMap2	access:private
LEAF_LENGTH	.\TCPageMap.h	/^  static const int LEAF_LENGTH = 1 << LEAF_BITS;$/;"	m	class:TCMalloc_PageMap3	access:private
LESS	.\AVLTree.h	/^        LESS = 2,$/;"	e	enum:WTF::AVLTree::SearchType
LESS_EQUAL	.\AVLTree.h	/^        LESS_EQUAL = EQUAL | LESS,$/;"	e	enum:WTF::AVLTree::SearchType
LIKELY	.\Compiler.h	173;"	d
LIKELY	.\Compiler.h	175;"	d
LLInt	.\text\StringImpl.h	/^namespace LLInt { class Data; }$/;"	n	namespace:JSC
LOCAL_LABEL_STRING	.\InlineASM.h	77;"	d
LOG	.\Assertions.h	359;"	d
LOG	.\Assertions.h	361;"	d
LOG	.\Assertions.h	363;"	d
LOG_DISABLED	.\Assertions.h	104;"	d
LOG_DISABLED	.\Assertions.h	106;"	d
LOG_ERROR	.\Assertions.h	349;"	d
LOG_ERROR	.\Assertions.h	351;"	d
LOG_ERROR	.\Assertions.h	353;"	d
LOG_VERBOSE	.\Assertions.h	371;"	d
LOG_VERBOSE	.\Assertions.h	373;"	d
LOG_VERBOSE	.\Assertions.h	375;"	d
LSB	.\dtoa.cpp	143;"	d	file:
Leaf	.\TCPageMap.h	/^  struct Leaf {$/;"	s	class:TCMalloc_PageMap2	access:private
Leaf	.\TCPageMap.h	/^  struct Leaf {$/;"	s	class:TCMalloc_PageMap3	access:private
LeftToRight	.\unicode\glib\UnicodeGLib.h	/^    LeftToRight,$/;"	e	enum:WTF::Unicode::Direction
LeftToRight	.\unicode\icu\UnicodeIcu.h	/^    LeftToRight = U_LEFT_TO_RIGHT,$/;"	e	enum:WTF::Unicode::Direction
LeftToRight	.\unicode\qt4\UnicodeQt4.h	/^    LeftToRight = QChar::DirL,$/;"	e	enum:WTF::Unicode::Direction
LeftToRight	.\unicode\wince\UnicodeWinCE.h	/^    LeftToRight = UnicodeCE::U_LEFT_TO_RIGHT,$/;"	e	enum:WTF::Unicode::Direction
LeftToRightEmbedding	.\unicode\glib\UnicodeGLib.h	/^    LeftToRightEmbedding,$/;"	e	enum:WTF::Unicode::Direction
LeftToRightEmbedding	.\unicode\icu\UnicodeIcu.h	/^    LeftToRightEmbedding = U_LEFT_TO_RIGHT_EMBEDDING,$/;"	e	enum:WTF::Unicode::Direction
LeftToRightEmbedding	.\unicode\qt4\UnicodeQt4.h	/^    LeftToRightEmbedding = QChar::DirLRE,$/;"	e	enum:WTF::Unicode::Direction
LeftToRightEmbedding	.\unicode\wince\UnicodeWinCE.h	/^    LeftToRightEmbedding = UnicodeCE::U_LEFT_TO_RIGHT_EMBEDDING,$/;"	e	enum:WTF::Unicode::Direction
LeftToRightOverride	.\unicode\glib\UnicodeGLib.h	/^    LeftToRightOverride,$/;"	e	enum:WTF::Unicode::Direction
LeftToRightOverride	.\unicode\icu\UnicodeIcu.h	/^    LeftToRightOverride = U_LEFT_TO_RIGHT_OVERRIDE,$/;"	e	enum:WTF::Unicode::Direction
LeftToRightOverride	.\unicode\qt4\UnicodeQt4.h	/^    LeftToRightOverride = QChar::DirLRO,$/;"	e	enum:WTF::Unicode::Direction
LeftToRightOverride	.\unicode\wince\UnicodeWinCE.h	/^    LeftToRightOverride = UnicodeCE::U_LEFT_TO_RIGHT_OVERRIDE,$/;"	e	enum:WTF::Unicode::Direction
Length	.\FastMalloc.cpp	/^typedef uintptr_t Length;$/;"	t	namespace:WTF	file:
Less	.\dtoa\bignum.h	/^        static bool Less(const Bignum& a, const Bignum& b) {$/;"	f	class:WTF::double_conversion::Bignum	access:public	signature:(const Bignum& a, const Bignum& b)
Less	.\unicode\Collator.h	/^        enum Result { Equal = 0, Greater = 1, Less = -1 };$/;"	e	enum:WTF::Collator::Result
LessEqual	.\dtoa\bignum.h	/^        static bool LessEqual(const Bignum& a, const Bignum& b) {$/;"	f	class:WTF::double_conversion::Bignum	access:public	signature:(const Bignum& a, const Bignum& b)
Letter_Lowercase	.\unicode\glib\UnicodeGLib.h	/^    Letter_Lowercase = U_MASK(G_UNICODE_LOWERCASE_LETTER),$/;"	e	enum:WTF::Unicode::CharCategory
Letter_Lowercase	.\unicode\icu\UnicodeIcu.h	/^    Letter_Lowercase = U_MASK(U_LOWERCASE_LETTER),$/;"	e	enum:WTF::Unicode::CharCategory
Letter_Lowercase	.\unicode\qt4\UnicodeQt4.h	/^    Letter_Lowercase = U_MASK(QChar::Letter_Lowercase),$/;"	e	enum:WTF::Unicode::CharCategory
Letter_Lowercase	.\unicode\wince\UnicodeWinCE.h	/^    Letter_Lowercase = TO_MASK(UnicodeCE::U_LOWERCASE_LETTER),$/;"	e	enum:WTF::Unicode::CharCategory
Letter_Modifier	.\unicode\glib\UnicodeGLib.h	/^    Letter_Modifier = U_MASK(G_UNICODE_MODIFIER_LETTER),$/;"	e	enum:WTF::Unicode::CharCategory
Letter_Modifier	.\unicode\icu\UnicodeIcu.h	/^    Letter_Modifier = U_MASK(U_MODIFIER_LETTER),$/;"	e	enum:WTF::Unicode::CharCategory
Letter_Modifier	.\unicode\qt4\UnicodeQt4.h	/^    Letter_Modifier = U_MASK(QChar::Letter_Modifier),$/;"	e	enum:WTF::Unicode::CharCategory
Letter_Modifier	.\unicode\wince\UnicodeWinCE.h	/^    Letter_Modifier = TO_MASK(UnicodeCE::U_MODIFIER_LETTER),$/;"	e	enum:WTF::Unicode::CharCategory
Letter_Other	.\unicode\glib\UnicodeGLib.h	/^    Letter_Other = U_MASK(G_UNICODE_OTHER_LETTER),$/;"	e	enum:WTF::Unicode::CharCategory
Letter_Other	.\unicode\icu\UnicodeIcu.h	/^    Letter_Other = U_MASK(U_OTHER_LETTER),$/;"	e	enum:WTF::Unicode::CharCategory
Letter_Other	.\unicode\qt4\UnicodeQt4.h	/^    Letter_Other = U_MASK(QChar::Letter_Other),$/;"	e	enum:WTF::Unicode::CharCategory
Letter_Other	.\unicode\wince\UnicodeWinCE.h	/^    Letter_Other = TO_MASK(UnicodeCE::U_OTHER_LETTER),$/;"	e	enum:WTF::Unicode::CharCategory
Letter_Titlecase	.\unicode\glib\UnicodeGLib.h	/^    Letter_Titlecase = U_MASK(G_UNICODE_TITLECASE_LETTER),$/;"	e	enum:WTF::Unicode::CharCategory
Letter_Titlecase	.\unicode\icu\UnicodeIcu.h	/^    Letter_Titlecase = U_MASK(U_TITLECASE_LETTER),$/;"	e	enum:WTF::Unicode::CharCategory
Letter_Titlecase	.\unicode\qt4\UnicodeQt4.h	/^    Letter_Titlecase = U_MASK(QChar::Letter_Titlecase),$/;"	e	enum:WTF::Unicode::CharCategory
Letter_Titlecase	.\unicode\wince\UnicodeWinCE.h	/^    Letter_Titlecase = TO_MASK(UnicodeCE::U_TITLECASE_LETTER),$/;"	e	enum:WTF::Unicode::CharCategory
Letter_Uppercase	.\unicode\glib\UnicodeGLib.h	/^    Letter_Uppercase = U_MASK(G_UNICODE_UPPERCASE_LETTER),$/;"	e	enum:WTF::Unicode::CharCategory
Letter_Uppercase	.\unicode\icu\UnicodeIcu.h	/^    Letter_Uppercase = U_MASK(U_UPPERCASE_LETTER),$/;"	e	enum:WTF::Unicode::CharCategory
Letter_Uppercase	.\unicode\qt4\UnicodeQt4.h	/^    Letter_Uppercase = U_MASK(QChar::Letter_Uppercase),$/;"	e	enum:WTF::Unicode::CharCategory
Letter_Uppercase	.\unicode\wince\UnicodeWinCE.h	/^    Letter_Uppercase = TO_MASK(UnicodeCE::U_UPPERCASE_LETTER),$/;"	e	enum:WTF::Unicode::CharCategory
LgFloor	.\FastMalloc.cpp	/^static inline int LgFloor(size_t n) {$/;"	f	namespace:WTF	file:	signature:(size_t n)
ListHashSet	.\ListHashSet.h	/^        ListHashSet();$/;"	p	class:WTF::ListHashSet	access:public	signature:()
ListHashSet	.\ListHashSet.h	/^        ListHashSet(const ListHashSet&);$/;"	p	class:WTF::ListHashSet	access:public	signature:(const ListHashSet&)
ListHashSet	.\ListHashSet.h	/^    inline ListHashSet<T, inlineCapacity, U>::ListHashSet()$/;"	f	class:WTF::ListHashSet	signature:()
ListHashSet	.\ListHashSet.h	/^    inline ListHashSet<T, inlineCapacity, U>::ListHashSet(const ListHashSet& other)$/;"	f	class:WTF::ListHashSet	signature:(const ListHashSet& other)
ListHashSet	.\ListHashSet.h	/^    template<typename ValueArg, size_t inlineCapacity = 256, typename HashArg = typename DefaultHash<ValueArg>::Hash> class ListHashSet {$/;"	c	namespace:WTF
ListHashSetConstIterator	.\ListHashSet.h	/^        ListHashSetConstIterator()$/;"	f	class:WTF::ListHashSetConstIterator	access:public	signature:()
ListHashSetConstIterator	.\ListHashSet.h	/^        ListHashSetConstIterator(const ListHashSetType* set, Node* position)$/;"	f	class:WTF::ListHashSetConstIterator	access:private	signature:(const ListHashSetType* set, Node* position)
ListHashSetConstIterator	.\ListHashSet.h	/^    template<typename ValueArg, size_t inlineCapacity, typename HashArg> class ListHashSetConstIterator {$/;"	c	namespace:WTF
ListHashSetConstReverseIterator	.\ListHashSet.h	/^        ListHashSetConstReverseIterator()$/;"	f	class:WTF::ListHashSetConstReverseIterator	access:public	signature:()
ListHashSetConstReverseIterator	.\ListHashSet.h	/^        ListHashSetConstReverseIterator(const ListHashSetType* set, Node* position)$/;"	f	class:WTF::ListHashSetConstReverseIterator	access:private	signature:(const ListHashSetType* set, Node* position)
ListHashSetConstReverseIterator	.\ListHashSet.h	/^    template<typename ValueArg, size_t inlineCapacity, typename HashArg> class ListHashSetConstReverseIterator {$/;"	c	namespace:WTF
ListHashSetIterator	.\ListHashSet.h	/^        ListHashSetIterator() { }$/;"	f	class:WTF::ListHashSetIterator	access:public	signature:()
ListHashSetIterator	.\ListHashSet.h	/^        ListHashSetIterator(const ListHashSetType* set, Node* position) : m_iterator(set, position) { }$/;"	f	class:WTF::ListHashSetIterator	access:private	signature:(const ListHashSetType* set, Node* position)
ListHashSetIterator	.\ListHashSet.h	/^    template<typename ValueArg, size_t inlineCapacity, typename HashArg> class ListHashSetIterator {$/;"	c	namespace:WTF
ListHashSetNode	.\ListHashSet.h	/^        ListHashSetNode(ValueArg value)$/;"	f	struct:WTF::ListHashSetNode	access:public	signature:(ValueArg value)
ListHashSetNode	.\ListHashSet.h	/^    template<typename ValueArg, size_t inlineCapacity> struct ListHashSetNode {$/;"	s	namespace:WTF
ListHashSetNodeAllocator	.\ListHashSet.h	/^        ListHashSetNodeAllocator() $/;"	f	struct:WTF::ListHashSetNodeAllocator	access:public	signature:()
ListHashSetNodeAllocator	.\ListHashSet.h	/^    template<typename ValueArg, size_t inlineCapacity> struct ListHashSetNodeAllocator {$/;"	s	namespace:WTF
ListHashSetNodeHashFunctions	.\ListHashSet.h	/^    template<typename HashArg> struct ListHashSetNodeHashFunctions {$/;"	s	namespace:WTF
ListHashSetReverseIterator	.\ListHashSet.h	/^        ListHashSetReverseIterator() { }$/;"	f	class:WTF::ListHashSetReverseIterator	access:public	signature:()
ListHashSetReverseIterator	.\ListHashSet.h	/^        ListHashSetReverseIterator(const ListHashSetType* set, Node* position) : m_iterator(set, position) { }$/;"	f	class:WTF::ListHashSetReverseIterator	access:private	signature:(const ListHashSetType* set, Node* position)
ListHashSetReverseIterator	.\ListHashSet.h	/^    template<typename ValueArg, size_t inlineCapacity, typename HashArg> class ListHashSetReverseIterator {$/;"	c	namespace:WTF
ListHashSetTranslator	.\ListHashSet.h	/^    struct ListHashSetTranslator {$/;"	s	namespace:WTF
ListHashSetTranslatorAdapter	.\ListHashSet.h	/^    struct ListHashSetTranslatorAdapter {$/;"	s	namespace:WTF
ListHashSetType	.\ListHashSet.h	/^        typedef ListHashSet<ValueArg, inlineCapacity, HashArg> ListHashSetType;$/;"	t	class:WTF::ListHashSetConstIterator	access:private
ListHashSetType	.\ListHashSet.h	/^        typedef ListHashSet<ValueArg, inlineCapacity, HashArg> ListHashSetType;$/;"	t	class:WTF::ListHashSetConstReverseIterator	access:private
ListHashSetType	.\ListHashSet.h	/^        typedef ListHashSet<ValueArg, inlineCapacity, HashArg> ListHashSetType;$/;"	t	class:WTF::ListHashSetIterator	access:private
ListHashSetType	.\ListHashSet.h	/^        typedef ListHashSet<ValueArg, inlineCapacity, HashArg> ListHashSetType;$/;"	t	class:WTF::ListHashSetReverseIterator	access:private
ListRefPtr	.\ListRefPtr.h	/^        ListRefPtr() : RefPtr<T>() {}$/;"	f	class:WTF::ListRefPtr	access:public	signature:()
ListRefPtr	.\ListRefPtr.h	/^        ListRefPtr(T* ptr) : RefPtr<T>(ptr) {}$/;"	f	class:WTF::ListRefPtr	access:public	signature:(T* ptr)
ListRefPtr	.\ListRefPtr.h	/^        ListRefPtr(const RefPtr<T>& o) : RefPtr<T>(o) {}$/;"	f	class:WTF::ListRefPtr	access:public	signature:(const RefPtr<T>& o)
ListRefPtr	.\ListRefPtr.h	/^        template <typename U> ListRefPtr(const PassRefPtr<U>& o) : RefPtr<T>(o) {}$/;"	f	class:WTF::ListRefPtr	access:public	signature:(const PassRefPtr<U>& o)
ListRefPtr	.\ListRefPtr.h	/^    template <typename T> class ListRefPtr : public RefPtr<T> {$/;"	c	namespace:WTF	inherits:RefPtr
LiteralIdentifierTable	.\WTFThreadData.h	/^typedef HashMap<const char*, RefPtr<StringImpl>, PtrHash<const char*> > LiteralIdentifierTable;$/;"	t	namespace:JSC
Lock	.\TCSpinLock.h	/^    inline void Lock() {$/;"	f	struct:TCMalloc_SpinLock	access:public	signature:()
Lock	.\TCSpinLock.h	/^  inline void Lock() {$/;"	f	struct:TCMalloc_SpinLock	access:public	signature:()
LockInverter	.\FastMalloc.cpp	/^  inline explicit LockInverter(SpinLock* held, SpinLock *temp)$/;"	f	class:WTF::__anon6::LockInverter	access:public	signature:(SpinLock* held, SpinLock *temp)
LockInverter	.\FastMalloc.cpp	/^class LockInverter {$/;"	c	namespace:WTF::__anon6	file:
Locker	.\Locker.h	/^    Locker(T& lockable) : m_lockable(lockable) { m_lockable.lock(); }$/;"	f	class:WTF::Locker	access:public	signature:(T& lockable)
Locker	.\Locker.h	/^template <typename T> class Locker {$/;"	c	namespace:WTF
Locker_h	.\Locker.h	29;"	d
Log2P	.\dtoa.cpp	145;"	d	file:
LookupType	.\HashTable.h	/^        typedef pair<ValueType*, bool> LookupType;$/;"	t	class:WTF::HashTable	access:private
Lowercase	.\HexNumber.h	/^    Lowercase,$/;"	e	enum:WTF::HexConversionMode
MAP_ANONYMOUS	.\TCSystemAlloc.cpp	60;"	d	file:
MD5	.\MD5.cpp	/^MD5::MD5()$/;"	f	class:WTF::MD5	signature:()
MD5	.\MD5.h	/^    WTF_EXPORT_PRIVATE MD5();$/;"	p	class:WTF::MD5	access:public	signature:()
MD5	.\MD5.h	/^class MD5 {$/;"	c	namespace:WTF
MD5STEP	.\MD5.cpp	120;"	d	file:
MD5Transform	.\MD5.cpp	/^static void MD5Transform(uint32_t buf[4], const uint32_t in[16])$/;"	f	namespace:WTF	file:	signature:(uint32_t buf[4], const uint32_t in[16])
MESSAGE	.\FastMalloc.cpp	503;"	d	file:
MINIMUM_BUMP_POOL_SIZE	.\BumpPointerAllocator.h	33;"	d
MS_VC_EXCEPTION	.\ThreadingWin.cpp	/^static const DWORD MS_VC_EXCEPTION = 0x406D1388;$/;"	v	file:
MachineWord	.\text\ASCIIFastPath.h	/^typedef uintptr_t MachineWord;$/;"	t	namespace:WTF
MainThreadFunction	.\MainThread.h	/^typedef void MainThreadFunction(void*);$/;"	t	namespace:WTF
MainThreadInvoker	.\qt\MainThreadQt.cpp	/^    MainThreadInvoker();$/;"	p	class:WTF::MainThreadInvoker	file:	access:public	signature:()
MainThreadInvoker	.\qt\MainThreadQt.cpp	/^MainThreadInvoker::MainThreadInvoker()$/;"	f	class:WTF::MainThreadInvoker	signature:()
MainThreadInvoker	.\qt\MainThreadQt.cpp	/^class MainThreadInvoker : public QObject {$/;"	c	namespace:WTF	file:	inherits:QObject
MainThread_h	.\MainThread.h	31;"	d
MakeCacheSpace	.\FastMalloc.cpp	/^  bool MakeCacheSpace();$/;"	p	class:WTF::TCMalloc_Central_FreeList	file:	access:private	signature:()
MakeCacheSpace	.\FastMalloc.cpp	/^bool TCMalloc_Central_FreeList::MakeCacheSpace() {$/;"	f	class:WTF::TCMalloc_Central_FreeList	signature:()
MallocZoneSupport_h	.\MallocZoneSupport.h	30;"	d
MapSelector	.\FastMalloc.cpp	/^template <> class MapSelector<32> {$/;"	c	namespace:WTF	file:
MapSelector	.\FastMalloc.cpp	/^template <> class MapSelector<64> {$/;"	c	namespace:WTF	file:
MapSelector	.\FastMalloc.cpp	/^template <int BITS> class MapSelector {$/;"	c	namespace:WTF	file:
MappedPassInReferenceType	.\HashMap.h	/^        typedef typename ReferenceTypeMaker<MappedPassInType>::ReferenceType MappedPassInReferenceType;$/;"	t	class:WTF::HashMap	access:private
MappedPassInReferenceType	.\RefPtrHashMap.h	/^        typedef typename ReferenceTypeMaker<MappedPassInType>::ReferenceType MappedPassInReferenceType;$/;"	t	class:WTF::HashMap	access:private
MappedPassInType	.\HashMap.h	/^        typedef typename MappedTraits::PassInType MappedPassInType;$/;"	t	class:WTF::HashMap	access:private
MappedPassInType	.\RefPtrHashMap.h	/^        typedef typename MappedTraits::PassInType MappedPassInType;$/;"	t	class:WTF::HashMap	access:private
MappedPassOutType	.\HashMap.h	/^        typedef typename MappedTraits::PassOutType MappedPassOutType;$/;"	t	class:WTF::HashMap	access:private
MappedPassOutType	.\RefPtrHashMap.h	/^        typedef typename MappedTraits::PassOutType MappedPassOutType;$/;"	t	class:WTF::HashMap	access:private
MappedPeekType	.\HashMap.h	/^        typedef typename MappedTraits::PeekType MappedPeekType;$/;"	t	class:WTF::HashMap	access:private
MappedPeekType	.\RefPtrHashMap.h	/^        typedef typename MappedTraits::PeekType MappedPeekType;$/;"	t	class:WTF::HashMap	access:private
MappedTraits	.\HashMap.h	/^        typedef MappedTraitsArg MappedTraits;$/;"	t	class:WTF::HashMap	access:private
MappedTraits	.\RefPtrHashMap.h	/^        typedef MappedTraitsArg MappedTraits;$/;"	t	class:WTF::HashMap	access:private
MappedType	.\HashMap.h	/^        typedef typename MappedTraits::TraitType MappedType;$/;"	t	class:WTF::HashMap	access:public
MappedType	.\RefPtrHashMap.h	/^        typedef typename MappedTraits::TraitType MappedType;$/;"	t	class:WTF::HashMap	access:public
MarkThreadIdle	.\FastMalloc.cpp	/^  virtual void MarkThreadIdle() {$/;"	f	class:WTF::TCMallocImplementation	access:public	signature:()
Mark_Enclosing	.\unicode\glib\UnicodeGLib.h	/^    Mark_Enclosing = U_MASK(G_UNICODE_ENCLOSING_MARK),$/;"	e	enum:WTF::Unicode::CharCategory
Mark_Enclosing	.\unicode\icu\UnicodeIcu.h	/^    Mark_Enclosing = U_MASK(U_ENCLOSING_MARK),$/;"	e	enum:WTF::Unicode::CharCategory
Mark_Enclosing	.\unicode\qt4\UnicodeQt4.h	/^    Mark_Enclosing = U_MASK(QChar::Mark_Enclosing),$/;"	e	enum:WTF::Unicode::CharCategory
Mark_Enclosing	.\unicode\wince\UnicodeWinCE.h	/^    Mark_Enclosing = TO_MASK(UnicodeCE::U_ENCLOSING_MARK),$/;"	e	enum:WTF::Unicode::CharCategory
Mark_NonSpacing	.\unicode\glib\UnicodeGLib.h	/^    Mark_NonSpacing = U_MASK(G_UNICODE_NON_SPACING_MARK),$/;"	e	enum:WTF::Unicode::CharCategory
Mark_NonSpacing	.\unicode\icu\UnicodeIcu.h	/^    Mark_NonSpacing = U_MASK(U_NON_SPACING_MARK),$/;"	e	enum:WTF::Unicode::CharCategory
Mark_NonSpacing	.\unicode\qt4\UnicodeQt4.h	/^    Mark_NonSpacing = U_MASK(QChar::Mark_NonSpacing),$/;"	e	enum:WTF::Unicode::CharCategory
Mark_NonSpacing	.\unicode\wince\UnicodeWinCE.h	/^    Mark_NonSpacing = TO_MASK(UnicodeCE::U_NON_SPACING_MARK),$/;"	e	enum:WTF::Unicode::CharCategory
Mark_SpacingCombining	.\unicode\glib\UnicodeGLib.h	/^    Mark_SpacingCombining = U_MASK(G_UNICODE_COMBINING_MARK),$/;"	e	enum:WTF::Unicode::CharCategory
Mark_SpacingCombining	.\unicode\icu\UnicodeIcu.h	/^    Mark_SpacingCombining = U_MASK(U_COMBINING_SPACING_MARK),$/;"	e	enum:WTF::Unicode::CharCategory
Mark_SpacingCombining	.\unicode\qt4\UnicodeQt4.h	/^    Mark_SpacingCombining = U_MASK(QChar::Mark_SpacingCombining),$/;"	e	enum:WTF::Unicode::CharCategory
Mark_SpacingCombining	.\unicode\wince\UnicodeWinCE.h	/^    Mark_SpacingCombining = TO_MASK(UnicodeCE::U_COMBINING_SPACING_MARK),$/;"	e	enum:WTF::Unicode::CharCategory
Max	.\dtoa\utils.h	/^    static T Max(T a, T b) {$/;"	f	namespace:WTF::double_conversion	signature:(T a, T b)
MaxSemaphoreCount	.\ThreadingWin.cpp	/^static const long MaxSemaphoreCount = static_cast<long>(~0UL >> 1);$/;"	v	file:
MemoryAligner	.\TCSystemAlloc.cpp	/^union MemoryAligner {$/;"	u	file:
MemoryAligner::d	.\TCSystemAlloc.cpp	/^  double d;$/;"	m	union:MemoryAligner	file:	access:public
MemoryAligner::p	.\TCSystemAlloc.cpp	/^  void*  p;$/;"	m	union:MemoryAligner	file:	access:public
MemoryAligner::s	.\TCSystemAlloc.cpp	/^  size_t s;$/;"	m	union:MemoryAligner	file:	access:public
MemoryAllocationCanFail	.\wince\MemoryManager.h	/^        MemoryAllocationCanFail() : m_old(memoryManager()->allocationCanFail()) { memoryManager()->setAllocationCanFail(true); }$/;"	f	class:WTF::MemoryAllocationCanFail	access:public	signature:()
MemoryAllocationCanFail	.\wince\MemoryManager.h	/^    class MemoryAllocationCanFail {$/;"	c	namespace:WTF
MemoryAllocationCannotFail	.\wince\MemoryManager.h	/^        MemoryAllocationCannotFail() : m_old(memoryManager()->allocationCanFail()) { memoryManager()->setAllocationCanFail(false); }$/;"	f	class:WTF::MemoryAllocationCannotFail	access:public	signature:()
MemoryAllocationCannotFail	.\wince\MemoryManager.h	/^    class MemoryAllocationCannotFail {$/;"	c	namespace:WTF
MemoryManager	.\wince\MemoryManager.cpp	/^MemoryManager::MemoryManager()$/;"	f	class:WTF::MemoryManager	signature:()
MemoryManager	.\wince\MemoryManager.h	/^        MemoryManager();$/;"	p	class:WTF::MemoryManager	access:public	signature:()
MemoryManager	.\wince\MemoryManager.h	/^    class MemoryManager {$/;"	c	namespace:WTF
MessageQueue	.\MessageQueue.h	/^        MessageQueue() : m_killed(false) { }$/;"	f	class:WTF::MessageQueue	access:public	signature:()
MessageQueue	.\MessageQueue.h	/^    class MessageQueue {$/;"	c	namespace:WTF
MessageQueueMessageReceived	.\MessageQueue.h	/^        MessageQueueMessageReceived   \/\/ A message was successfully received and returned.$/;"	e	enum:WTF::MessageQueueWaitResult
MessageQueueTerminated	.\MessageQueue.h	/^        MessageQueueTerminated,       \/\/ Queue was destroyed while waiting for message.$/;"	e	enum:WTF::MessageQueueWaitResult
MessageQueueTimeout	.\MessageQueue.h	/^        MessageQueueTimeout,          \/\/ Timeout was specified and it expired.$/;"	e	enum:WTF::MessageQueueWaitResult
MessageQueueWaitResult	.\MessageQueue.h	/^    enum MessageQueueWaitResult {$/;"	g	namespace:WTF
MessageQueue_h	.\MessageQueue.h	31;"	d
MetaAllocator	.\MetaAllocator.cpp	/^MetaAllocator::MetaAllocator(size_t allocationGranule)$/;"	f	class:WTF::MetaAllocator	signature:(size_t allocationGranule)
MetaAllocator	.\MetaAllocator.h	/^    WTF_EXPORT_PRIVATE MetaAllocator(size_t allocationGranule);$/;"	p	class:WTF::MetaAllocator	access:public	signature:(size_t allocationGranule)
MetaAllocator	.\MetaAllocator.h	/^class MetaAllocator {$/;"	c	namespace:WTF
MetaAllocatorHandle	.\MetaAllocator.cpp	/^MetaAllocatorHandle::MetaAllocatorHandle(MetaAllocator* allocator, void* start, size_t sizeInBytes, void* ownerUID)$/;"	f	class:WTF::MetaAllocatorHandle	signature:(MetaAllocator* allocator, void* start, size_t sizeInBytes, void* ownerUID)
MetaAllocatorHandle	.\MetaAllocatorHandle.h	/^    MetaAllocatorHandle(MetaAllocator*, void* start, size_t sizeInBytes, void* ownerUID);$/;"	p	class:WTF::MetaAllocatorHandle	access:private	signature:(MetaAllocator*, void* start, size_t sizeInBytes, void* ownerUID)
MetaAllocatorHandle	.\MetaAllocatorHandle.h	/^class MetaAllocatorHandle : public RefCounted<MetaAllocatorHandle>, public RedBlackTree<MetaAllocatorHandle, void*>::Node {$/;"	c	namespace:WTF	inherits:RefCounted,RedBlackTree::Node
MetaAllocatorTracker	.\MetaAllocator.h	/^class MetaAllocatorTracker {$/;"	c	namespace:WTF
MetaDataAlloc	.\FastMalloc.cpp	/^static void* MetaDataAlloc(size_t bytes) {$/;"	f	namespace:WTF	file:	signature:(size_t bytes)
Min	.\dtoa\utils.h	/^    static T Min(T a, T b) {$/;"	f	namespace:WTF::double_conversion	signature:(T a, T b)
Minus	.\dtoa\diy-fp.h	/^        static DiyFp Minus(const DiyFp& a, const DiyFp& b) {$/;"	f	class:WTF::double_conversion::DiyFp	access:public	signature:(const DiyFp& a, const DiyFp& b)
Mover	.\HashTable.h	/^    template<typename T> struct Mover<T, false> { static void move(T& from, T& to) { to = from; } };$/;"	s	namespace:WTF
Mover	.\HashTable.h	/^    template<typename T> struct Mover<T, true> { static void move(T& from, T& to) { hashTableSwap(from, to); } };$/;"	s	namespace:WTF
Multiply	.\dtoa\diy-fp.cc	/^    void DiyFp::Multiply(const DiyFp& other) {$/;"	f	class:WTF::double_conversion::DiyFp	signature:(const DiyFp& other)
Multiply	.\dtoa\diy-fp.h	/^        void Multiply(const DiyFp& other);$/;"	p	class:WTF::double_conversion::DiyFp	access:public	signature:(const DiyFp& other)
Multiply	.\dtoa\fixed-dtoa.cc	/^        void Multiply(uint32_t multiplicand) {$/;"	f	class:WTF::double_conversion::UInt128	access:public	signature:(uint32_t multiplicand)
MultiplyByPowerOfTen	.\dtoa\bignum.cc	/^    void Bignum::MultiplyByPowerOfTen(int exponent) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(int exponent)
MultiplyByPowerOfTen	.\dtoa\bignum.h	/^        void MultiplyByPowerOfTen(int exponent);$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(int exponent)
MultiplyByUInt32	.\dtoa\bignum.cc	/^    void Bignum::MultiplyByUInt32(uint32_t factor) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(uint32_t factor)
MultiplyByUInt32	.\dtoa\bignum.h	/^        void MultiplyByUInt32(uint32_t factor);$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(uint32_t factor)
MultiplyByUInt64	.\dtoa\bignum.cc	/^    void Bignum::MultiplyByUInt64(uint64_t factor) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(uint64_t factor)
MultiplyByUInt64	.\dtoa\bignum.h	/^        void MultiplyByUInt64(uint64_t factor);$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(uint64_t factor)
Mutex	.\ThreadingPrimitives.h	/^    WTF_EXPORT_PRIVATE Mutex();$/;"	p	class:WTF::Mutex	access:public	signature:()
Mutex	.\ThreadingPrimitives.h	/^class Mutex {$/;"	c	namespace:WTF
Mutex	.\ThreadingPthreads.cpp	/^Mutex::Mutex()$/;"	f	class:WTF::Mutex	signature:()
Mutex	.\ThreadingWin.cpp	/^Mutex::Mutex()$/;"	f	class:WTF::Mutex	signature:()
MutexLocker	.\ThreadingPrimitives.h	/^typedef Locker<Mutex> MutexLocker;$/;"	t	namespace:WTF
MutexVerificationMode	.\ThreadRestrictionVerifier.h	/^        MutexVerificationMode,$/;"	e	enum:WTF::ThreadRestrictionVerifier::VerificationMode
NEVER_INLINE	.\Compiler.h	149;"	d
NEVER_INLINE	.\Compiler.h	151;"	d
NEVER_INLINE	.\Compiler.h	153;"	d
NOMINMAX	.\Platform.h	511;"	d
NOSHLWAPI	.\Platform.h	512;"	d
NO_FLAGS	.\dtoa\double-conversion.h	/^            NO_FLAGS = 0,$/;"	e	enum:WTF::double_conversion::DoubleToStringConverter::Flags
NO_FLAGS	.\dtoa\double-conversion.h	/^            NO_FLAGS = 0,$/;"	e	enum:WTF::double_conversion::StringToDoubleConverter::Flags
NO_RETURN	.\Compiler.h	185;"	d
NO_RETURN	.\Compiler.h	187;"	d
NO_RETURN	.\Compiler.h	189;"	d
NO_RETURN_DUE_TO_ASSERT	.\Assertions.h	233;"	d
NO_RETURN_DUE_TO_ASSERT	.\Assertions.h	266;"	d
NO_RETURN_DUE_TO_CRASH	.\Assertions.h	186;"	d
NO_RETURN_DUE_TO_CRASH	.\Assertions.h	188;"	d
NO_RETURN_WITH_VALUE	.\Compiler.h	198;"	d
NO_RETURN_WITH_VALUE	.\Compiler.h	200;"	d
NO_TCMALLOC_SAMPLES	.\FastMalloc.cpp	92;"	d	file:
N_ONES_	.\TCPackedCache.h	125;"	d
N_ONES_	.\TCPackedCache.h	232;"	d
NaN	.\dtoa\double.h	/^        static double NaN() {$/;"	f	class:WTF::double_conversion::Double	access:public	signature:()
New	.\FastMalloc.cpp	/^  Span* New(Length n);$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:public	signature:(Length n)
New	.\FastMalloc.cpp	/^  T* New() {$/;"	f	class:WTF::PageHeapAllocator	access:public	signature:()
New	.\FastMalloc.cpp	/^inline Span* TCMalloc_PageHeap::New(Length n) {$/;"	f	class:WTF::TCMalloc_PageHeap	signature:(Length n)
NewArrayImpl	.\FastAllocBase.h	/^        struct NewArrayImpl {$/;"	s	namespace:WTF::Internal
NewArrayImpl	.\FastAllocBase.h	/^        struct NewArrayImpl<T, false, false> {$/;"	s	namespace:WTF::Internal
NewArrayImpl	.\FastAllocBase.h	/^        struct NewArrayImpl<T, false, true> {$/;"	s	namespace:WTF::Internal
NewArrayImpl	.\FastAllocBase.h	/^        struct NewArrayImpl<T, true, false> {$/;"	s	namespace:WTF::Internal
NewHeap	.\FastMalloc.cpp	/^  static inline TCMalloc_ThreadCache* NewHeap(ThreadIdentifier tid);$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:private	signature:(ThreadIdentifier tid)
NewHeap	.\FastMalloc.cpp	/^inline TCMalloc_ThreadCache* TCMalloc_ThreadCache::NewHeap(ThreadIdentifier tid) {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:(ThreadIdentifier tid)
NewNode	.\TCPageMap.h	/^  Node* NewNode() {$/;"	f	class:TCMalloc_PageMap3	access:private	signature:()
NewSpan	.\FastMalloc.cpp	/^static Span* NewSpan(PageID p, Length len) {$/;"	f	namespace:WTF	file:	signature:(PageID p, Length len)
NewThreadContext	.\Threading.cpp	/^    NewThreadContext(ThreadFunction entryPoint, void* data, const char* name)$/;"	f	struct:WTF::NewThreadContext	access:public	signature:(ThreadFunction entryPoint, void* data, const char* name)
NewThreadContext	.\Threading.cpp	/^struct NewThreadContext {$/;"	s	namespace:WTF	file:
NextDouble	.\dtoa\double.h	/^        double NextDouble() const {$/;"	f	class:WTF::double_conversion::Double	access:public	signature:() const
NoCategory	.\unicode\glib\UnicodeGLib.h	/^    NoCategory =  0,$/;"	e	enum:WTF::Unicode::CharCategory
NoCategory	.\unicode\icu\UnicodeIcu.h	/^    NoCategory =  0,$/;"	e	enum:WTF::Unicode::CharCategory
NoCategory	.\unicode\qt4\UnicodeQt4.h	/^    NoCategory = 0,$/;"	e	enum:WTF::Unicode::CharCategory
NoCategory	.\unicode\wince\UnicodeWinCE.h	/^    NoCategory =  0,$/;"	e	enum:WTF::Unicode::CharCategory
NoType	.\Functional.h	/^    struct NoType {$/;"	s	class:WTF::HasRefAndDeref	access:private
NoType	.\TypeTraits.h	/^            struct NoType {$/;"	s	class:WTF::IsConvertibleToInteger::IsConvertibleToDouble	access:private
NoType	.\TypeTraits.h	/^        struct NoType {$/;"	s	class:WTF::IsSubclass	access:private
NoType	.\TypeTraits.h	/^        struct NoType {$/;"	s	class:WTF::IsSubclassOfTemplate	access:private
NoVerificationMode	.\ThreadRestrictionVerifier.h	/^        NoVerificationMode,$/;"	e	enum:WTF::ThreadRestrictionVerifier::VerificationMode
Node	.\ListHashSet.h	/^        typedef ListHashSetNode<ValueArg, inlineCapacity> Node;$/;"	t	class:WTF::ListHashSet	access:private
Node	.\ListHashSet.h	/^        typedef ListHashSetNode<ValueArg, inlineCapacity> Node;$/;"	t	class:WTF::ListHashSetConstIterator	access:private
Node	.\ListHashSet.h	/^        typedef ListHashSetNode<ValueArg, inlineCapacity> Node;$/;"	t	class:WTF::ListHashSetConstReverseIterator	access:private
Node	.\ListHashSet.h	/^        typedef ListHashSetNode<ValueArg, inlineCapacity> Node;$/;"	t	class:WTF::ListHashSetIterator	access:private
Node	.\ListHashSet.h	/^        typedef ListHashSetNode<ValueArg, inlineCapacity> Node;$/;"	t	class:WTF::ListHashSetReverseIterator	access:private
Node	.\ListHashSet.h	/^        typedef ListHashSetNode<ValueArg, inlineCapacity> Node;$/;"	t	struct:WTF::ListHashSetNodeAllocator	access:public
Node	.\RedBlackTree.h	/^    class Node {$/;"	c	class:WTF::RedBlackTree	access:public
Node	.\TCPageMap.h	/^  struct Node {$/;"	s	class:TCMalloc_PageMap3	access:private
NodeAllocator	.\ListHashSet.h	/^        typedef ListHashSetNodeAllocator<ValueArg, inlineCapacity> NodeAllocator;$/;"	t	class:WTF::ListHashSet	access:private
NodeAllocator	.\ListHashSet.h	/^        typedef ListHashSetNodeAllocator<ValueArg, inlineCapacity> NodeAllocator;$/;"	t	struct:WTF::ListHashSetNode	access:public
NodeAllocator	.\ListHashSet.h	/^        typedef ListHashSetNodeAllocator<ValueArg, inlineCapacity> NodeAllocator;$/;"	t	struct:WTF::ListHashSetNodeAllocator	access:public
NodeHash	.\ListHashSet.h	/^        typedef ListHashSetNodeHashFunctions<HashArg> NodeHash;$/;"	t	class:WTF::ListHashSet	access:private
NodeTraits	.\ListHashSet.h	/^        typedef HashTraits<Node*> NodeTraits;$/;"	t	class:WTF::ListHashSet	access:private
NonASCIIMask	.\text\ASCIIFastPath.h	/^template<> struct NonASCIIMask<4, LChar> {$/;"	s	namespace:WTF
NonASCIIMask	.\text\ASCIIFastPath.h	/^template<> struct NonASCIIMask<4, UChar> {$/;"	s	namespace:WTF
NonASCIIMask	.\text\ASCIIFastPath.h	/^template<> struct NonASCIIMask<8, LChar> {$/;"	s	namespace:WTF
NonASCIIMask	.\text\ASCIIFastPath.h	/^template<> struct NonASCIIMask<8, UChar> {$/;"	s	namespace:WTF
NonConstIterator	.\Deque.h	/^        typedef DequeIterator<T, inlineCapacity> NonConstIterator;$/;"	t	class:WTF::DequeConstIterator	access:private
NonConstIterator	.\Deque.h	/^        typedef DequeReverseIterator<T, inlineCapacity> NonConstIterator;$/;"	t	class:WTF::DequeConstReverseIterator	access:private
NonNullDeleteArrayImpl	.\FastAllocBase.h	/^        struct NonNullDeleteArrayImpl {$/;"	s	namespace:WTF::Internal
NonNullDeleteArrayImpl	.\FastAllocBase.h	/^        struct NonNullDeleteArrayImpl<T, false> {$/;"	s	namespace:WTF::Internal
NonNullPassRefPtr	.\PassRefPtr.h	/^        NonNullPassRefPtr(T* ptr)$/;"	f	class:WTF::NonNullPassRefPtr	access:public	signature:(T* ptr)
NonNullPassRefPtr	.\PassRefPtr.h	/^        NonNullPassRefPtr(const NonNullPassRefPtr& o)$/;"	f	class:WTF::NonNullPassRefPtr	access:public	signature:(const NonNullPassRefPtr& o)
NonNullPassRefPtr	.\PassRefPtr.h	/^        template<typename U> NonNullPassRefPtr(const NonNullPassRefPtr<U>& o)$/;"	f	class:WTF::NonNullPassRefPtr	access:public	signature:(const NonNullPassRefPtr<U>& o)
NonNullPassRefPtr	.\PassRefPtr.h	/^        template<typename U> NonNullPassRefPtr(const PassRefPtr<U>& o)$/;"	f	class:WTF::NonNullPassRefPtr	access:public	signature:(const PassRefPtr<U>& o)
NonNullPassRefPtr	.\PassRefPtr.h	/^        template<typename U> NonNullPassRefPtr(const RefPtr<U>& o)$/;"	f	class:WTF::NonNullPassRefPtr	access:public	signature:(const RefPtr<U>& o)
NonNullPassRefPtr	.\PassRefPtr.h	/^    template<typename T> class NonNullPassRefPtr {$/;"	c	namespace:WTF
NonSpacingMark	.\unicode\glib\UnicodeGLib.h	/^    NonSpacingMark,$/;"	e	enum:WTF::Unicode::Direction
NonSpacingMark	.\unicode\icu\UnicodeIcu.h	/^    NonSpacingMark = U_DIR_NON_SPACING_MARK,$/;"	e	enum:WTF::Unicode::Direction
NonSpacingMark	.\unicode\qt4\UnicodeQt4.h	/^    NonSpacingMark = QChar::DirNSM,$/;"	e	enum:WTF::Unicode::Direction
NonSpacingMark	.\unicode\wince\UnicodeWinCE.h	/^    NonSpacingMark = UnicodeCE::U_DIR_NON_SPACING_MARK,$/;"	e	enum:WTF::Unicode::Direction
Normalize	.\dtoa\diy-fp.h	/^        static DiyFp Normalize(const DiyFp& a) {$/;"	f	class:WTF::double_conversion::DiyFp	access:public	signature:(const DiyFp& a)
Normalize	.\dtoa\diy-fp.h	/^        void Normalize() {$/;"	f	class:WTF::double_conversion::DiyFp	access:public	signature:()
NormalizedBoundaries	.\dtoa\double.h	/^        void NormalizedBoundaries(DiyFp* out_m_minus, DiyFp* out_m_plus) const {$/;"	f	class:WTF::double_conversion::Double	access:public	signature:(DiyFp* out_m_minus, DiyFp* out_m_plus) const
NormalizedExponent	.\dtoa\bignum-dtoa.cc	/^    static int NormalizedExponent(uint64_t significand, int exponent) {$/;"	f	namespace:WTF::double_conversion	file:	signature:(uint64_t significand, int exponent)
NotFound_h	.\NotFound.h	27;"	d
NotNull	.\StdLibExtras.h	/^enum NotNullTag { NotNull };$/;"	e	enum:NotNullTag
NotNullTag	.\StdLibExtras.h	/^enum NotNullTag { NotNull };$/;"	g
NullPtr_h	.\NullPtr.h	28;"	d
NumMoveSize	.\FastMalloc.cpp	/^static int NumMoveSize(size_t size) {$/;"	f	namespace:WTF	file:	signature:(size_t size)
Number	.\TCPageMap.h	/^  typedef uintptr_t Number;$/;"	t	class:TCMalloc_PageMap1	access:public
Number	.\TCPageMap.h	/^  typedef uintptr_t Number;$/;"	t	class:TCMalloc_PageMap2	access:public
Number	.\TCPageMap.h	/^  typedef uintptr_t Number;$/;"	t	class:TCMalloc_PageMap3	access:public
NumberOfCores_h	.\NumberOfCores.h	22;"	d
NumberToStringBuffer	.\dtoa.h	/^typedef char NumberToStringBuffer[NumberToStringBufferLength];$/;"	t	namespace:WTF
NumberToStringBufferLength	.\dtoa.h	/^const unsigned NumberToStringBufferLength = 96;$/;"	v
NumberToUStringBuffer	.\dtoa.h	/^typedef UChar NumberToUStringBuffer[NumberToStringBufferLength];$/;"	t	namespace:WTF
Number_DecimalDigit	.\unicode\glib\UnicodeGLib.h	/^    Number_DecimalDigit = U_MASK(G_UNICODE_DECIMAL_NUMBER),$/;"	e	enum:WTF::Unicode::CharCategory
Number_DecimalDigit	.\unicode\icu\UnicodeIcu.h	/^    Number_DecimalDigit = U_MASK(U_DECIMAL_DIGIT_NUMBER),$/;"	e	enum:WTF::Unicode::CharCategory
Number_DecimalDigit	.\unicode\qt4\UnicodeQt4.h	/^    Number_DecimalDigit = U_MASK(QChar::Number_DecimalDigit),$/;"	e	enum:WTF::Unicode::CharCategory
Number_DecimalDigit	.\unicode\wince\UnicodeWinCE.h	/^    Number_DecimalDigit = TO_MASK(UnicodeCE::U_DECIMAL_DIGIT_NUMBER),$/;"	e	enum:WTF::Unicode::CharCategory
Number_Letter	.\unicode\glib\UnicodeGLib.h	/^    Number_Letter = U_MASK(G_UNICODE_LETTER_NUMBER),$/;"	e	enum:WTF::Unicode::CharCategory
Number_Letter	.\unicode\icu\UnicodeIcu.h	/^    Number_Letter = U_MASK(U_LETTER_NUMBER),$/;"	e	enum:WTF::Unicode::CharCategory
Number_Letter	.\unicode\qt4\UnicodeQt4.h	/^    Number_Letter = U_MASK(QChar::Number_Letter),$/;"	e	enum:WTF::Unicode::CharCategory
Number_Letter	.\unicode\wince\UnicodeWinCE.h	/^    Number_Letter = TO_MASK(UnicodeCE::U_LETTER_NUMBER),$/;"	e	enum:WTF::Unicode::CharCategory
Number_Other	.\unicode\glib\UnicodeGLib.h	/^    Number_Other = U_MASK(G_UNICODE_OTHER_NUMBER),$/;"	e	enum:WTF::Unicode::CharCategory
Number_Other	.\unicode\icu\UnicodeIcu.h	/^    Number_Other = U_MASK(U_OTHER_NUMBER),$/;"	e	enum:WTF::Unicode::CharCategory
Number_Other	.\unicode\qt4\UnicodeQt4.h	/^    Number_Other = U_MASK(QChar::Number_Other),$/;"	e	enum:WTF::Unicode::CharCategory
Number_Other	.\unicode\wince\UnicodeWinCE.h	/^    Number_Other = TO_MASK(UnicodeCE::U_OTHER_NUMBER),$/;"	e	enum:WTF::Unicode::CharCategory
OBJC_CLASS	.\Compiler.h	249;"	d
OBJC_CLASS	.\Compiler.h	251;"	d
OBJECT_OFFSETOF	.\StdLibExtras.h	68;"	d
OS	.\Platform.h	48;"	d
OSAllocator	.\OSAllocator.h	/^class OSAllocator {$/;"	c	namespace:WTF
OSAllocator_h	.\OSAllocator.h	27;"	d
OVERRIDE	.\Compiler.h	218;"	d
OVERRIDE	.\Compiler.h	221;"	d
OVERRIDE	.\Compiler.h	226;"	d
OctalCharacter	.\url\src\URLCharacterTypes.h	/^        OctalCharacter = 1 << 5,$/;"	e	enum:WTF::URLCharacterTypes::CharTypes
OnCallback	.\wx\MainThreadWx.cpp	/^    void OnCallback(wxCommandEvent& event)$/;"	f	class:wxCallAfter	access:public	signature:(wxCommandEvent& event)
OrdinalNumber	.\text\TextPosition.h	/^    OrdinalNumber() : m_zeroBasedValue(0) { }$/;"	f	class:WTF::OrdinalNumber	access:public	signature:()
OrdinalNumber	.\text\TextPosition.h	/^    OrdinalNumber(int zeroBasedInt) : m_zeroBasedValue(zeroBasedInt) { }$/;"	f	class:WTF::OrdinalNumber	access:private	signature:(int zeroBasedInt)
OrdinalNumber	.\text\TextPosition.h	/^class OrdinalNumber {$/;"	c	namespace:WTF
OtherNeutral	.\unicode\glib\UnicodeGLib.h	/^    OtherNeutral,$/;"	e	enum:WTF::Unicode::Direction
OtherNeutral	.\unicode\icu\UnicodeIcu.h	/^    OtherNeutral = U_OTHER_NEUTRAL,$/;"	e	enum:WTF::Unicode::Direction
OtherNeutral	.\unicode\qt4\UnicodeQt4.h	/^    OtherNeutral = QChar::DirON,$/;"	e	enum:WTF::Unicode::Direction
OtherNeutral	.\unicode\wince\UnicodeWinCE.h	/^    OtherNeutral = UnicodeCE::U_OTHER_NEUTRAL,$/;"	e	enum:WTF::Unicode::Direction
Other_Control	.\unicode\glib\UnicodeGLib.h	/^    Other_Control = U_MASK(G_UNICODE_CONTROL),$/;"	e	enum:WTF::Unicode::CharCategory
Other_Control	.\unicode\icu\UnicodeIcu.h	/^    Other_Control = U_MASK(U_CONTROL_CHAR),$/;"	e	enum:WTF::Unicode::CharCategory
Other_Control	.\unicode\qt4\UnicodeQt4.h	/^    Other_Control = U_MASK(QChar::Other_Control),$/;"	e	enum:WTF::Unicode::CharCategory
Other_Control	.\unicode\wince\UnicodeWinCE.h	/^    Other_Control = TO_MASK(UnicodeCE::U_CONTROL_CHAR),$/;"	e	enum:WTF::Unicode::CharCategory
Other_Format	.\unicode\glib\UnicodeGLib.h	/^    Other_Format = U_MASK(G_UNICODE_FORMAT),$/;"	e	enum:WTF::Unicode::CharCategory
Other_Format	.\unicode\icu\UnicodeIcu.h	/^    Other_Format = U_MASK(U_FORMAT_CHAR),$/;"	e	enum:WTF::Unicode::CharCategory
Other_Format	.\unicode\qt4\UnicodeQt4.h	/^    Other_Format = U_MASK(QChar::Other_Format),$/;"	e	enum:WTF::Unicode::CharCategory
Other_Format	.\unicode\wince\UnicodeWinCE.h	/^    Other_Format = TO_MASK(UnicodeCE::U_FORMAT_CHAR),$/;"	e	enum:WTF::Unicode::CharCategory
Other_NotAssigned	.\unicode\glib\UnicodeGLib.h	/^    Other_NotAssigned = U_MASK(G_UNICODE_UNASSIGNED),$/;"	e	enum:WTF::Unicode::CharCategory
Other_NotAssigned	.\unicode\icu\UnicodeIcu.h	/^    Other_NotAssigned = U_MASK(U_GENERAL_OTHER_TYPES),$/;"	e	enum:WTF::Unicode::CharCategory
Other_NotAssigned	.\unicode\qt4\UnicodeQt4.h	/^    Other_NotAssigned = U_MASK(QChar::Other_NotAssigned),$/;"	e	enum:WTF::Unicode::CharCategory
Other_NotAssigned	.\unicode\wince\UnicodeWinCE.h	/^    Other_NotAssigned = TO_MASK(UnicodeCE::U_GENERAL_OTHER_TYPES),$/;"	e	enum:WTF::Unicode::CharCategory
Other_PrivateUse	.\unicode\glib\UnicodeGLib.h	/^    Other_PrivateUse = U_MASK(G_UNICODE_PRIVATE_USE),$/;"	e	enum:WTF::Unicode::CharCategory
Other_PrivateUse	.\unicode\icu\UnicodeIcu.h	/^    Other_PrivateUse = U_MASK(U_PRIVATE_USE_CHAR),$/;"	e	enum:WTF::Unicode::CharCategory
Other_PrivateUse	.\unicode\qt4\UnicodeQt4.h	/^    Other_PrivateUse = U_MASK(QChar::Other_PrivateUse),$/;"	e	enum:WTF::Unicode::CharCategory
Other_PrivateUse	.\unicode\wince\UnicodeWinCE.h	/^    Other_PrivateUse = TO_MASK(UnicodeCE::U_PRIVATE_USE_CHAR),$/;"	e	enum:WTF::Unicode::CharCategory
Other_Surrogate	.\unicode\glib\UnicodeGLib.h	/^    Other_Surrogate = U_MASK(G_UNICODE_SURROGATE),$/;"	e	enum:WTF::Unicode::CharCategory
Other_Surrogate	.\unicode\icu\UnicodeIcu.h	/^    Other_Surrogate = U_MASK(U_SURROGATE),$/;"	e	enum:WTF::Unicode::CharCategory
Other_Surrogate	.\unicode\qt4\UnicodeQt4.h	/^    Other_Surrogate = U_MASK(QChar::Other_Surrogate),$/;"	e	enum:WTF::Unicode::CharCategory
Other_Surrogate	.\unicode\wince\UnicodeWinCE.h	/^    Other_Surrogate = TO_MASK(UnicodeCE::U_SURROGATE),$/;"	e	enum:WTF::Unicode::CharCategory
OutOfLineBits	.\BitVector.h	/^        OutOfLineBits(size_t numBits)$/;"	f	class:WTF::BitVector::OutOfLineBits	access:private	signature:(size_t numBits)
OutOfLineBits	.\BitVector.h	/^    class OutOfLineBits {$/;"	c	class:WTF::BitVector	access:private
OwnArrayPtr	.\OwnArrayPtr.h	/^    OwnArrayPtr() : m_ptr(0) { }$/;"	f	class:WTF::OwnArrayPtr	access:public	signature:()
OwnArrayPtr	.\OwnArrayPtr.h	/^    OwnArrayPtr(const OwnArrayPtr<T>&);$/;"	p	class:WTF::OwnArrayPtr	access:public	signature:(const OwnArrayPtr<T>&)
OwnArrayPtr	.\OwnArrayPtr.h	/^    template<typename U> OwnArrayPtr(const PassOwnArrayPtr<U>& o);$/;"	p	class:WTF::OwnArrayPtr	access:public	signature:(const PassOwnArrayPtr<U>& o)
OwnArrayPtr	.\OwnArrayPtr.h	/^template <typename T> class OwnArrayPtr {$/;"	c	namespace:WTF
OwnArrayPtr	.\OwnArrayPtr.h	/^template<typename T> template<typename U> inline OwnArrayPtr<T>::OwnArrayPtr(const PassOwnArrayPtr<U>& o)$/;"	f	class:WTF::OwnArrayPtr	signature:(const PassOwnArrayPtr<U>& o)
OwnPtr	.\OwnPtr.h	/^        OwnPtr() : m_ptr(0) { }$/;"	f	class:WTF::OwnPtr	access:public	signature:()
OwnPtr	.\OwnPtr.h	/^        OwnPtr(const OwnPtr<ValueType>&);$/;"	p	class:WTF::OwnPtr	access:public	signature:(const OwnPtr<ValueType>&)
OwnPtr	.\OwnPtr.h	/^        OwnPtr(std::nullptr_t) : m_ptr(0) { }$/;"	f	class:WTF::OwnPtr	access:public	signature:(std::nullptr_t)
OwnPtr	.\OwnPtr.h	/^        template<typename U> OwnPtr(const PassOwnPtr<U>& o);$/;"	p	class:WTF::OwnPtr	access:public	signature:(const PassOwnPtr<U>& o)
OwnPtr	.\OwnPtr.h	/^    template<typename T> class OwnPtr {$/;"	c	namespace:WTF
OwnPtr	.\OwnPtr.h	/^    template<typename T> template<typename U> inline OwnPtr<T>::OwnPtr(const PassOwnPtr<U>& o)$/;"	f	class:WTF::OwnPtr	signature:(const PassOwnPtr<U>& o)
OwnPtr_should_stay_small	.\SizeLimits.cpp	/^COMPILE_ASSERT(sizeof(OwnPtr<int>) == sizeof(int*), OwnPtr_should_stay_small);$/;"	v
P	.\dtoa.cpp	131;"	d	file:
P5Node	.\dtoa.cpp	/^    P5Node() { }$/;"	f	struct:WTF::P5Node	access:public	signature:()
P5Node	.\dtoa.cpp	/^struct P5Node {$/;"	s	namespace:WTF	file:
PLATFORM	.\Platform.h	37;"	d
PRECISION	.\dtoa\double-conversion.h	/^            PRECISION$/;"	e	enum:WTF::double_conversion::DoubleToStringConverter::DtoaMode
PRIuS	.\FastMalloc.cpp	466;"	d	file:
PTHREAD_KEYS_MAX	.\ThreadIdentifierDataPthreads.cpp	41;"	d	file:
PackedCache	.\TCPackedCache.h	/^  explicit PackedCache(V initial_value) {$/;"	f	class:PackedCache	access:public	signature:(V initial_value)
PackedCache	.\TCPackedCache.h	/^class PackedCache {$/;"	c
PackedCache::Clear	.\TCPackedCache.h	/^  void Clear(V value) {$/;"	f	class:PackedCache	access:public	signature:(V value)
PackedCache::EntryToUpper	.\TCPackedCache.h	/^  static UPPER EntryToUpper(T t) { return t & kUpperMask; }$/;"	f	class:PackedCache	access:private	signature:(T t)
PackedCache::EntryToValue	.\TCPackedCache.h	/^  static V EntryToValue(T t) { return t & kValueMask; }$/;"	f	class:PackedCache	access:private	signature:(T t)
PackedCache::GetOrDefault	.\TCPackedCache.h	/^  V GetOrDefault(K key, V default_value) const {$/;"	f	class:PackedCache	access:public	signature:(K key, V default_value) const
PackedCache::Has	.\TCPackedCache.h	/^  bool Has(K key) const {$/;"	f	class:PackedCache	access:public	signature:(K key) const
PackedCache::Hash	.\TCPackedCache.h	/^  static size_t Hash(K key) {$/;"	f	class:PackedCache	access:private	signature:(K key)
PackedCache::K	.\TCPackedCache.h	/^  typedef uintptr_t K;$/;"	t	class:PackedCache	access:public
PackedCache::KeyMatch	.\TCPackedCache.h	/^  static bool KeyMatch(T entry, K key) {$/;"	f	class:PackedCache	access:private	signature:(T entry, K key)
PackedCache::KeyToUpper	.\TCPackedCache.h	/^  static UPPER KeyToUpper(K k) {$/;"	f	class:PackedCache	access:private	signature:(K k)
PackedCache::PackedCache	.\TCPackedCache.h	/^  explicit PackedCache(V initial_value) {$/;"	f	class:PackedCache	access:public	signature:(V initial_value)
PackedCache::Put	.\TCPackedCache.h	/^  void Put(K key, V value) {$/;"	f	class:PackedCache	access:public	signature:(K key, V value)
PackedCache::UPPER	.\TCPackedCache.h	/^  typedef T UPPER;$/;"	t	class:PackedCache	access:private
PackedCache::UpperToPartialKey	.\TCPackedCache.h	/^  static K UpperToPartialKey(UPPER u) {$/;"	f	class:PackedCache	access:private	signature:(UPPER u)
PackedCache::V	.\TCPackedCache.h	/^  typedef size_t V;$/;"	t	class:PackedCache	access:public
PackedCache::array_	.\TCPackedCache.h	/^  T array_[1 << kHashbits];$/;"	m	class:PackedCache	access:private
PackedCache::kHashbits	.\TCPackedCache.h	/^  static const size_t kHashbits = 12;$/;"	m	class:PackedCache	access:public
PackedCache::kKeyMask	.\TCPackedCache.h	/^  static const K kKeyMask = N_ONES_(K, kKeybits);$/;"	m	class:PackedCache	access:private
PackedCache::kTbits	.\TCPackedCache.h	/^  static const size_t kTbits = 8 * sizeof(T);$/;"	m	class:PackedCache	access:private
PackedCache::kUpperMask	.\TCPackedCache.h	/^  static const T kUpperMask = N_ONES_(T, kUpperbits) << kValuebits;$/;"	m	class:PackedCache	access:private
PackedCache::kUpperbits	.\TCPackedCache.h	/^  static const int kUpperbits = kKeybits - kHashbits;$/;"	m	class:PackedCache	access:private
PackedCache::kValueMask	.\TCPackedCache.h	/^  static const V kValueMask = N_ONES_(V, kValuebits);$/;"	m	class:PackedCache	access:private
PackedCache::kValuebits	.\TCPackedCache.h	/^  static const size_t kValuebits = 8;$/;"	m	class:PackedCache	access:public
PackedIntVector	.\PackedIntVector.h	/^    PackedIntVector()$/;"	f	class:WTF::PackedIntVector	access:public	signature:()
PackedIntVector	.\PackedIntVector.h	/^    PackedIntVector(const PackedIntVector& other)$/;"	f	class:WTF::PackedIntVector	access:public	signature:(const PackedIntVector& other)
PackedIntVector	.\PackedIntVector.h	/^class PackedIntVector {$/;"	c	namespace:WTF
PackedIntVector_h	.\PackedIntVector.h	27;"	d
PageAllocation	.\PageAllocation.h	/^    PageAllocation()$/;"	f	class:WTF::PageAllocation	access:public	signature:()
PageAllocation	.\PageAllocation.h	/^    PageAllocation(void* base, size_t size)$/;"	f	class:WTF::PageAllocation	access:private	signature:(void* base, size_t size)
PageAllocation	.\PageAllocation.h	/^class PageAllocation : private PageBlock {$/;"	c	namespace:WTF	inherits:PageBlock
PageAllocationAligned	.\PageAllocationAligned.h	/^    PageAllocationAligned()$/;"	f	class:WTF::PageAllocationAligned	access:public	signature:()
PageAllocationAligned	.\PageAllocationAligned.h	/^    PageAllocationAligned(void* base, size_t size)$/;"	f	class:WTF::PageAllocationAligned	access:private	signature:(void* base, size_t size)
PageAllocationAligned	.\PageAllocationAligned.h	/^    PageAllocationAligned(void* base, size_t size, void* reservationBase, size_t reservationSize)$/;"	f	class:WTF::PageAllocationAligned	access:private	signature:(void* base, size_t size, void* reservationBase, size_t reservationSize)
PageAllocationAligned	.\PageAllocationAligned.h	/^class PageAllocationAligned : private PageBlock {$/;"	c	namespace:WTF	inherits:PageBlock
PageAllocationAligned_h	.\PageAllocationAligned.h	27;"	d
PageAllocation_h	.\PageAllocation.h	27;"	d
PageBlock	.\PageBlock.h	/^    PageBlock();$/;"	p	class:WTF::PageBlock	access:public	signature:()
PageBlock	.\PageBlock.h	/^    PageBlock(const PageBlock&);$/;"	p	class:WTF::PageBlock	access:public	signature:(const PageBlock&)
PageBlock	.\PageBlock.h	/^    PageBlock(void*, size_t, bool hasGuardPages);$/;"	p	class:WTF::PageBlock	access:public	signature:(void*, size_t, bool hasGuardPages)
PageBlock	.\PageBlock.h	/^class PageBlock {$/;"	c	namespace:WTF
PageBlock	.\PageBlock.h	/^inline PageBlock::PageBlock()$/;"	f	class:WTF::PageBlock	signature:()
PageBlock	.\PageBlock.h	/^inline PageBlock::PageBlock(const PageBlock& other)$/;"	f	class:WTF::PageBlock	signature:(const PageBlock& other)
PageBlock	.\PageBlock.h	/^inline PageBlock::PageBlock(void* base, size_t size, bool hasGuardPages)$/;"	f	class:WTF::PageBlock	signature:(void* base, size_t size, bool hasGuardPages)
PageBlock_h	.\PageBlock.h	27;"	d
PageHeapAllocator	.\FastMalloc.cpp	/^class PageHeapAllocator {$/;"	c	namespace:WTF	file:
PageHeapUnion	.\FastMalloc.cpp	/^} PageHeapUnion;$/;"	t	namespace:WTF	typeref:union:WTF::__anon5	file:
PageID	.\FastMalloc.cpp	/^typedef uintptr_t PageID;$/;"	t	namespace:WTF	file:
PageMap	.\FastMalloc.cpp	/^  typedef MapSelector<8*sizeof(uintptr_t)>::Type PageMap;$/;"	t	class:WTF::TCMalloc_PageHeap	file:	access:private
PageMapCache	.\FastMalloc.cpp	/^  typedef MapSelector<8*sizeof(uintptr_t)>::CacheType PageMapCache;$/;"	t	class:WTF::TCMalloc_PageHeap	file:	access:private
PageMapFreeObjectFinder	.\FastMalloc.cpp	/^    PageMapFreeObjectFinder(const RemoteMemoryReader& reader, FreeObjectFinder& freeObjectFinder)$/;"	f	class:WTF::PageMapFreeObjectFinder	access:public	signature:(const RemoteMemoryReader& reader, FreeObjectFinder& freeObjectFinder)
PageMapFreeObjectFinder	.\FastMalloc.cpp	/^class PageMapFreeObjectFinder {$/;"	c	namespace:WTF	file:
PageMapMemoryUsageRecorder	.\FastMalloc.cpp	/^    PageMapMemoryUsageRecorder(task_t task, void* context, unsigned typeMask, vm_range_recorder_t* recorder, const RemoteMemoryReader& reader, const FreeObjectFinder& freeObjectFinder)$/;"	f	class:WTF::PageMapMemoryUsageRecorder	access:public	signature:(task_t task, void* context, unsigned typeMask, vm_range_recorder_t* recorder, const RemoteMemoryReader& reader, const FreeObjectFinder& freeObjectFinder)
PageMapMemoryUsageRecorder	.\FastMalloc.cpp	/^class PageMapMemoryUsageRecorder {$/;"	c	namespace:WTF	file:
PageReservation	.\PageReservation.h	/^    PageReservation()$/;"	f	class:WTF::PageReservation	access:public	signature:()
PageReservation	.\PageReservation.h	/^    PageReservation(void* base, size_t size, bool writable, bool executable, bool hasGuardPages)$/;"	f	class:WTF::PageReservation	access:private	signature:(void* base, size_t size, bool writable, bool executable, bool hasGuardPages)
PageReservation	.\PageReservation.h	/^class PageReservation : private PageBlock {$/;"	c	namespace:WTF	inherits:PageBlock
PageReservation_h	.\PageReservation.h	27;"	d
PagesToMB	.\FastMalloc.cpp	/^static double PagesToMB(uint64_t pages) {$/;"	f	namespace:WTF	file:	signature:(uint64_t pages)
PairFirstExtractor	.\HashMap.h	/^    template<typename PairType> struct PairFirstExtractor {$/;"	s	namespace:WTF
PairHash	.\HashFunctions.h	/^    template<typename T, typename U> struct PairHash {$/;"	s	namespace:WTF
PairHashTraits	.\HashTraits.h	/^    struct PairHashTraits : GenericHashTraits<pair<typename FirstTraitsArg::TraitType, typename SecondTraitsArg::TraitType> > {$/;"	s	namespace:WTF	inherits:GenericHashTraits
ParallelEnvironment	.\ParallelJobsGeneric.cpp	/^ParallelEnvironment::ParallelEnvironment(ThreadFunction threadFunction, size_t sizeOfParameter, int requestedJobNumber) :$/;"	f	class:WTF::ParallelEnvironment	signature:(ThreadFunction threadFunction, size_t sizeOfParameter, int requestedJobNumber)
ParallelEnvironment	.\ParallelJobsGeneric.h	/^    ParallelEnvironment(ThreadFunction, size_t sizeOfParameter, int requestedJobNumber);$/;"	p	class:WTF::ParallelEnvironment	access:public	signature:(ThreadFunction, size_t sizeOfParameter, int requestedJobNumber)
ParallelEnvironment	.\ParallelJobsGeneric.h	/^class ParallelEnvironment {$/;"	c	namespace:WTF
ParallelEnvironment	.\ParallelJobsLibdispatch.h	/^    ParallelEnvironment(ThreadFunction threadFunction, size_t sizeOfParameter, int requestedJobNumber)$/;"	f	class:WTF::ParallelEnvironment	access:public	signature:(ThreadFunction threadFunction, size_t sizeOfParameter, int requestedJobNumber)
ParallelEnvironment	.\ParallelJobsLibdispatch.h	/^class ParallelEnvironment {$/;"	c	namespace:WTF
ParallelEnvironment	.\ParallelJobsOpenMP.h	/^    ParallelEnvironment(ThreadFunction threadFunction, size_t sizeOfParameter, int requestedJobNumber) :$/;"	f	class:WTF::ParallelEnvironment	access:public	signature:(ThreadFunction threadFunction, size_t sizeOfParameter, int requestedJobNumber)
ParallelEnvironment	.\ParallelJobsOpenMP.h	/^class ParallelEnvironment {$/;"	c	namespace:WTF
ParallelJobs	.\ParallelJobs.h	/^    ParallelJobs(WorkerFunction func, int requestedJobNumber) :$/;"	f	class:WTF::ParallelJobs	access:public	signature:(WorkerFunction func, int requestedJobNumber)
ParallelJobs	.\ParallelJobs.h	/^class ParallelJobs {$/;"	c	namespace:WTF
ParallelJobsGeneric_h	.\ParallelJobsGeneric.h	29;"	d
ParallelJobsLibdispatch_h	.\ParallelJobsLibdispatch.h	29;"	d
ParallelJobsOpenMP_h	.\ParallelJobsOpenMP.h	29;"	d
ParallelJobs_h	.\ParallelJobs.h	29;"	d
ParamStorageTraits	.\Functional.h	/^template<typename T> struct ParamStorageTraits {$/;"	s	namespace:WTF
ParamStorageTraits	.\Functional.h	/^template<typename T> struct ParamStorageTraits<PassRefPtr<T> > {$/;"	s	namespace:WTF
ParamStorageTraits	.\Functional.h	/^template<typename T> struct ParamStorageTraits<RefPtr<T> > {$/;"	s	namespace:WTF
ParamStorageTraits	.\Functional.h	/^template<typename T> struct ParamStorageTraits<RetainPtr<T> > {$/;"	s	namespace:WTF
ParsedURL	.\url\api\ParsedURL.cpp	/^ParsedURL::ParsedURL(const String& urlString)$/;"	f	class:WTF::ParsedURL	signature:(const String& urlString)
ParsedURL	.\url\api\ParsedURL.h	/^    ParsedURL() { };$/;"	f	class:WTF::ParsedURL	access:public	signature:()
ParsedURL	.\url\api\ParsedURL.h	/^    WTF_EXPORT_PRIVATE explicit ParsedURL(const String&);$/;"	p	class:WTF::ParsedURL	access:public	signature:(const String&)
ParsedURL	.\url\api\ParsedURL.h	/^class ParsedURL {$/;"	c	namespace:WTF
ParsedURL_h	.\url\api\ParsedURL.h	27;"	d
Pass	.\Deque.h	/^        typedef PassTraits<T> Pass;$/;"	t	class:WTF::Deque	access:public
PassInType	.\HashTraits.h	/^        typedef PassOwnPtr<P> PassInType;$/;"	t	struct:WTF::HashTraits	access:public
PassInType	.\HashTraits.h	/^        typedef PassRefPtr<P> PassInType;$/;"	t	struct:WTF::HashTraits	access:public
PassInType	.\HashTraits.h	/^        typedef const T& PassInType;$/;"	t	struct:WTF::GenericHashTraits	access:public
PassOutType	.\HashTraits.h	/^        typedef PassOwnPtr<P> PassOutType;$/;"	t	struct:WTF::HashTraits	access:public
PassOutType	.\HashTraits.h	/^        typedef T PassOutType;$/;"	t	struct:WTF::GenericHashTraits	access:public
PassOwnArrayPtr	.\PassOwnArrayPtr.h	/^    PassOwnArrayPtr() : m_ptr(0) { }$/;"	f	class:WTF::PassOwnArrayPtr	access:public	signature:()
PassOwnArrayPtr	.\PassOwnArrayPtr.h	/^    PassOwnArrayPtr(const PassOwnArrayPtr& o) : m_ptr(o.leakPtr()) { }$/;"	f	class:WTF::PassOwnArrayPtr	access:public	signature:(const PassOwnArrayPtr& o)
PassOwnArrayPtr	.\PassOwnArrayPtr.h	/^    PassOwnArrayPtr(std::nullptr_t) : m_ptr(0) { }$/;"	f	class:WTF::PassOwnArrayPtr	access:public	signature:(std::nullptr_t)
PassOwnArrayPtr	.\PassOwnArrayPtr.h	/^    explicit PassOwnArrayPtr(PtrType ptr) : m_ptr(ptr) { }$/;"	f	class:WTF::PassOwnArrayPtr	access:private	signature:(PtrType ptr)
PassOwnArrayPtr	.\PassOwnArrayPtr.h	/^    template<typename U> PassOwnArrayPtr(const PassOwnArrayPtr<U>& o) : m_ptr(o.leakPtr()) { }$/;"	f	class:WTF::PassOwnArrayPtr	access:public	signature:(const PassOwnArrayPtr<U>& o)
PassOwnArrayPtr	.\PassOwnArrayPtr.h	/^template<typename T> class PassOwnArrayPtr {$/;"	c	namespace:WTF
PassOwnPtr	.\PassOwnPtr.h	/^        PassOwnPtr() : m_ptr(0) { }$/;"	f	class:WTF::PassOwnPtr	access:public	signature:()
PassOwnPtr	.\PassOwnPtr.h	/^        PassOwnPtr(const PassOwnPtr& o) : m_ptr(o.leakPtr()) { }$/;"	f	class:WTF::PassOwnPtr	access:public	signature:(const PassOwnPtr& o)
PassOwnPtr	.\PassOwnPtr.h	/^        PassOwnPtr(std::nullptr_t) : m_ptr(0) { }$/;"	f	class:WTF::PassOwnPtr	access:public	signature:(std::nullptr_t)
PassOwnPtr	.\PassOwnPtr.h	/^        explicit PassOwnPtr(PtrType ptr) : m_ptr(ptr) { }$/;"	f	class:WTF::PassOwnPtr	access:private	signature:(PtrType ptr)
PassOwnPtr	.\PassOwnPtr.h	/^        template<typename U> PassOwnPtr(const PassOwnPtr<U>& o) : m_ptr(o.leakPtr()) { }$/;"	f	class:WTF::PassOwnPtr	access:public	signature:(const PassOwnPtr<U>& o)
PassOwnPtr	.\PassOwnPtr.h	/^    template<typename T> class PassOwnPtr {$/;"	c	namespace:WTF
PassRefPtr	.\PassRefPtr.h	/^        PassRefPtr() : m_ptr(0) { }$/;"	f	class:WTF::PassRefPtr	access:public	signature:()
PassRefPtr	.\PassRefPtr.h	/^        PassRefPtr(T* ptr) : m_ptr(ptr) { refIfNotNull(ptr); }$/;"	f	class:WTF::PassRefPtr	access:public	signature:(T* ptr)
PassRefPtr	.\PassRefPtr.h	/^        PassRefPtr(T* ptr, bool) : m_ptr(ptr) { }$/;"	f	class:WTF::PassRefPtr	access:private	signature:(T* ptr, bool)
PassRefPtr	.\PassRefPtr.h	/^        PassRefPtr(const PassRefPtr& o) : m_ptr(o.leakRef()) { }$/;"	f	class:WTF::PassRefPtr	access:public	signature:(const PassRefPtr& o)
PassRefPtr	.\PassRefPtr.h	/^        template<typename U> PassRefPtr(const PassRefPtr<U>& o) : m_ptr(o.leakRef()) { }$/;"	f	class:WTF::PassRefPtr	access:public	signature:(const PassRefPtr<U>& o)
PassRefPtr	.\PassRefPtr.h	/^        template<typename U> PassRefPtr(const RefPtr<U>&);$/;"	p	class:WTF::PassRefPtr	access:public	signature:(const RefPtr<U>&)
PassRefPtr	.\PassRefPtr.h	/^    template<typename T> class PassRefPtr {$/;"	c	namespace:WTF
PassRefPtr	.\PassRefPtr.h	/^    template<typename T> template<typename U> inline PassRefPtr<T>::PassRefPtr(const RefPtr<U>& o)$/;"	f	class:WTF::PassRefPtr	signature:(const RefPtr<U>& o)
PassRefPtr_should_stay_small	.\SizeLimits.cpp	/^COMPILE_ASSERT(sizeof(PassRefPtr<RefCounted<int> >) == sizeof(int*), PassRefPtr_should_stay_small);$/;"	v
PassTraits	.\PassTraits.h	/^template<typename T> struct PassTraits {$/;"	s	namespace:WTF
PassTraits	.\PassTraits.h	/^template<typename T> struct PassTraits<OwnPtr<T> > {$/;"	s	namespace:WTF
PassTraits	.\PassTraits.h	/^template<typename T> struct PassTraits<RefPtr<T> > {$/;"	s	namespace:WTF
PassType	.\Deque.h	/^        typedef typename PassTraits<T>::PassType PassType;$/;"	t	class:WTF::Deque	access:public
PassType	.\PassTraits.h	/^    typedef PassOwnPtr<T> PassType;$/;"	t	struct:WTF::PassTraits	access:public
PassType	.\PassTraits.h	/^    typedef PassRefPtr<T> PassType;$/;"	t	struct:WTF::PassTraits	access:public
PassType	.\PassTraits.h	/^    typedef T PassType;$/;"	t	struct:WTF::PassTraits	access:public
Password	.\url\src\URLSegments.h	/^        Password,$/;"	e	enum:WTF::URLSegments::ComponentType
Path	.\url\src\URLSegments.h	/^        Path,$/;"	e	enum:WTF::URLSegments::ComponentType
PeekType	.\HashTraits.h	/^        typedef T PeekType;$/;"	t	struct:WTF::GenericHashTraits	access:public
PeekType	.\HashTraits.h	/^        typedef typename OwnPtr<P>::PtrType PeekType;$/;"	t	struct:WTF::HashTraits	access:public
PickNextSample	.\FastMalloc.cpp	/^  void PickNextSample(size_t k);$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:(size_t k)
PickNextSample	.\FastMalloc.cpp	/^void TCMalloc_ThreadCache::PickNextSample(size_t k) {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:(size_t k)
PlacementNewAdopt	.\RefPtr.h	/^    enum PlacementNewAdoptType { PlacementNewAdopt };$/;"	e	enum:WTF::PlacementNewAdoptType
PlacementNewAdoptType	.\RefPtr.h	/^    enum PlacementNewAdoptType { PlacementNewAdopt };$/;"	g	namespace:WTF
PlatformCondition	.\ThreadingPrimitives.h	/^typedef pthread_cond_t PlatformCondition;$/;"	t	namespace:WTF
PlatformMutex	.\ThreadingPrimitives.h	/^typedef pthread_mutex_t PlatformMutex;$/;"	t	namespace:WTF
PlatformReadWriteLock	.\ThreadingPrimitives.h	/^typedef pthread_rwlock_t PlatformReadWriteLock;$/;"	t	namespace:WTF
PlatformReadWriteLock	.\ThreadingPrimitives.h	/^typedef void* PlatformReadWriteLock;$/;"	t	namespace:WTF
PlusCompare	.\dtoa\bignum.cc	/^    int Bignum::PlusCompare(const Bignum& a, const Bignum& b, const Bignum& c) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(const Bignum& a, const Bignum& b, const Bignum& c)
PlusCompare	.\dtoa\bignum.h	/^        static int PlusCompare(const Bignum& a, const Bignum& b, const Bignum& c);$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(const Bignum& a, const Bignum& b, const Bignum& c)
PlusEqual	.\dtoa\bignum.h	/^        static bool PlusEqual(const Bignum& a, const Bignum& b, const Bignum& c) {$/;"	f	class:WTF::double_conversion::Bignum	access:public	signature:(const Bignum& a, const Bignum& b, const Bignum& c)
PlusLess	.\dtoa\bignum.h	/^        static bool PlusLess(const Bignum& a, const Bignum& b, const Bignum& c) {$/;"	f	class:WTF::double_conversion::Bignum	access:public	signature:(const Bignum& a, const Bignum& b, const Bignum& c)
PlusLessEqual	.\dtoa\bignum.h	/^        static bool PlusLessEqual(const Bignum& a, const Bignum& b, const Bignum& c) {$/;"	f	class:WTF::double_conversion::Bignum	access:public	signature:(const Bignum& a, const Bignum& b, const Bignum& c)
PointerType	.\HashTable.h	/^        typedef ValueType* PointerType;$/;"	t	class:WTF::HashTableIterator	access:private
PointerType	.\HashTable.h	/^        typedef const ValueType* PointerType;$/;"	t	class:WTF::HashTableConstIterator	access:private
PointerType	.\ListHashSet.h	/^        typedef ValueType* PointerType;$/;"	t	class:WTF::ListHashSetIterator	access:private
PointerType	.\ListHashSet.h	/^        typedef ValueType* PointerType;$/;"	t	class:WTF::ListHashSetReverseIterator	access:private
PointerType	.\ListHashSet.h	/^        typedef const ValueType* PointerType;$/;"	t	class:WTF::ListHashSetConstIterator	access:private
PointerType	.\ListHashSet.h	/^        typedef const ValueType* PointerType;$/;"	t	class:WTF::ListHashSetConstReverseIterator	access:private
Pop	.\FastMalloc.cpp	/^  ALWAYS_INLINE void* Pop() {$/;"	f	class:WTF::TCMalloc_ThreadCache_FreeList	access:public	signature:()
PopDirectionalFormat	.\unicode\glib\UnicodeGLib.h	/^    PopDirectionalFormat,$/;"	e	enum:WTF::Unicode::Direction
PopDirectionalFormat	.\unicode\icu\UnicodeIcu.h	/^    PopDirectionalFormat = U_POP_DIRECTIONAL_FORMAT,$/;"	e	enum:WTF::Unicode::Direction
PopDirectionalFormat	.\unicode\qt4\UnicodeQt4.h	/^    PopDirectionalFormat = QChar::DirPDF,$/;"	e	enum:WTF::Unicode::Direction
PopDirectionalFormat	.\unicode\wince\UnicodeWinCE.h	/^    PopDirectionalFormat = UnicodeCE::U_POP_DIRECTIONAL_FORMAT,$/;"	e	enum:WTF::Unicode::Direction
PopRange	.\FastMalloc.cpp	/^  void PopRange(int N, void **start, void **end) {$/;"	f	class:WTF::TCMalloc_ThreadCache_FreeList	access:public	signature:(int N, void **start, void **end)
Populate	.\FastMalloc.cpp	/^  ALWAYS_INLINE void Populate();$/;"	p	class:WTF::TCMalloc_Central_FreeList	file:	access:private	signature:()
Populate	.\FastMalloc.cpp	/^ALWAYS_INLINE void TCMalloc_Central_FreeList::Populate() {$/;"	f	class:WTF::TCMalloc_Central_FreeList	signature:()
Port	.\url\src\URLSegments.h	/^        Port,$/;"	e	enum:WTF::URLSegments::ComponentType
PossiblyNull	.\PossiblyNull.h	/^    PossiblyNull(T data)$/;"	f	struct:WTF::PossiblyNull	access:public	signature:(T data)
PossiblyNull	.\PossiblyNull.h	/^    PossiblyNull(const PossiblyNull<T>& source)$/;"	f	struct:WTF::PossiblyNull	access:public	signature:(const PossiblyNull<T>& source)
PossiblyNull	.\PossiblyNull.h	/^template <typename T> struct PossiblyNull {$/;"	s	namespace:WTF
PossiblyNull_h	.\PossiblyNull.h	27;"	d
PowersOfTenCache	.\dtoa\cached-powers.h	/^    class PowersOfTenCache {$/;"	c	namespace:WTF::double_conversion
PreallocateMoreMemory	.\TCPageMap.h	/^  void PreallocateMoreMemory() {$/;"	f	class:TCMalloc_PageMap2	access:public	signature:()
PreallocateMoreMemory	.\TCPageMap.h	/^  void PreallocateMoreMemory() {$/;"	f	class:TCMalloc_PageMap3	access:public	signature:()
PreallocateMoreMemory	.\TCPageMap.h	/^  void PreallocateMoreMemory() {}$/;"	f	class:TCMalloc_PageMap1	access:public	signature:()
Print	.\FastMalloc.cpp	/^  void Print() const;$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:() const
Print	.\FastMalloc.cpp	/^void TCMalloc_ThreadCache::Print() const {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:() const
PrintStats	.\FastMalloc.cpp	/^static void PrintStats(int level) {$/;"	f	namespace:WTF	file:	signature:(int level)
Properties	.\unicode\qt4\UnicodeQt4.h	/^    struct Properties {$/;"	s	namespace:QUnicodeTables
PtrHash	.\HashFunctions.h	/^    template<typename P> struct PtrHash<RefPtr<P> > : PtrHash<P*> {$/;"	s	namespace:WTF	inherits:PtrHash
PtrHash	.\HashFunctions.h	/^    template<typename T> struct PtrHash {$/;"	s	namespace:WTF
PtrHash	.\RetainPtr.h	/^    template<typename P> struct PtrHash<RetainPtr<P> > : PtrHash<typename RetainPtr<P>::PtrType> {$/;"	s	namespace:WTF	inherits:PtrHash
PtrType	.\OwnArrayPtr.h	/^    typedef T* PtrType;$/;"	t	class:WTF::OwnArrayPtr	access:public
PtrType	.\OwnPtr.h	/^        typedef ValueType* PtrType;$/;"	t	class:WTF::OwnPtr	access:public
PtrType	.\PassOwnArrayPtr.h	/^    typedef T* PtrType;$/;"	t	class:WTF::PassOwnArrayPtr	access:public
PtrType	.\PassOwnPtr.h	/^        typedef ValueType* PtrType;$/;"	t	class:WTF::PassOwnPtr	access:public
PtrType	.\RetainPtr.h	/^        typedef ValueType* PtrType;$/;"	t	class:WTF::RetainPtr	access:public
Punctuation_Close	.\unicode\glib\UnicodeGLib.h	/^    Punctuation_Close = U_MASK(G_UNICODE_CLOSE_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
Punctuation_Close	.\unicode\icu\UnicodeIcu.h	/^    Punctuation_Close = U_MASK(U_END_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
Punctuation_Close	.\unicode\qt4\UnicodeQt4.h	/^    Punctuation_Close = U_MASK(QChar::Punctuation_Close),$/;"	e	enum:WTF::Unicode::CharCategory
Punctuation_Close	.\unicode\wince\UnicodeWinCE.h	/^    Punctuation_Close = TO_MASK(UnicodeCE::U_END_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
Punctuation_Connector	.\unicode\glib\UnicodeGLib.h	/^    Punctuation_Connector = U_MASK(G_UNICODE_CONNECT_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
Punctuation_Connector	.\unicode\icu\UnicodeIcu.h	/^    Punctuation_Connector = U_MASK(U_CONNECTOR_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
Punctuation_Connector	.\unicode\qt4\UnicodeQt4.h	/^    Punctuation_Connector = U_MASK(QChar::Punctuation_Connector),$/;"	e	enum:WTF::Unicode::CharCategory
Punctuation_Connector	.\unicode\wince\UnicodeWinCE.h	/^    Punctuation_Connector = TO_MASK(UnicodeCE::U_CONNECTOR_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
Punctuation_Dash	.\unicode\glib\UnicodeGLib.h	/^    Punctuation_Dash = U_MASK(G_UNICODE_DASH_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
Punctuation_Dash	.\unicode\icu\UnicodeIcu.h	/^    Punctuation_Dash = U_MASK(U_DASH_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
Punctuation_Dash	.\unicode\qt4\UnicodeQt4.h	/^    Punctuation_Dash = U_MASK(QChar::Punctuation_Dash),$/;"	e	enum:WTF::Unicode::CharCategory
Punctuation_Dash	.\unicode\wince\UnicodeWinCE.h	/^    Punctuation_Dash = TO_MASK(UnicodeCE::U_DASH_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
Punctuation_FinalQuote	.\unicode\glib\UnicodeGLib.h	/^    Punctuation_FinalQuote = U_MASK(G_UNICODE_FINAL_PUNCTUATION)$/;"	e	enum:WTF::Unicode::CharCategory
Punctuation_FinalQuote	.\unicode\icu\UnicodeIcu.h	/^    Punctuation_FinalQuote = U_MASK(U_FINAL_PUNCTUATION)$/;"	e	enum:WTF::Unicode::CharCategory
Punctuation_FinalQuote	.\unicode\qt4\UnicodeQt4.h	/^    Punctuation_FinalQuote = U_MASK(QChar::Punctuation_FinalQuote),$/;"	e	enum:WTF::Unicode::CharCategory
Punctuation_FinalQuote	.\unicode\wince\UnicodeWinCE.h	/^    Punctuation_FinalQuote = TO_MASK(UnicodeCE::U_FINAL_PUNCTUATION)$/;"	e	enum:WTF::Unicode::CharCategory
Punctuation_InitialQuote	.\unicode\glib\UnicodeGLib.h	/^    Punctuation_InitialQuote = U_MASK(G_UNICODE_INITIAL_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
Punctuation_InitialQuote	.\unicode\icu\UnicodeIcu.h	/^    Punctuation_InitialQuote = U_MASK(U_INITIAL_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
Punctuation_InitialQuote	.\unicode\qt4\UnicodeQt4.h	/^    Punctuation_InitialQuote = U_MASK(QChar::Punctuation_InitialQuote),$/;"	e	enum:WTF::Unicode::CharCategory
Punctuation_InitialQuote	.\unicode\wince\UnicodeWinCE.h	/^    Punctuation_InitialQuote = TO_MASK(UnicodeCE::U_INITIAL_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
Punctuation_Open	.\unicode\glib\UnicodeGLib.h	/^    Punctuation_Open = U_MASK(G_UNICODE_OPEN_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
Punctuation_Open	.\unicode\icu\UnicodeIcu.h	/^    Punctuation_Open = U_MASK(U_START_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
Punctuation_Open	.\unicode\qt4\UnicodeQt4.h	/^    Punctuation_Open = U_MASK(QChar::Punctuation_Open),$/;"	e	enum:WTF::Unicode::CharCategory
Punctuation_Open	.\unicode\wince\UnicodeWinCE.h	/^    Punctuation_Open = TO_MASK(UnicodeCE::U_START_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
Punctuation_Other	.\unicode\glib\UnicodeGLib.h	/^    Punctuation_Other = U_MASK(G_UNICODE_OTHER_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
Punctuation_Other	.\unicode\icu\UnicodeIcu.h	/^    Punctuation_Other = U_MASK(U_OTHER_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
Punctuation_Other	.\unicode\qt4\UnicodeQt4.h	/^    Punctuation_Other = U_MASK(QChar::Punctuation_Other),$/;"	e	enum:WTF::Unicode::CharCategory
Punctuation_Other	.\unicode\wince\UnicodeWinCE.h	/^    Punctuation_Other = TO_MASK(UnicodeCE::U_OTHER_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
Push	.\FastMalloc.cpp	/^  ALWAYS_INLINE void Push(void* ptr) {$/;"	f	class:WTF::TCMalloc_ThreadCache_FreeList	access:public	signature:(void* ptr)
PushRange	.\FastMalloc.cpp	/^  void PushRange(int N, void *start, void *end) {$/;"	f	class:WTF::TCMalloc_ThreadCache_FreeList	access:public	signature:(int N, void *start, void *end)
Put	.\TCPackedCache.h	/^  void Put(K key, V value) {$/;"	f	class:PackedCache	access:public	signature:(K key, V value)
QGuiApplication	.\qt\compat\qguiapplication.h	/^struct QGuiApplication : public QApplication$/;"	s	inherits:QApplication
QGuiApplication::styleHints	.\qt\compat\qguiapplication.h	/^    static QApplication* styleHints()$/;"	f	struct:QGuiApplication	access:public	signature:()
QUnicodeTables	.\unicode\qt4\UnicodeQt4.h	/^namespace QUnicodeTables {$/;"	n
QUnicodeTables::Properties	.\unicode\qt4\UnicodeQt4.h	/^    struct Properties {$/;"	s	namespace:QUnicodeTables
QUnicodeTables::Properties::caseFoldDiff	.\unicode\qt4\UnicodeQt4.h	/^        signed short caseFoldDiff : 16;$/;"	m	struct:QUnicodeTables::Properties	access:public
QUnicodeTables::Properties::caseFoldSpecial	.\unicode\qt4\UnicodeQt4.h	/^        ushort caseFoldSpecial : 1; \/* currently unused *\/$/;"	m	struct:QUnicodeTables::Properties	access:public
QUnicodeTables::Properties::category	.\unicode\qt4\UnicodeQt4.h	/^        ushort category : 8;$/;"	m	struct:QUnicodeTables::Properties	access:public
QUnicodeTables::Properties::combiningClass	.\unicode\qt4\UnicodeQt4.h	/^        ushort combiningClass :8;$/;"	m	struct:QUnicodeTables::Properties	access:public
QUnicodeTables::Properties::digitValue	.\unicode\qt4\UnicodeQt4.h	/^        signed short digitValue : 6; \/* 5 needed *\/$/;"	m	struct:QUnicodeTables::Properties	access:public
QUnicodeTables::Properties::direction	.\unicode\qt4\UnicodeQt4.h	/^        ushort direction : 8;$/;"	m	struct:QUnicodeTables::Properties	access:public
QUnicodeTables::Properties::joining	.\unicode\qt4\UnicodeQt4.h	/^        ushort joining : 2;$/;"	m	struct:QUnicodeTables::Properties	access:public
QUnicodeTables::Properties::line_break_class	.\unicode\qt4\UnicodeQt4.h	/^        ushort line_break_class : 8;$/;"	m	struct:QUnicodeTables::Properties	access:public
QUnicodeTables::Properties::lowerCaseDiff	.\unicode\qt4\UnicodeQt4.h	/^        signed short lowerCaseDiff : 16;$/;"	m	struct:QUnicodeTables::Properties	access:public
QUnicodeTables::Properties::lowerCaseSpecial	.\unicode\qt4\UnicodeQt4.h	/^        ushort lowerCaseSpecial : 1;$/;"	m	struct:QUnicodeTables::Properties	access:public
QUnicodeTables::Properties::mirrorDiff	.\unicode\qt4\UnicodeQt4.h	/^        signed short mirrorDiff : 16;$/;"	m	struct:QUnicodeTables::Properties	access:public
QUnicodeTables::Properties::titleCaseDiff	.\unicode\qt4\UnicodeQt4.h	/^        signed short titleCaseDiff : 16;$/;"	m	struct:QUnicodeTables::Properties	access:public
QUnicodeTables::Properties::titleCaseSpecial	.\unicode\qt4\UnicodeQt4.h	/^        ushort titleCaseSpecial : 1;$/;"	m	struct:QUnicodeTables::Properties	access:public
QUnicodeTables::Properties::unicodeVersion	.\unicode\qt4\UnicodeQt4.h	/^        ushort unicodeVersion : 4;$/;"	m	struct:QUnicodeTables::Properties	access:public
QUnicodeTables::Properties::upperCaseDiff	.\unicode\qt4\UnicodeQt4.h	/^        signed short upperCaseDiff : 16;$/;"	m	struct:QUnicodeTables::Properties	access:public
QUnicodeTables::Properties::upperCaseSpecial	.\unicode\qt4\UnicodeQt4.h	/^        ushort upperCaseSpecial : 1;$/;"	m	struct:QUnicodeTables::Properties	access:public
QUnicodeTables::properties	.\unicode\qt4\UnicodeQt4.h	/^    Q_CORE_EXPORT const Properties * QT_FASTCALL properties(uint ucs4);$/;"	p	namespace:QUnicodeTables	signature:(uint ucs4)
QUnicodeTables::properties	.\unicode\qt4\UnicodeQt4.h	/^    Q_CORE_EXPORT const Properties * QT_FASTCALL properties(ushort ucs2);$/;"	p	namespace:QUnicodeTables	signature:(ushort ucs2)
Query	.\url\src\URLSegments.h	/^        Query,$/;"	e	enum:WTF::URLSegments::ComponentType
QueryCharacter	.\url\src\URLCharacterTypes.h	/^        QueryCharacter = 1 << 0,$/;"	e	enum:WTF::URLCharacterTypes::CharTypes
Quick_max	.\dtoa.cpp	148;"	d	file:
R	.\Functional.h	/^    explicit FunctionWrapper(R (C::*function)())$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(C::*function)
R	.\Functional.h	/^    explicit FunctionWrapper(R (C::*function)(P1))$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(C::*function)
R	.\Functional.h	/^    explicit FunctionWrapper(R (C::*function)(P1, P2))$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(C::*function)
R	.\Functional.h	/^    explicit FunctionWrapper(R (C::*function)(P1, P2, P3))$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(C::*function)
R	.\Functional.h	/^    explicit FunctionWrapper(R (C::*function)(P1, P2, P3, P4))$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(C::*function)
R	.\Functional.h	/^    explicit FunctionWrapper(R (C::*function)(P1, P2, P3, P4, P5))$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(C::*function)
REF_DEREF_INLINE	.\PassRefPtr.h	36;"	d
REF_DEREF_INLINE	.\PassRefPtr.h	40;"	d
REF_DEREF_INLINE	.\PassRefPtr.h	55;"	d
ROOT_BITS	.\TCPageMap.h	/^  static const int ROOT_BITS = 5;$/;"	m	class:TCMalloc_PageMap2	access:private
ROOT_LENGTH	.\TCPageMap.h	/^  static const int ROOT_LENGTH = 1 << ROOT_BITS;$/;"	m	class:TCMalloc_PageMap2	access:private
RVCT_VERSION_AT_LEAST	.\Compiler.h	79;"	d
RVCT_VERSION_AT_LEAST	.\Compiler.h	82;"	d
RadixStringToDouble	.\dtoa\double-conversion.cc	/^    static double RadixStringToDouble(const char* current,$/;"	f	namespace:WTF::double_conversion	file:	signature:(const char* current, const char* end, bool sign, bool allow_trailing_junk, double junk_string_value, const char** trailing_pointer)
RawKeyType	.\RefPtrHashMap.h	/^        typedef T* RawKeyType;$/;"	t	class:WTF::HashMap	access:public
RawURLBuffer	.\url\src\RawURLBuffer.h	/^    RawURLBuffer() : URLBuffer<CharacterType>()$/;"	f	class:WTF::RawURLBuffer	access:public	signature:()
RawURLBuffer	.\url\src\RawURLBuffer.h	/^class RawURLBuffer : public URLBuffer<CharacterType> {$/;"	c	namespace:WTF	inherits:URLBuffer
RawURLBuffer_h	.\url\src\RawURLBuffer.h	30;"	d
ReadDiyFp	.\dtoa\strtod.cc	/^    static void ReadDiyFp(Vector<const char> buffer,$/;"	f	namespace:WTF::double_conversion	file:	signature:(Vector<const char> buffer, DiyFp* result, int* remaining_decimals)
ReadStackTraces	.\FastMalloc.cpp	/^  virtual void** ReadStackTraces() {$/;"	f	class:WTF::TCMallocImplementation	access:public	signature:()
ReadUInt64	.\dtoa\bignum.cc	/^    static uint64_t ReadUInt64(Vector<const char> buffer,$/;"	f	namespace:WTF::double_conversion	file:	signature:(Vector<const char> buffer, int from, int digits_to_read)
ReadUint64	.\dtoa\strtod.cc	/^    static uint64_t ReadUint64(Vector<const char> buffer,$/;"	f	namespace:WTF::double_conversion	file:	signature:(Vector<const char> buffer, int* number_of_read_digits)
ReadWriteLock	.\ThreadingPrimitives.h	/^    ReadWriteLock();$/;"	p	class:WTF::ReadWriteLock	access:public	signature:()
ReadWriteLock	.\ThreadingPrimitives.h	/^class ReadWriteLock {$/;"	c	namespace:WTF
ReadWriteLock	.\ThreadingPthreads.cpp	/^ReadWriteLock::ReadWriteLock()$/;"	f	class:WTF::ReadWriteLock	signature:()
RecomputeThreadCacheSize	.\FastMalloc.cpp	/^  static void                  RecomputeThreadCacheSize();$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:()
RecomputeThreadCacheSize	.\FastMalloc.cpp	/^void TCMalloc_ThreadCache::RecomputeThreadCacheSize() {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:()
RecordOverflow	.\CheckedArithmetic.h	/^    RecordOverflow()$/;"	f	class:WTF::RecordOverflow	access:protected	signature:()
RecordOverflow	.\CheckedArithmetic.h	/^class RecordOverflow {$/;"	c	namespace:WTF
RecordSpan	.\FastMalloc.cpp	/^  void RecordSpan(Span* span) {$/;"	f	class:WTF::TCMalloc_PageHeap	file:	access:private	signature:(Span* span)
Red	.\RedBlackTree.h	/^        Red = 1,$/;"	e	enum:WTF::RedBlackTree::Color
RedBlackTree	.\RedBlackTree.h	/^    RedBlackTree()$/;"	f	class:WTF::RedBlackTree	access:public	signature:()
RedBlackTree	.\RedBlackTree.h	/^class RedBlackTree {$/;"	c	namespace:WTF
RedBlackTree_h	.\RedBlackTree.h	30;"	d
RefAndDeref	.\Functional.h	/^template<typename T, bool shouldRefAndDeref> struct RefAndDeref {$/;"	s	namespace:WTF
RefAndDeref	.\Functional.h	/^template<typename T> struct RefAndDeref<T*, true> {$/;"	s	namespace:WTF
RefCounted	.\RefCounted.h	/^    RefCounted() { }$/;"	f	class:WTF::RefCounted	access:protected	signature:()
RefCounted	.\RefCounted.h	/^template<typename T> class RefCounted : public RefCountedBase {$/;"	c	namespace:WTF	inherits:RefCountedBase
RefCountedArray	.\RefCountedArray.h	/^    RefCountedArray()$/;"	f	class:WTF::RefCountedArray	access:public	signature:()
RefCountedArray	.\RefCountedArray.h	/^    RefCountedArray(const RefCountedArray& other)$/;"	f	class:WTF::RefCountedArray	access:public	signature:(const RefCountedArray& other)
RefCountedArray	.\RefCountedArray.h	/^    explicit RefCountedArray(const Vector<T>& other)$/;"	f	class:WTF::RefCountedArray	access:public	signature:(const Vector<T>& other)
RefCountedArray	.\RefCountedArray.h	/^class RefCountedArray {$/;"	c	namespace:WTF
RefCountedArray_h	.\RefCountedArray.h	27;"	d
RefCountedBase	.\RefCounted.h	/^    RefCountedBase()$/;"	f	class:WTF::RefCountedBase	access:protected	signature:()
RefCountedBase	.\RefCounted.h	/^class RefCountedBase {$/;"	c	namespace:WTF
RefCountedCustomAllocated	.\RefCounted.h	/^template<typename T> class RefCountedCustomAllocated : public RefCountedBase {$/;"	c	namespace:WTF	inherits:RefCountedBase
RefCountedCustomAllocated_should_stay_small	.\SizeLimits.cpp	/^COMPILE_ASSERT(sizeof(RefCountedCustomAllocated<int>) == sizeof(SameSizeAsRefCounted), RefCountedCustomAllocated_should_stay_small);$/;"	v
RefCountedLeakCounter	.\RefCountedLeakCounter.cpp	/^RefCountedLeakCounter::RefCountedLeakCounter(const char*) { }$/;"	f	class:WTF::RefCountedLeakCounter	signature:(const char*)
RefCountedLeakCounter	.\RefCountedLeakCounter.h	/^        WTF_EXPORT_PRIVATE explicit RefCountedLeakCounter(const char* description);$/;"	p	struct:WTF::RefCountedLeakCounter	access:public	signature:(const char* description)
RefCountedLeakCounter	.\RefCountedLeakCounter.h	/^    struct RefCountedLeakCounter {$/;"	s	namespace:WTF
RefCountedLeakCounter_h	.\RefCountedLeakCounter.h	22;"	d
RefCounted_h	.\RefCounted.h	22;"	d
RefCounted_should_stay_small	.\SizeLimits.cpp	/^COMPILE_ASSERT(sizeof(RefCounted<int>) == sizeof(SameSizeAsRefCounted), RefCounted_should_stay_small);$/;"	v
RefPtr	.\RefPtr.h	/^        ALWAYS_INLINE RefPtr() : m_ptr(0) { }$/;"	f	class:WTF::RefPtr	access:public	signature:()
RefPtr	.\RefPtr.h	/^        ALWAYS_INLINE RefPtr(PlacementNewAdoptType) { }$/;"	f	class:WTF::RefPtr	access:public	signature:(PlacementNewAdoptType)
RefPtr	.\RefPtr.h	/^        ALWAYS_INLINE RefPtr(T* ptr) : m_ptr(ptr) { refIfNotNull(ptr); }$/;"	f	class:WTF::RefPtr	access:public	signature:(T* ptr)
RefPtr	.\RefPtr.h	/^        ALWAYS_INLINE RefPtr(const RefPtr& o) : m_ptr(o.m_ptr) { refIfNotNull(m_ptr); }$/;"	f	class:WTF::RefPtr	access:public	signature:(const RefPtr& o)
RefPtr	.\RefPtr.h	/^        RefPtr(HashTableDeletedValueType) : m_ptr(hashTableDeletedValue()) { }$/;"	f	class:WTF::RefPtr	access:public	signature:(HashTableDeletedValueType)
RefPtr	.\RefPtr.h	/^        template<typename U> RefPtr(const NonNullPassRefPtr<U>&);$/;"	p	class:WTF::RefPtr	access:public	signature:(const NonNullPassRefPtr<U>&)
RefPtr	.\RefPtr.h	/^        template<typename U> RefPtr(const PassRefPtr<U>&);$/;"	p	class:WTF::RefPtr	access:public	signature:(const PassRefPtr<U>&)
RefPtr	.\RefPtr.h	/^        template<typename U> RefPtr(const RefPtr<U>& o) : m_ptr(o.get()) { refIfNotNull(m_ptr); }$/;"	f	class:WTF::RefPtr	access:public	signature:(const RefPtr<U>& o)
RefPtr	.\RefPtr.h	/^    template<typename T> class RefPtr {$/;"	c	namespace:WTF
RefPtr	.\RefPtr.h	/^    template<typename T> template<typename U> inline RefPtr<T>::RefPtr(const NonNullPassRefPtr<U>& o)$/;"	f	class:WTF::RefPtr	signature:(const NonNullPassRefPtr<U>& o)
RefPtr	.\RefPtr.h	/^    template<typename T> template<typename U> inline RefPtr<T>::RefPtr(const PassRefPtr<U>& o)$/;"	f	class:WTF::RefPtr	signature:(const PassRefPtr<U>& o)
RefPtrHashMap_h	.\RefPtrHashMap.h	22;"	d
RefPtr_should_stay_small	.\SizeLimits.cpp	/^COMPILE_ASSERT(sizeof(RefPtr<RefCounted<int> >) == sizeof(int*), RefPtr_should_stay_small);$/;"	v
ReferenceType	.\HashMap.h	/^        typedef T& ReferenceType;$/;"	t	struct:WTF::ReferenceTypeMaker	access:public
ReferenceType	.\HashTable.h	/^        typedef ValueType& ReferenceType;$/;"	t	class:WTF::HashTableIterator	access:private
ReferenceType	.\HashTable.h	/^        typedef const ValueType& ReferenceType;$/;"	t	class:WTF::HashTableConstIterator	access:private
ReferenceType	.\ListHashSet.h	/^        typedef ValueType& ReferenceType;$/;"	t	class:WTF::ListHashSetIterator	access:private
ReferenceType	.\ListHashSet.h	/^        typedef ValueType& ReferenceType;$/;"	t	class:WTF::ListHashSetReverseIterator	access:private
ReferenceType	.\ListHashSet.h	/^        typedef const ValueType& ReferenceType;$/;"	t	class:WTF::ListHashSetConstIterator	access:private
ReferenceType	.\ListHashSet.h	/^        typedef const ValueType& ReferenceType;$/;"	t	class:WTF::ListHashSetConstReverseIterator	access:private
ReferenceTypeMaker	.\HashMap.h	/^    template<typename T> struct ReferenceTypeMaker {$/;"	s	namespace:WTF
ReferenceTypeMaker	.\HashMap.h	/^    template<typename T> struct ReferenceTypeMaker<T&> {$/;"	s	namespace:WTF
RegisterSizeClass	.\FastMalloc.cpp	/^  void RegisterSizeClass(Span* span, size_t sc);$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:public	signature:(Span* span, size_t sc)
RegisterSizeClass	.\FastMalloc.cpp	/^void TCMalloc_PageHeap::RegisterSizeClass(Span* span, size_t sc) {$/;"	f	class:WTF::TCMalloc_PageHeap	signature:(Span* span, size_t sc)
ReleaseFreeList	.\FastMalloc.cpp	/^  void ReleaseFreeList(Span*, Span*);$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:public	signature:(Span*, Span*)
ReleaseFreeList	.\FastMalloc.cpp	/^void TCMalloc_PageHeap::ReleaseFreeList(Span* list, Span* returned) {$/;"	f	class:WTF::TCMalloc_PageHeap	signature:(Span* list, Span* returned)
ReleaseFreeMemory	.\FastMalloc.cpp	/^  virtual void ReleaseFreeMemory() {$/;"	f	class:WTF::TCMallocImplementation	access:public	signature:()
ReleaseFreePages	.\FastMalloc.cpp	/^  void ReleaseFreePages();$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:public	signature:()
ReleaseFreePages	.\FastMalloc.cpp	/^void TCMalloc_PageHeap::ReleaseFreePages() {$/;"	f	class:WTF::TCMalloc_PageHeap	signature:()
ReleaseListToSpans	.\FastMalloc.cpp	/^  void ReleaseListToSpans(void *start);$/;"	p	class:WTF::TCMalloc_Central_FreeList	file:	access:private	signature:(void *start)
ReleaseListToSpans	.\FastMalloc.cpp	/^void TCMalloc_Central_FreeList::ReleaseListToSpans(void* start) {$/;"	f	class:WTF::TCMalloc_Central_FreeList	signature:(void* start)
ReleaseToCentralCache	.\FastMalloc.cpp	/^  void ReleaseToCentralCache(size_t cl, int N);$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:(size_t cl, int N)
ReleaseToCentralCache	.\FastMalloc.cpp	/^inline void TCMalloc_ThreadCache::ReleaseToCentralCache(size_t cl, int N) {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:(size_t cl, int N)
ReleaseToSpans	.\FastMalloc.cpp	/^  ALWAYS_INLINE void ReleaseToSpans(void* object);$/;"	p	class:WTF::TCMalloc_Central_FreeList	file:	access:private	signature:(void* object)
ReleaseToSpans	.\FastMalloc.cpp	/^ALWAYS_INLINE void TCMalloc_Central_FreeList::ReleaseToSpans(void* object) {$/;"	f	class:WTF::TCMalloc_Central_FreeList	signature:(void* object)
RemoteMemoryReader	.\MallocZoneSupport.h	/^    RemoteMemoryReader(task_t task, memory_reader_t* reader)$/;"	f	class:WTF::RemoteMemoryReader	access:public	signature:(task_t task, memory_reader_t* reader)
RemoteMemoryReader	.\MallocZoneSupport.h	/^class RemoteMemoryReader {$/;"	c	namespace:WTF
RemoveChecked	.\CheckedArithmetic.h	/^template <typename T> struct RemoveChecked {$/;"	s	namespace:WTF
RemoveChecked	.\CheckedArithmetic.h	/^template <typename T> struct RemoveChecked<Checked<T, CrashOnOverflow> > {$/;"	s	namespace:WTF
RemoveChecked	.\CheckedArithmetic.h	/^template <typename T> struct RemoveChecked<Checked<T, RecordOverflow> > {$/;"	s	namespace:WTF
RemoveConst	.\TypeTraits.h	/^    template <typename T> struct RemoveConst {$/;"	s	namespace:WTF
RemoveConst	.\TypeTraits.h	/^    template <typename T> struct RemoveConst<const T> {$/;"	s	namespace:WTF
RemoveConstVolatile	.\TypeTraits.h	/^    template <typename T> struct RemoveConstVolatile {$/;"	s	namespace:WTF
RemoveExtent	.\TypeTraits.h	/^    template <typename T, size_t N> struct RemoveExtent<T[N]> {$/;"	s	namespace:WTF
RemoveExtent	.\TypeTraits.h	/^    template <typename T> struct RemoveExtent {$/;"	s	namespace:WTF
RemoveExtent	.\TypeTraits.h	/^    template <typename T> struct RemoveExtent<T[]> {$/;"	s	namespace:WTF
RemovePointer	.\TypeTraits.h	/^    template <typename T> struct RemovePointer {$/;"	s	namespace:WTF
RemovePointer	.\TypeTraits.h	/^    template <typename T> struct RemovePointer<T*> {$/;"	s	namespace:WTF
RemoveRange	.\FastMalloc.cpp	/^  void RemoveRange(void **start, void **end, int *N);$/;"	p	class:WTF::TCMalloc_Central_FreeList	file:	access:public	signature:(void **start, void **end, int *N)
RemoveRange	.\FastMalloc.cpp	/^void TCMalloc_Central_FreeList::RemoveRange(void **start, void **end, int *N) {$/;"	f	class:WTF::TCMalloc_Central_FreeList	signature:(void **start, void **end, int *N)
RemoveReference	.\TypeTraits.h	/^    template <typename T> struct RemoveReference {$/;"	s	namespace:WTF
RemoveReference	.\TypeTraits.h	/^    template <typename T> struct RemoveReference<T&> {$/;"	s	namespace:WTF
RemoveTemplate	.\TypeTraits.h	/^    template <typename T, template <class V> class OuterTemplate> struct RemoveTemplate {$/;"	s	namespace:WTF
RemoveTemplate	.\TypeTraits.h	/^    template <typename T, template <class V> class OuterTemplate> struct RemoveTemplate<OuterTemplate<T>, OuterTemplate> {$/;"	s	namespace:WTF
RemoveVolatile	.\TypeTraits.h	/^    template <typename T> struct RemoveVolatile {$/;"	s	namespace:WTF
RemoveVolatile	.\TypeTraits.h	/^    template <typename T> struct RemoveVolatile<volatile T> {$/;"	s	namespace:WTF
Reset	.\dtoa\utils.h	/^        void Reset() { position_ = 0; }$/;"	f	class:WTF::double_conversion::StringBuilder	access:public	signature:()
Result	.\CheckedArithmetic.h	/^template <typename U, typename V> struct Result : ResultBase<typename RemoveChecked<U>::CleanType, typename RemoveChecked<V>::CleanType> {$/;"	s	namespace:WTF	inherits:ResultBase
Result	.\unicode\Collator.h	/^        enum Result { Equal = 0, Greater = 1, Less = -1 };$/;"	g	class:WTF::Collator	access:public
ResultBase	.\CheckedArithmetic.h	/^template <typename U, typename V> struct ResultBase<U, V, false, false> {$/;"	s	namespace:WTF
ResultBase	.\CheckedArithmetic.h	/^template <typename U, typename V> struct ResultBase<U, V, false, true> {$/;"	s	namespace:WTF
ResultBase	.\CheckedArithmetic.h	/^template <typename U, typename V> struct ResultBase<U, V, true, false> {$/;"	s	namespace:WTF
ResultBase	.\CheckedArithmetic.h	/^template <typename U> struct ResultBase<U, U, false, true> {$/;"	s	namespace:WTF
ResultOverflowed	.\CheckedArithmetic.h	/^enum ResultOverflowedTag { ResultOverflowed };$/;"	e	enum:WTF::ResultOverflowedTag
ResultOverflowedTag	.\CheckedArithmetic.h	/^enum ResultOverflowedTag { ResultOverflowed };$/;"	g	namespace:WTF
ResultType	.\CheckedArithmetic.h	/^    typedef U ResultType;$/;"	t	struct:WTF::ResultBase	access:public
ResultType	.\CheckedArithmetic.h	/^    typedef U ResultType;$/;"	t	struct:WTF::SignednessSelector	access:public
ResultType	.\CheckedArithmetic.h	/^    typedef V ResultType;$/;"	t	struct:WTF::ResultBase	access:public
ResultType	.\CheckedArithmetic.h	/^    typedef V ResultType;$/;"	t	struct:WTF::SignednessSelector	access:public
ResultType	.\CheckedArithmetic.h	/^    typedef typename SignednessSelector<U, V>::ResultType ResultType;$/;"	t	struct:WTF::ResultBase	access:public
ResultType	.\Functional.h	/^    typedef R ResultType;$/;"	t	class:WTF::FunctionWrapper	access:public
RetainPtr	.\RetainPtr.h	/^        RetainPtr() : m_ptr(0) {}$/;"	f	class:WTF::RetainPtr	access:public	signature:()
RetainPtr	.\RetainPtr.h	/^        RetainPtr(AdoptCFTag, PtrType ptr) : m_ptr(ptr) { }$/;"	f	class:WTF::RetainPtr	access:public	signature:(AdoptCFTag, PtrType ptr)
RetainPtr	.\RetainPtr.h	/^        RetainPtr(AdoptNSTag, PtrType ptr) : m_ptr(ptr) { adoptNSReference(ptr); }$/;"	f	class:WTF::RetainPtr	access:public	signature:(AdoptNSTag, PtrType ptr)
RetainPtr	.\RetainPtr.h	/^        RetainPtr(HashTableDeletedValueType) : m_ptr(hashTableDeletedValue()) { }$/;"	f	class:WTF::RetainPtr	access:public	signature:(HashTableDeletedValueType)
RetainPtr	.\RetainPtr.h	/^        RetainPtr(PtrType ptr) : m_ptr(ptr) { if (ptr) CFRetain(ptr); }$/;"	f	class:WTF::RetainPtr	access:public	signature:(PtrType ptr)
RetainPtr	.\RetainPtr.h	/^        RetainPtr(RetainPtr&& o) : m_ptr(o.leakRef()) { }$/;"	f	class:WTF::RetainPtr	access:public	signature:(RetainPtr&& o)
RetainPtr	.\RetainPtr.h	/^        RetainPtr(const RetainPtr& o) : m_ptr(o.m_ptr) { if (PtrType ptr = m_ptr) CFRetain(ptr); }$/;"	f	class:WTF::RetainPtr	access:public	signature:(const RetainPtr& o)
RetainPtr	.\RetainPtr.h	/^        template<typename U> RetainPtr(const RetainPtr<U>&);$/;"	p	class:WTF::RetainPtr	access:public	signature:(const RetainPtr<U>&)
RetainPtr	.\RetainPtr.h	/^    template<typename T> class RetainPtr {$/;"	c	namespace:WTF
RetainPtr	.\RetainPtr.h	/^    template<typename T> template<typename U> inline RetainPtr<T>::RetainPtr(const RetainPtr<U>& o)$/;"	f	class:WTF::RetainPtr	signature:(const RetainPtr<U>& o)
RetainPtr_h	.\RetainPtr.h	22;"	d
ReturnedBytes	.\FastMalloc.cpp	/^  size_t ReturnedBytes() const;$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:public	signature:() const
ReturnedBytes	.\FastMalloc.cpp	/^size_t TCMalloc_PageHeap::ReturnedBytes() const {$/;"	f	class:WTF::TCMalloc_PageHeap	signature:() const
RightToLeft	.\unicode\glib\UnicodeGLib.h	/^    RightToLeft,$/;"	e	enum:WTF::Unicode::Direction
RightToLeft	.\unicode\icu\UnicodeIcu.h	/^    RightToLeft = U_RIGHT_TO_LEFT,$/;"	e	enum:WTF::Unicode::Direction
RightToLeft	.\unicode\qt4\UnicodeQt4.h	/^    RightToLeft = QChar::DirR,$/;"	e	enum:WTF::Unicode::Direction
RightToLeft	.\unicode\wince\UnicodeWinCE.h	/^    RightToLeft = UnicodeCE::U_RIGHT_TO_LEFT,$/;"	e	enum:WTF::Unicode::Direction
RightToLeftArabic	.\unicode\glib\UnicodeGLib.h	/^    RightToLeftArabic,$/;"	e	enum:WTF::Unicode::Direction
RightToLeftArabic	.\unicode\icu\UnicodeIcu.h	/^    RightToLeftArabic = U_RIGHT_TO_LEFT_ARABIC,$/;"	e	enum:WTF::Unicode::Direction
RightToLeftArabic	.\unicode\qt4\UnicodeQt4.h	/^    RightToLeftArabic = QChar::DirAL,$/;"	e	enum:WTF::Unicode::Direction
RightToLeftArabic	.\unicode\wince\UnicodeWinCE.h	/^    RightToLeftArabic = UnicodeCE::U_RIGHT_TO_LEFT_ARABIC,$/;"	e	enum:WTF::Unicode::Direction
RightToLeftEmbedding	.\unicode\glib\UnicodeGLib.h	/^    RightToLeftEmbedding,$/;"	e	enum:WTF::Unicode::Direction
RightToLeftEmbedding	.\unicode\icu\UnicodeIcu.h	/^    RightToLeftEmbedding = U_RIGHT_TO_LEFT_EMBEDDING,$/;"	e	enum:WTF::Unicode::Direction
RightToLeftEmbedding	.\unicode\qt4\UnicodeQt4.h	/^    RightToLeftEmbedding = QChar::DirRLE,$/;"	e	enum:WTF::Unicode::Direction
RightToLeftEmbedding	.\unicode\wince\UnicodeWinCE.h	/^    RightToLeftEmbedding = UnicodeCE::U_RIGHT_TO_LEFT_EMBEDDING,$/;"	e	enum:WTF::Unicode::Direction
RightToLeftOverride	.\unicode\glib\UnicodeGLib.h	/^    RightToLeftOverride,$/;"	e	enum:WTF::Unicode::Direction
RightToLeftOverride	.\unicode\icu\UnicodeIcu.h	/^    RightToLeftOverride = U_RIGHT_TO_LEFT_OVERRIDE,$/;"	e	enum:WTF::Unicode::Direction
RightToLeftOverride	.\unicode\qt4\UnicodeQt4.h	/^    RightToLeftOverride = QChar::DirRLO,$/;"	e	enum:WTF::Unicode::Direction
RightToLeftOverride	.\unicode\wince\UnicodeWinCE.h	/^    RightToLeftOverride = UnicodeCE::U_RIGHT_TO_LEFT_OVERRIDE,$/;"	e	enum:WTF::Unicode::Direction
RoundUp	.\dtoa\fixed-dtoa.cc	/^    static void RoundUp(Vector<char> buffer, int* length, int* decimal_point) {$/;"	f	namespace:WTF::double_conversion	file:	signature:(Vector<char> buffer, int* length, int* decimal_point)
RoundWeed	.\dtoa\fast-dtoa.cc	/^    static bool RoundWeed(Vector<char> buffer,$/;"	f	namespace:WTF::double_conversion	file:	signature:(Vector<char> buffer, int length, uint64_t distance_too_high_w, uint64_t unsafe_interval, uint64_t rest, uint64_t ten_kappa, uint64_t unit)
RoundWeedCounted	.\dtoa\fast-dtoa.cc	/^    static bool RoundWeedCounted(Vector<char> buffer,$/;"	f	namespace:WTF::double_conversion	file:	signature:(Vector<char> buffer, int length, uint64_t rest, uint64_t ten_kappa, uint64_t unit, int* kappa)
RoundingDecimalPlaces	.\DecimalNumber.h	/^enum RoundingDecimalPlacesType { RoundingDecimalPlaces };$/;"	e	enum:WTF::RoundingDecimalPlacesType
RoundingDecimalPlacesType	.\DecimalNumber.h	/^enum RoundingDecimalPlacesType { RoundingDecimalPlaces };$/;"	g	namespace:WTF
RoundingSignificantFigures	.\DecimalNumber.h	/^enum RoundingSignificantFiguresType { RoundingSignificantFigures };$/;"	e	enum:WTF::RoundingSignificantFiguresType
RoundingSignificantFiguresType	.\DecimalNumber.h	/^enum RoundingSignificantFiguresType { RoundingSignificantFigures };$/;"	g	namespace:WTF
SHA1	.\SHA1.cpp	/^SHA1::SHA1()$/;"	f	class:WTF::SHA1	signature:()
SHA1	.\SHA1.h	/^    WTF_EXPORT_PRIVATE SHA1();$/;"	p	class:WTF::SHA1	access:public	signature:()
SHA1	.\SHA1.h	/^class SHA1 {$/;"	c	namespace:WTF
SHORTEST	.\dtoa\double-conversion.h	/^            SHORTEST,$/;"	e	enum:WTF::double_conversion::DoubleToStringConverter::DtoaMode
SLL_Next	.\FastMalloc.cpp	/^static inline void *SLL_Next(void *t) {$/;"	f	namespace:WTF	file:	signature:(void *t)
SLL_Pop	.\FastMalloc.cpp	/^static inline void *SLL_Pop(void **list) {$/;"	f	namespace:WTF	file:	signature:(void **list)
SLL_PopRange	.\FastMalloc.cpp	/^static inline void SLL_PopRange(void **head, int N, void **start, void **end) {$/;"	f	namespace:WTF	file:	signature:(void **head, int N, void **start, void **end)
SLL_Push	.\FastMalloc.cpp	/^static inline void SLL_Push(void **list, void *element) {$/;"	f	namespace:WTF	file:	signature:(void **list, void *element)
SLL_PushRange	.\FastMalloc.cpp	/^static inline void SLL_PushRange(void **head, void *start, void *end) {$/;"	f	namespace:WTF	file:	signature:(void **head, void *start, void *end)
SLL_SetNext	.\FastMalloc.cpp	/^static inline void SLL_SetNext(void *t, void *n) {$/;"	f	namespace:WTF	file:	signature:(void *t, void *n)
SLL_Size	.\FastMalloc.cpp	/^static inline size_t SLL_Size(void *head) {$/;"	f	namespace:WTF	file:	signature:(void *head)
SPAN_HISTORY	.\FastMalloc.cpp	1124;"	d	file:
SPINLOCK_INITIALIZER	.\TCSpinLock.h	136;"	d
SPINLOCK_INITIALIZER	.\TCSpinLock.h	230;"	d
SPINLOCK_INITIALIZER	.\TCSpinLock.h	267;"	d
STRINGIZE	.\StdLibExtras.h	71;"	d
STRINGIZE_VALUE_OF	.\StdLibExtras.h	72;"	d
SYMBOL_STRING	.\InlineASM.h	34;"	d
SYMBOL_STRING	.\InlineASM.h	36;"	d
SYMBOL_STRING_RELOCATION	.\InlineASM.h	46;"	d
SYMBOL_STRING_RELOCATION	.\InlineASM.h	48;"	d
SYMBOL_STRING_RELOCATION	.\InlineASM.h	50;"	d
SYMBOL_STRING_RELOCATION	.\InlineASM.h	52;"	d
SameSizeAsRefCounted	.\SizeLimits.cpp	/^struct SameSizeAsRefCounted {$/;"	s	namespace:WTF	file:
SampleAllocation	.\FastMalloc.cpp	/^  bool SampleAllocation(size_t k);$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:(size_t k)
SampleAllocation	.\FastMalloc.cpp	/^inline bool TCMalloc_ThreadCache::SampleAllocation(size_t k) {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:(size_t k)
Scale_Bit	.\dtoa.cpp	648;"	d	file:
Scavenge	.\FastMalloc.cpp	/^  void Scavenge();$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:()
Scavenge	.\FastMalloc.cpp	/^inline void TCMalloc_ThreadCache::Scavenge() {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:()
Scheme	.\url\src\URLSegments.h	/^        Scheme,$/;"	e	enum:WTF::URLSegments::ComponentType
SearchType	.\AVLTree.h	/^    enum SearchType {$/;"	g	class:WTF::AVLTree	access:public
SecondTraits	.\HashTraits.h	/^        typedef SecondTraitsArg SecondTraits;$/;"	t	struct:WTF::PairHashTraits	access:public
SecondTraits	.\VectorTraits.h	/^        typedef VectorTraits<Second> SecondTraits;$/;"	t	struct:WTF::VectorTraits	access:public
Segment	.\SegmentedVector.h	/^        typedef Vector<T, SegmentSize> Segment;$/;"	t	class:WTF::SegmentedVector	access:private
SegmentSeparator	.\unicode\glib\UnicodeGLib.h	/^    SegmentSeparator,$/;"	e	enum:WTF::Unicode::Direction
SegmentSeparator	.\unicode\icu\UnicodeIcu.h	/^    SegmentSeparator = U_SEGMENT_SEPARATOR,$/;"	e	enum:WTF::Unicode::Direction
SegmentSeparator	.\unicode\qt4\UnicodeQt4.h	/^    SegmentSeparator = QChar::DirS,$/;"	e	enum:WTF::Unicode::Direction
SegmentSeparator	.\unicode\wince\UnicodeWinCE.h	/^    SegmentSeparator = UnicodeCE::U_SEGMENT_SEPARATOR,$/;"	e	enum:WTF::Unicode::Direction
SegmentedVector	.\SegmentedVector.h	/^        SegmentedVector()$/;"	f	class:WTF::SegmentedVector	access:public	signature:()
SegmentedVector	.\SegmentedVector.h	/^    template <typename T, size_t SegmentSize> class SegmentedVector {$/;"	c	namespace:WTF
SegmentedVectorIterator	.\SegmentedVector.h	/^        SegmentedVectorIterator(SegmentedVector<T, SegmentSize>& vector, size_t segment, size_t index)$/;"	f	class:WTF::SegmentedVectorIterator	access:private	signature:(SegmentedVector<T, SegmentSize>& vector, size_t segment, size_t index)
SegmentedVectorIterator	.\SegmentedVector.h	/^    template <typename T, size_t SegmentSize> class SegmentedVectorIterator {$/;"	c	namespace:WTF
SegmentedVector_h	.\SegmentedVector.h	30;"	d
Sentinel	.\SentinelLinkedList.h	/^enum SentinelTag { Sentinel };$/;"	e	enum:WTF::SentinelTag
SentinelLinkedList	.\SentinelLinkedList.h	/^    SentinelLinkedList();$/;"	p	class:WTF::SentinelLinkedList	access:public	signature:()
SentinelLinkedList	.\SentinelLinkedList.h	/^template <typename T, typename RawNode = T> class SentinelLinkedList {$/;"	c	namespace:WTF
SentinelLinkedList	.\SentinelLinkedList.h	/^template <typename T, typename RawNode> inline SentinelLinkedList<T, RawNode>::SentinelLinkedList()$/;"	f	class:WTF::SentinelLinkedList	signature:()
SentinelLinkedList_h	.\SentinelLinkedList.h	38;"	d
SentinelTag	.\SentinelLinkedList.h	/^enum SentinelTag { Sentinel };$/;"	g	namespace:WTF
Separator_Line	.\unicode\glib\UnicodeGLib.h	/^    Separator_Line = U_MASK(G_UNICODE_LINE_SEPARATOR),$/;"	e	enum:WTF::Unicode::CharCategory
Separator_Line	.\unicode\icu\UnicodeIcu.h	/^    Separator_Line = U_MASK(U_LINE_SEPARATOR),$/;"	e	enum:WTF::Unicode::CharCategory
Separator_Line	.\unicode\qt4\UnicodeQt4.h	/^    Separator_Line = U_MASK(QChar::Separator_Line),$/;"	e	enum:WTF::Unicode::CharCategory
Separator_Line	.\unicode\wince\UnicodeWinCE.h	/^    Separator_Line = TO_MASK(UnicodeCE::U_LINE_SEPARATOR),$/;"	e	enum:WTF::Unicode::CharCategory
Separator_Paragraph	.\unicode\glib\UnicodeGLib.h	/^    Separator_Paragraph = U_MASK(G_UNICODE_PARAGRAPH_SEPARATOR),$/;"	e	enum:WTF::Unicode::CharCategory
Separator_Paragraph	.\unicode\icu\UnicodeIcu.h	/^    Separator_Paragraph = U_MASK(U_PARAGRAPH_SEPARATOR),$/;"	e	enum:WTF::Unicode::CharCategory
Separator_Paragraph	.\unicode\qt4\UnicodeQt4.h	/^    Separator_Paragraph = U_MASK(QChar::Separator_Paragraph),$/;"	e	enum:WTF::Unicode::CharCategory
Separator_Paragraph	.\unicode\wince\UnicodeWinCE.h	/^    Separator_Paragraph = TO_MASK(UnicodeCE::U_PARAGRAPH_SEPARATOR),$/;"	e	enum:WTF::Unicode::CharCategory
Separator_Space	.\unicode\glib\UnicodeGLib.h	/^    Separator_Space = U_MASK(G_UNICODE_SPACE_SEPARATOR),$/;"	e	enum:WTF::Unicode::CharCategory
Separator_Space	.\unicode\icu\UnicodeIcu.h	/^    Separator_Space = U_MASK(U_SPACE_SEPARATOR),$/;"	e	enum:WTF::Unicode::CharCategory
Separator_Space	.\unicode\qt4\UnicodeQt4.h	/^    Separator_Space = U_MASK(QChar::Separator_Space),$/;"	e	enum:WTF::Unicode::CharCategory
Separator_Space	.\unicode\wince\UnicodeWinCE.h	/^    Separator_Space = TO_MASK(UnicodeCE::U_SPACE_SEPARATOR),$/;"	e	enum:WTF::Unicode::CharCategory
SetNumericProperty	.\FastMalloc.cpp	/^  virtual bool SetNumericProperty(const char* name, size_t value) {$/;"	f	class:WTF::TCMallocImplementation	access:public	signature:(const char* name, size_t value)
SetPosition	.\dtoa\utils.h	/^        void SetPosition(int position)$/;"	f	class:WTF::double_conversion::StringBuilder	access:public	signature:(int position)
Shift	.\dtoa\fixed-dtoa.cc	/^        void Shift(int shift_amount) {$/;"	f	class:WTF::double_conversion::UInt128	access:public	signature:(int shift_amount)
ShiftLeft	.\dtoa\bignum.cc	/^    void Bignum::ShiftLeft(int shift_amount) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(int shift_amount)
ShiftLeft	.\dtoa\bignum.h	/^        void ShiftLeft(int shift_amount);$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(int shift_amount)
ShouldRoundDecimalPlaces	.\text\WTFString.h	/^    ShouldRoundDecimalPlaces = 1 << 1,$/;"	e	enum:WTF::FloatConversionFlags
ShouldRoundSignificantFigures	.\text\WTFString.h	/^    ShouldRoundSignificantFigures = 1 << 0,$/;"	e	enum:WTF::FloatConversionFlags
ShouldTruncateTrailingZeros	.\text\WTFString.h	/^    ShouldTruncateTrailingZeros = 1 << 2$/;"	e	enum:WTF::FloatConversionFlags
ShrinkCache	.\FastMalloc.cpp	/^  bool ShrinkCache(int locked_size_class, bool force);$/;"	p	class:WTF::TCMalloc_Central_FreeList	file:	access:private	signature:(int locked_size_class, bool force)
ShrinkCache	.\FastMalloc.cpp	/^bool TCMalloc_Central_FreeList::ShrinkCache(int locked_size_class, bool force) {$/;"	f	class:WTF::TCMalloc_Central_FreeList	signature:(int locked_size_class, bool force)
Sign	.\dtoa\double.h	/^        int Sign() const {$/;"	f	class:WTF::double_conversion::Double	access:public	signature:() const
Sign_bit	.\dtoa.cpp	144;"	d	file:
SignedType	.\HashFunctions.h	/^    template<> struct IntTypes<1> { typedef int8_t SignedType; typedef uint8_t UnsignedType; };$/;"	t	struct:WTF::IntTypes	access:public
SignedType	.\HashFunctions.h	/^    template<> struct IntTypes<2> { typedef int16_t SignedType; typedef uint16_t UnsignedType; };$/;"	t	struct:WTF::IntTypes	access:public
SignedType	.\HashFunctions.h	/^    template<> struct IntTypes<4> { typedef int32_t SignedType; typedef uint32_t UnsignedType; };$/;"	t	struct:WTF::IntTypes	access:public
SignedType	.\HashFunctions.h	/^    template<> struct IntTypes<8> { typedef int64_t SignedType; typedef uint64_t UnsignedType; };$/;"	t	struct:WTF::IntTypes	access:public
SignedZero	.\dtoa\double-conversion.cc	/^    static double SignedZero(bool sign) {$/;"	f	namespace:WTF::double_conversion	file:	signature:(bool sign)
SignednessSelector	.\CheckedArithmetic.h	/^template <typename U, typename V> struct SignednessSelector<U, V, false, false> {$/;"	s	namespace:WTF
SignednessSelector	.\CheckedArithmetic.h	/^template <typename U, typename V> struct SignednessSelector<U, V, false, true> {$/;"	s	namespace:WTF
SignednessSelector	.\CheckedArithmetic.h	/^template <typename U, typename V> struct SignednessSelector<U, V, true, false> {$/;"	s	namespace:WTF
SignednessSelector	.\CheckedArithmetic.h	/^template <typename U, typename V> struct SignednessSelector<U, V, true, true> {$/;"	s	namespace:WTF
Significand	.\dtoa\double.h	/^        uint64_t Significand() const {$/;"	f	class:WTF::double_conversion::Double	access:public	signature:() const
SignificandSizeForOrderOfMagnitude	.\dtoa\double.h	/^        static int SignificandSizeForOrderOfMagnitude(int order) {$/;"	f	class:WTF::double_conversion::Double	access:public	signature:(int order)
SimpleClassHashTraits	.\HashTraits.h	/^    template<typename T> struct SimpleClassHashTraits : GenericHashTraits<T> {$/;"	s	namespace:WTF	inherits:GenericHashTraits
SimpleClassVectorTraits	.\VectorTraits.h	/^    struct SimpleClassVectorTraits : VectorTraitsBase<false, void>$/;"	s	namespace:WTF	inherits:VectorTraitsBase
SimpleStats	.\SimpleStats.h	/^    SimpleStats()$/;"	f	class:WTF::SimpleStats	access:public	signature:()
SimpleStats	.\SimpleStats.h	/^class SimpleStats {$/;"	c	namespace:WTF
SimpleStats_h	.\SimpleStats.h	27;"	d
SingleDispatchQueueVerificationMode	.\ThreadRestrictionVerifier.h	/^        SingleDispatchQueueVerificationMode,$/;"	e	enum:WTF::ThreadRestrictionVerifier::VerificationMode
SingleThreadVerificationMode	.\ThreadRestrictionVerifier.h	/^        SingleThreadVerificationMode,$/;"	e	enum:WTF::ThreadRestrictionVerifier::VerificationMode
SinglyLinkedList	.\SinglyLinkedList.h	/^    SinglyLinkedList();$/;"	p	class:WTF::SinglyLinkedList	access:public	signature:()
SinglyLinkedList	.\SinglyLinkedList.h	/^template <typename Node> class SinglyLinkedList {$/;"	c	namespace:WTF
SinglyLinkedList	.\SinglyLinkedList.h	/^template <typename Node> inline SinglyLinkedList<Node>::SinglyLinkedList()$/;"	f	class:WTF::SinglyLinkedList	signature:()
SinglyLinkedList_h	.\SinglyLinkedList.h	27;"	d
Size	.\FastMalloc.cpp	/^  size_t Size() const { return size_; }$/;"	f	class:WTF::TCMalloc_ThreadCache	access:public	signature:() const
SizeClass	.\FastMalloc.cpp	/^static ALWAYS_INLINE size_t SizeClass(size_t size) {$/;"	f	namespace:WTF	file:	signature:(size_t size)
SizeInHexChars	.\dtoa\bignum.cc	/^    static int SizeInHexChars(S number) {$/;"	f	namespace:WTF::double_conversion	file:	signature:(S number)
SpaceOrNewlinePredicate	.\text\StringImpl.cpp	/^class SpaceOrNewlinePredicate {$/;"	c	namespace:WTF	file:
Span	.\FastMalloc.cpp	/^struct Span {$/;"	s	namespace:WTF	file:
SpanList	.\FastMalloc.cpp	/^  struct SpanList {$/;"	s	class:WTF::TCMalloc_PageHeap	file:	access:private
SpanToMallocResult	.\FastMalloc.cpp	/^static inline void* SpanToMallocResult(Span *span) {$/;"	f	namespace:WTF	file:	signature:(Span *span)
SpecialPort	.\url\src\URLParser.h	/^    enum SpecialPort {$/;"	g	class:WTF::URLParser	access:public
Spectrum	.\Spectrum.h	/^    Spectrum() { }$/;"	f	class:WTF::Spectrum	access:public	signature:()
Spectrum	.\Spectrum.h	/^class Spectrum {$/;"	c	namespace:WTF
Spectrum_h	.\Spectrum.h	27;"	d
SpinLock	.\TCSpinLock.h	/^typedef TCMalloc_SpinLock SpinLock;$/;"	t
SpinLockHolder	.\TCSpinLock.h	/^typedef TCMalloc_SpinLockHolder SpinLockHolder;$/;"	t
Split	.\FastMalloc.cpp	/^  Span* Split(Span* span, Length n);$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:public	signature:(Span* span, Length n)
Split	.\FastMalloc.cpp	/^Span* TCMalloc_PageHeap::Split(Span* span, Length n) {$/;"	f	class:WTF::TCMalloc_PageHeap	signature:(Span* span, Length n)
Square	.\dtoa\bignum.cc	/^    void Bignum::Square() {$/;"	f	class:WTF::double_conversion::Bignum	signature:()
Square	.\dtoa\bignum.h	/^        void Square();$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:()
StackBounds	.\StackBounds.h	/^    StackBounds()$/;"	f	class:WTF::StackBounds	access:public	signature:()
StackBounds	.\StackBounds.h	/^class StackBounds {$/;"	c	namespace:WTF
StackBounds_h	.\StackBounds.h	28;"	d
StackTrace	.\FastMalloc.cpp	/^struct StackTrace {$/;"	s	namespace:WTF	file:
StaticConstructors_h	.\StaticConstructors.h	22;"	d
Statistics	.\MetaAllocator.h	/^    struct Statistics {$/;"	s	class:WTF::MetaAllocator	access:public
StorageType	.\Functional.h	/^    typedef RefPtr<T> StorageType;$/;"	t	struct:WTF::ParamStorageTraits	access:public
StorageType	.\Functional.h	/^    typedef RetainPtr<T> StorageType;$/;"	t	struct:WTF::ParamStorageTraits	access:public
StorageType	.\Functional.h	/^    typedef T StorageType;$/;"	t	struct:WTF::ParamStorageTraits	access:public
StrLength	.\dtoa\utils.h	/^    inline int StrLength(const char* string) {$/;"	f	namespace:WTF::double_conversion	signature:(const char* string)
String	.\qt\StringQt.cpp	/^String::String(const QString& qstr)$/;"	f	class:WTF::String	signature:(const QString& qstr)
String	.\qt\StringQt.cpp	/^String::String(const QStringRef& ref)$/;"	f	class:WTF::String	signature:(const QStringRef& ref)
String	.\text\WTFString.cpp	/^String::String(const LChar* characters)$/;"	f	class:WTF::String	signature:(const LChar* characters)
String	.\text\WTFString.cpp	/^String::String(const LChar* characters, unsigned length)$/;"	f	class:WTF::String	signature:(const LChar* characters, unsigned length)
String	.\text\WTFString.cpp	/^String::String(const UChar* characters, unsigned length)$/;"	f	class:WTF::String	signature:(const UChar* characters, unsigned length)
String	.\text\WTFString.cpp	/^String::String(const UChar* str)$/;"	f	class:WTF::String	signature:(const UChar* str)
String	.\text\WTFString.cpp	/^String::String(const char* characters)$/;"	f	class:WTF::String	signature:(const char* characters)
String	.\text\WTFString.cpp	/^String::String(const char* characters, unsigned length)$/;"	f	class:WTF::String	signature:(const char* characters, unsigned length)
String	.\text\WTFString.h	/^    String() { }$/;"	f	class:WTF::String	access:public	signature:()
String	.\text\WTFString.h	/^    String(CFStringRef);$/;"	p	class:WTF::String	access:public	signature:(CFStringRef)
String	.\text\WTFString.h	/^    String(NSString*);$/;"	p	class:WTF::String	access:public	signature:(NSString*)
String	.\text\WTFString.h	/^    String(PassRefPtr<StringImpl> impl) : m_impl(impl) { }$/;"	f	class:WTF::String	access:public	signature:(PassRefPtr<StringImpl> impl)
String	.\text\WTFString.h	/^    String(RefPtr<StringImpl> impl) : m_impl(impl) { }$/;"	f	class:WTF::String	access:public	signature:(RefPtr<StringImpl> impl)
String	.\text\WTFString.h	/^    String(StringImpl* impl) : m_impl(impl) { }$/;"	f	class:WTF::String	access:public	signature:(StringImpl* impl)
String	.\text\WTFString.h	/^    String(WTF::HashTableDeletedValueType) : m_impl(WTF::HashTableDeletedValue) { }$/;"	f	class:WTF::String	access:public	signature:(WTF::HashTableDeletedValueType)
String	.\text\WTFString.h	/^    String(const BlackBerry::WebKit::WebString&);$/;"	p	class:WTF::String	access:public	signature:(const BlackBerry::WebKit::WebString&)
String	.\text\WTFString.h	/^    String(const QString&);$/;"	p	class:WTF::String	access:public	signature:(const QString&)
String	.\text\WTFString.h	/^    String(const QStringRef&);$/;"	p	class:WTF::String	access:public	signature:(const QStringRef&)
String	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE String(const LChar* characters);$/;"	p	class:WTF::String	access:public	signature:(const LChar* characters)
String	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE String(const LChar* characters, unsigned length);$/;"	p	class:WTF::String	access:public	signature:(const LChar* characters, unsigned length)
String	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE String(const UChar* characters, unsigned length);$/;"	p	class:WTF::String	access:public	signature:(const UChar* characters, unsigned length)
String	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE String(const UChar*);$/;"	p	class:WTF::String	access:public	signature:(const UChar*)
String	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE String(const char* characters);$/;"	p	class:WTF::String	access:public	signature:(const char* characters)
String	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE String(const char* characters, unsigned length);$/;"	p	class:WTF::String	access:public	signature:(const char* characters, unsigned length)
String	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE String(const wxString&);$/;"	p	class:WTF::String	access:public	signature:(const wxString&)
String	.\text\WTFString.h	/^    explicit String(const Vector<UChar, inlineCapacity>&);$/;"	p	class:WTF::String	access:public	signature:(const Vector<UChar, inlineCapacity>&)
String	.\text\WTFString.h	/^String::String(const Vector<UChar, inlineCapacity>& vector)$/;"	f	class:WTF::String	signature:(const Vector<UChar, inlineCapacity>& vector)
String	.\text\WTFString.h	/^class String {$/;"	c	namespace:WTF
String	.\wx\StringWx.cpp	/^String::String(const wxString& wxstr)$/;"	f	class:WTF::String	signature:(const wxString& wxstr)
String::show	.\text\WTFString.cpp	/^void String::show() const$/;"	f	class:String	signature:() const
StringAppend	.\text\StringOperators.h	/^    StringAppend(StringType1 string1, StringType2 string2)$/;"	f	class:WTF::StringAppend	access:public	signature:(StringType1 string1, StringType2 string2)
StringAppend	.\text\StringOperators.h	/^class StringAppend {$/;"	c	namespace:WTF
StringBuffer	.\text\StringBuffer.h	/^    explicit StringBuffer(unsigned length)$/;"	f	class:WTF::StringBuffer	access:public	signature:(unsigned length)
StringBuffer	.\text\StringBuffer.h	/^class StringBuffer {$/;"	c	namespace:WTF
StringBuffer_h	.\text\StringBuffer.h	30;"	d
StringBuilder	.\dtoa\utils.h	/^        StringBuilder(char* buffer, int size)$/;"	f	class:WTF::double_conversion::StringBuilder	access:public	signature:(char* buffer, int size)
StringBuilder	.\dtoa\utils.h	/^    class StringBuilder {$/;"	c	namespace:WTF::double_conversion
StringBuilder	.\text\StringBuilder.h	/^    StringBuilder()$/;"	f	class:WTF::StringBuilder	access:public	signature:()
StringBuilder	.\text\StringBuilder.h	/^class StringBuilder {$/;"	c	namespace:WTF
StringBuilder_h	.\text\StringBuilder.h	28;"	d
StringConcatenate_h	.\text\StringConcatenate.h	27;"	d
StringHash	.\text\StringHash.h	/^    struct StringHash {$/;"	s	namespace:WTF
StringHash_h	.\text\StringHash.h	23;"	d
StringHasher	.\StringHasher.h	/^    inline StringHasher()$/;"	f	class:WTF::StringHasher	access:public	signature:()
StringHasher	.\StringHasher.h	/^class StringHasher {$/;"	c	namespace:WTF
StringImpl	.\text\StringImpl.h	/^    StringImpl(const LChar* characters, unsigned length)$/;"	f	class:WTF::StringImpl	access:private	signature:(const LChar* characters, unsigned length)
StringImpl	.\text\StringImpl.h	/^    StringImpl(const LChar* characters, unsigned length, ConstructStaticStringTag)$/;"	f	class:WTF::StringImpl	access:private	signature:(const LChar* characters, unsigned length, ConstructStaticStringTag)
StringImpl	.\text\StringImpl.h	/^    StringImpl(const LChar* characters, unsigned length, PassRefPtr<StringImpl> base)$/;"	f	class:WTF::StringImpl	access:private	signature:(const LChar* characters, unsigned length, PassRefPtr<StringImpl> base)
StringImpl	.\text\StringImpl.h	/^    StringImpl(const UChar* characters, unsigned length)$/;"	f	class:WTF::StringImpl	access:private	signature:(const UChar* characters, unsigned length)
StringImpl	.\text\StringImpl.h	/^    StringImpl(const UChar* characters, unsigned length, ConstructStaticStringTag)$/;"	f	class:WTF::StringImpl	access:private	signature:(const UChar* characters, unsigned length, ConstructStaticStringTag)
StringImpl	.\text\StringImpl.h	/^    StringImpl(const UChar* characters, unsigned length, PassRefPtr<StringImpl> base)$/;"	f	class:WTF::StringImpl	access:private	signature:(const UChar* characters, unsigned length, PassRefPtr<StringImpl> base)
StringImpl	.\text\StringImpl.h	/^    StringImpl(unsigned length)$/;"	f	class:WTF::StringImpl	access:private	signature:(unsigned length)
StringImpl	.\text\StringImpl.h	/^    StringImpl(unsigned length, Force8Bit)$/;"	f	class:WTF::StringImpl	access:private	signature:(unsigned length, Force8Bit)
StringImpl	.\text\StringImpl.h	/^class StringImpl {$/;"	c	namespace:WTF
StringImpl_h	.\text\StringImpl.h	24;"	d
StringOperators_h	.\text\StringOperators.h	23;"	d
StringToDouble	.\dtoa\double-conversion.cc	/^    double StringToDoubleConverter::StringToDouble($/;"	f	class:WTF::double_conversion::StringToDoubleConverter	signature:( const char* input, int length, int* processed_characters_count)
StringToDouble	.\dtoa\double-conversion.h	/^        double StringToDouble(const char* buffer,$/;"	p	class:WTF::double_conversion::StringToDoubleConverter	access:public	signature:(const char* buffer, int length, int* processed_characters_count)
StringToDoubleConverter	.\dtoa\double-conversion.h	/^        StringToDoubleConverter(int flags,$/;"	f	class:WTF::double_conversion::StringToDoubleConverter	access:public	signature:(int flags, double empty_string_value, double junk_string_value, const char* infinity_symbol, const char* nan_symbol)
StringToDoubleConverter	.\dtoa\double-conversion.h	/^    class StringToDoubleConverter {$/;"	c	namespace:WTF::double_conversion
StringTypeAdapter	.\text\StringConcatenate.h	/^    StringTypeAdapter<AtomicString>(const AtomicString& string)$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(const AtomicString& string)
StringTypeAdapter	.\text\StringConcatenate.h	/^    StringTypeAdapter<LChar*>(LChar* buffer)$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(LChar* buffer)
StringTypeAdapter	.\text\StringConcatenate.h	/^    StringTypeAdapter<LChar>(LChar buffer)$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(LChar buffer)
StringTypeAdapter	.\text\StringConcatenate.h	/^    StringTypeAdapter<String>(const String& string)$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(const String& string)
StringTypeAdapter	.\text\StringConcatenate.h	/^    StringTypeAdapter<UChar>(UChar buffer)$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(UChar buffer)
StringTypeAdapter	.\text\StringConcatenate.h	/^    StringTypeAdapter<Vector<LChar> >(const Vector<LChar>& buffer)$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(const Vector<LChar>& buffer)
StringTypeAdapter	.\text\StringConcatenate.h	/^    StringTypeAdapter<Vector<char> >(const Vector<char>& buffer)$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(const Vector<char>& buffer)
StringTypeAdapter	.\text\StringConcatenate.h	/^    StringTypeAdapter<char*>(char* buffer)$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(char* buffer)
StringTypeAdapter	.\text\StringConcatenate.h	/^    StringTypeAdapter<char>(char buffer)$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(char buffer)
StringTypeAdapter	.\text\StringConcatenate.h	/^    StringTypeAdapter<const LChar*>(const LChar* buffer)$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(const LChar* buffer)
StringTypeAdapter	.\text\StringConcatenate.h	/^    StringTypeAdapter<const UChar*>(const UChar* buffer)$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(const UChar* buffer)
StringTypeAdapter	.\text\StringConcatenate.h	/^    StringTypeAdapter<const char*>(const char* buffer)$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(const char* buffer)
StringTypeAdapter	.\text\StringConcatenate.h	/^class StringTypeAdapter {$/;"	c	namespace:WTF
StringTypeAdapter	.\text\StringConcatenate.h	/^class StringTypeAdapter<AtomicString> {$/;"	c	namespace:WTF
StringTypeAdapter	.\text\StringConcatenate.h	/^class StringTypeAdapter<LChar*> {$/;"	c	namespace:WTF
StringTypeAdapter	.\text\StringConcatenate.h	/^class StringTypeAdapter<LChar> {$/;"	c	namespace:WTF
StringTypeAdapter	.\text\StringConcatenate.h	/^class StringTypeAdapter<String> {$/;"	c	namespace:WTF
StringTypeAdapter	.\text\StringConcatenate.h	/^class StringTypeAdapter<UChar> {$/;"	c	namespace:WTF
StringTypeAdapter	.\text\StringConcatenate.h	/^class StringTypeAdapter<Vector<LChar> > {$/;"	c	namespace:WTF
StringTypeAdapter	.\text\StringConcatenate.h	/^class StringTypeAdapter<Vector<char> > {$/;"	c	namespace:WTF
StringTypeAdapter	.\text\StringConcatenate.h	/^class StringTypeAdapter<char*> {$/;"	c	namespace:WTF
StringTypeAdapter	.\text\StringConcatenate.h	/^class StringTypeAdapter<char> {$/;"	c	namespace:WTF
StringTypeAdapter	.\text\StringConcatenate.h	/^class StringTypeAdapter<const LChar*> {$/;"	c	namespace:WTF
StringTypeAdapter	.\text\StringConcatenate.h	/^class StringTypeAdapter<const UChar*> {$/;"	c	namespace:WTF
StringTypeAdapter	.\text\StringConcatenate.h	/^class StringTypeAdapter<const char*> {$/;"	c	namespace:WTF
StringTypeAdapter	.\text\StringOperators.h	/^    StringTypeAdapter<StringAppend<StringType1, StringType2> >(StringAppend<StringType1, StringType2>& buffer)$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(StringAppend<StringType1, StringType2>& buffer)
StringTypeAdapter	.\text\StringOperators.h	/^class StringTypeAdapter<StringAppend<StringType1, StringType2> > {$/;"	c	namespace:WTF
Strtod	.\dtoa\strtod.cc	/^    double Strtod(Vector<const char> buffer, int exponent) {$/;"	f	namespace:WTF::double_conversion	signature:(Vector<const char> buffer, int exponent)
Strtod	.\dtoa\strtod.h	/^    double Strtod(Vector<const char> buffer, int exponent);$/;"	p	namespace:WTF::double_conversion	signature:(Vector<const char> buffer, int exponent)
SubVector	.\dtoa\utils.h	/^        Vector<T> SubVector(int from, int to) {$/;"	f	class:WTF::double_conversion::Vector	access:public	signature:(int from, int to)
SubstringLocation	.\text\AtomicString.cpp	/^struct SubstringLocation {$/;"	s	namespace:WTF	file:
SubstringTranslator	.\text\AtomicString.cpp	/^struct SubstringTranslator {$/;"	s	namespace:WTF	file:
Subtract	.\dtoa\diy-fp.h	/^        void Subtract(const DiyFp& other) {$/;"	f	class:WTF::double_conversion::DiyFp	access:public	signature:(const DiyFp& other)
SubtractBignum	.\dtoa\bignum.cc	/^    void Bignum::SubtractBignum(const Bignum& other) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(const Bignum& other)
SubtractBignum	.\dtoa\bignum.h	/^        void SubtractBignum(const Bignum& other);$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(const Bignum& other)
SubtractTimes	.\dtoa\bignum.cc	/^    void Bignum::SubtractTimes(const Bignum& other, int factor) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(const Bignum& other, int factor)
SubtractTimes	.\dtoa\bignum.h	/^        void SubtractTimes(const Bignum& other, int factor);$/;"	p	class:WTF::double_conversion::Bignum	access:private	signature:(const Bignum& other, int factor)
Symbol_Currency	.\unicode\glib\UnicodeGLib.h	/^    Symbol_Currency = U_MASK(G_UNICODE_CURRENCY_SYMBOL),$/;"	e	enum:WTF::Unicode::CharCategory
Symbol_Currency	.\unicode\icu\UnicodeIcu.h	/^    Symbol_Currency = U_MASK(U_CURRENCY_SYMBOL),$/;"	e	enum:WTF::Unicode::CharCategory
Symbol_Currency	.\unicode\qt4\UnicodeQt4.h	/^    Symbol_Currency = U_MASK(QChar::Symbol_Currency),$/;"	e	enum:WTF::Unicode::CharCategory
Symbol_Currency	.\unicode\wince\UnicodeWinCE.h	/^    Symbol_Currency = TO_MASK(UnicodeCE::U_CURRENCY_SYMBOL),$/;"	e	enum:WTF::Unicode::CharCategory
Symbol_Math	.\unicode\glib\UnicodeGLib.h	/^    Symbol_Math = U_MASK(G_UNICODE_MATH_SYMBOL),$/;"	e	enum:WTF::Unicode::CharCategory
Symbol_Math	.\unicode\icu\UnicodeIcu.h	/^    Symbol_Math = U_MASK(U_MATH_SYMBOL),$/;"	e	enum:WTF::Unicode::CharCategory
Symbol_Math	.\unicode\qt4\UnicodeQt4.h	/^    Symbol_Math = U_MASK(QChar::Symbol_Math),$/;"	e	enum:WTF::Unicode::CharCategory
Symbol_Math	.\unicode\wince\UnicodeWinCE.h	/^    Symbol_Math = TO_MASK(UnicodeCE::U_MATH_SYMBOL),$/;"	e	enum:WTF::Unicode::CharCategory
Symbol_Modifier	.\unicode\glib\UnicodeGLib.h	/^    Symbol_Modifier = U_MASK(G_UNICODE_MODIFIER_SYMBOL),$/;"	e	enum:WTF::Unicode::CharCategory
Symbol_Modifier	.\unicode\icu\UnicodeIcu.h	/^    Symbol_Modifier = U_MASK(U_MODIFIER_SYMBOL),$/;"	e	enum:WTF::Unicode::CharCategory
Symbol_Modifier	.\unicode\qt4\UnicodeQt4.h	/^    Symbol_Modifier = U_MASK(QChar::Symbol_Modifier),$/;"	e	enum:WTF::Unicode::CharCategory
Symbol_Modifier	.\unicode\wince\UnicodeWinCE.h	/^    Symbol_Modifier = TO_MASK(UnicodeCE::U_MODIFIER_SYMBOL),$/;"	e	enum:WTF::Unicode::CharCategory
Symbol_Other	.\unicode\glib\UnicodeGLib.h	/^    Symbol_Other = U_MASK(G_UNICODE_OTHER_SYMBOL),$/;"	e	enum:WTF::Unicode::CharCategory
Symbol_Other	.\unicode\icu\UnicodeIcu.h	/^    Symbol_Other = U_MASK(U_OTHER_SYMBOL),$/;"	e	enum:WTF::Unicode::CharCategory
Symbol_Other	.\unicode\qt4\UnicodeQt4.h	/^    Symbol_Other = U_MASK(QChar::Symbol_Other)$/;"	e	enum:WTF::Unicode::CharCategory
Symbol_Other	.\unicode\wince\UnicodeWinCE.h	/^    Symbol_Other = TO_MASK(UnicodeCE::U_OTHER_SYMBOL),$/;"	e	enum:WTF::Unicode::CharCategory
SystemBytes	.\FastMalloc.cpp	/^  inline uint64_t SystemBytes() const { return system_bytes_; }$/;"	f	class:WTF::TCMalloc_PageHeap	access:public	signature:() const
TARGETING_LEOPARD	.\Platform.h	341;"	d
TARGETING_LION	.\Platform.h	345;"	d
TARGETING_SNOW_LEOPARD	.\Platform.h	343;"	d
TCEntry	.\FastMalloc.cpp	/^struct TCEntry {$/;"	s	namespace:WTF	file:
TCMALLOC_INTERNAL_SPINLOCK_H__	.\TCSpinLock.h	35;"	d
TCMALLOC_PACKED_CACHE_INL_H__	.\TCPackedCache.h	112;"	d
TCMALLOC_PAGEMAP_H__	.\TCPageMap.h	46;"	d
TCMALLOC_SYSTEM_ALLOC_H__	.\TCSystemAlloc.h	37;"	d
TCMallocGuard	.\FastMalloc.cpp	/^  TCMallocGuard() {$/;"	f	class:WTF::TCMallocGuard	access:public	signature:()
TCMallocGuard	.\FastMalloc.cpp	/^class TCMallocGuard {$/;"	c	namespace:WTF	file:
TCMallocImplementation	.\FastMalloc.cpp	/^class TCMallocImplementation : public MallocExtension {$/;"	c	namespace:WTF	file:	inherits:MallocExtension
TCMallocStats	.\FastMalloc.cpp	/^struct TCMallocStats {$/;"	s	namespace:WTF	file:
TCMalloc_Central_FreeList	.\FastMalloc.cpp	/^class TCMalloc_Central_FreeList {$/;"	c	namespace:WTF	file:
TCMalloc_Central_FreeListPadded	.\FastMalloc.cpp	/^class TCMalloc_Central_FreeListPadded : public TCMalloc_Central_FreeList {$/;"	c	namespace:WTF	file:	inherits:TCMalloc_Central_FreeList
TCMalloc_PageHeap	.\FastMalloc.cpp	/^class TCMalloc_PageHeap {$/;"	c	namespace:WTF	file:
TCMalloc_PageMap1	.\TCPageMap.h	/^class TCMalloc_PageMap1 {$/;"	c
TCMalloc_PageMap1::Ensure	.\TCPageMap.h	/^  bool Ensure(Number, size_t) {$/;"	f	class:TCMalloc_PageMap1	access:public	signature:(Number, size_t)
TCMalloc_PageMap1::Number	.\TCPageMap.h	/^  typedef uintptr_t Number;$/;"	t	class:TCMalloc_PageMap1	access:public
TCMalloc_PageMap1::PreallocateMoreMemory	.\TCPageMap.h	/^  void PreallocateMoreMemory() {}$/;"	f	class:TCMalloc_PageMap1	access:public	signature:()
TCMalloc_PageMap1::array_	.\TCPageMap.h	/^  void** array_;$/;"	m	class:TCMalloc_PageMap1	access:private
TCMalloc_PageMap1::get	.\TCPageMap.h	/^  void* get(Number k) const {$/;"	f	class:TCMalloc_PageMap1	access:public	signature:(Number k) const
TCMalloc_PageMap1::init	.\TCPageMap.h	/^  void init(void* (*allocator)(size_t)) {$/;"	f	class:TCMalloc_PageMap1	access:public	signature:(void* (*allocator)(size_t))
TCMalloc_PageMap1::set	.\TCPageMap.h	/^  void set(Number k, void* v) {$/;"	f	class:TCMalloc_PageMap1	access:public	signature:(Number k, void* v)
TCMalloc_PageMap2	.\TCPageMap.h	/^class TCMalloc_PageMap2 {$/;"	c
TCMalloc_PageMap2::Ensure	.\TCPageMap.h	/^  bool Ensure(Number start, size_t n) {$/;"	f	class:TCMalloc_PageMap2	access:public	signature:(Number start, size_t n)
TCMalloc_PageMap2::LEAF_BITS	.\TCPageMap.h	/^  static const int LEAF_BITS = BITS - ROOT_BITS;$/;"	m	class:TCMalloc_PageMap2	access:private
TCMalloc_PageMap2::LEAF_LENGTH	.\TCPageMap.h	/^  static const int LEAF_LENGTH = 1 << LEAF_BITS;$/;"	m	class:TCMalloc_PageMap2	access:private
TCMalloc_PageMap2::Leaf	.\TCPageMap.h	/^  struct Leaf {$/;"	s	class:TCMalloc_PageMap2	access:private
TCMalloc_PageMap2::Leaf::values	.\TCPageMap.h	/^    void* values[LEAF_LENGTH];$/;"	m	struct:TCMalloc_PageMap2::Leaf	access:public
TCMalloc_PageMap2::Number	.\TCPageMap.h	/^  typedef uintptr_t Number;$/;"	t	class:TCMalloc_PageMap2	access:public
TCMalloc_PageMap2::PreallocateMoreMemory	.\TCPageMap.h	/^  void PreallocateMoreMemory() {$/;"	f	class:TCMalloc_PageMap2	access:public	signature:()
TCMalloc_PageMap2::ROOT_BITS	.\TCPageMap.h	/^  static const int ROOT_BITS = 5;$/;"	m	class:TCMalloc_PageMap2	access:private
TCMalloc_PageMap2::ROOT_LENGTH	.\TCPageMap.h	/^  static const int ROOT_LENGTH = 1 << ROOT_BITS;$/;"	m	class:TCMalloc_PageMap2	access:private
TCMalloc_PageMap2::allocator_	.\TCPageMap.h	/^  void* (*allocator_)(size_t);          \/\/ Memory allocator$/;"	m	class:TCMalloc_PageMap2	access:private
TCMalloc_PageMap2::get	.\TCPageMap.h	/^  void* get(Number k) const {$/;"	f	class:TCMalloc_PageMap2	access:public	signature:(Number k) const
TCMalloc_PageMap2::init	.\TCPageMap.h	/^  void init(void* (*allocator)(size_t)) {$/;"	f	class:TCMalloc_PageMap2	access:public	signature:(void* (*allocator)(size_t))
TCMalloc_PageMap2::root_	.\TCPageMap.h	/^  Leaf* root_[ROOT_LENGTH];             \/\/ Pointers to 32 child nodes$/;"	m	class:TCMalloc_PageMap2	access:private
TCMalloc_PageMap2::set	.\TCPageMap.h	/^  void set(Number k, void* v) {$/;"	f	class:TCMalloc_PageMap2	access:public	signature:(Number k, void* v)
TCMalloc_PageMap2::visitAllocations	.\TCPageMap.h	/^  void visitAllocations(Visitor& visitor, const MemoryReader&) {$/;"	f	class:TCMalloc_PageMap2	access:public	signature:(Visitor& visitor, const MemoryReader&)
TCMalloc_PageMap2::visitValues	.\TCPageMap.h	/^  void visitValues(Visitor& visitor, const MemoryReader& reader)$/;"	f	class:TCMalloc_PageMap2	access:public	signature:(Visitor& visitor, const MemoryReader& reader)
TCMalloc_PageMap3	.\TCPageMap.h	/^class TCMalloc_PageMap3 {$/;"	c
TCMalloc_PageMap3::Ensure	.\TCPageMap.h	/^  bool Ensure(Number start, size_t n) {$/;"	f	class:TCMalloc_PageMap3	access:public	signature:(Number start, size_t n)
TCMalloc_PageMap3::INTERIOR_BITS	.\TCPageMap.h	/^  static const int INTERIOR_BITS = (BITS + 2) \/ 3; \/\/ Round-up$/;"	m	class:TCMalloc_PageMap3	access:private
TCMalloc_PageMap3::INTERIOR_LENGTH	.\TCPageMap.h	/^  static const int INTERIOR_LENGTH = 1 << INTERIOR_BITS;$/;"	m	class:TCMalloc_PageMap3	access:private
TCMalloc_PageMap3::LEAF_BITS	.\TCPageMap.h	/^  static const int LEAF_BITS = BITS - 2*INTERIOR_BITS;$/;"	m	class:TCMalloc_PageMap3	access:private
TCMalloc_PageMap3::LEAF_LENGTH	.\TCPageMap.h	/^  static const int LEAF_LENGTH = 1 << LEAF_BITS;$/;"	m	class:TCMalloc_PageMap3	access:private
TCMalloc_PageMap3::Leaf	.\TCPageMap.h	/^  struct Leaf {$/;"	s	class:TCMalloc_PageMap3	access:private
TCMalloc_PageMap3::Leaf::values	.\TCPageMap.h	/^    void* values[LEAF_LENGTH];$/;"	m	struct:TCMalloc_PageMap3::Leaf	access:public
TCMalloc_PageMap3::NewNode	.\TCPageMap.h	/^  Node* NewNode() {$/;"	f	class:TCMalloc_PageMap3	access:private	signature:()
TCMalloc_PageMap3::Node	.\TCPageMap.h	/^  struct Node {$/;"	s	class:TCMalloc_PageMap3	access:private
TCMalloc_PageMap3::Node::ptrs	.\TCPageMap.h	/^    Node* ptrs[INTERIOR_LENGTH];$/;"	m	struct:TCMalloc_PageMap3::Node	access:public
TCMalloc_PageMap3::Number	.\TCPageMap.h	/^  typedef uintptr_t Number;$/;"	t	class:TCMalloc_PageMap3	access:public
TCMalloc_PageMap3::PreallocateMoreMemory	.\TCPageMap.h	/^  void PreallocateMoreMemory() {$/;"	f	class:TCMalloc_PageMap3	access:public	signature:()
TCMalloc_PageMap3::allocator_	.\TCPageMap.h	/^  void* (*allocator_)(size_t);          \/\/ Memory allocator$/;"	m	class:TCMalloc_PageMap3	access:private
TCMalloc_PageMap3::get	.\TCPageMap.h	/^  void* get(Number k) const {$/;"	f	class:TCMalloc_PageMap3	access:public	signature:(Number k) const
TCMalloc_PageMap3::init	.\TCPageMap.h	/^  void init(void* (*allocator)(size_t)) {$/;"	f	class:TCMalloc_PageMap3	access:public	signature:(void* (*allocator)(size_t))
TCMalloc_PageMap3::root_	.\TCPageMap.h	/^  Node* root_;                          \/\/ Root of radix tree$/;"	m	class:TCMalloc_PageMap3	access:private
TCMalloc_PageMap3::set	.\TCPageMap.h	/^  void set(Number k, void* v) {$/;"	f	class:TCMalloc_PageMap3	access:public	signature:(Number k, void* v)
TCMalloc_PageMap3::visitAllocations	.\TCPageMap.h	/^  void visitAllocations(Visitor& visitor, const MemoryReader& reader) {$/;"	f	class:TCMalloc_PageMap3	access:public	signature:(Visitor& visitor, const MemoryReader& reader)
TCMalloc_PageMap3::visitValues	.\TCPageMap.h	/^  void visitValues(Visitor& visitor, const MemoryReader& reader) {$/;"	f	class:TCMalloc_PageMap3	access:public	signature:(Visitor& visitor, const MemoryReader& reader)
TCMalloc_SlowLock	.\TCSpinLock.h	/^static void TCMalloc_SlowLock(LPLONG lockword) {$/;"	f	signature:(LPLONG lockword)
TCMalloc_SlowLock	.\TCSpinLock.h	/^static void TCMalloc_SlowLock(LPLONG lockword);$/;"	p	signature:(LPLONG lockword)
TCMalloc_SlowLock	.\TCSpinLock.h	/^static void TCMalloc_SlowLock(volatile unsigned int* lockword) {$/;"	f	signature:(volatile unsigned int* lockword)
TCMalloc_SlowLock	.\TCSpinLock.h	/^static void TCMalloc_SlowLock(volatile unsigned int* lockword);$/;"	p	signature:(volatile unsigned int* lockword)
TCMalloc_SpinLock	.\TCSpinLock.h	/^struct TCMalloc_SpinLock {$/;"	s
TCMalloc_SpinLock::Finalize	.\TCSpinLock.h	/^    inline void Finalize() { }$/;"	f	struct:TCMalloc_SpinLock	access:public	signature:()
TCMalloc_SpinLock::Finalize	.\TCSpinLock.h	/^  inline void Finalize() {$/;"	f	struct:TCMalloc_SpinLock	access:public	signature:()
TCMalloc_SpinLock::Init	.\TCSpinLock.h	/^    inline void Init() { lockword_ = 0; }$/;"	f	struct:TCMalloc_SpinLock	access:public	signature:()
TCMalloc_SpinLock::Init	.\TCSpinLock.h	/^    inline void Init() { m_lockword = 0; }$/;"	f	struct:TCMalloc_SpinLock	access:public	signature:()
TCMalloc_SpinLock::Init	.\TCSpinLock.h	/^  inline void Init() {$/;"	f	struct:TCMalloc_SpinLock	access:public	signature:()
TCMalloc_SpinLock::IsHeld	.\TCSpinLock.h	/^    inline bool IsHeld() const {$/;"	f	struct:TCMalloc_SpinLock	access:public	signature:() const
TCMalloc_SpinLock::IsHeld	.\TCSpinLock.h	/^  bool IsHeld() {$/;"	f	struct:TCMalloc_SpinLock	access:public	signature:()
TCMalloc_SpinLock::Lock	.\TCSpinLock.h	/^    inline void Lock() {$/;"	f	struct:TCMalloc_SpinLock	access:public	signature:()
TCMalloc_SpinLock::Lock	.\TCSpinLock.h	/^  inline void Lock() {$/;"	f	struct:TCMalloc_SpinLock	access:public	signature:()
TCMalloc_SpinLock::Unlock	.\TCSpinLock.h	/^    inline void Unlock() {$/;"	f	struct:TCMalloc_SpinLock	access:public	signature:()
TCMalloc_SpinLock::Unlock	.\TCSpinLock.h	/^  inline void Unlock() {$/;"	f	struct:TCMalloc_SpinLock	access:public	signature:()
TCMalloc_SpinLock::lockword_	.\TCSpinLock.h	/^    volatile unsigned int lockword_;$/;"	m	struct:TCMalloc_SpinLock	access:public
TCMalloc_SpinLock::m_lockword	.\TCSpinLock.h	/^    LONG m_lockword;$/;"	m	struct:TCMalloc_SpinLock	access:public
TCMalloc_SpinLock::private_lock_	.\TCSpinLock.h	/^  pthread_mutex_t private_lock_;$/;"	m	struct:TCMalloc_SpinLock	access:public
TCMalloc_SpinLockHolder	.\TCSpinLock.h	/^  inline explicit TCMalloc_SpinLockHolder(TCMalloc_SpinLock* l)$/;"	f	class:TCMalloc_SpinLockHolder	access:public	signature:(TCMalloc_SpinLock* l)
TCMalloc_SpinLockHolder	.\TCSpinLock.h	/^class TCMalloc_SpinLockHolder {$/;"	c
TCMalloc_SpinLockHolder::TCMalloc_SpinLockHolder	.\TCSpinLock.h	/^  inline explicit TCMalloc_SpinLockHolder(TCMalloc_SpinLock* l)$/;"	f	class:TCMalloc_SpinLockHolder	access:public	signature:(TCMalloc_SpinLock* l)
TCMalloc_SpinLockHolder::lock_	.\TCSpinLock.h	/^  TCMalloc_SpinLock* lock_;$/;"	m	class:TCMalloc_SpinLockHolder	access:private
TCMalloc_SpinLockHolder::~TCMalloc_SpinLockHolder	.\TCSpinLock.h	/^  inline ~TCMalloc_SpinLockHolder() { lock_->Unlock(); }$/;"	f	class:TCMalloc_SpinLockHolder	access:public	signature:()
TCMalloc_SystemAlloc	.\TCSystemAlloc.cpp	/^void* TCMalloc_SystemAlloc(size_t size, size_t *actual_size, size_t alignment) {$/;"	f	signature:(size_t size, size_t *actual_size, size_t alignment)
TCMalloc_SystemAlloc	.\TCSystemAlloc.h	/^extern void* TCMalloc_SystemAlloc(size_t bytes, size_t *actual_bytes,$/;"	p	signature:(size_t bytes, size_t *actual_bytes, size_t alignment = 0)
TCMalloc_SystemCommit	.\TCSystemAlloc.cpp	/^void TCMalloc_SystemCommit(void* start, size_t length)$/;"	f	signature:(void* start, size_t length)
TCMalloc_SystemCommit	.\TCSystemAlloc.h	/^extern void TCMalloc_SystemCommit(void* start, size_t length);$/;"	p	signature:(void* start, size_t length)
TCMalloc_SystemCommit	.\TCSystemAlloc.h	/^inline void TCMalloc_SystemCommit(void*, size_t) { }$/;"	f	signature:(void*, size_t)
TCMalloc_SystemRelease	.\TCSystemAlloc.cpp	/^void TCMalloc_SystemRelease(void* start, size_t length)$/;"	f	signature:(void* start, size_t length)
TCMalloc_SystemRelease	.\TCSystemAlloc.h	/^extern void TCMalloc_SystemRelease(void* start, size_t length);$/;"	p	signature:(void* start, size_t length)
TCMalloc_SystemRelease	.\TCSystemAlloc.h	/^inline void TCMalloc_SystemRelease(void*, size_t) { }$/;"	f	signature:(void*, size_t)
TCMalloc_ThreadCache	.\FastMalloc.cpp	/^class TCMalloc_ThreadCache {$/;"	c	namespace:WTF	file:
TCMalloc_ThreadCache_FreeList	.\FastMalloc.cpp	/^class TCMalloc_ThreadCache_FreeList {$/;"	c	namespace:WTF	file:
THREADNAME_INFO	.\ThreadingWin.cpp	/^} THREADNAME_INFO;$/;"	t	namespace:WTF	typeref:struct:WTF::tagTHREADNAME_INFO	file:
THUMB_FUNC_PARAM	.\InlineASM.h	40;"	d
THUMB_FUNC_PARAM	.\InlineASM.h	42;"	d
TLS_OUT_OF_INDEXES	.\FastMalloc.cpp	116;"	d	file:
TLS_OUT_OF_INDEXES	.\ThreadSpecific.h	131;"	d
TO_MASK	.\unicode\wince\UnicodeWinCE.h	32;"	d
TemporaryChange	.\TemporaryChange.h	/^    TemporaryChange(T& scopedVariable, T newValue)$/;"	f	class:WTF::TemporaryChange	access:public	signature:(T& scopedVariable, T newValue)
TemporaryChange	.\TemporaryChange.h	/^class TemporaryChange {$/;"	c	namespace:WTF
TemporaryChange_h	.\TemporaryChange.h	27;"	d
Ten_pmax	.\dtoa.cpp	139;"	d	file:
TestBaseClass	.\TypeTraits.cpp	/^class TestBaseClass {$/;"	c	namespace:WTF	file:
TestDerivedClass	.\TypeTraits.cpp	/^class TestDerivedClass : public TestBaseClass<int> {$/;"	c	namespace:WTF	file:	inherits:TestBaseClass
TextCaseInsensitive	.\text\StringImpl.h	/^enum TextCaseSensitivity { TextCaseSensitive, TextCaseInsensitive };$/;"	e	enum:WTF::TextCaseSensitivity
TextCaseSensitive	.\text\StringImpl.h	/^enum TextCaseSensitivity { TextCaseSensitive, TextCaseInsensitive };$/;"	e	enum:WTF::TextCaseSensitivity
TextCaseSensitivity	.\text\StringImpl.h	/^enum TextCaseSensitivity { TextCaseSensitive, TextCaseInsensitive };$/;"	g	namespace:WTF
TextPosition	.\text\TextPosition.h	/^    TextPosition() { }$/;"	f	class:WTF::TextPosition	access:public	signature:()
TextPosition	.\text\TextPosition.h	/^    TextPosition(OrdinalNumber line, OrdinalNumber column)$/;"	f	class:WTF::TextPosition	access:public	signature:(OrdinalNumber line, OrdinalNumber column)
TextPosition	.\text\TextPosition.h	/^class TextPosition {$/;"	c	namespace:WTF
TextPosition_h	.\text\TextPosition.h	26;"	d
ThreadCondition	.\ThreadingPrimitives.h	/^    WTF_EXPORT_PRIVATE ThreadCondition();$/;"	p	class:WTF::ThreadCondition	access:public	signature:()
ThreadCondition	.\ThreadingPrimitives.h	/^class ThreadCondition {$/;"	c	namespace:WTF
ThreadCondition	.\ThreadingPthreads.cpp	/^ThreadCondition::ThreadCondition()$/;"	f	class:WTF::ThreadCondition	signature:()
ThreadCondition	.\ThreadingWin.cpp	/^ThreadCondition::ThreadCondition()$/;"	f	class:WTF::ThreadCondition	signature:()
ThreadFunction	.\ParallelJobsGeneric.h	/^    typedef void (*ThreadFunction)(void*);$/;"	t	class:WTF::ParallelEnvironment	access:public
ThreadFunction	.\ParallelJobsLibdispatch.h	/^    typedef void (*ThreadFunction)(void*);$/;"	t	class:WTF::ParallelEnvironment	access:public
ThreadFunction	.\ParallelJobsOpenMP.h	/^    typedef void (*ThreadFunction)(void*);$/;"	t	class:WTF::ParallelEnvironment	access:public
ThreadFunction	.\ThreadFunctionInvocation.h	/^typedef void (*ThreadFunction)(void* argument);$/;"	t	namespace:WTF
ThreadFunction	.\Threading.h	/^typedef void (*ThreadFunction)(void* argument);$/;"	t	namespace:WTF
ThreadFunctionInvocation	.\ThreadFunctionInvocation.h	/^    ThreadFunctionInvocation(ThreadFunction function, void* data)$/;"	f	struct:WTF::ThreadFunctionInvocation	access:public	signature:(ThreadFunction function, void* data)
ThreadFunctionInvocation	.\ThreadFunctionInvocation.h	/^struct ThreadFunctionInvocation {$/;"	s	namespace:WTF
ThreadFunctionInvocation_h	.\ThreadFunctionInvocation.h	30;"	d
ThreadFunctionWithReturnValue	.\Threading.cpp	/^typedef void* (*ThreadFunctionWithReturnValue)(void* argument);$/;"	t	namespace:WTF	file:
ThreadFunctionWithReturnValueInvocation	.\Threading.cpp	/^    ThreadFunctionWithReturnValueInvocation(ThreadFunctionWithReturnValue function, void* data)$/;"	f	struct:WTF::ThreadFunctionWithReturnValueInvocation	access:public	signature:(ThreadFunctionWithReturnValue function, void* data)
ThreadFunctionWithReturnValueInvocation	.\Threading.cpp	/^struct ThreadFunctionWithReturnValueInvocation {$/;"	s	namespace:WTF	file:
ThreadIdentifier	.\FastMalloc.cpp	/^  typedef DWORD ThreadIdentifier;$/;"	t	class:WTF::TCMalloc_ThreadCache	file:	access:private
ThreadIdentifier	.\FastMalloc.cpp	/^  typedef pthread_t ThreadIdentifier;$/;"	t	class:WTF::TCMalloc_ThreadCache	file:	access:private
ThreadIdentifier	.\MainThread.h	/^typedef uint32_t ThreadIdentifier;$/;"	t	namespace:WTF
ThreadIdentifier	.\Threading.h	/^typedef uint32_t ThreadIdentifier;$/;"	t	namespace:WTF
ThreadIdentifierData	.\ThreadIdentifierDataPthreads.h	/^    ThreadIdentifierData(ThreadIdentifier identifier)$/;"	f	class:WTF::ThreadIdentifierData	access:private	signature:(ThreadIdentifier identifier)
ThreadIdentifierData	.\ThreadIdentifierDataPthreads.h	/^class ThreadIdentifierData {$/;"	c	namespace:WTF
ThreadIdentifierDataPthreads_h	.\ThreadIdentifierDataPthreads.h	32;"	d
ThreadMap	.\ThreadingPthreads.cpp	/^typedef HashMap<ThreadIdentifier, pthread_t> ThreadMap;$/;"	t	namespace:WTF	file:
ThreadPrivate	.\ParallelJobsGeneric.h	/^        ThreadPrivate()$/;"	f	class:WTF::ParallelEnvironment::ThreadPrivate	access:public	signature:()
ThreadPrivate	.\ParallelJobsGeneric.h	/^    class ThreadPrivate : public RefCounted<ThreadPrivate> {$/;"	c	class:WTF::ParallelEnvironment	inherits:RefCounted	access:public
ThreadRestrictionVerifier	.\ThreadRestrictionVerifier.h	/^    ThreadRestrictionVerifier()$/;"	f	class:WTF::ThreadRestrictionVerifier	access:public	signature:()
ThreadRestrictionVerifier	.\ThreadRestrictionVerifier.h	/^class ThreadRestrictionVerifier {$/;"	c	namespace:WTF
ThreadRestrictionVerifier_h	.\ThreadRestrictionVerifier.h	32;"	d
ThreadSafeRefCounted	.\ThreadSafeRefCounted.h	/^    ThreadSafeRefCounted()$/;"	f	class:WTF::ThreadSafeRefCounted	access:protected	signature:()
ThreadSafeRefCounted	.\ThreadSafeRefCounted.h	/^template<class T> class ThreadSafeRefCounted : public ThreadSafeRefCountedBase {$/;"	c	namespace:WTF	inherits:ThreadSafeRefCountedBase
ThreadSafeRefCountedBase	.\ThreadSafeRefCounted.h	/^    ThreadSafeRefCountedBase(int initialRefCount = 1)$/;"	f	class:WTF::ThreadSafeRefCountedBase	access:public	signature:(int initialRefCount = 1)
ThreadSafeRefCountedBase	.\ThreadSafeRefCounted.h	/^class ThreadSafeRefCountedBase {$/;"	c	namespace:WTF
ThreadSafeRefCounted_h	.\ThreadSafeRefCounted.h	60;"	d
ThreadSpecific	.\ThreadSpecific.h	/^    ThreadSpecific();$/;"	p	class:WTF::ThreadSpecific	access:public	signature:()
ThreadSpecific	.\ThreadSpecific.h	/^inline ThreadSpecific<T>::ThreadSpecific()$/;"	f	class:WTF::ThreadSpecific	signature:()
ThreadSpecific	.\ThreadSpecific.h	/^template<typename T> class ThreadSpecific {$/;"	c	namespace:WTF
ThreadSpecificThreadExit	.\ThreadSpecific.h	/^    friend void ThreadSpecificThreadExit();$/;"	p	class:WTF::ThreadSpecific	access:friend	signature:()
ThreadSpecificThreadExit	.\ThreadSpecific.h	/^void ThreadSpecificThreadExit();$/;"	p	namespace:WTF	signature:()
ThreadSpecificThreadExit	.\ThreadSpecificWin.cpp	/^void ThreadSpecificThreadExit()$/;"	f	namespace:WTF	signature:()
ThreadingPrimitives_h	.\ThreadingPrimitives.h	32;"	d
ThreadingWindowWndProc	.\win\MainThreadWin.cpp	/^LRESULT CALLBACK ThreadingWindowWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)$/;"	f	namespace:WTF	signature:(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
Threading_h	.\Threading.h	60;"	d
Times	.\dtoa\diy-fp.h	/^        static DiyFp Times(const DiyFp& a, const DiyFp& b) {$/;"	f	class:WTF::double_conversion::DiyFp	access:public	signature:(const DiyFp& a, const DiyFp& b)
Times10	.\dtoa\bignum.h	/^        void Times10() { return MultiplyByUInt32(10); }$/;"	f	class:WTF::double_conversion::Bignum	access:public	signature:()
Tiny0	.\dtoa.cpp	146;"	d	file:
Tiny1	.\dtoa.cpp	147;"	d	file:
ToExponential	.\dtoa\double-conversion.cc	/^    bool DoubleToStringConverter::ToExponential($/;"	f	class:WTF::double_conversion::DoubleToStringConverter	signature:( double value, int requested_digits, StringBuilder* result_builder) const
ToExponential	.\dtoa\double-conversion.h	/^        bool ToExponential(double value,$/;"	p	class:WTF::double_conversion::DoubleToStringConverter	access:public	signature:(double value, int requested_digits, StringBuilder* result_builder) const
ToFixed	.\dtoa\double-conversion.cc	/^    bool DoubleToStringConverter::ToFixed(double value,$/;"	f	class:WTF::double_conversion::DoubleToStringConverter	signature:(double value, int requested_digits, StringBuilder* result_builder) const
ToFixed	.\dtoa\double-conversion.h	/^        bool ToFixed(double value,$/;"	p	class:WTF::double_conversion::DoubleToStringConverter	access:public	signature:(double value, int requested_digits, StringBuilder* result_builder) const
ToHexString	.\dtoa\bignum.cc	/^    bool Bignum::ToHexString(char* buffer, int buffer_size) const {$/;"	f	class:WTF::double_conversion::Bignum	signature:(char* buffer, int buffer_size) const
ToHexString	.\dtoa\bignum.h	/^        bool ToHexString(char* buffer, int buffer_size) const;$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(char* buffer, int buffer_size) const
ToPrecision	.\dtoa\double-conversion.cc	/^    bool DoubleToStringConverter::ToPrecision(double value,$/;"	f	class:WTF::double_conversion::DoubleToStringConverter	signature:(double value, int precision, StringBuilder* result_builder) const
ToPrecision	.\dtoa\double-conversion.h	/^        bool ToPrecision(double value,$/;"	p	class:WTF::double_conversion::DoubleToStringConverter	access:public	signature:(double value, int precision, StringBuilder* result_builder) const
ToShortest	.\dtoa\double-conversion.cc	/^    bool DoubleToStringConverter::ToShortest(double value,$/;"	f	class:WTF::double_conversion::DoubleToStringConverter	signature:(double value, StringBuilder* result_builder) const
ToShortest	.\dtoa\double-conversion.h	/^        bool ToShortest(double value, StringBuilder* result_builder) const;$/;"	p	class:WTF::double_conversion::DoubleToStringConverter	access:public	signature:(double value, StringBuilder* result_builder) const
TraitType	.\HashTraits.h	/^        typedef T TraitType;$/;"	t	struct:WTF::GenericHashTraits	access:public
TraitType	.\HashTraits.h	/^        typedef pair<typename FirstTraits::TraitType, typename SecondTraits::TraitType> TraitType;$/;"	t	struct:WTF::PairHashTraits	access:public
TraitType	.\ValueCheck.h	/^    typedef P* TraitType;$/;"	t	struct:WTF::ValueCheck	access:public
TraitType	.\ValueCheck.h	/^    typedef T TraitType;$/;"	t	struct:WTF::ValueCheck	access:public
TraitType	.\Vector.h	/^        typedef Vector<T> TraitType;$/;"	t	struct:WTF::ValueCheck	access:public
Translator	.\RefPtrHashMap.h	/^            Translator;$/;"	t	class:WTF::HashMap	access:private
Tree	.\MetaAllocator.h	/^    typedef RedBlackTree<FreeSpaceNode, size_t> Tree;$/;"	t	class:WTF::MetaAllocator	access:private
TrimLeadingZeros	.\dtoa\strtod.cc	/^    static Vector<const char> TrimLeadingZeros(Vector<const char> buffer) {$/;"	f	namespace:WTF::double_conversion	file:	signature:(Vector<const char> buffer)
TrimToMaxSignificantDigits	.\dtoa\strtod.cc	/^    static void TrimToMaxSignificantDigits(Vector<const char> buffer,$/;"	f	namespace:WTF::double_conversion	file:	signature:(Vector<const char> buffer, int exponent, char* significant_buffer, int* significant_exponent)
TrimTrailingZeros	.\dtoa\strtod.cc	/^    static Vector<const char> TrimTrailingZeros(Vector<const char> buffer) {$/;"	f	namespace:WTF::double_conversion	file:	signature:(Vector<const char> buffer)
TrimZeros	.\dtoa\fixed-dtoa.cc	/^    static void TrimZeros(Vector<char> buffer, int* length, int* decimal_point) {$/;"	f	namespace:WTF::double_conversion	file:	signature:(Vector<char> buffer, int* length, int* decimal_point)
TryDevMem	.\TCSystemAlloc.cpp	/^static void* TryDevMem(size_t size, size_t *actual_size, size_t alignment) {$/;"	f	file:	signature:(size_t size, size_t *actual_size, size_t alignment)
TryMallocReturnValue	.\FastMalloc.h	/^        TryMallocReturnValue(const TryMallocReturnValue& source)$/;"	f	struct:WTF::TryMallocReturnValue	access:public	signature:(const TryMallocReturnValue& source)
TryMallocReturnValue	.\FastMalloc.h	/^        TryMallocReturnValue(void* data)$/;"	f	struct:WTF::TryMallocReturnValue	access:public	signature:(void* data)
TryMallocReturnValue	.\FastMalloc.h	/^    struct TryMallocReturnValue {$/;"	s	namespace:WTF
TryMmap	.\TCSystemAlloc.cpp	/^static void* TryMmap(size_t size, size_t *actual_size, size_t alignment) {$/;"	f	file:	signature:(size_t size, size_t *actual_size, size_t alignment)
TrySbrk	.\TCSystemAlloc.cpp	/^static void* TrySbrk(size_t size, size_t *actual_size, size_t alignment) {$/;"	f	file:	signature:(size_t size, size_t *actual_size, size_t alignment)
TryVirtualAlloc	.\TCSystemAlloc.cpp	/^static void* TryVirtualAlloc(size_t size, size_t *actual_size, size_t alignment) {$/;"	f	file:	signature:(size_t size, size_t *actual_size, size_t alignment)
Type	.\FastMalloc.cpp	/^  typedef TCMalloc_PageMap2<32 - kPageShift> Type;$/;"	t	class:WTF::MapSelector	file:	access:public
Type	.\FastMalloc.cpp	/^  typedef TCMalloc_PageMap3<64 - kPageShift - kBitsUnusedOn64Bit> Type;$/;"	t	class:WTF::MapSelector	file:	access:public
Type	.\FastMalloc.cpp	/^  typedef TCMalloc_PageMap3<BITS-kPageShift> Type;$/;"	t	class:WTF::MapSelector	file:	access:public
Type	.\PassTraits.h	/^    typedef OwnPtr<T> Type;$/;"	t	struct:WTF::PassTraits	access:public
Type	.\PassTraits.h	/^    typedef RefPtr<T> Type;$/;"	t	struct:WTF::PassTraits	access:public
Type	.\PassTraits.h	/^    typedef T Type;$/;"	t	struct:WTF::PassTraits	access:public
Type	.\TypeTraits.h	/^        >::Type Type;$/;"	t	struct:WTF::DecayArray	access:public
Type	.\TypeTraits.h	/^        typedef T Type;$/;"	t	struct:WTF::RemoveConst	access:public
Type	.\TypeTraits.h	/^        typedef T Type;$/;"	t	struct:WTF::RemoveExtent	access:public
Type	.\TypeTraits.h	/^        typedef T Type;$/;"	t	struct:WTF::RemovePointer	access:public
Type	.\TypeTraits.h	/^        typedef T Type;$/;"	t	struct:WTF::RemoveReference	access:public
Type	.\TypeTraits.h	/^        typedef T Type;$/;"	t	struct:WTF::RemoveTemplate	access:public
Type	.\TypeTraits.h	/^        typedef T Type;$/;"	t	struct:WTF::RemoveVolatile	access:public
Type	.\TypeTraits.h	/^        typedef typename RemoveVolatile<typename RemoveConst<T>::Type>::Type Type;$/;"	t	struct:WTF::RemoveConstVolatile	access:public
Type	.\TypeTraits.h	/^    template <bool Predicate, class If, class Then> struct Conditional  { typedef If Type; };$/;"	t	struct:WTF::Conditional	access:public
Type	.\TypeTraits.h	/^    template <class If, class Then> struct Conditional<false, If, Then> { typedef Then Type; };$/;"	t	struct:WTF::Conditional	access:public
TypeChecker	.\Functional.h	/^    TypeChecker { };$/;"	s	class:WTF::HasRefAndDeref	access:private
TypeOperations	.\Deque.h	/^        typedef VectorTypeOperations<T> TypeOperations;$/;"	t	class:WTF::Deque	access:private
TypeOperations	.\Vector.h	/^        typedef VectorTypeOperations<T> TypeOperations;$/;"	t	class:WTF::Vector	access:private
TypeTraits_h	.\TypeTraits.h	23;"	d
TypedArrayBase	.\TypedArrayBase.h	/^    TypedArrayBase(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::TypedArrayBase	access:protected	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
TypedArrayBase	.\TypedArrayBase.h	/^class TypedArrayBase : public ArrayBufferView {$/;"	c	namespace:WTF	inherits:ArrayBufferView
TypedArrayBase_h	.\TypedArrayBase.h	28;"	d
U	.\TypeTraits.h	/^        typedef typename RemoveReference<T>::Type U;$/;"	t	struct:WTF::DecayArray	access:public
U	.\dtoa.cpp	/^} U;$/;"	t	namespace:WTF	typeref:union:WTF::__anon4	file:
U16_BACK_1	.\unicode\UnicodeMacrosFromICU.h	55;"	d
U16_FWD_1	.\unicode\UnicodeMacrosFromICU.h	72;"	d
U16_GET	.\unicode\UnicodeMacrosFromICU.h	28;"	d
U16_GET_SUPPLEMENTARY	.\unicode\UnicodeMacrosFromICU.h	15;"	d
U16_IS_LEAD	.\unicode\UnicodeMacrosFromICU.h	12;"	d
U16_IS_SINGLE	.\unicode\UnicodeMacrosFromICU.h	24;"	d
U16_IS_SURROGATE	.\unicode\UnicodeMacrosFromICU.h	25;"	d
U16_IS_SURROGATE_LEAD	.\unicode\UnicodeMacrosFromICU.h	26;"	d
U16_IS_TRAIL	.\unicode\UnicodeMacrosFromICU.h	13;"	d
U16_LEAD	.\unicode\UnicodeMacrosFromICU.h	18;"	d
U16_LENGTH	.\unicode\UnicodeMacrosFromICU.h	20;"	d
U16_NEXT	.\unicode\UnicodeMacrosFromICU.h	61;"	d
U16_PREV	.\unicode\UnicodeMacrosFromICU.h	44;"	d
U16_SURROGATE_OFFSET	.\unicode\UnicodeMacrosFromICU.h	14;"	d
U16_TRAIL	.\unicode\UnicodeMacrosFromICU.h	19;"	d
U8_APPEND_UNSAFE	.\unicode\UnicodeMacrosFromICU.h	82;"	d
U8_MAX_LENGTH	.\unicode\UnicodeMacrosFromICU.h	80;"	d
UChar	.\unicode\glib\UnicodeGLib.h	/^typedef uint16_t UChar;$/;"	t
UChar	.\unicode\qt4\UnicodeQt4.h	/^typedef wchar_t UChar;$/;"	t
UChar32	.\unicode\glib\UnicodeGLib.h	/^typedef int32_t UChar32;$/;"	t
UChar32	.\unicode\qt4\UnicodeQt4.h	/^typedef uint32_t UChar32;$/;"	t
UCharBuffer	.\text\AtomicString.cpp	/^struct UCharBuffer {$/;"	s	namespace:WTF	file:
UCharBufferTranslator	.\text\AtomicString.cpp	/^struct UCharBufferTranslator {$/;"	s	namespace:WTF	file:
UCharIsTwoBytes	.\unicode\Unicode.h	/^COMPILE_ASSERT(sizeof(UChar) == 2, UCharIsTwoBytes);$/;"	v
UCharPredicate	.\text\StringImpl.cpp	/^    inline UCharPredicate(CharacterMatchFunctionPtr function): m_function(function) { }$/;"	f	class:WTF::UCharPredicate	access:public	signature:(CharacterMatchFunctionPtr function)
UCharPredicate	.\text\StringImpl.cpp	/^class UCharPredicate {$/;"	c	namespace:WTF	file:
UINT64_2PART_C	.\dtoa\utils.h	87;"	d
UInt128	.\dtoa\fixed-dtoa.cc	/^        UInt128() : high_bits_(0), low_bits_(0) { }$/;"	f	class:WTF::double_conversion::UInt128	access:public	signature:()
UInt128	.\dtoa\fixed-dtoa.cc	/^        UInt128(uint64_t high, uint64_t low) : high_bits_(high), low_bits_(low) { }$/;"	f	class:WTF::double_conversion::UInt128	access:public	signature:(uint64_t high, uint64_t low)
UInt128	.\dtoa\fixed-dtoa.cc	/^    class UInt128 {$/;"	c	namespace:WTF::double_conversion	file:
UNIMPLEMENTED	.\dtoa\utils.h	35;"	d
UNIQUE_ZERO	.\dtoa\double-conversion.h	/^            UNIQUE_ZERO = 8$/;"	e	enum:WTF::double_conversion::DoubleToStringConverter::Flags
UNLIKELY	.\Compiler.h	162;"	d
UNLIKELY	.\Compiler.h	164;"	d
UNREACHABLE	.\dtoa\utils.h	36;"	d
UNUSED_PARAM	.\UnusedParam.h	32;"	d
UNUSED_PARAM	.\UnusedParam.h	34;"	d
UPPER	.\TCPackedCache.h	/^  typedef T UPPER;$/;"	t	class:PackedCache	access:private
URLBuffer	.\url\src\URLBuffer.h	/^    URLBuffer() : m_buffer(0), m_capacity(0), m_length(0) { }$/;"	f	class:WTF::URLBuffer	access:public	signature:()
URLBuffer	.\url\src\URLBuffer.h	/^class URLBuffer {$/;"	c	namespace:WTF
URLBuffer_h	.\url\src\URLBuffer.h	30;"	d
URLCharacterTypes	.\url\src\URLCharacterTypes.h	/^class URLCharacterTypes {$/;"	c	namespace:WTF
URLCharacterTypes_h	.\url\src\URLCharacterTypes.h	30;"	d
URLComponent	.\url\src\URLComponent.h	/^    URLComponent() : m_begin(0), m_length(-1) { }$/;"	f	class:WTF::URLComponent	access:public	signature:()
URLComponent	.\url\src\URLComponent.h	/^    URLComponent(int begin, int length) : m_begin(begin), m_length(length) { }$/;"	f	class:WTF::URLComponent	access:public	signature:(int begin, int length)
URLComponent	.\url\src\URLComponent.h	/^class URLComponent {$/;"	c	namespace:WTF
URLComponent_h	.\url\src\URLComponent.h	30;"	d
URLEscape_h	.\url\src\URLEscape.h	31;"	d
URLParser	.\url\src\URLParser.h	/^    URLParser();$/;"	p	class:WTF::URLParser	access:private	signature:()
URLParser	.\url\src\URLParser.h	/^class URLParser {$/;"	c	namespace:WTF
URLParser_h	.\url\src\URLParser.h	38;"	d
URLQueryCanonicalizer	.\url\src\URLQueryCanonicalizer.h	/^class URLQueryCanonicalizer {$/;"	c	namespace:WTF
URLQueryCanonicalizer_h	.\url\src\URLQueryCanonicalizer.h	31;"	d
URLSegments	.\url\src\URLSegments.h	/^    URLSegments() { }$/;"	f	class:WTF::URLSegments	access:public	signature:()
URLSegments	.\url\src\URLSegments.h	/^class URLSegments {$/;"	c	namespace:WTF
URLSegments_h	.\url\src\URLSegments.h	30;"	d
URLString	.\url\api\URLString.h	/^    URLString() { }$/;"	f	class:WTF::URLString	access:public	signature:()
URLString	.\url\api\URLString.h	/^    explicit URLString(const String& string)$/;"	f	class:WTF::URLString	access:private	signature:(const String& string)
URLString	.\url\api\URLString.h	/^class URLString {$/;"	c	namespace:WTF
URLString_h	.\url\api\URLString.h	27;"	d
USCRIPT_ARABIC	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_ARABIC       =  2,  \/* Arab *\/$/;"	e	enum:UScriptCode
USCRIPT_ARMENIAN	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_ARMENIAN     =  3,  \/* Armn *\/$/;"	e	enum:UScriptCode
USCRIPT_BALINESE	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_BALINESE                      = 62, \/* Bali *\/$/;"	e	enum:UScriptCode
USCRIPT_BATAK	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_BATAK                         = 63, \/* Batk *\/$/;"	e	enum:UScriptCode
USCRIPT_BENGALI	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_BENGALI      =  4,  \/* Beng *\/$/;"	e	enum:UScriptCode
USCRIPT_BLISSYMBOLS	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_BLISSYMBOLS                   = 64, \/* Blis *\/$/;"	e	enum:UScriptCode
USCRIPT_BOPOMOFO	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_BOPOMOFO     =  5,  \/* Bopo *\/$/;"	e	enum:UScriptCode
USCRIPT_BRAHMI	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_BRAHMI                        = 65, \/* Brah *\/$/;"	e	enum:UScriptCode
USCRIPT_BRAILLE	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_BRAILLE      = 46,  \/* Brai *\/$/;"	e	enum:UScriptCode
USCRIPT_BUGINESE	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_BUGINESE      = 55, \/* Bugi *\/$/;"	e	enum:UScriptCode
USCRIPT_BUHID	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_BUHID        = 44,  \/* Buhd *\/$/;"	e	enum:UScriptCode
USCRIPT_CANADIAN_ABORIGINAL	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_CANADIAN_ABORIGINAL = 40,  \/* Cans *\/$/;"	e	enum:UScriptCode
USCRIPT_CHAM	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_CHAM                          = 66, \/* Cham *\/$/;"	e	enum:UScriptCode
USCRIPT_CHEROKEE	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_CHEROKEE     =  6,  \/* Cher *\/$/;"	e	enum:UScriptCode
USCRIPT_CIRTH	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_CIRTH                         = 67, \/* Cirt *\/$/;"	e	enum:UScriptCode
USCRIPT_CODE_LIMIT	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_CODE_LIMIT    = 104$/;"	e	enum:UScriptCode
USCRIPT_COMMON	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_COMMON       =  0 , \/* Zyyy *\/$/;"	e	enum:UScriptCode
USCRIPT_COPTIC	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_COPTIC       =  7,  \/* Copt *\/$/;"	e	enum:UScriptCode
USCRIPT_CUNEIFORM	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_CUNEIFORM                     = 101,\/* Xsux *\/$/;"	e	enum:UScriptCode
USCRIPT_CYPRIOT	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_CYPRIOT      = 47,  \/* Cprt *\/$/;"	e	enum:UScriptCode
USCRIPT_CYRILLIC	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_CYRILLIC     =  8,  \/* Cyrl *\/$/;"	e	enum:UScriptCode
USCRIPT_DEMOTIC_EGYPTIAN	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_DEMOTIC_EGYPTIAN              = 69, \/* Egyd *\/$/;"	e	enum:UScriptCode
USCRIPT_DESERET	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_DESERET      =  9,  \/* Dsrt *\/$/;"	e	enum:UScriptCode
USCRIPT_DEVANAGARI	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_DEVANAGARI   = 10,  \/* Deva *\/$/;"	e	enum:UScriptCode
USCRIPT_EASTERN_SYRIAC	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_EASTERN_SYRIAC                = 97, \/* Syrn *\/$/;"	e	enum:UScriptCode
USCRIPT_EGYPTIAN_HIEROGLYPHS	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_EGYPTIAN_HIEROGLYPHS          = 71, \/* Egyp *\/$/;"	e	enum:UScriptCode
USCRIPT_ESTRANGELO_SYRIAC	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_ESTRANGELO_SYRIAC             = 95, \/* Syre *\/$/;"	e	enum:UScriptCode
USCRIPT_ETHIOPIC	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_ETHIOPIC     = 11,  \/* Ethi *\/$/;"	e	enum:UScriptCode
USCRIPT_GEORGIAN	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_GEORGIAN     = 12,  \/* Geor *\/$/;"	e	enum:UScriptCode
USCRIPT_GLAGOLITIC	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_GLAGOLITIC    = 56, \/* Glag *\/$/;"	e	enum:UScriptCode
USCRIPT_GOTHIC	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_GOTHIC       = 13,  \/* Goth *\/$/;"	e	enum:UScriptCode
USCRIPT_GREEK	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_GREEK        = 14,  \/* Grek *\/$/;"	e	enum:UScriptCode
USCRIPT_GUJARATI	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_GUJARATI     = 15,  \/* Gujr *\/$/;"	e	enum:UScriptCode
USCRIPT_GURMUKHI	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_GURMUKHI     = 16,  \/* Guru *\/$/;"	e	enum:UScriptCode
USCRIPT_HAN	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_HAN          = 17,  \/* Hani *\/$/;"	e	enum:UScriptCode
USCRIPT_HANGUL	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_HANGUL       = 18,  \/* Hang *\/$/;"	e	enum:UScriptCode
USCRIPT_HANUNOO	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_HANUNOO      = 43,  \/* Hano *\/$/;"	e	enum:UScriptCode
USCRIPT_HARAPPAN_INDUS	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_HARAPPAN_INDUS                = 77, \/* Inds *\/$/;"	e	enum:UScriptCode
USCRIPT_HEBREW	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_HEBREW       = 19,  \/* Hebr *\/$/;"	e	enum:UScriptCode
USCRIPT_HIERATIC_EGYPTIAN	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_HIERATIC_EGYPTIAN             = 70, \/* Egyh *\/$/;"	e	enum:UScriptCode
USCRIPT_HIRAGANA	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_HIRAGANA     = 20,  \/* Hira *\/$/;"	e	enum:UScriptCode
USCRIPT_INHERITED	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_INHERITED    =  1,  \/* Qaai *\/$/;"	e	enum:UScriptCode
USCRIPT_INVALID_CODE	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_INVALID_CODE = -1,$/;"	e	enum:UScriptCode
USCRIPT_JAVANESE	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_JAVANESE                      = 78, \/* Java *\/$/;"	e	enum:UScriptCode
USCRIPT_KANNADA	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_KANNADA      = 21,  \/* Knda *\/$/;"	e	enum:UScriptCode
USCRIPT_KATAKANA	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_KATAKANA     = 22,  \/* Kana *\/$/;"	e	enum:UScriptCode
USCRIPT_KATAKANA_OR_HIRAGANA	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_KATAKANA_OR_HIRAGANA = 54,\/*Hrkt *\/$/;"	e	enum:UScriptCode
USCRIPT_KAYAH_LI	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_KAYAH_LI                      = 79, \/* Kali *\/$/;"	e	enum:UScriptCode
USCRIPT_KHAROSHTHI	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_KHAROSHTHI    = 57, \/* Khar *\/$/;"	e	enum:UScriptCode
USCRIPT_KHMER	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_KHMER        = 23,  \/* Khmr *\/$/;"	e	enum:UScriptCode
USCRIPT_KHUTSURI	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_KHUTSURI                      = 72, \/* Geok *\/$/;"	e	enum:UScriptCode
USCRIPT_LAO	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_LAO          = 24,  \/* Laoo *\/$/;"	e	enum:UScriptCode
USCRIPT_LATIN	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_LATIN        = 25,  \/* Latn *\/$/;"	e	enum:UScriptCode
USCRIPT_LATIN_FRAKTUR	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_LATIN_FRAKTUR                 = 80, \/* Latf *\/$/;"	e	enum:UScriptCode
USCRIPT_LATIN_GAELIC	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_LATIN_GAELIC                  = 81, \/* Latg *\/$/;"	e	enum:UScriptCode
USCRIPT_LEPCHA	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_LEPCHA                        = 82, \/* Lepc *\/$/;"	e	enum:UScriptCode
USCRIPT_LIMBU	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_LIMBU        = 48,  \/* Limb *\/$/;"	e	enum:UScriptCode
USCRIPT_LINEAR_A	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_LINEAR_A                      = 83, \/* Lina *\/$/;"	e	enum:UScriptCode
USCRIPT_LINEAR_B	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_LINEAR_B     = 49,  \/* Linb *\/$/;"	e	enum:UScriptCode
USCRIPT_MALAYALAM	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_MALAYALAM    = 26,  \/* Mlym *\/$/;"	e	enum:UScriptCode
USCRIPT_MANDAEAN	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_MANDAEAN                      = 84, \/* Mand *\/$/;"	e	enum:UScriptCode
USCRIPT_MAYAN_HIEROGLYPHS	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_MAYAN_HIEROGLYPHS             = 85, \/* Maya *\/$/;"	e	enum:UScriptCode
USCRIPT_MEROITIC	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_MEROITIC                      = 86, \/* Mero *\/$/;"	e	enum:UScriptCode
USCRIPT_MONGOLIAN	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_MONGOLIAN    = 27,  \/* Mong *\/$/;"	e	enum:UScriptCode
USCRIPT_MYANMAR	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_MYANMAR      = 28,  \/* Mymr *\/$/;"	e	enum:UScriptCode
USCRIPT_NEW_TAI_LUE	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_NEW_TAI_LUE   = 59, \/* Talu *\/$/;"	e	enum:UScriptCode
USCRIPT_NKO	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_NKO                           = 87, \/* Nkoo *\/$/;"	e	enum:UScriptCode
USCRIPT_OGHAM	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_OGHAM        = 29,  \/* Ogam *\/$/;"	e	enum:UScriptCode
USCRIPT_OLD_CHURCH_SLAVONIC_CYRILLIC	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_OLD_CHURCH_SLAVONIC_CYRILLIC  = 68, \/* Cyrs *\/$/;"	e	enum:UScriptCode
USCRIPT_OLD_HUNGARIAN	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_OLD_HUNGARIAN                 = 76, \/* Hung *\/$/;"	e	enum:UScriptCode
USCRIPT_OLD_ITALIC	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_OLD_ITALIC   = 30,  \/* Ital *\/$/;"	e	enum:UScriptCode
USCRIPT_OLD_PERMIC	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_OLD_PERMIC                    = 89, \/* Perm *\/$/;"	e	enum:UScriptCode
USCRIPT_OLD_PERSIAN	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_OLD_PERSIAN   = 61, \/* Xpeo *\/$/;"	e	enum:UScriptCode
USCRIPT_ORIYA	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_ORIYA        = 31,  \/* Orya *\/$/;"	e	enum:UScriptCode
USCRIPT_ORKHON	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_ORKHON                        = 88, \/* Orkh *\/$/;"	e	enum:UScriptCode
USCRIPT_OSMANYA	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_OSMANYA      = 50,  \/* Osma *\/$/;"	e	enum:UScriptCode
USCRIPT_PAHAWH_HMONG	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_PAHAWH_HMONG                  = 75, \/* Hmng *\/$/;"	e	enum:UScriptCode
USCRIPT_PHAGS_PA	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_PHAGS_PA                      = 90, \/* Phag *\/$/;"	e	enum:UScriptCode
USCRIPT_PHOENICIAN	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_PHOENICIAN                    = 91, \/* Phnx *\/$/;"	e	enum:UScriptCode
USCRIPT_PHONETIC_POLLARD	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_PHONETIC_POLLARD              = 92, \/* Plrd *\/$/;"	e	enum:UScriptCode
USCRIPT_RONGORONGO	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_RONGORONGO                    = 93, \/* Roro *\/$/;"	e	enum:UScriptCode
USCRIPT_RUNIC	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_RUNIC        = 32,  \/* Runr *\/$/;"	e	enum:UScriptCode
USCRIPT_SARATI	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_SARATI                        = 94, \/* Sara *\/$/;"	e	enum:UScriptCode
USCRIPT_SHAVIAN	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_SHAVIAN      = 51,  \/* Shaw *\/$/;"	e	enum:UScriptCode
USCRIPT_SIMPLIFIED_HAN	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_SIMPLIFIED_HAN                = 73, \/* Hans *\/$/;"	e	enum:UScriptCode
USCRIPT_SINHALA	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_SINHALA      = 33,  \/* Sinh *\/$/;"	e	enum:UScriptCode
USCRIPT_SYLOTI_NAGRI	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_SYLOTI_NAGRI  = 58, \/* Sylo *\/$/;"	e	enum:UScriptCode
USCRIPT_SYRIAC	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_SYRIAC       = 34,  \/* Syrc *\/$/;"	e	enum:UScriptCode
USCRIPT_TAGALOG	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_TAGALOG      = 42,  \/* Tglg *\/$/;"	e	enum:UScriptCode
USCRIPT_TAGBANWA	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_TAGBANWA     = 45,  \/* Tagb *\/$/;"	e	enum:UScriptCode
USCRIPT_TAI_LE	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_TAI_LE       = 52,  \/* Tale *\/$/;"	e	enum:UScriptCode
USCRIPT_TAMIL	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_TAMIL        = 35,  \/* Taml *\/$/;"	e	enum:UScriptCode
USCRIPT_TELUGU	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_TELUGU       = 36,  \/* Telu *\/$/;"	e	enum:UScriptCode
USCRIPT_TENGWAR	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_TENGWAR                       = 98, \/* Teng *\/$/;"	e	enum:UScriptCode
USCRIPT_THAANA	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_THAANA       = 37,  \/* Thaa *\/$/;"	e	enum:UScriptCode
USCRIPT_THAI	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_THAI         = 38,  \/* Thai *\/$/;"	e	enum:UScriptCode
USCRIPT_TIBETAN	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_TIBETAN      = 39,  \/* Tibt *\/$/;"	e	enum:UScriptCode
USCRIPT_TIFINAGH	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_TIFINAGH      = 60, \/* Tfng *\/$/;"	e	enum:UScriptCode
USCRIPT_TRADITIONAL_HAN	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_TRADITIONAL_HAN               = 74, \/* Hant *\/$/;"	e	enum:UScriptCode
USCRIPT_UCAS	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_UCAS         = USCRIPT_CANADIAN_ABORIGINAL,$/;"	e	enum:UScriptCode
USCRIPT_UGARITIC	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_UGARITIC     = 53,  \/* Ugar *\/$/;"	e	enum:UScriptCode
USCRIPT_UNKNOWN	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_UNKNOWN                       = 103,\/* Zzzz *\/ \/* Unknown="Code for uncoded script", for unassigned code points *\/$/;"	e	enum:UScriptCode
USCRIPT_UNWRITTEN_LANGUAGES	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_UNWRITTEN_LANGUAGES           = 102,\/* Zxxx *\/$/;"	e	enum:UScriptCode
USCRIPT_VAI	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_VAI                           = 99, \/* Vaii *\/$/;"	e	enum:UScriptCode
USCRIPT_VISIBLE_SPEECH	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_VISIBLE_SPEECH                = 100, \/* Visp *\/$/;"	e	enum:UScriptCode
USCRIPT_WESTERN_SYRIAC	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_WESTERN_SYRIAC                = 96, \/* Syrj *\/$/;"	e	enum:UScriptCode
USCRIPT_YI	.\unicode\ScriptCodesFromICU.h	/^      USCRIPT_YI           = 41,  \/* Yiii *\/$/;"	e	enum:UScriptCode
USE	.\Platform.h	54;"	d
USE_BACKGROUND_THREAD_TO_SCAVENGE_MEMORY	.\FastMalloc.cpp	104;"	d	file:
USE_BACKGROUND_THREAD_TO_SCAVENGE_MEMORY	.\FastMalloc.cpp	106;"	d	file:
USE_LONG_LONG	.\dtoa.cpp	160;"	d	file:
USE_SYSTEM_MALLOC	.\Platform.h	490;"	d
USE_SYSTEM_MALLOC	.\Platform.h	781;"	d
UScriptCode	.\unicode\ScriptCodesFromICU.h	/^typedef enum UScriptCode {$/;"	g
UScriptCode	.\unicode\ScriptCodesFromICU.h	/^} UScriptCode;$/;"	t	typeref:enum:UScriptCode
UTF8CaseFunction	.\unicode\glib\UnicodeGLib.cpp	/^typedef gchar* (*UTF8CaseFunction)(const gchar*, gssize length);$/;"	t	namespace:WTF::Unicode	file:
UTF8SequenceLength	.\unicode\UTF8.cpp	/^int UTF8SequenceLength(char b0)$/;"	f	namespace:WTF::Unicode	signature:(char b0)
UTF8SequenceLength	.\unicode\UTF8.h	/^    int UTF8SequenceLength(char);$/;"	p	namespace:WTF::Unicode	signature:(char)
UTF8_IS_SURROGATE	.\unicode\glib\UnicodeGLib.cpp	29;"	d	file:
U_IS_BMP	.\unicode\UnicodeMacrosFromICU.h	11;"	d
U_IS_SUPPLEMENTARY	.\unicode\UnicodeMacrosFromICU.h	22;"	d
U_IS_SURROGATE	.\unicode\UnicodeMacrosFromICU.h	23;"	d
U_MASK	.\unicode\UnicodeMacrosFromICU.h	78;"	d
Uint16Array	.\Uint16Array.h	/^    inline Uint16Array(PassRefPtr<ArrayBuffer>,$/;"	p	class:WTF::Uint16Array	access:private	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
Uint16Array	.\Uint16Array.h	/^Uint16Array::Uint16Array(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Uint16Array	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
Uint16Array	.\Uint16Array.h	/^class Uint16Array : public IntegralTypedArrayBase<unsigned short> {$/;"	c	namespace:WTF	inherits:IntegralTypedArrayBase
Uint16Array_h	.\Uint16Array.h	28;"	d
Uint32Array	.\Uint32Array.h	/^    inline Uint32Array(PassRefPtr<ArrayBuffer>,$/;"	p	class:WTF::Uint32Array	access:private	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
Uint32Array	.\Uint32Array.h	/^Uint32Array::Uint32Array(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Uint32Array	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
Uint32Array	.\Uint32Array.h	/^class Uint32Array : public IntegralTypedArrayBase<unsigned int> {$/;"	c	namespace:WTF	inherits:IntegralTypedArrayBase
Uint32Array_h	.\Uint32Array.h	28;"	d
Uint8Array	.\Uint8Array.h	/^    inline Uint8Array(PassRefPtr<ArrayBuffer>,$/;"	p	class:WTF::Uint8Array	access:protected	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
Uint8Array	.\Uint8Array.h	/^Uint8Array::Uint8Array(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Uint8Array	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
Uint8Array	.\Uint8Array.h	/^class Uint8Array : public IntegralTypedArrayBase<unsigned char> {$/;"	c	namespace:WTF	inherits:IntegralTypedArrayBase
Uint8Array_h	.\Uint8Array.h	28;"	d
Uint8ClampedArray	.\Uint8ClampedArray.h	/^    inline Uint8ClampedArray(PassRefPtr<ArrayBuffer>,$/;"	p	class:WTF::Uint8ClampedArray	access:private	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
Uint8ClampedArray	.\Uint8ClampedArray.h	/^Uint8ClampedArray::Uint8ClampedArray(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Uint8ClampedArray	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
Uint8ClampedArray	.\Uint8ClampedArray.h	/^class Uint8ClampedArray : public Uint8Array {$/;"	c	namespace:WTF	inherits:Uint8Array
Uint8ClampedArray_h	.\Uint8ClampedArray.h	29;"	d
Unicode	.\unicode\CharacterNames.h	/^namespace Unicode {$/;"	n	namespace:WTF
Unicode	.\unicode\UTF8.cpp	/^namespace Unicode {$/;"	n	namespace:WTF	file:
Unicode	.\unicode\UTF8.h	/^namespace Unicode {$/;"	n	namespace:WTF
Unicode	.\unicode\glib\UnicodeGLib.cpp	/^namespace Unicode {$/;"	n	namespace:WTF	file:
Unicode	.\unicode\glib\UnicodeGLib.h	/^namespace Unicode {$/;"	n	namespace:WTF
Unicode	.\unicode\icu\UnicodeIcu.h	/^namespace Unicode {$/;"	n	namespace:WTF
Unicode	.\unicode\qt4\UnicodeQt4.h	/^namespace Unicode {$/;"	n	namespace:WTF
Unicode	.\unicode\wince\UnicodeWinCE.cpp	/^namespace Unicode {$/;"	n	namespace:WTF	file:
Unicode	.\unicode\wince\UnicodeWinCE.h	/^namespace Unicode {$/;"	n	namespace:WTF
UnicodeGLib_h	.\unicode\glib\UnicodeGLib.h	26;"	d
UnicodeMacrosFromICU_h	.\unicode\UnicodeMacrosFromICU.h	7;"	d
UnionFind	.\UnionFind.h	/^    UnionFind()$/;"	f	class:WTF::UnionFind	access:public	signature:()
UnionFind	.\UnionFind.h	/^class UnionFind {$/;"	c	namespace:WTF
UnionFind_h	.\UnionFind.h	27;"	d
UnknownUsage	.\OSAllocator.h	/^        UnknownUsage = -1,$/;"	e	enum:WTF::OSAllocator::Usage
Unlock	.\TCSpinLock.h	/^    inline void Unlock() {$/;"	f	struct:TCMalloc_SpinLock	access:public	signature:()
Unlock	.\TCSpinLock.h	/^  inline void Unlock() {$/;"	f	struct:TCMalloc_SpinLock	access:public	signature:()
UnsignedType	.\HashFunctions.h	/^    template<> struct IntTypes<1> { typedef int8_t SignedType; typedef uint8_t UnsignedType; };$/;"	t	struct:WTF::IntTypes	access:public
UnsignedType	.\HashFunctions.h	/^    template<> struct IntTypes<2> { typedef int16_t SignedType; typedef uint16_t UnsignedType; };$/;"	t	struct:WTF::IntTypes	access:public
UnsignedType	.\HashFunctions.h	/^    template<> struct IntTypes<4> { typedef int32_t SignedType; typedef uint32_t UnsignedType; };$/;"	t	struct:WTF::IntTypes	access:public
UnsignedType	.\HashFunctions.h	/^    template<> struct IntTypes<8> { typedef int64_t SignedType; typedef uint64_t UnsignedType; };$/;"	t	struct:WTF::IntTypes	access:public
UnsignedWithZeroKeyHashTraits	.\HashTraits.h	/^    template<typename T> struct UnsignedWithZeroKeyHashTraits : GenericHashTraits<T> {$/;"	s	namespace:WTF	inherits:GenericHashTraits
UnspecifiedBoolType	.\CheckedArithmetic.h	/^    typedef void* (Checked::*UnspecifiedBoolType);$/;"	t	class:WTF::Checked	access:public
UnspecifiedBoolType	.\OwnArrayPtr.h	/^    typedef T* OwnArrayPtr::*UnspecifiedBoolType;$/;"	t	class:WTF::OwnArrayPtr::OwnArrayPtr	access:public
UnspecifiedBoolType	.\OwnPtr.h	/^        typedef PtrType OwnPtr::*UnspecifiedBoolType;$/;"	t	class:WTF::OwnPtr::OwnPtr	access:public
UnspecifiedBoolType	.\PassOwnArrayPtr.h	/^    typedef PtrType PassOwnArrayPtr::*UnspecifiedBoolType;$/;"	t	class:WTF::PassOwnArrayPtr::PassOwnArrayPtr	access:public
UnspecifiedBoolType	.\PassOwnPtr.h	/^        typedef PtrType PassOwnPtr::*UnspecifiedBoolType;$/;"	t	class:WTF::PassOwnPtr::PassOwnPtr	access:public
UnspecifiedBoolType	.\PassRefPtr.h	/^        typedef T* (PassRefPtr::*UnspecifiedBoolType);$/;"	t	class:WTF::PassRefPtr	access:public
UnspecifiedBoolType	.\RefPtr.h	/^        typedef T* (RefPtr::*UnspecifiedBoolType);$/;"	t	class:WTF::RefPtr	access:public
UnspecifiedBoolType	.\RetainPtr.h	/^        typedef PtrType RetainPtr::*UnspecifiedBoolType;$/;"	t	class:WTF::RetainPtr::RetainPtr	access:public
UnspecifiedBoolType	.\gobject\GOwnPtr.h	/^    typedef T* GOwnPtr::*UnspecifiedBoolType;$/;"	t	class:WTF::GOwnPtr::GOwnPtr	access:public
UnspecifiedBoolType	.\gobject\GRefPtr.h	/^    typedef T* GRefPtr::*UnspecifiedBoolType;$/;"	t	class:WTF::GRefPtr::GRefPtr	access:public
UnspecifiedBoolTypeA	.\text\WTFString.h	/^    typedef struct ImplicitConversionFromWTFStringToBoolDisallowedA* (String::*UnspecifiedBoolTypeA);$/;"	t	class:WTF::String	typeref:struct:WTF::String::ImplicitConversionFromWTFStringToBoolDisallowedA	access:public
UnspecifiedBoolTypeB	.\text\WTFString.h	/^    typedef struct ImplicitConversionFromWTFStringToBoolDisallowedB* (String::*UnspecifiedBoolTypeB);$/;"	t	class:WTF::String	typeref:struct:WTF::String::ImplicitConversionFromWTFStringToBoolDisallowedB	access:public
UnspecifiedPort	.\url\src\URLParser.h	/^        UnspecifiedPort = -1,$/;"	e	enum:WTF::URLParser::SpecialPort
UpperBoundary	.\dtoa\double.h	/^        DiyFp UpperBoundary() const {$/;"	f	class:WTF::double_conversion::Double	access:public	signature:() const
UpperToPartialKey	.\TCPackedCache.h	/^  static K UpperToPartialKey(UPPER u) {$/;"	f	class:PackedCache	access:private	signature:(UPPER u)
Uppercase	.\HexNumber.h	/^    Uppercase$/;"	e	enum:WTF::HexConversionMode
Usage	.\OSAllocator.h	/^    enum Usage {$/;"	g	class:WTF::OSAllocator	access:public
UserInfoCharacter	.\url\src\URLCharacterTypes.h	/^        UserInfoCharacter = 1 << 1,$/;"	e	enum:WTF::URLCharacterTypes::CharTypes
Username	.\url\src\URLSegments.h	/^        Username,$/;"	e	enum:WTF::URLSegments::ComponentType
V	.\TCPackedCache.h	/^  typedef size_t V;$/;"	t	class:PackedCache	access:public
VMTags_h	.\VMTags.h	27;"	d
VM_TAG_FOR_COLLECTOR_MEMORY	.\VMTags.h	54;"	d
VM_TAG_FOR_COLLECTOR_MEMORY	.\VMTags.h	56;"	d
VM_TAG_FOR_COLLECTOR_MEMORY	.\VMTags.h	68;"	d
VM_TAG_FOR_EXECUTABLEALLOCATOR_MEMORY	.\VMTags.h	42;"	d
VM_TAG_FOR_EXECUTABLEALLOCATOR_MEMORY	.\VMTags.h	44;"	d
VM_TAG_FOR_EXECUTABLEALLOCATOR_MEMORY	.\VMTags.h	69;"	d
VM_TAG_FOR_REGISTERFILE_MEMORY	.\VMTags.h	48;"	d
VM_TAG_FOR_REGISTERFILE_MEMORY	.\VMTags.h	50;"	d
VM_TAG_FOR_REGISTERFILE_MEMORY	.\VMTags.h	70;"	d
VM_TAG_FOR_TCMALLOC_MEMORY	.\VMTags.h	36;"	d
VM_TAG_FOR_TCMALLOC_MEMORY	.\VMTags.h	38;"	d
VM_TAG_FOR_TCMALLOC_MEMORY	.\VMTags.h	67;"	d
VM_TAG_FOR_WEBCORE_PURGEABLE_MEMORY	.\VMTags.h	60;"	d
VM_TAG_FOR_WEBCORE_PURGEABLE_MEMORY	.\VMTags.h	62;"	d
VM_TAG_FOR_WEBCORE_PURGEABLE_MEMORY	.\VMTags.h	71;"	d
ValidationBufferSize	.\FastMalloc.h	/^        static const int ValidationBufferSize = sizeof(ValidationHeader) + sizeof(ValidationTag);$/;"	v
ValidationHeader	.\FastMalloc.h	/^        struct ValidationHeader {$/;"	s	namespace:WTF::Internal
ValidationPrefix	.\FastMalloc.h	/^            ValidationPrefix = 0xf00df00d,$/;"	e	enum:WTF::Internal::__anon7
ValidationSuffix	.\FastMalloc.h	/^            ValidationSuffix = 0x0badf00d$/;"	e	enum:WTF::Internal::__anon7
ValidationTag	.\FastMalloc.h	/^        typedef unsigned ValidationTag;$/;"	t	namespace:WTF::Internal
ValueCheck	.\ValueCheck.h	/^template<typename P> struct ValueCheck<P*> {$/;"	s	namespace:WTF
ValueCheck	.\ValueCheck.h	/^template<typename T> struct ValueCheck {$/;"	s	namespace:WTF
ValueCheck	.\Vector.h	/^    template<typename T> struct ValueCheck<Vector<T> > {$/;"	s	namespace:WTF
ValueCheck_h	.\ValueCheck.h	27;"	d
ValueTraits	.\HashMap.h	/^        typedef PairHashTraits<KeyTraits, MappedTraits> ValueTraits;$/;"	t	class:WTF::HashMap	access:private
ValueTraits	.\HashSet.h	/^        typedef TraitsArg ValueTraits;$/;"	t	class:WTF::HashSet	access:private
ValueTraits	.\HashTable.h	/^        typedef Traits ValueTraits;$/;"	t	class:WTF::HashTable	access:public
ValueTraits	.\RefPtrHashMap.h	/^        typedef PairHashTraits<KeyTraits, MappedTraits> ValueTraits;$/;"	t	class:WTF::HashMap	access:private
ValueType	.\HashCountedSet.h	/^        typedef Value ValueType;$/;"	t	class:WTF::HashCountedSet	access:public
ValueType	.\HashIterators.h	/^        typedef std::pair<KeyType, MappedType> ValueType;$/;"	t	struct:WTF::HashTableConstIteratorAdapter	access:private
ValueType	.\HashIterators.h	/^        typedef std::pair<KeyType, MappedType> ValueType;$/;"	t	struct:WTF::HashTableIteratorAdapter	access:private
ValueType	.\HashMap.h	/^        typedef typename ValueTraits::TraitType ValueType;$/;"	t	class:WTF::HashMap	access:public
ValueType	.\HashSet.h	/^        typedef typename ValueTraits::TraitType ValueType;$/;"	t	class:WTF::HashSet	access:public
ValueType	.\HashTable.h	/^        typedef Value ValueType;$/;"	t	class:WTF::HashTable	access:public
ValueType	.\HashTable.h	/^        typedef Value ValueType;$/;"	t	class:WTF::HashTableConstIterator	access:private
ValueType	.\HashTable.h	/^        typedef Value ValueType;$/;"	t	class:WTF::HashTableIterator	access:private
ValueType	.\ListHashSet.h	/^        typedef ValueArg ValueType;$/;"	t	class:WTF::ListHashSet	access:public
ValueType	.\ListHashSet.h	/^        typedef ValueArg ValueType;$/;"	t	class:WTF::ListHashSetConstIterator	access:private
ValueType	.\ListHashSet.h	/^        typedef ValueArg ValueType;$/;"	t	class:WTF::ListHashSetConstReverseIterator	access:private
ValueType	.\ListHashSet.h	/^        typedef ValueArg ValueType;$/;"	t	class:WTF::ListHashSetIterator	access:private
ValueType	.\ListHashSet.h	/^        typedef ValueArg ValueType;$/;"	t	class:WTF::ListHashSetReverseIterator	access:private
ValueType	.\OwnPtr.h	/^        typedef typename RemovePointer<T>::Type ValueType;$/;"	t	class:WTF::OwnPtr	access:public
ValueType	.\PassOwnPtr.h	/^        typedef typename RemovePointer<T>::Type ValueType;$/;"	t	class:WTF::PassOwnPtr	access:public
ValueType	.\RefPtrHashMap.h	/^        typedef typename ValueTraits::TraitType ValueType;$/;"	t	class:WTF::HashMap	access:public
ValueType	.\RetainPtr.h	/^        typedef typename RemovePointer<T>::Type ValueType;$/;"	t	class:WTF::RetainPtr	access:public
ValueType	.\Vector.h	/^        typedef T ValueType;$/;"	t	class:WTF::Vector	access:public
Values	.\HashIterators.h	/^        typedef HashTableConstValuesIterator<HashTableType, KeyType, MappedType> Values;$/;"	t	struct:WTF::HashTableConstIteratorAdapter	access:public
Values	.\HashIterators.h	/^        typedef HashTableValuesIterator<HashTableType, KeyType, MappedType> Values;$/;"	t	struct:WTF::HashTableIteratorAdapter	access:public
Vector	.\Vector.h	/^        Vector() $/;"	f	class:WTF::Vector	access:public	signature:()
Vector	.\Vector.h	/^        Vector(const Vector&);$/;"	p	class:WTF::Vector	access:public	signature:(const Vector&)
Vector	.\Vector.h	/^        Vector(const Vector<T, otherCapacity>&);$/;"	p	class:WTF::Vector	access:public	signature:(const Vector<T, otherCapacity>&)
Vector	.\Vector.h	/^        Vector(size_t size, const T& val)$/;"	f	class:WTF::Vector	access:public	signature:(size_t size, const T& val)
Vector	.\Vector.h	/^        explicit Vector(size_t size) $/;"	f	class:WTF::Vector	access:public	signature:(size_t size)
Vector	.\Vector.h	/^    Vector<T, inlineCapacity>::Vector(const Vector& other)$/;"	f	class:WTF::Vector	signature:(const Vector& other)
Vector	.\Vector.h	/^    Vector<T, inlineCapacity>::Vector(const Vector<T, otherCapacity>& other)$/;"	f	class:WTF::Vector	signature:(const Vector<T, otherCapacity>& other)
Vector	.\Vector.h	/^    class Vector {$/;"	c	namespace:WTF
Vector	.\dtoa\utils.h	/^        Vector() : start_(NULL), length_(0) {}$/;"	f	class:WTF::double_conversion::Vector	access:public	signature:()
Vector	.\dtoa\utils.h	/^        Vector(T* data, int length) : start_(data), length_(length) {$/;"	f	class:WTF::double_conversion::Vector	access:public	signature:(T* data, int length)
Vector	.\dtoa\utils.h	/^    class Vector {$/;"	c	namespace:WTF::double_conversion
VectorBuffer	.\Vector.h	/^        VectorBuffer()$/;"	f	class:WTF::VectorBuffer	access:public	signature:()
VectorBuffer	.\Vector.h	/^        VectorBuffer(size_t capacity)$/;"	f	class:WTF::VectorBuffer	access:public	signature:(size_t capacity)
VectorBuffer	.\Vector.h	/^    class VectorBuffer : private VectorBufferBase<T> {$/;"	c	namespace:WTF	inherits:VectorBufferBase
VectorBuffer	.\Vector.h	/^    class VectorBuffer<T, 0> : private VectorBufferBase<T> {$/;"	c	namespace:WTF	inherits:VectorBufferBase
VectorBufferBase	.\Vector.h	/^        VectorBufferBase()$/;"	f	class:WTF::VectorBufferBase	access:protected	signature:()
VectorBufferBase	.\Vector.h	/^        VectorBufferBase(T* buffer, size_t capacity)$/;"	f	class:WTF::VectorBufferBase	access:protected	signature:(T* buffer, size_t capacity)
VectorBufferBase	.\Vector.h	/^    class VectorBufferBase {$/;"	c	namespace:WTF
VectorComparer	.\Vector.h	/^    struct VectorComparer<false, T>$/;"	s	namespace:WTF
VectorComparer	.\Vector.h	/^    struct VectorComparer<true, T>$/;"	s	namespace:WTF
VectorCopier	.\Vector.h	/^    struct VectorCopier<false, T>$/;"	s	namespace:WTF
VectorCopier	.\Vector.h	/^    struct VectorCopier<true, T>$/;"	s	namespace:WTF
VectorDestructor	.\Vector.h	/^    struct VectorDestructor<false, T>$/;"	s	namespace:WTF
VectorDestructor	.\Vector.h	/^    struct VectorDestructor<true, T>$/;"	s	namespace:WTF
VectorFiller	.\Vector.h	/^    struct VectorFiller<false, T>$/;"	s	namespace:WTF
VectorFiller	.\Vector.h	/^    struct VectorFiller<true, T>$/;"	s	namespace:WTF
VectorInitializer	.\Vector.h	/^    struct VectorInitializer<false, ignore, T>$/;"	s	namespace:WTF
VectorInitializer	.\Vector.h	/^    struct VectorInitializer<true, false, T>$/;"	s	namespace:WTF
VectorInitializer	.\Vector.h	/^    struct VectorInitializer<true, true, T>$/;"	s	namespace:WTF
VectorMover	.\Vector.h	/^    struct VectorMover<false, T>$/;"	s	namespace:WTF
VectorMover	.\Vector.h	/^    struct VectorMover<true, T>$/;"	s	namespace:WTF
VectorReverseProxy	.\Vector.h	/^            VectorReverseProxy();$/;"	p	class:WTF::Vector::VectorReverseProxy	access:private	signature:()
VectorReverseProxy	.\Vector.h	/^            VectorReverseProxy(const VectorReverseProxy&);$/;"	p	class:WTF::Vector::VectorReverseProxy	access:private	signature:(const VectorReverseProxy&)
VectorReverseProxy	.\Vector.h	/^        class VectorReverseProxy : private Vector {$/;"	c	class:WTF::Vector	inherits:Vector	access:private
VectorTraits	.\VectorTraits.h	/^    struct VectorTraits : VectorTraitsBase<IsPod<T>::value, T> { };$/;"	s	namespace:WTF	inherits:VectorTraitsBase
VectorTraits	.\VectorTraits.h	/^    struct VectorTraits<OwnPtr<P> > : SimpleClassVectorTraits { };$/;"	s	namespace:WTF	inherits:SimpleClassVectorTraits
VectorTraits	.\VectorTraits.h	/^    struct VectorTraits<RefPtr<P> > : SimpleClassVectorTraits { };$/;"	s	namespace:WTF	inherits:SimpleClassVectorTraits
VectorTraits	.\VectorTraits.h	/^    struct VectorTraits<pair<First, Second> >$/;"	s	namespace:WTF
VectorTraits	.\text\WTFString.h	/^template <> struct VectorTraits<String> : SimpleClassVectorTraits { };$/;"	s	namespace:WTF	inherits:SimpleClassVectorTraits
VectorTraitsBase	.\VectorTraits.h	/^    struct VectorTraitsBase<false, T>$/;"	s	namespace:WTF
VectorTraitsBase	.\VectorTraits.h	/^    struct VectorTraitsBase<true, T>$/;"	s	namespace:WTF
VectorTypeOperations	.\Vector.h	/^    struct VectorTypeOperations$/;"	s	namespace:WTF
Vector_should_stay_small	.\SizeLimits.cpp	/^COMPILE_ASSERT(sizeof(Vector<int>) == 3 * sizeof(int*), Vector_should_stay_small);$/;"	v
VerificationMode	.\ThreadRestrictionVerifier.h	/^    enum VerificationMode {$/;"	g	class:WTF::ThreadRestrictionVerifier	access:private
VirtualAlloc	.\wince\MemoryManager.cpp	29;"	d	file:
VirtualAlloc_failure	.\TCSystemAlloc.cpp	/^static bool VirtualAlloc_failure = false;$/;"	v	file:
VirtualFree	.\wince\MemoryManager.cpp	30;"	d	file:
WARN_UNUSED_RETURN	.\Compiler.h	208;"	d
WARN_UNUSED_RETURN	.\Compiler.h	210;"	d
WARN_UNUSED_RETURN	.\FastMalloc.h	/^        template <typename T> bool getValue(T& data) WARN_UNUSED_RETURN;$/;"	m	struct:WTF::TryMallocReturnValue	access:public
WARN_UNUSED_RETURN	.\OwnArrayPtr.h	/^    PtrType leakPtr() WARN_UNUSED_RETURN;$/;"	m	class:WTF::OwnArrayPtr	access:public
WARN_UNUSED_RETURN	.\OwnPtr.h	/^        PtrType leakPtr() WARN_UNUSED_RETURN;$/;"	m	class:WTF::OwnPtr	access:public
WARN_UNUSED_RETURN	.\PassOwnArrayPtr.h	/^    PtrType leakPtr() const WARN_UNUSED_RETURN;$/;"	m	class:WTF::PassOwnArrayPtr	access:public
WARN_UNUSED_RETURN	.\PassOwnPtr.h	/^        PtrType leakPtr() const WARN_UNUSED_RETURN;$/;"	m	class:WTF::PassOwnPtr	access:public
WARN_UNUSED_RETURN	.\PassRefPtr.h	/^        T* leakRef() const WARN_UNUSED_RETURN;$/;"	m	class:WTF::PassRefPtr	access:public
WARN_UNUSED_RETURN	.\PossiblyNull.h	/^    bool getValue(T& out) WARN_UNUSED_RETURN;$/;"	m	struct:WTF::PossiblyNull	access:public
WARN_UNUSED_RETURN	.\RetainPtr.h	/^        PtrType leakRef() WARN_UNUSED_RETURN;$/;"	m	class:WTF::RetainPtr	access:public
WIN32_LEAN_AND_MEAN	.\CurrentTime.cpp	44;"	d	file:
WIN32_LEAN_AND_MEAN	.\FastMalloc.cpp	436;"	d	file:
WIN32_LEAN_AND_MEAN	.\TCSpinLock.h	202;"	d
WIN32_LEAN_AND_MEAN	.\TCSpinLock.h	51;"	d
WTF	.\ASCIICType.h	/^namespace WTF {$/;"	n
WTF	.\AVLTree.h	/^namespace WTF {$/;"	n
WTF	.\Alignment.h	/^namespace WTF {$/;"	n
WTF	.\ArrayBuffer.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\ArrayBuffer.h	/^namespace WTF {$/;"	n
WTF	.\ArrayBufferView.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\ArrayBufferView.h	/^namespace WTF {$/;"	n
WTF	.\Atomics.h	/^namespace WTF {$/;"	n
WTF	.\BitVector.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\BitVector.h	/^namespace WTF {$/;"	n
WTF	.\Bitmap.h	/^namespace WTF {$/;"	n
WTF	.\BlockStack.h	/^namespace WTF {$/;"	n
WTF	.\BloomFilter.h	/^namespace WTF {$/;"	n
WTF	.\BoundsCheckedPointer.h	/^namespace WTF {$/;"	n
WTF	.\BumpPointerAllocator.h	/^namespace WTF {$/;"	n
WTF	.\ByteArray.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\ByteArray.h	/^namespace WTF {$/;"	n
WTF	.\CheckedArithmetic.h	/^namespace WTF {$/;"	n
WTF	.\Complex.h	/^namespace WTF {$/;"	n
WTF	.\CryptographicallyRandomNumber.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\CryptographicallyRandomNumber.h	/^namespace WTF {$/;"	n
WTF	.\CurrentTime.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\CurrentTime.h	/^namespace WTF {$/;"	n
WTF	.\DataLog.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\DataLog.h	/^namespace WTF {$/;"	n
WTF	.\DateMath.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\DateMath.h	/^namespace WTF {$/;"	n
WTF	.\DecimalNumber.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\DecimalNumber.h	/^namespace WTF {$/;"	n
WTF	.\Decoder.h	/^namespace WTF {$/;"	n
WTF	.\Deque.h	/^namespace WTF {$/;"	n
WTF	.\DoublyLinkedList.h	/^namespace WTF {$/;"	n
WTF	.\Encoder.h	/^namespace WTF {$/;"	n
WTF	.\FastAllocBase.h	/^namespace WTF {$/;"	n
WTF	.\FastMalloc.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\FastMalloc.h	/^namespace WTF {$/;"	n
WTF	.\FixedArray.h	/^namespace WTF {$/;"	n
WTF	.\Float32Array.h	/^namespace WTF {$/;"	n
WTF	.\Float64Array.h	/^namespace WTF {$/;"	n
WTF	.\Forward.h	/^namespace WTF {$/;"	n
WTF	.\Functional.h	/^namespace WTF {$/;"	n
WTF	.\GetPtr.h	/^namespace WTF {$/;"	n
WTF	.\HashCountedSet.h	/^namespace WTF {$/;"	n
WTF	.\HashFunctions.h	/^namespace WTF {$/;"	n
WTF	.\HashIterators.h	/^namespace WTF {$/;"	n
WTF	.\HashMap.h	/^namespace WTF {$/;"	n
WTF	.\HashSet.h	/^namespace WTF {$/;"	n
WTF	.\HashTable.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\HashTable.h	/^namespace WTF {$/;"	n
WTF	.\HashTraits.h	/^namespace WTF {$/;"	n
WTF	.\HexNumber.h	/^namespace WTF {$/;"	n
WTF	.\Int16Array.h	/^namespace WTF {$/;"	n
WTF	.\Int32Array.h	/^namespace WTF {$/;"	n
WTF	.\Int8Array.h	/^namespace WTF {$/;"	n
WTF	.\IntegralTypedArrayBase.h	/^namespace WTF {$/;"	n
WTF	.\ListHashSet.h	/^namespace WTF {$/;"	n
WTF	.\ListRefPtr.h	/^namespace WTF {$/;"	n
WTF	.\Locker.h	/^namespace WTF {$/;"	n
WTF	.\MD5.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\MD5.h	/^namespace WTF {$/;"	n
WTF	.\MainThread.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\MainThread.h	/^namespace WTF {$/;"	n
WTF	.\MallocZoneSupport.h	/^namespace WTF {$/;"	n
WTF	.\MessageQueue.h	/^namespace WTF {$/;"	n
WTF	.\MetaAllocator.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\MetaAllocator.h	/^namespace WTF {$/;"	n
WTF	.\MetaAllocatorHandle.h	/^namespace WTF {$/;"	n
WTF	.\NonCopyingSort.h	/^namespace WTF {$/;"	n
WTF	.\NotFound.h	/^namespace WTF {$/;"	n
WTF	.\NumberOfCores.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\NumberOfCores.h	/^namespace WTF {$/;"	n
WTF	.\OSAllocator.h	/^namespace WTF {$/;"	n
WTF	.\OSAllocatorPosix.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\OSAllocatorWin.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\OSRandomSource.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\OSRandomSource.h	/^namespace WTF {$/;"	n
WTF	.\OwnArrayPtr.h	/^namespace WTF {$/;"	n
WTF	.\OwnPtr.h	/^namespace WTF {$/;"	n
WTF	.\OwnPtrCommon.h	/^namespace WTF {$/;"	n
WTF	.\PackedIntVector.h	/^namespace WTF {$/;"	n
WTF	.\PageAllocation.h	/^namespace WTF {$/;"	n
WTF	.\PageAllocationAligned.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\PageAllocationAligned.h	/^namespace WTF {$/;"	n
WTF	.\PageBlock.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\PageBlock.h	/^namespace WTF {$/;"	n
WTF	.\PageReservation.h	/^namespace WTF {$/;"	n
WTF	.\ParallelJobs.h	/^namespace WTF {$/;"	n
WTF	.\ParallelJobsGeneric.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\ParallelJobsGeneric.h	/^namespace WTF {$/;"	n
WTF	.\ParallelJobsLibdispatch.h	/^namespace WTF {$/;"	n
WTF	.\ParallelJobsOpenMP.h	/^namespace WTF {$/;"	n
WTF	.\PassOwnArrayPtr.h	/^namespace WTF {$/;"	n
WTF	.\PassOwnPtr.h	/^namespace WTF {$/;"	n
WTF	.\PassRefPtr.h	/^namespace WTF {$/;"	n
WTF	.\PassTraits.h	/^namespace WTF {$/;"	n
WTF	.\PossiblyNull.h	/^namespace WTF {$/;"	n
WTF	.\RandomNumber.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\RandomNumber.h	/^namespace WTF {$/;"	n
WTF	.\RandomNumberSeed.h	/^namespace WTF {$/;"	n
WTF	.\RedBlackTree.h	/^namespace WTF {$/;"	n
WTF	.\RefCounted.h	/^namespace WTF {$/;"	n
WTF	.\RefCountedArray.h	/^namespace WTF {$/;"	n
WTF	.\RefCountedLeakCounter.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\RefCountedLeakCounter.h	/^namespace WTF {$/;"	n
WTF	.\RefPtr.h	/^namespace WTF {$/;"	n
WTF	.\RefPtrHashMap.h	/^namespace WTF {$/;"	n
WTF	.\RetainPtr.h	/^namespace WTF {$/;"	n
WTF	.\SHA1.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\SHA1.h	/^namespace WTF {$/;"	n
WTF	.\SegmentedVector.h	/^namespace WTF {$/;"	n
WTF	.\SentinelLinkedList.h	/^namespace WTF {$/;"	n
WTF	.\SimpleStats.h	/^namespace WTF {$/;"	n
WTF	.\SinglyLinkedList.h	/^namespace WTF {$/;"	n
WTF	.\SizeLimits.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\Spectrum.h	/^namespace WTF {$/;"	n
WTF	.\StackBounds.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\StackBounds.h	/^namespace WTF {$/;"	n
WTF	.\StdLibExtras.h	/^namespace WTF {$/;"	n
WTF	.\StringHasher.h	/^namespace WTF {$/;"	n
WTF	.\TemporaryChange.h	/^namespace WTF {$/;"	n
WTF	.\ThreadFunctionInvocation.h	/^namespace WTF {$/;"	n
WTF	.\ThreadIdentifierDataPthreads.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\ThreadIdentifierDataPthreads.h	/^namespace WTF {$/;"	n
WTF	.\ThreadRestrictionVerifier.h	/^namespace WTF {$/;"	n
WTF	.\ThreadSafeRefCounted.h	/^namespace WTF {$/;"	n
WTF	.\ThreadSpecific.h	/^namespace WTF {$/;"	n
WTF	.\ThreadSpecificWin.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\Threading.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\Threading.h	/^namespace WTF {$/;"	n
WTF	.\ThreadingPrimitives.h	/^namespace WTF {$/;"	n
WTF	.\ThreadingPthreads.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\ThreadingWin.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\TypeTraits.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\TypeTraits.h	/^namespace WTF {$/;"	n
WTF	.\TypedArrayBase.h	/^namespace WTF {$/;"	n
WTF	.\Uint16Array.h	/^namespace WTF {$/;"	n
WTF	.\Uint32Array.h	/^namespace WTF {$/;"	n
WTF	.\Uint8Array.h	/^namespace WTF {$/;"	n
WTF	.\Uint8ClampedArray.h	/^namespace WTF {$/;"	n
WTF	.\UnionFind.h	/^namespace WTF {$/;"	n
WTF	.\ValueCheck.h	/^namespace WTF {$/;"	n
WTF	.\Vector.h	/^namespace WTF {$/;"	n
WTF	.\VectorTraits.h	/^namespace WTF {$/;"	n
WTF	.\WTFThreadData.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\WTFThreadData.h	/^namespace WTF {$/;"	n
WTF	.\blackberry\MainThreadBlackBerry.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\chromium\ChromiumThreading.h	/^namespace WTF {$/;"	n
WTF	.\chromium\MainThreadChromium.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\dtoa.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\dtoa.h	/^namespace WTF {$/;"	n
WTF	.\dtoa\bignum-dtoa.cc	/^namespace WTF {$/;"	n	file:
WTF	.\dtoa\bignum-dtoa.h	/^namespace WTF {$/;"	n
WTF	.\dtoa\bignum.cc	/^namespace WTF {$/;"	n	file:
WTF	.\dtoa\bignum.h	/^namespace WTF {$/;"	n
WTF	.\dtoa\cached-powers.cc	/^namespace WTF {$/;"	n	file:
WTF	.\dtoa\cached-powers.h	/^namespace WTF {$/;"	n
WTF	.\dtoa\diy-fp.cc	/^namespace WTF {$/;"	n	file:
WTF	.\dtoa\diy-fp.h	/^namespace WTF {$/;"	n
WTF	.\dtoa\double-conversion.cc	/^namespace WTF {$/;"	n	file:
WTF	.\dtoa\double-conversion.h	/^namespace WTF {$/;"	n
WTF	.\dtoa\double.h	/^namespace WTF {$/;"	n
WTF	.\dtoa\fast-dtoa.cc	/^namespace WTF {$/;"	n	file:
WTF	.\dtoa\fast-dtoa.h	/^namespace WTF {$/;"	n
WTF	.\dtoa\fixed-dtoa.cc	/^namespace WTF {$/;"	n	file:
WTF	.\dtoa\fixed-dtoa.h	/^namespace WTF {$/;"	n
WTF	.\dtoa\strtod.cc	/^namespace WTF {$/;"	n	file:
WTF	.\dtoa\strtod.h	/^namespace WTF {$/;"	n
WTF	.\dtoa\utils.h	/^namespace WTF {$/;"	n
WTF	.\efl\MainThreadEfl.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\efl\OwnPtrEfl.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\gobject\GOwnPtr.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\gobject\GOwnPtr.h	/^namespace WTF {$/;"	n
WTF	.\gobject\GRefPtr.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\gobject\GRefPtr.h	/^namespace WTF {$/;"	n
WTF	.\gtk\MainThreadGtk.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\qt\MainThreadQt.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\qt\StringQt.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\text\ASCIIFastPath.h	/^namespace WTF {$/;"	n
WTF	.\text\AtomicString.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\text\AtomicString.h	/^namespace WTF {$/;"	n
WTF	.\text\AtomicStringHash.h	/^namespace WTF {$/;"	n
WTF	.\text\AtomicStringImpl.h	/^namespace WTF {$/;"	n
WTF	.\text\CString.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\text\CString.h	/^namespace WTF {$/;"	n
WTF	.\text\StringBuffer.h	/^namespace WTF {$/;"	n
WTF	.\text\StringBuilder.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\text\StringBuilder.h	/^namespace WTF {$/;"	n
WTF	.\text\StringConcatenate.h	/^namespace WTF {$/;"	n
WTF	.\text\StringHash.h	/^namespace WTF {$/;"	n
WTF	.\text\StringImpl.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\text\StringImpl.h	/^namespace WTF {$/;"	n
WTF	.\text\StringOperators.h	/^namespace WTF {$/;"	n
WTF	.\text\StringStatics.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\text\TextPosition.h	/^namespace WTF {$/;"	n
WTF	.\text\WTFString.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\text\WTFString.h	/^namespace WTF {$/;"	n
WTF	.\threads\BinarySemaphore.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\threads\BinarySemaphore.h	/^namespace WTF {$/;"	n
WTF	.\threads\win\BinarySemaphoreWin.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\unicode\CharacterNames.h	/^namespace WTF {$/;"	n
WTF	.\unicode\Collator.h	/^namespace WTF {$/;"	n
WTF	.\unicode\CollatorDefault.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\unicode\UTF8.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\unicode\UTF8.h	/^namespace WTF {$/;"	n
WTF	.\unicode\glib\UnicodeGLib.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\unicode\glib\UnicodeGLib.h	/^namespace WTF {$/;"	n
WTF	.\unicode\icu\CollatorICU.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\unicode\icu\UnicodeIcu.h	/^namespace WTF {$/;"	n
WTF	.\unicode\qt4\UnicodeQt4.h	/^namespace WTF {$/;"	n
WTF	.\unicode\wince\UnicodeWinCE.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\unicode\wince\UnicodeWinCE.h	/^namespace WTF {$/;"	n
WTF	.\url\api\ParsedURL.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\url\api\ParsedURL.h	/^namespace WTF {$/;"	n
WTF	.\url\api\URLString.h	/^namespace WTF {$/;"	n
WTF	.\url\src\RawURLBuffer.h	/^namespace WTF {$/;"	n
WTF	.\url\src\URLBuffer.h	/^namespace WTF {$/;"	n
WTF	.\url\src\URLCharacterTypes.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\url\src\URLCharacterTypes.h	/^namespace WTF {$/;"	n
WTF	.\url\src\URLComponent.h	/^namespace WTF {$/;"	n
WTF	.\url\src\URLEscape.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\url\src\URLEscape.h	/^namespace WTF {$/;"	n
WTF	.\url\src\URLParser.h	/^namespace WTF {$/;"	n
WTF	.\url\src\URLQueryCanonicalizer.h	/^namespace WTF {$/;"	n
WTF	.\url\src\URLSegments.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\url\src\URLSegments.h	/^namespace WTF {$/;"	n
WTF	.\win\MainThreadWin.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\win\OwnPtrWin.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\wince\FastMallocWinCE.h	/^namespace WTF {$/;"	n
WTF	.\wince\MemoryManager.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\wince\MemoryManager.h	/^namespace WTF {$/;"	n
WTF	.\wx\MainThreadWx.cpp	/^namespace WTF {$/;"	n	file:
WTF	.\wx\StringWx.cpp	/^namespace WTF {$/;"	n	file:
WTF::AVLTree	.\AVLTree.h	/^class AVLTree {$/;"	c	namespace:WTF
WTF::AVLTree::AVLTree	.\AVLTree.h	/^    AVLTree() { abs.root = null(); }$/;"	f	class:WTF::AVLTree	access:public	signature:()
WTF::AVLTree::EQUAL	.\AVLTree.h	/^        EQUAL = 1,$/;"	e	enum:WTF::AVLTree::SearchType
WTF::AVLTree::GREATER	.\AVLTree.h	/^        GREATER = 4,$/;"	e	enum:WTF::AVLTree::SearchType
WTF::AVLTree::GREATER_EQUAL	.\AVLTree.h	/^        GREATER_EQUAL = EQUAL | GREATER$/;"	e	enum:WTF::AVLTree::SearchType
WTF::AVLTree::Iterator	.\AVLTree.h	/^    class Iterator {$/;"	c	class:WTF::AVLTree	access:public
WTF::AVLTree::Iterator::Iterator	.\AVLTree.h	/^        Iterator() { depth = ~0U; }$/;"	f	class:WTF::AVLTree::Iterator	access:public	signature:()
WTF::AVLTree::Iterator::branch	.\AVLTree.h	/^        BSet branch;$/;"	m	class:WTF::AVLTree::Iterator	access:protected
WTF::AVLTree::Iterator::cmp_k_n	.\AVLTree.h	/^        int cmp_k_n(key k, handle h) { return tree_->abs.compare_key_node(k, h); }$/;"	f	class:WTF::AVLTree::Iterator	access:protected	signature:(key k, handle h)
WTF::AVLTree::Iterator::cmp_n_n	.\AVLTree.h	/^        int cmp_n_n(handle h1, handle h2) { return tree_->abs.compare_node_node(h1, h2); }$/;"	f	class:WTF::AVLTree::Iterator	access:protected	signature:(handle h1, handle h2)
WTF::AVLTree::Iterator::depth	.\AVLTree.h	/^        unsigned depth;$/;"	m	class:WTF::AVLTree::Iterator	access:protected
WTF::AVLTree::Iterator::get_gt	.\AVLTree.h	/^        handle get_gt(handle h) { return tree_->abs.get_greater(h); }$/;"	f	class:WTF::AVLTree::Iterator	access:protected	signature:(handle h)
WTF::AVLTree::Iterator::get_lt	.\AVLTree.h	/^        handle get_lt(handle h) { return tree_->abs.get_less(h); }$/;"	f	class:WTF::AVLTree::Iterator	access:protected	signature:(handle h)
WTF::AVLTree::Iterator::null	.\AVLTree.h	/^        handle null() { return tree_->abs.null(); }$/;"	f	class:WTF::AVLTree::Iterator	access:protected	signature:()
WTF::AVLTree::Iterator::operator *	.\AVLTree.h	/^        handle operator*()$/;"	f	class:WTF::AVLTree::Iterator	access:public	signature:()
WTF::AVLTree::Iterator::operator ++	.\AVLTree.h	/^        void operator++()$/;"	f	class:WTF::AVLTree::Iterator	access:public	signature:()
WTF::AVLTree::Iterator::operator ++	.\AVLTree.h	/^        void operator++(int) { ++(*this); }$/;"	f	class:WTF::AVLTree::Iterator	access:public	signature:(int)
WTF::AVLTree::Iterator::operator --	.\AVLTree.h	/^        void operator--()$/;"	f	class:WTF::AVLTree::Iterator	access:public	signature:()
WTF::AVLTree::Iterator::operator --	.\AVLTree.h	/^        void operator--(int) { --(*this); }$/;"	f	class:WTF::AVLTree::Iterator	access:public	signature:(int)
WTF::AVLTree::Iterator::path_h	.\AVLTree.h	/^        handle path_h[maxDepth - 1];$/;"	m	class:WTF::AVLTree::Iterator	access:protected
WTF::AVLTree::Iterator::start_iter	.\AVLTree.h	/^        void start_iter(AVLTree &tree, key k, SearchType st = EQUAL)$/;"	f	class:WTF::AVLTree::Iterator	access:public	signature:(AVLTree &tree, key k, SearchType st = EQUAL)
WTF::AVLTree::Iterator::start_iter_greatest	.\AVLTree.h	/^        void start_iter_greatest(AVLTree &tree)$/;"	f	class:WTF::AVLTree::Iterator	access:public	signature:(AVLTree &tree)
WTF::AVLTree::Iterator::start_iter_least	.\AVLTree.h	/^        void start_iter_least(AVLTree &tree)$/;"	f	class:WTF::AVLTree::Iterator	access:public	signature:(AVLTree &tree)
WTF::AVLTree::Iterator::tree_	.\AVLTree.h	/^        AVLTree *tree_;$/;"	m	class:WTF::AVLTree::Iterator	access:protected
WTF::AVLTree::LESS	.\AVLTree.h	/^        LESS = 2,$/;"	e	enum:WTF::AVLTree::SearchType
WTF::AVLTree::LESS_EQUAL	.\AVLTree.h	/^        LESS_EQUAL = EQUAL | LESS,$/;"	e	enum:WTF::AVLTree::SearchType
WTF::AVLTree::SearchType	.\AVLTree.h	/^    enum SearchType {$/;"	g	class:WTF::AVLTree	access:public
WTF::AVLTree::abs	.\AVLTree.h	/^    abs_plus_root abs;$/;"	m	class:WTF::AVLTree	access:protected
WTF::AVLTree::abs_plus_root	.\AVLTree.h	/^    struct abs_plus_root : public Abstractor {$/;"	s	class:WTF::AVLTree	inherits:Abstractor	access:protected
WTF::AVLTree::abs_plus_root::root	.\AVLTree.h	/^        handle root;$/;"	m	struct:WTF::AVLTree::abs_plus_root	access:public
WTF::AVLTree::abstractor	.\AVLTree.h	/^    Abstractor& abstractor() { return abs; }$/;"	f	class:WTF::AVLTree	access:public	signature:()
WTF::AVLTree::balance	.\AVLTree.h	/^    handle balance(handle bal_h)$/;"	f	class:WTF::AVLTree	access:private	signature:(handle bal_h)
WTF::AVLTree::build	.\AVLTree.h	/^    bool build(fwd_iter p, size num_nodes)$/;"	f	class:WTF::AVLTree	access:public	signature:(fwd_iter p, size num_nodes)
WTF::AVLTree::cmp_k_n	.\AVLTree.h	/^    int cmp_k_n(key k, handle h) { return abs.compare_key_node(k, h); }$/;"	f	class:WTF::AVLTree	access:protected	signature:(key k, handle h)
WTF::AVLTree::cmp_n_n	.\AVLTree.h	/^    int cmp_n_n(handle h1, handle h2) { return abs.compare_node_node(h1, h2); }$/;"	f	class:WTF::AVLTree	access:protected	signature:(handle h1, handle h2)
WTF::AVLTree::get_bf	.\AVLTree.h	/^    int get_bf(handle h) { return abs.get_balance_factor(h); }$/;"	f	class:WTF::AVLTree	access:protected	signature:(handle h)
WTF::AVLTree::get_gt	.\AVLTree.h	/^    handle get_gt(handle h) { return abs.get_greater(h); }$/;"	f	class:WTF::AVLTree	access:protected	signature:(handle h)
WTF::AVLTree::get_lt	.\AVLTree.h	/^    handle get_lt(handle h) { return abs.get_less(h); }$/;"	f	class:WTF::AVLTree	access:protected	signature:(handle h)
WTF::AVLTree::handle	.\AVLTree.h	/^    typedef typename Abstractor::handle handle;$/;"	t	class:WTF::AVLTree	access:public
WTF::AVLTree::insert	.\AVLTree.h	/^    inline handle insert(handle h);$/;"	p	class:WTF::AVLTree	access:public	signature:(handle h)
WTF::AVLTree::insert	.\AVLTree.h	/^AVLTree<Abstractor, maxDepth, BSet>::insert(handle h)$/;"	f	class:WTF::AVLTree	signature:(handle h)
WTF::AVLTree::is_empty	.\AVLTree.h	/^    bool is_empty() { return abs.root == null(); }$/;"	f	class:WTF::AVLTree	access:public	signature:()
WTF::AVLTree::key	.\AVLTree.h	/^    typedef typename Abstractor::key key;$/;"	t	class:WTF::AVLTree	access:public
WTF::AVLTree::null	.\AVLTree.h	/^    handle null() { return abs.null(); }$/;"	f	class:WTF::AVLTree	access:protected	signature:()
WTF::AVLTree::purge	.\AVLTree.h	/^    void purge() { abs.root = null(); }$/;"	f	class:WTF::AVLTree	access:public	signature:()
WTF::AVLTree::remove	.\AVLTree.h	/^    inline handle remove(key k);$/;"	p	class:WTF::AVLTree	access:public	signature:(key k)
WTF::AVLTree::remove	.\AVLTree.h	/^AVLTree<Abstractor, maxDepth, BSet>::remove(key k)$/;"	f	class:WTF::AVLTree	signature:(key k)
WTF::AVLTree::search	.\AVLTree.h	/^    inline handle search(key k, SearchType st = EQUAL);$/;"	p	class:WTF::AVLTree	access:public	signature:(key k, SearchType st = EQUAL)
WTF::AVLTree::search	.\AVLTree.h	/^AVLTree<Abstractor, maxDepth, BSet>::search(key k, typename AVLTree<Abstractor, maxDepth, BSet>::SearchType st)$/;"	f	class:WTF::AVLTree	signature:(key k, typename AVLTree<Abstractor, maxDepth, BSet>::SearchType st)
WTF::AVLTree::search_greatest	.\AVLTree.h	/^    inline handle search_greatest();$/;"	p	class:WTF::AVLTree	access:public	signature:()
WTF::AVLTree::search_greatest	.\AVLTree.h	/^AVLTree<Abstractor, maxDepth, BSet>::search_greatest()$/;"	f	class:WTF::AVLTree	signature:()
WTF::AVLTree::search_least	.\AVLTree.h	/^    inline handle search_least();$/;"	p	class:WTF::AVLTree	access:public	signature:()
WTF::AVLTree::search_least	.\AVLTree.h	/^AVLTree<Abstractor, maxDepth, BSet>::search_least()$/;"	f	class:WTF::AVLTree	signature:()
WTF::AVLTree::set_bf	.\AVLTree.h	/^    void set_bf(handle h, int bf) { abs.set_balance_factor(h, bf); }$/;"	f	class:WTF::AVLTree	access:protected	signature:(handle h, int bf)
WTF::AVLTree::set_gt	.\AVLTree.h	/^    void set_gt(handle h, handle gh) { abs.set_greater(h, gh); }$/;"	f	class:WTF::AVLTree	access:protected	signature:(handle h, handle gh)
WTF::AVLTree::set_lt	.\AVLTree.h	/^    void set_lt(handle h, handle lh) { abs.set_less(h, lh); }$/;"	f	class:WTF::AVLTree	access:protected	signature:(handle h, handle lh)
WTF::AVLTree::size	.\AVLTree.h	/^    typedef typename Abstractor::size size;$/;"	t	class:WTF::AVLTree	access:public
WTF::AVLTree::subst	.\AVLTree.h	/^    inline handle subst(handle new_node);$/;"	p	class:WTF::AVLTree	access:public	signature:(handle new_node)
WTF::AVLTree::subst	.\AVLTree.h	/^AVLTree<Abstractor, maxDepth, BSet>::subst(handle new_node)$/;"	f	class:WTF::AVLTree	signature:(handle new_node)
WTF::AVLTreeDefaultBSet	.\AVLTree.h	/^class AVLTreeDefaultBSet {$/;"	c	namespace:WTF
WTF::AVLTreeDefaultBSet::m_data	.\AVLTree.h	/^    FixedArray<bool, maxDepth> m_data;$/;"	m	class:WTF::AVLTreeDefaultBSet	access:private
WTF::AVLTreeDefaultBSet::operator []	.\AVLTree.h	/^    bool& operator[](unsigned i) { ASSERT(i < maxDepth); return m_data[i]; }$/;"	f	class:WTF::AVLTreeDefaultBSet	access:public	signature:(unsigned i)
WTF::AVLTreeDefaultBSet::reset	.\AVLTree.h	/^    void reset() { for (unsigned i = 0; i < maxDepth; ++i) m_data[i] = false; }$/;"	f	class:WTF::AVLTreeDefaultBSet	access:public	signature:()
WTF::AVLTreeDefaultBSet::set	.\AVLTree.h	/^    void set() { for (unsigned i = 0; i < maxDepth; ++i) m_data[i] = true; }$/;"	f	class:WTF::AVLTreeDefaultBSet	access:public	signature:()
WTF::AdminRegionRecorder	.\FastMalloc.cpp	/^class AdminRegionRecorder {$/;"	c	namespace:WTF	file:
WTF::AdminRegionRecorder::AdminRegionRecorder	.\FastMalloc.cpp	/^    AdminRegionRecorder(task_t task, void* context, unsigned typeMask, vm_range_recorder_t* recorder, const RemoteMemoryReader& reader)$/;"	f	class:WTF::AdminRegionRecorder	access:public	signature:(task_t task, void* context, unsigned typeMask, vm_range_recorder_t* recorder, const RemoteMemoryReader& reader)
WTF::AdminRegionRecorder::m_context	.\FastMalloc.cpp	/^    void* m_context;$/;"	m	class:WTF::AdminRegionRecorder	file:	access:private
WTF::AdminRegionRecorder::m_pendingRegions	.\FastMalloc.cpp	/^    Vector<vm_range_t, 1024> m_pendingRegions;$/;"	m	class:WTF::AdminRegionRecorder	file:	access:private
WTF::AdminRegionRecorder::m_reader	.\FastMalloc.cpp	/^    const RemoteMemoryReader& m_reader;$/;"	m	class:WTF::AdminRegionRecorder	file:	access:private
WTF::AdminRegionRecorder::m_recorder	.\FastMalloc.cpp	/^    vm_range_recorder_t* m_recorder;$/;"	m	class:WTF::AdminRegionRecorder	file:	access:private
WTF::AdminRegionRecorder::m_task	.\FastMalloc.cpp	/^    task_t m_task;$/;"	m	class:WTF::AdminRegionRecorder	file:	access:private
WTF::AdminRegionRecorder::m_typeMask	.\FastMalloc.cpp	/^    unsigned m_typeMask;$/;"	m	class:WTF::AdminRegionRecorder	file:	access:private
WTF::AdminRegionRecorder::recordPendingRegions	.\FastMalloc.cpp	/^    void recordPendingRegions()$/;"	f	class:WTF::AdminRegionRecorder	access:public	signature:()
WTF::AdminRegionRecorder::recordRegion	.\FastMalloc.cpp	/^    void recordRegion(vm_address_t ptr, size_t size)$/;"	f	class:WTF::AdminRegionRecorder	access:public	signature:(vm_address_t ptr, size_t size)
WTF::AdminRegionRecorder::visit	.\FastMalloc.cpp	/^    void visit(void *ptr, size_t size)$/;"	f	class:WTF::AdminRegionRecorder	access:public	signature:(void *ptr, size_t size)
WTF::AdminRegionRecorder::~AdminRegionRecorder	.\FastMalloc.cpp	/^    ~AdminRegionRecorder()$/;"	f	class:WTF::AdminRegionRecorder	access:public	signature:()
WTF::AdoptCF	.\RetainPtr.h	/^    enum AdoptCFTag { AdoptCF };$/;"	e	enum:WTF::AdoptCFTag
WTF::AdoptCFTag	.\RetainPtr.h	/^    enum AdoptCFTag { AdoptCF };$/;"	g	namespace:WTF
WTF::AdoptNS	.\RetainPtr.h	/^    enum AdoptNSTag { AdoptNS };$/;"	e	enum:WTF::AdoptNSTag
WTF::AdoptNSTag	.\RetainPtr.h	/^    enum AdoptNSTag { AdoptNS };$/;"	g	namespace:WTF
WTF::AlignedBuffer	.\Alignment.h	/^    template<size_t size> struct AlignedBuffer<size, 16> { WTF_ALIGNED(AlignedBufferChar, buffer[size], 16); };$/;"	s	namespace:WTF
WTF::AlignedBuffer	.\Alignment.h	/^    template<size_t size> struct AlignedBuffer<size, 1> { AlignedBufferChar buffer[size]; };$/;"	s	namespace:WTF
WTF::AlignedBuffer	.\Alignment.h	/^    template<size_t size> struct AlignedBuffer<size, 2> { WTF_ALIGNED(AlignedBufferChar, buffer[size], 2);  };$/;"	s	namespace:WTF
WTF::AlignedBuffer	.\Alignment.h	/^    template<size_t size> struct AlignedBuffer<size, 32> { WTF_ALIGNED(AlignedBufferChar, buffer[size], 32); };$/;"	s	namespace:WTF
WTF::AlignedBuffer	.\Alignment.h	/^    template<size_t size> struct AlignedBuffer<size, 4> { WTF_ALIGNED(AlignedBufferChar, buffer[size], 4);  };$/;"	s	namespace:WTF
WTF::AlignedBuffer	.\Alignment.h	/^    template<size_t size> struct AlignedBuffer<size, 64> { WTF_ALIGNED(AlignedBufferChar, buffer[size], 64); };$/;"	s	namespace:WTF
WTF::AlignedBuffer	.\Alignment.h	/^    template<size_t size> struct AlignedBuffer<size, 8> { WTF_ALIGNED(AlignedBufferChar, buffer[size], 8);  };$/;"	s	namespace:WTF
WTF::AlignedBuffer::WTF_ALIGNED	.\Alignment.h	/^    template<size_t size> struct AlignedBuffer<size, 16> { WTF_ALIGNED(AlignedBufferChar, buffer[size], 16); };$/;"	p	struct:WTF::AlignedBuffer	access:public	signature:(AlignedBufferChar, buffer[size], 16)
WTF::AlignedBuffer::WTF_ALIGNED	.\Alignment.h	/^    template<size_t size> struct AlignedBuffer<size, 2> { WTF_ALIGNED(AlignedBufferChar, buffer[size], 2);  };$/;"	p	struct:WTF::AlignedBuffer	access:public	signature:(AlignedBufferChar, buffer[size], 2)
WTF::AlignedBuffer::WTF_ALIGNED	.\Alignment.h	/^    template<size_t size> struct AlignedBuffer<size, 32> { WTF_ALIGNED(AlignedBufferChar, buffer[size], 32); };$/;"	p	struct:WTF::AlignedBuffer	access:public	signature:(AlignedBufferChar, buffer[size], 32)
WTF::AlignedBuffer::WTF_ALIGNED	.\Alignment.h	/^    template<size_t size> struct AlignedBuffer<size, 4> { WTF_ALIGNED(AlignedBufferChar, buffer[size], 4);  };$/;"	p	struct:WTF::AlignedBuffer	access:public	signature:(AlignedBufferChar, buffer[size], 4)
WTF::AlignedBuffer::WTF_ALIGNED	.\Alignment.h	/^    template<size_t size> struct AlignedBuffer<size, 64> { WTF_ALIGNED(AlignedBufferChar, buffer[size], 64); };$/;"	p	struct:WTF::AlignedBuffer	access:public	signature:(AlignedBufferChar, buffer[size], 64)
WTF::AlignedBuffer::WTF_ALIGNED	.\Alignment.h	/^    template<size_t size> struct AlignedBuffer<size, 8> { WTF_ALIGNED(AlignedBufferChar, buffer[size], 8);  };$/;"	p	struct:WTF::AlignedBuffer	access:public	signature:(AlignedBufferChar, buffer[size], 8)
WTF::AlignedBuffer::buffer	.\Alignment.h	/^    template<size_t size> struct AlignedBuffer<size, 1> { AlignedBufferChar buffer[size]; };$/;"	m	struct:WTF::AlignedBuffer	access:public
WTF::AlignedBufferChar	.\Alignment.h	/^    typedef char __attribute__((__may_alias__)) AlignedBufferChar; $/;"	t	namespace:WTF
WTF::AllocAlignmentInteger	.\FastMalloc.h	/^    typedef unsigned long long AllocAlignmentInteger;$/;"	t	namespace:WTF
WTF::AllocAlignmentInteger	.\wince\FastMallocWinCE.h	/^    typedef unsigned long long AllocAlignmentInteger;$/;"	t	namespace:WTF
WTF::AllocationSize	.\FastMalloc.cpp	/^static size_t AllocationSize(size_t bytes) {$/;"	f	namespace:WTF	file:	signature:(size_t bytes)
WTF::AllowTrailingJunk	.\dtoa.h	/^enum AllowTrailingJunkTag { DisallowTrailingJunk = 0, AllowTrailingJunk };$/;"	e	enum:WTF::AllowTrailingJunkTag
WTF::AllowTrailingJunkTag	.\dtoa.h	/^enum AllowTrailingJunkTag { DisallowTrailingJunk = 0, AllowTrailingJunk };$/;"	g	namespace:WTF
WTF::AllowTrailingSpaces	.\dtoa.h	/^enum AllowTrailingSpacesTag { DisallowTrailingSpaces = 0, AllowTrailingSpaces };$/;"	e	enum:WTF::AllowTrailingSpacesTag
WTF::AllowTrailingSpacesTag	.\dtoa.h	/^enum AllowTrailingSpacesTag { DisallowTrailingSpaces = 0, AllowTrailingSpaces };$/;"	g	namespace:WTF
WTF::AlreadyHashed	.\text\StringHash.h	/^    struct AlreadyHashed : IntHash<unsigned> {$/;"	s	namespace:WTF	inherits:IntHash
WTF::AlreadyHashed::avoidDeletedValue	.\text\StringHash.h	/^        static unsigned avoidDeletedValue(unsigned hash)$/;"	f	struct:WTF::AlreadyHashed	access:public	signature:(unsigned hash)
WTF::AlreadyHashed::hash	.\text\StringHash.h	/^        static unsigned hash(unsigned key) { return key; }$/;"	f	struct:WTF::AlreadyHashed	access:public	signature:(unsigned key)
WTF::ArithmeticOperations	.\CheckedArithmetic.h	/^template <typename LHS, typename RHS, typename ResultType> struct ArithmeticOperations<LHS, RHS, ResultType, false, false> {$/;"	s	namespace:WTF
WTF::ArithmeticOperations	.\CheckedArithmetic.h	/^template <typename LHS, typename RHS, typename ResultType> struct ArithmeticOperations<LHS, RHS, ResultType, true, true> {$/;"	s	namespace:WTF
WTF::ArithmeticOperations	.\CheckedArithmetic.h	/^template <typename ResultType> struct ArithmeticOperations<int, unsigned, ResultType, true, false> {$/;"	s	namespace:WTF
WTF::ArithmeticOperations	.\CheckedArithmetic.h	/^template <typename ResultType> struct ArithmeticOperations<unsigned, int, ResultType, false, true> {$/;"	s	namespace:WTF
WTF::ArithmeticOperations::add	.\CheckedArithmetic.h	/^    static inline bool add(int64_t lhs, int64_t rhs, ResultType& result)$/;"	f	struct:WTF::ArithmeticOperations	access:public	signature:(int64_t lhs, int64_t rhs, ResultType& result)
WTF::ArithmeticOperations::equals	.\CheckedArithmetic.h	/^    static inline bool equals(LHS lhs, RHS rhs) { return lhs == rhs; }$/;"	f	struct:WTF::ArithmeticOperations	access:public	signature:(LHS lhs, RHS rhs)
WTF::ArithmeticOperations::equals	.\CheckedArithmetic.h	/^    static inline bool equals(int lhs, unsigned rhs)$/;"	f	struct:WTF::ArithmeticOperations	access:public	signature:(int lhs, unsigned rhs)
WTF::ArithmeticOperations::equals	.\CheckedArithmetic.h	/^    static inline bool equals(unsigned lhs, int rhs)$/;"	f	struct:WTF::ArithmeticOperations	access:public	signature:(unsigned lhs, int rhs)
WTF::ArithmeticOperations::multiply	.\CheckedArithmetic.h	/^    static inline bool multiply(int64_t lhs, int64_t rhs, ResultType& result)$/;"	f	struct:WTF::ArithmeticOperations	access:public	signature:(int64_t lhs, int64_t rhs, ResultType& result)
WTF::ArithmeticOperations::signsMatch	.\CheckedArithmetic.h	/^    static inline bool signsMatch(LHS lhs, RHS rhs)$/;"	f	struct:WTF::ArithmeticOperations	access:public	signature:(LHS lhs, RHS rhs)
WTF::ArithmeticOperations::sub	.\CheckedArithmetic.h	/^    static inline bool sub(int64_t lhs, int64_t rhs, ResultType& result)$/;"	f	struct:WTF::ArithmeticOperations	access:public	signature:(int64_t lhs, int64_t rhs, ResultType& result)
WTF::ArrayBuffer	.\ArrayBuffer.h	/^class ArrayBuffer : public RefCounted<ArrayBuffer> {$/;"	c	namespace:WTF	inherits:RefCounted
WTF::ArrayBuffer::ArrayBuffer	.\ArrayBuffer.h	/^    inline ArrayBuffer(ArrayBufferContents&);$/;"	p	class:WTF::ArrayBuffer	access:private	signature:(ArrayBufferContents&)
WTF::ArrayBuffer::ArrayBuffer	.\ArrayBuffer.h	/^ArrayBuffer::ArrayBuffer(ArrayBufferContents& contents)$/;"	f	class:WTF::ArrayBuffer	signature:(ArrayBufferContents& contents)
WTF::ArrayBuffer::addView	.\ArrayBuffer.cpp	/^void ArrayBuffer::addView(ArrayBufferView* view)$/;"	f	class:WTF::ArrayBuffer	signature:(ArrayBufferView* view)
WTF::ArrayBuffer::addView	.\ArrayBuffer.h	/^    void addView(ArrayBufferView*);$/;"	p	class:WTF::ArrayBuffer	access:public	signature:(ArrayBufferView*)
WTF::ArrayBuffer::byteLength	.\ArrayBuffer.h	/^    inline unsigned byteLength() const;$/;"	p	class:WTF::ArrayBuffer	access:public	signature:() const
WTF::ArrayBuffer::byteLength	.\ArrayBuffer.h	/^unsigned ArrayBuffer::byteLength() const$/;"	f	class:WTF::ArrayBuffer	signature:() const
WTF::ArrayBuffer::clampIndex	.\ArrayBuffer.h	/^    inline unsigned clampIndex(int index) const;$/;"	p	class:WTF::ArrayBuffer	access:private	signature:(int index) const
WTF::ArrayBuffer::clampIndex	.\ArrayBuffer.h	/^unsigned ArrayBuffer::clampIndex(int index) const$/;"	f	class:WTF::ArrayBuffer	signature:(int index) const
WTF::ArrayBuffer::clampValue	.\ArrayBuffer.h	/^    static inline int clampValue(int x, int left, int right);$/;"	p	class:WTF::ArrayBuffer	access:private	signature:(int x, int left, int right)
WTF::ArrayBuffer::clampValue	.\ArrayBuffer.h	/^int ArrayBuffer::clampValue(int x, int left, int right)$/;"	f	class:WTF::ArrayBuffer	signature:(int x, int left, int right)
WTF::ArrayBuffer::create	.\ArrayBuffer.h	/^    static inline PassRefPtr<ArrayBuffer> create(ArrayBuffer*);$/;"	p	class:WTF::ArrayBuffer	access:public	signature:(ArrayBuffer*)
WTF::ArrayBuffer::create	.\ArrayBuffer.h	/^    static inline PassRefPtr<ArrayBuffer> create(ArrayBufferContents&);$/;"	p	class:WTF::ArrayBuffer	access:public	signature:(ArrayBufferContents&)
WTF::ArrayBuffer::create	.\ArrayBuffer.h	/^    static inline PassRefPtr<ArrayBuffer> create(const void* source, unsigned byteLength);$/;"	p	class:WTF::ArrayBuffer	access:public	signature:(const void* source, unsigned byteLength)
WTF::ArrayBuffer::create	.\ArrayBuffer.h	/^    static inline PassRefPtr<ArrayBuffer> create(unsigned numElements, unsigned elementByteSize);$/;"	p	class:WTF::ArrayBuffer	access:public	signature:(unsigned numElements, unsigned elementByteSize)
WTF::ArrayBuffer::create	.\ArrayBuffer.h	/^PassRefPtr<ArrayBuffer> ArrayBuffer::create(ArrayBuffer* other)$/;"	f	class:WTF::ArrayBuffer	signature:(ArrayBuffer* other)
WTF::ArrayBuffer::create	.\ArrayBuffer.h	/^PassRefPtr<ArrayBuffer> ArrayBuffer::create(ArrayBufferContents& contents)$/;"	f	class:WTF::ArrayBuffer	signature:(ArrayBufferContents& contents)
WTF::ArrayBuffer::create	.\ArrayBuffer.h	/^PassRefPtr<ArrayBuffer> ArrayBuffer::create(const void* source, unsigned byteLength)$/;"	f	class:WTF::ArrayBuffer	signature:(const void* source, unsigned byteLength)
WTF::ArrayBuffer::create	.\ArrayBuffer.h	/^PassRefPtr<ArrayBuffer> ArrayBuffer::create(unsigned numElements, unsigned elementByteSize)$/;"	f	class:WTF::ArrayBuffer	signature:(unsigned numElements, unsigned elementByteSize)
WTF::ArrayBuffer::data	.\ArrayBuffer.h	/^    inline const void* data() const;$/;"	p	class:WTF::ArrayBuffer	access:public	signature:() const
WTF::ArrayBuffer::data	.\ArrayBuffer.h	/^    inline void* data();$/;"	p	class:WTF::ArrayBuffer	access:public	signature:()
WTF::ArrayBuffer::data	.\ArrayBuffer.h	/^const void* ArrayBuffer::data() const$/;"	f	class:WTF::ArrayBuffer	signature:() const
WTF::ArrayBuffer::data	.\ArrayBuffer.h	/^void* ArrayBuffer::data()$/;"	f	class:WTF::ArrayBuffer	signature:()
WTF::ArrayBuffer::isNeutered	.\ArrayBuffer.h	/^    bool isNeutered() { return !m_contents.m_data; }$/;"	f	class:WTF::ArrayBuffer	access:public	signature:()
WTF::ArrayBuffer::m_contents	.\ArrayBuffer.h	/^    ArrayBufferContents m_contents;$/;"	m	class:WTF::ArrayBuffer	access:private
WTF::ArrayBuffer::m_firstView	.\ArrayBuffer.h	/^    ArrayBufferView* m_firstView;$/;"	m	class:WTF::ArrayBuffer	access:private
WTF::ArrayBuffer::removeView	.\ArrayBuffer.cpp	/^void ArrayBuffer::removeView(ArrayBufferView* view)$/;"	f	class:WTF::ArrayBuffer	signature:(ArrayBufferView* view)
WTF::ArrayBuffer::removeView	.\ArrayBuffer.h	/^    void removeView(ArrayBufferView*);$/;"	p	class:WTF::ArrayBuffer	access:public	signature:(ArrayBufferView*)
WTF::ArrayBuffer::slice	.\ArrayBuffer.h	/^    inline PassRefPtr<ArrayBuffer> slice(int begin) const;$/;"	p	class:WTF::ArrayBuffer	access:public	signature:(int begin) const
WTF::ArrayBuffer::slice	.\ArrayBuffer.h	/^    inline PassRefPtr<ArrayBuffer> slice(int begin, int end) const;$/;"	p	class:WTF::ArrayBuffer	access:public	signature:(int begin, int end) const
WTF::ArrayBuffer::slice	.\ArrayBuffer.h	/^PassRefPtr<ArrayBuffer> ArrayBuffer::slice(int begin) const$/;"	f	class:WTF::ArrayBuffer	signature:(int begin) const
WTF::ArrayBuffer::slice	.\ArrayBuffer.h	/^PassRefPtr<ArrayBuffer> ArrayBuffer::slice(int begin, int end) const$/;"	f	class:WTF::ArrayBuffer	signature:(int begin, int end) const
WTF::ArrayBuffer::sliceImpl	.\ArrayBuffer.h	/^    inline PassRefPtr<ArrayBuffer> sliceImpl(unsigned begin, unsigned end) const;$/;"	p	class:WTF::ArrayBuffer	access:private	signature:(unsigned begin, unsigned end) const
WTF::ArrayBuffer::sliceImpl	.\ArrayBuffer.h	/^PassRefPtr<ArrayBuffer> ArrayBuffer::sliceImpl(unsigned begin, unsigned end) const$/;"	f	class:WTF::ArrayBuffer	signature:(unsigned begin, unsigned end) const
WTF::ArrayBuffer::transfer	.\ArrayBuffer.cpp	/^bool ArrayBuffer::transfer(ArrayBufferContents& result, Vector<RefPtr<ArrayBufferView> >& neuteredViews)$/;"	f	class:WTF::ArrayBuffer	signature:(ArrayBufferContents& result, Vector<RefPtr<ArrayBufferView> >& neuteredViews)
WTF::ArrayBuffer::transfer	.\ArrayBuffer.h	/^    WTF_EXPORT_PRIVATE bool transfer(ArrayBufferContents&, Vector<RefPtr<ArrayBufferView> >& neuteredViews);$/;"	p	class:WTF::ArrayBuffer	access:public	signature:(ArrayBufferContents&, Vector<RefPtr<ArrayBufferView> >& neuteredViews)
WTF::ArrayBuffer::~ArrayBuffer	.\ArrayBuffer.h	/^    ~ArrayBuffer() { }$/;"	f	class:WTF::ArrayBuffer	access:public	signature:()
WTF::ArrayBufferContents	.\ArrayBuffer.h	/^class ArrayBufferContents {$/;"	c	namespace:WTF
WTF::ArrayBufferContents::ArrayBufferContents	.\ArrayBuffer.h	/^    ArrayBufferContents() $/;"	f	class:WTF::ArrayBufferContents	access:public	signature:()
WTF::ArrayBufferContents::ArrayBufferContents	.\ArrayBuffer.h	/^    ArrayBufferContents(void* data, unsigned sizeInBytes) $/;"	f	class:WTF::ArrayBufferContents	access:private	signature:(void* data, unsigned sizeInBytes)
WTF::ArrayBufferContents::WTF_MAKE_NONCOPYABLE	.\ArrayBuffer.h	/^    WTF_MAKE_NONCOPYABLE(ArrayBufferContents);$/;"	p	class:WTF::ArrayBufferContents	access:private	signature:(ArrayBufferContents)
WTF::ArrayBufferContents::data	.\ArrayBuffer.h	/^    void* data() { return m_data; }$/;"	f	class:WTF::ArrayBufferContents	access:public	signature:()
WTF::ArrayBufferContents::m_data	.\ArrayBuffer.h	/^    void* m_data;$/;"	m	class:WTF::ArrayBufferContents	access:private
WTF::ArrayBufferContents::m_sizeInBytes	.\ArrayBuffer.h	/^    unsigned m_sizeInBytes;$/;"	m	class:WTF::ArrayBufferContents	access:private
WTF::ArrayBufferContents::sizeInBytes	.\ArrayBuffer.h	/^    unsigned sizeInBytes() { return m_sizeInBytes; }$/;"	f	class:WTF::ArrayBufferContents	access:public	signature:()
WTF::ArrayBufferContents::transfer	.\ArrayBuffer.h	/^    void transfer(ArrayBufferContents& other)$/;"	f	class:WTF::ArrayBufferContents	access:private	signature:(ArrayBufferContents& other)
WTF::ArrayBufferContents::tryAllocate	.\ArrayBuffer.h	/^    static inline void tryAllocate(unsigned numElements, unsigned elementByteSize, ArrayBufferContents&);$/;"	p	class:WTF::ArrayBufferContents	access:private	signature:(unsigned numElements, unsigned elementByteSize, ArrayBufferContents&)
WTF::ArrayBufferContents::tryAllocate	.\ArrayBuffer.h	/^void ArrayBufferContents::tryAllocate(unsigned numElements, unsigned elementByteSize, ArrayBufferContents& result)$/;"	f	class:WTF::ArrayBufferContents	signature:(unsigned numElements, unsigned elementByteSize, ArrayBufferContents& result)
WTF::ArrayBufferContents::~ArrayBufferContents	.\ArrayBuffer.h	/^    inline ~ArrayBufferContents();$/;"	p	class:WTF::ArrayBufferContents	access:public	signature:()
WTF::ArrayBufferContents::~ArrayBufferContents	.\ArrayBuffer.h	/^ArrayBufferContents::~ArrayBufferContents()$/;"	f	class:WTF::ArrayBufferContents	signature:()
WTF::ArrayBufferView	.\ArrayBufferView.h	/^class WTF_EXPORT_PRIVATE_RTTI ArrayBufferView : public RefCounted<ArrayBufferView> {$/;"	c	namespace:WTF	inherits:RefCounted
WTF::ArrayBufferView::ArrayBufferView	.\ArrayBufferView.cpp	/^ArrayBufferView::ArrayBufferView(PassRefPtr<ArrayBuffer> buffer,$/;"	f	class:WTF::ArrayBufferView	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset)
WTF::ArrayBufferView::ArrayBufferView	.\ArrayBufferView.h	/^    WTF_EXPORT_PRIVATE ArrayBufferView(PassRefPtr<ArrayBuffer>, unsigned byteOffset);$/;"	p	class:WTF::ArrayBufferView	access:protected	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset)
WTF::ArrayBufferView::baseAddress	.\ArrayBufferView.h	/^    void* baseAddress() const$/;"	f	class:WTF::ArrayBufferView	access:public	signature:() const
WTF::ArrayBufferView::buffer	.\ArrayBufferView.h	/^    PassRefPtr<ArrayBuffer> buffer() const$/;"	f	class:WTF::ArrayBufferView	access:public	signature:() const
WTF::ArrayBufferView::byteLength	.\ArrayBufferView.h	/^    virtual unsigned byteLength() const = 0;$/;"	p	class:WTF::ArrayBufferView	access:public	signature:() const
WTF::ArrayBufferView::byteOffset	.\ArrayBufferView.h	/^    unsigned byteOffset() const$/;"	f	class:WTF::ArrayBufferView	access:public	signature:() const
WTF::ArrayBufferView::calculateOffsetAndLength	.\ArrayBufferView.h	/^    static inline void calculateOffsetAndLength(int start, int end, unsigned arraySize,$/;"	p	class:WTF::ArrayBufferView	access:protected	signature:(int start, int end, unsigned arraySize, unsigned* offset, unsigned* length)
WTF::ArrayBufferView::calculateOffsetAndLength	.\ArrayBufferView.h	/^void ArrayBufferView::calculateOffsetAndLength(int start, int end, unsigned arraySize,$/;"	f	class:WTF::ArrayBufferView	signature:(int start, int end, unsigned arraySize, unsigned* offset, unsigned* length)
WTF::ArrayBufferView::clampOffsetAndNumElements	.\ArrayBufferView.h	/^    static void clampOffsetAndNumElements(PassRefPtr<ArrayBuffer> buffer,$/;"	f	class:WTF::ArrayBufferView	access:protected	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned arrayByteOffset, unsigned *offset, unsigned *numElements)
WTF::ArrayBufferView::isByteArray	.\ArrayBufferView.h	/^    virtual bool isByteArray() const { return false; }$/;"	f	class:WTF::ArrayBufferView	access:public	signature:() const
WTF::ArrayBufferView::isDataView	.\ArrayBufferView.h	/^    virtual bool isDataView() const { return false; }$/;"	f	class:WTF::ArrayBufferView	access:public	signature:() const
WTF::ArrayBufferView::isDoubleArray	.\ArrayBufferView.h	/^    virtual bool isDoubleArray() const { return false; }$/;"	f	class:WTF::ArrayBufferView	access:public	signature:() const
WTF::ArrayBufferView::isFloatArray	.\ArrayBufferView.h	/^    virtual bool isFloatArray() const { return false; }$/;"	f	class:WTF::ArrayBufferView	access:public	signature:() const
WTF::ArrayBufferView::isIntArray	.\ArrayBufferView.h	/^    virtual bool isIntArray() const { return false; }$/;"	f	class:WTF::ArrayBufferView	access:public	signature:() const
WTF::ArrayBufferView::isShortArray	.\ArrayBufferView.h	/^    virtual bool isShortArray() const { return false; }$/;"	f	class:WTF::ArrayBufferView	access:public	signature:() const
WTF::ArrayBufferView::isUnsignedByteArray	.\ArrayBufferView.h	/^    virtual bool isUnsignedByteArray() const { return false; }$/;"	f	class:WTF::ArrayBufferView	access:public	signature:() const
WTF::ArrayBufferView::isUnsignedByteClampedArray	.\ArrayBufferView.h	/^    virtual bool isUnsignedByteClampedArray() const { return false; }$/;"	f	class:WTF::ArrayBufferView	access:public	signature:() const
WTF::ArrayBufferView::isUnsignedIntArray	.\ArrayBufferView.h	/^    virtual bool isUnsignedIntArray() const { return false; }$/;"	f	class:WTF::ArrayBufferView	access:public	signature:() const
WTF::ArrayBufferView::isUnsignedShortArray	.\ArrayBufferView.h	/^    virtual bool isUnsignedShortArray() const { return false; }$/;"	f	class:WTF::ArrayBufferView	access:public	signature:() const
WTF::ArrayBufferView::m_baseAddress	.\ArrayBufferView.h	/^    void* m_baseAddress;$/;"	m	class:WTF::ArrayBufferView	access:protected
WTF::ArrayBufferView::m_buffer	.\ArrayBufferView.h	/^    RefPtr<ArrayBuffer> m_buffer;$/;"	m	class:WTF::ArrayBufferView	access:private
WTF::ArrayBufferView::m_byteOffset	.\ArrayBufferView.h	/^    unsigned m_byteOffset;$/;"	m	class:WTF::ArrayBufferView	access:protected
WTF::ArrayBufferView::m_nextView	.\ArrayBufferView.h	/^    ArrayBufferView* m_nextView;$/;"	m	class:WTF::ArrayBufferView	access:private
WTF::ArrayBufferView::m_prevView	.\ArrayBufferView.h	/^    ArrayBufferView* m_prevView;$/;"	m	class:WTF::ArrayBufferView	access:private
WTF::ArrayBufferView::neuter	.\ArrayBufferView.cpp	/^void ArrayBufferView::neuter()$/;"	f	class:WTF::ArrayBufferView	signature:()
WTF::ArrayBufferView::neuter	.\ArrayBufferView.h	/^    WTF_EXPORT_PRIVATE virtual void neuter();$/;"	p	class:WTF::ArrayBufferView	access:protected	signature:()
WTF::ArrayBufferView::setImpl	.\ArrayBufferView.h	/^    inline bool setImpl(ArrayBufferView*, unsigned byteOffset);$/;"	p	class:WTF::ArrayBufferView	access:protected	signature:(ArrayBufferView*, unsigned byteOffset)
WTF::ArrayBufferView::setImpl	.\ArrayBufferView.h	/^bool ArrayBufferView::setImpl(ArrayBufferView* array, unsigned byteOffset)$/;"	f	class:WTF::ArrayBufferView	signature:(ArrayBufferView* array, unsigned byteOffset)
WTF::ArrayBufferView::setRangeImpl	.\ArrayBufferView.h	/^    inline bool setRangeImpl(const char* data, size_t dataByteLength, unsigned byteOffset);$/;"	p	class:WTF::ArrayBufferView	access:protected	signature:(const char* data, size_t dataByteLength, unsigned byteOffset)
WTF::ArrayBufferView::setRangeImpl	.\ArrayBufferView.h	/^bool ArrayBufferView::setRangeImpl(const char* data, size_t dataByteLength, unsigned byteOffset)$/;"	f	class:WTF::ArrayBufferView	signature:(const char* data, size_t dataByteLength, unsigned byteOffset)
WTF::ArrayBufferView::verifySubRange	.\ArrayBufferView.h	/^    static bool verifySubRange(PassRefPtr<ArrayBuffer> buffer,$/;"	f	class:WTF::ArrayBufferView	access:protected	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned numElements)
WTF::ArrayBufferView::zeroRangeImpl	.\ArrayBufferView.h	/^    inline bool zeroRangeImpl(unsigned byteOffset, size_t rangeByteLength);$/;"	p	class:WTF::ArrayBufferView	access:protected	signature:(unsigned byteOffset, size_t rangeByteLength)
WTF::ArrayBufferView::zeroRangeImpl	.\ArrayBufferView.h	/^bool ArrayBufferView::zeroRangeImpl(unsigned byteOffset, size_t rangeByteLength)$/;"	f	class:WTF::ArrayBufferView	signature:(unsigned byteOffset, size_t rangeByteLength)
WTF::ArrayBufferView::~ArrayBufferView	.\ArrayBufferView.cpp	/^ArrayBufferView::~ArrayBufferView()$/;"	f	class:WTF::ArrayBufferView	signature:()
WTF::ArrayBufferView::~ArrayBufferView	.\ArrayBufferView.h	/^    WTF_EXPORT_PRIVATE virtual ~ArrayBufferView();$/;"	p	class:WTF::ArrayBufferView	access:public	signature:()
WTF::ArrayLengthHelperFunction	.\StdLibExtras.h	/^template<typename T, size_t Size> char (&ArrayLengthHelperFunction(T (&)[Size]))[Size];$/;"	p	namespace:WTF	signature:(T (
WTF::AtomicString	.\text\AtomicString.h	/^class AtomicString {$/;"	c	namespace:WTF
WTF::AtomicString::AtomicString	.\text\AtomicString.h	/^    ATOMICSTRING_CONVERSION AtomicString(StringImpl* imp) : m_string(add(imp)) { }$/;"	f	class:WTF::AtomicString	access:public	signature:(StringImpl* imp)
WTF::AtomicString::AtomicString	.\text\AtomicString.h	/^    ATOMICSTRING_CONVERSION AtomicString(const String& s) : m_string(add(s.impl())) { }$/;"	f	class:WTF::AtomicString	access:public	signature:(const String& s)
WTF::AtomicString::AtomicString	.\text\AtomicString.h	/^    AtomicString() { }$/;"	f	class:WTF::AtomicString	access:public	signature:()
WTF::AtomicString::AtomicString	.\text\AtomicString.h	/^    AtomicString(AtomicStringImpl* imp) : m_string(imp) { }$/;"	f	class:WTF::AtomicString	access:public	signature:(AtomicStringImpl* imp)
WTF::AtomicString::AtomicString	.\text\AtomicString.h	/^    AtomicString(CFStringRef s) :  m_string(add(String(s).impl())) { }$/;"	f	class:WTF::AtomicString	access:public	signature:(CFStringRef s)
WTF::AtomicString::AtomicString	.\text\AtomicString.h	/^    AtomicString(NSString* s) : m_string(add(String(s).impl())) { }$/;"	f	class:WTF::AtomicString	access:public	signature:(NSString* s)
WTF::AtomicString::AtomicString	.\text\AtomicString.h	/^    AtomicString(StringImpl* baseString, unsigned start, unsigned length) : m_string(add(baseString, start, length)) { }$/;"	f	class:WTF::AtomicString	access:public	signature:(StringImpl* baseString, unsigned start, unsigned length)
WTF::AtomicString::AtomicString	.\text\AtomicString.h	/^    AtomicString(WTF::HashTableDeletedValueType) : m_string(WTF::HashTableDeletedValue) { }$/;"	f	class:WTF::AtomicString	access:public	signature:(WTF::HashTableDeletedValueType)
WTF::AtomicString::AtomicString	.\text\AtomicString.h	/^    AtomicString(const LChar* s) : m_string(add(s)) { }$/;"	f	class:WTF::AtomicString	access:public	signature:(const LChar* s)
WTF::AtomicString::AtomicString	.\text\AtomicString.h	/^    AtomicString(const QString& s) : m_string(add(String(s).impl())) { }$/;"	f	class:WTF::AtomicString	access:public	signature:(const QString& s)
WTF::AtomicString::AtomicString	.\text\AtomicString.h	/^    AtomicString(const UChar* s) : m_string(add(s)) { }$/;"	f	class:WTF::AtomicString	access:public	signature:(const UChar* s)
WTF::AtomicString::AtomicString	.\text\AtomicString.h	/^    AtomicString(const UChar* s, unsigned length) : m_string(add(s, length)) { }$/;"	f	class:WTF::AtomicString	access:public	signature:(const UChar* s, unsigned length)
WTF::AtomicString::AtomicString	.\text\AtomicString.h	/^    AtomicString(const UChar* s, unsigned length, unsigned existingHash) : m_string(add(s, length, existingHash)) { }$/;"	f	class:WTF::AtomicString	access:public	signature:(const UChar* s, unsigned length, unsigned existingHash)
WTF::AtomicString::AtomicString	.\text\AtomicString.h	/^    AtomicString(const char* s) : m_string(add(s)) { }$/;"	f	class:WTF::AtomicString	access:public	signature:(const char* s)
WTF::AtomicString::add	.\text\AtomicString.cpp	/^PassRefPtr<StringImpl> AtomicString::add(StringImpl* baseString, unsigned start, unsigned length)$/;"	f	class:WTF::AtomicString	signature:(StringImpl* baseString, unsigned start, unsigned length)
WTF::AtomicString::add	.\text\AtomicString.cpp	/^PassRefPtr<StringImpl> AtomicString::add(const LChar* c)$/;"	f	class:WTF::AtomicString	signature:(const LChar* c)
WTF::AtomicString::add	.\text\AtomicString.cpp	/^PassRefPtr<StringImpl> AtomicString::add(const UChar* s)$/;"	f	class:WTF::AtomicString	signature:(const UChar* s)
WTF::AtomicString::add	.\text\AtomicString.cpp	/^PassRefPtr<StringImpl> AtomicString::add(const UChar* s, unsigned length)$/;"	f	class:WTF::AtomicString	signature:(const UChar* s, unsigned length)
WTF::AtomicString::add	.\text\AtomicString.cpp	/^PassRefPtr<StringImpl> AtomicString::add(const UChar* s, unsigned length, unsigned existingHash)$/;"	f	class:WTF::AtomicString	signature:(const UChar* s, unsigned length, unsigned existingHash)
WTF::AtomicString::add	.\text\AtomicString.h	/^    ALWAYS_INLINE static PassRefPtr<StringImpl> add(StringImpl* r)$/;"	f	class:WTF::AtomicString	access:private	signature:(StringImpl* r)
WTF::AtomicString::add	.\text\AtomicString.h	/^    ALWAYS_INLINE static PassRefPtr<StringImpl> add(const char* s) { return add(reinterpret_cast<const LChar*>(s)); };$/;"	f	class:WTF::AtomicString	access:private	signature:(const char* s)
WTF::AtomicString::add	.\text\AtomicString.h	/^    ALWAYS_INLINE static PassRefPtr<StringImpl> add(const char* s, unsigned length) { return add(reinterpret_cast<const char*>(s), length); };$/;"	f	class:WTF::AtomicString	access:private	signature:(const char* s, unsigned length)
WTF::AtomicString::add	.\text\AtomicString.h	/^    WTF_EXPORT_PRIVATE static PassRefPtr<StringImpl> add(StringImpl*, unsigned offset, unsigned length);$/;"	p	class:WTF::AtomicString	access:private	signature:(StringImpl*, unsigned offset, unsigned length)
WTF::AtomicString::add	.\text\AtomicString.h	/^    WTF_EXPORT_PRIVATE static PassRefPtr<StringImpl> add(const LChar*);$/;"	p	class:WTF::AtomicString	access:private	signature:(const LChar*)
WTF::AtomicString::add	.\text\AtomicString.h	/^    WTF_EXPORT_PRIVATE static PassRefPtr<StringImpl> add(const UChar*);$/;"	p	class:WTF::AtomicString	access:private	signature:(const UChar*)
WTF::AtomicString::add	.\text\AtomicString.h	/^    WTF_EXPORT_PRIVATE static PassRefPtr<StringImpl> add(const UChar*, unsigned length);$/;"	p	class:WTF::AtomicString	access:private	signature:(const UChar*, unsigned length)
WTF::AtomicString::add	.\text\AtomicString.h	/^    WTF_EXPORT_PRIVATE static PassRefPtr<StringImpl> add(const UChar*, unsigned length, unsigned existingHash);$/;"	p	class:WTF::AtomicString	access:private	signature:(const UChar*, unsigned length, unsigned existingHash)
WTF::AtomicString::addSlowCase	.\text\AtomicString.cpp	/^PassRefPtr<StringImpl> AtomicString::addSlowCase(StringImpl* r)$/;"	f	class:WTF::AtomicString	signature:(StringImpl* r)
WTF::AtomicString::addSlowCase	.\text\AtomicString.h	/^    WTF_EXPORT_PRIVATE static PassRefPtr<StringImpl> addSlowCase(StringImpl*);$/;"	p	class:WTF::AtomicString	access:private	signature:(StringImpl*)
WTF::AtomicString::characters	.\text\AtomicString.h	/^    const UChar* characters() const { return m_string.characters(); }$/;"	f	class:WTF::AtomicString	access:public	signature:() const
WTF::AtomicString::contains	.\text\AtomicString.h	/^    bool contains(UChar c) const { return m_string.contains(c); }$/;"	f	class:WTF::AtomicString	access:public	signature:(UChar c) const
WTF::AtomicString::contains	.\text\AtomicString.h	/^    bool contains(const LChar* s, bool caseSensitive = true) const$/;"	f	class:WTF::AtomicString	access:public	signature:(const LChar* s, bool caseSensitive = true) const
WTF::AtomicString::contains	.\text\AtomicString.h	/^    bool contains(const String& s, bool caseSensitive = true) const$/;"	f	class:WTF::AtomicString	access:public	signature:(const String& s, bool caseSensitive = true) const
WTF::AtomicString::createCFString	.\text\AtomicString.h	/^    CFStringRef createCFString() const { return m_string.createCFString(); }$/;"	f	class:WTF::AtomicString	access:public	signature:() const
WTF::AtomicString::endsWith	.\text\AtomicString.h	/^    bool endsWith(const String& s, bool caseSensitive = true) const$/;"	f	class:WTF::AtomicString	access:public	signature:(const String& s, bool caseSensitive = true) const
WTF::AtomicString::find	.\text\AtomicString.cpp	/^AtomicStringImpl* AtomicString::find(const UChar* s, unsigned length, unsigned existingHash)$/;"	f	class:WTF::AtomicString	signature:(const UChar* s, unsigned length, unsigned existingHash)
WTF::AtomicString::find	.\text\AtomicString.h	/^    WTF_EXPORT_PRIVATE static AtomicStringImpl* find(const UChar* s, unsigned length, unsigned existingHash);$/;"	p	class:WTF::AtomicString	access:public	signature:(const UChar* s, unsigned length, unsigned existingHash)
WTF::AtomicString::find	.\text\AtomicString.h	/^    size_t find(UChar c, size_t start = 0) const { return m_string.find(c, start); }$/;"	f	class:WTF::AtomicString	access:public	signature:(UChar c, size_t start = 0) const
WTF::AtomicString::find	.\text\AtomicString.h	/^    size_t find(const LChar* s, size_t start = 0, bool caseSentitive = true) const$/;"	f	class:WTF::AtomicString	access:public	signature:(const LChar* s, size_t start = 0, bool caseSentitive = true) const
WTF::AtomicString::find	.\text\AtomicString.h	/^    size_t find(const String& s, size_t start = 0, bool caseSentitive = true) const$/;"	f	class:WTF::AtomicString	access:public	signature:(const String& s, size_t start = 0, bool caseSentitive = true) const
WTF::AtomicString::fromUTF8	.\text\AtomicString.h	/^    static AtomicString fromUTF8(const char*);$/;"	p	class:WTF::AtomicString	access:public	signature:(const char*)
WTF::AtomicString::fromUTF8	.\text\AtomicString.h	/^    static AtomicString fromUTF8(const char*, size_t);$/;"	p	class:WTF::AtomicString	access:public	signature:(const char*, size_t)
WTF::AtomicString::fromUTF8	.\text\AtomicString.h	/^inline AtomicString AtomicString::fromUTF8(const char* characters)$/;"	f	class:WTF::AtomicString	signature:(const char* characters)
WTF::AtomicString::fromUTF8	.\text\AtomicString.h	/^inline AtomicString AtomicString::fromUTF8(const char* characters, size_t length)$/;"	f	class:WTF::AtomicString	signature:(const char* characters, size_t length)
WTF::AtomicString::fromUTF8Internal	.\text\AtomicString.cpp	/^AtomicString AtomicString::fromUTF8Internal(const char* charactersStart, const char* charactersEnd)$/;"	f	class:WTF::AtomicString	signature:(const char* charactersStart, const char* charactersEnd)
WTF::AtomicString::fromUTF8Internal	.\text\AtomicString.h	/^    WTF_EXPORT_PRIVATE static AtomicString fromUTF8Internal(const char*, const char*);$/;"	p	class:WTF::AtomicString	access:private	signature:(const char*, const char*)
WTF::AtomicString::impl	.\text\AtomicString.h	/^    AtomicStringImpl* impl() const { return static_cast<AtomicStringImpl *>(m_string.impl()); }$/;"	f	class:WTF::AtomicString	access:public	signature:() const
WTF::AtomicString::init	.\text\AtomicString.h	/^    WTF_EXPORT_PRIVATE static void init();$/;"	p	class:WTF::AtomicString	access:public	signature:()
WTF::AtomicString::init	.\text\StringStatics.cpp	/^void AtomicString::init()$/;"	f	class:WTF::AtomicString	signature:()
WTF::AtomicString::isEmpty	.\text\AtomicString.h	/^    bool isEmpty() const { return m_string.isEmpty(); }$/;"	f	class:WTF::AtomicString	access:public	signature:() const
WTF::AtomicString::isHashTableDeletedValue	.\text\AtomicString.h	/^    bool isHashTableDeletedValue() const { return m_string.isHashTableDeletedValue(); }$/;"	f	class:WTF::AtomicString	access:public	signature:() const
WTF::AtomicString::isNull	.\text\AtomicString.h	/^    bool isNull() const { return m_string.isNull(); }$/;"	f	class:WTF::AtomicString	access:public	signature:() const
WTF::AtomicString::length	.\text\AtomicString.h	/^    unsigned length() const { return m_string.length(); }$/;"	f	class:WTF::AtomicString	access:public	signature:() const
WTF::AtomicString::lower	.\text\AtomicString.cpp	/^AtomicString AtomicString::lower() const$/;"	f	class:WTF::AtomicString	signature:() const
WTF::AtomicString::lower	.\text\AtomicString.h	/^    WTF_EXPORT_PRIVATE AtomicString lower() const;$/;"	p	class:WTF::AtomicString	access:public	signature:() const
WTF::AtomicString::m_string	.\text\AtomicString.h	/^    String m_string;$/;"	m	class:WTF::AtomicString	access:private
WTF::AtomicString::operator NSString*	.\text\AtomicString.h	/^    operator NSString*() const { return m_string; }$/;"	f	class:WTF::AtomicString	access:public	signature:() const
WTF::AtomicString::operator QString	.\text\AtomicString.h	/^    operator QString() const { return m_string; }$/;"	f	class:WTF::AtomicString	access:public	signature:() const
WTF::AtomicString::operator []	.\text\AtomicString.h	/^    UChar operator[](unsigned int i) const { return m_string[i]; }$/;"	f	class:WTF::AtomicString	access:public	signature:(unsigned int i) const
WTF::AtomicString::operator const String&	.\text\AtomicString.h	/^    operator const String&() const { return m_string; }$/;"	f	class:WTF::AtomicString	access:public	signature:() const
WTF::AtomicString::percentage	.\text\AtomicString.h	/^    bool percentage(int& p) const { return m_string.percentage(p); }$/;"	f	class:WTF::AtomicString	access:public	signature:(int& p) const
WTF::AtomicString::remove	.\text\AtomicString.cpp	/^void AtomicString::remove(StringImpl* r)$/;"	f	class:WTF::AtomicString	signature:(StringImpl* r)
WTF::AtomicString::remove	.\text\AtomicString.h	/^    static void remove(StringImpl*);$/;"	p	class:WTF::AtomicString	access:public	signature:(StringImpl*)
WTF::AtomicString::show	.\text\AtomicString.cpp	/^void AtomicString::show() const$/;"	f	class:WTF::AtomicString	signature:() const
WTF::AtomicString::show	.\text\AtomicString.h	/^    void show() const;$/;"	p	class:WTF::AtomicString	access:public	signature:() const
WTF::AtomicString::startsWith	.\text\AtomicString.h	/^    bool startsWith(const String& s, bool caseSensitive = true) const$/;"	f	class:WTF::AtomicString	access:public	signature:(const String& s, bool caseSensitive = true) const
WTF::AtomicString::string	.\text\AtomicString.h	/^    const String& string() const { return m_string; };$/;"	f	class:WTF::AtomicString	access:public	signature:() const
WTF::AtomicString::toDouble	.\text\AtomicString.h	/^    double toDouble(bool* ok = 0) const { return m_string.toDouble(ok); }$/;"	f	class:WTF::AtomicString	access:public	signature:(bool* ok = 0) const
WTF::AtomicString::toFloat	.\text\AtomicString.h	/^    float toFloat(bool* ok = 0) const { return m_string.toFloat(ok); }$/;"	f	class:WTF::AtomicString	access:public	signature:(bool* ok = 0) const
WTF::AtomicString::toInt	.\text\AtomicString.h	/^    int toInt(bool* ok = 0) const { return m_string.toInt(ok); }$/;"	f	class:WTF::AtomicString	access:public	signature:(bool* ok = 0) const
WTF::AtomicString::upper	.\text\AtomicString.h	/^    AtomicString upper() const { return AtomicString(impl()->upper()); }$/;"	f	class:WTF::AtomicString	access:public	signature:() const
WTF::AtomicStringHash	.\text\AtomicStringHash.h	/^    struct AtomicStringHash {$/;"	s	namespace:WTF
WTF::AtomicStringHash::equal	.\text\AtomicStringHash.h	/^        static bool equal(const AtomicString& a, const AtomicString& b)$/;"	f	struct:WTF::AtomicStringHash	access:public	signature:(const AtomicString& a, const AtomicString& b)
WTF::AtomicStringHash::hash	.\text\AtomicStringHash.h	/^        static unsigned hash(const AtomicString& key)$/;"	f	struct:WTF::AtomicStringHash	access:public	signature:(const AtomicString& key)
WTF::AtomicStringHash::safeToCompareToEmptyOrDeleted	.\text\AtomicStringHash.h	/^        static const bool safeToCompareToEmptyOrDeleted = false;$/;"	m	struct:WTF::AtomicStringHash	access:public
WTF::AtomicStringImpl	.\text\AtomicStringImpl.h	/^class AtomicStringImpl : public StringImpl$/;"	c	namespace:WTF	inherits:StringImpl
WTF::AtomicStringImpl::AtomicStringImpl	.\text\AtomicStringImpl.h	/^    AtomicStringImpl() : StringImpl(0) {}$/;"	f	class:WTF::AtomicStringImpl	access:public	signature:()
WTF::AtomicStringTable	.\text\AtomicString.cpp	/^class AtomicStringTable {$/;"	c	namespace:WTF	file:
WTF::AtomicStringTable::create	.\text\AtomicString.cpp	/^    static AtomicStringTable* create()$/;"	f	class:WTF::AtomicStringTable	access:public	signature:()
WTF::AtomicStringTable::destroy	.\text\AtomicString.cpp	/^    static void destroy(AtomicStringTable* table)$/;"	f	class:WTF::AtomicStringTable	file:	access:private	signature:(AtomicStringTable* table)
WTF::AtomicStringTable::m_table	.\text\AtomicString.cpp	/^    HashSet<StringImpl*> m_table;$/;"	m	class:WTF::AtomicStringTable	file:	access:private
WTF::AtomicStringTable::table	.\text\AtomicString.cpp	/^    HashSet<StringImpl*>& table()$/;"	f	class:WTF::AtomicStringTable	access:public	signature:()
WTF::AtomicStringTableDestructor	.\WTFThreadData.h	/^typedef void (*AtomicStringTableDestructor)(AtomicStringTable*);$/;"	t	namespace:WTF
WTF::BasicRawSentinelNode	.\SentinelLinkedList.h	/^class BasicRawSentinelNode {$/;"	c	namespace:WTF
WTF::BasicRawSentinelNode::BasicRawSentinelNode	.\SentinelLinkedList.h	/^    BasicRawSentinelNode()$/;"	f	class:WTF::BasicRawSentinelNode	access:public	signature:()
WTF::BasicRawSentinelNode::BasicRawSentinelNode	.\SentinelLinkedList.h	/^    BasicRawSentinelNode(SentinelTag)$/;"	f	class:WTF::BasicRawSentinelNode	access:public	signature:(SentinelTag)
WTF::BasicRawSentinelNode::isOnList	.\SentinelLinkedList.h	/^    bool isOnList() const$/;"	f	class:WTF::BasicRawSentinelNode	access:public	signature:() const
WTF::BasicRawSentinelNode::m_next	.\SentinelLinkedList.h	/^    BasicRawSentinelNode* m_next;$/;"	m	class:WTF::BasicRawSentinelNode	access:private
WTF::BasicRawSentinelNode::m_prev	.\SentinelLinkedList.h	/^    BasicRawSentinelNode* m_prev;$/;"	m	class:WTF::BasicRawSentinelNode	access:private
WTF::BasicRawSentinelNode::next	.\SentinelLinkedList.h	/^    T* next() { return static_cast<T*>(m_next); }$/;"	f	class:WTF::BasicRawSentinelNode	access:public	signature:()
WTF::BasicRawSentinelNode::prev	.\SentinelLinkedList.h	/^    T* prev() { return static_cast<T*>(m_prev); }$/;"	f	class:WTF::BasicRawSentinelNode	access:public	signature:()
WTF::BasicRawSentinelNode::remove	.\SentinelLinkedList.h	/^    void remove();$/;"	p	class:WTF::BasicRawSentinelNode	access:public	signature:()
WTF::BasicRawSentinelNode::remove	.\SentinelLinkedList.h	/^template <typename T> void BasicRawSentinelNode<T>::remove()$/;"	f	class:WTF::BasicRawSentinelNode	signature:()
WTF::BasicRawSentinelNode::setNext	.\SentinelLinkedList.h	/^    void setNext(BasicRawSentinelNode* next) { m_next = next; }$/;"	f	class:WTF::BasicRawSentinelNode	access:public	signature:(BasicRawSentinelNode* next)
WTF::BasicRawSentinelNode::setPrev	.\SentinelLinkedList.h	/^    void setPrev(BasicRawSentinelNode* prev) { m_prev = prev; }$/;"	f	class:WTF::BasicRawSentinelNode	access:public	signature:(BasicRawSentinelNode* prev)
WTF::BigInt	.\dtoa.cpp	/^struct BigInt {$/;"	s	namespace:WTF	file:
WTF::BigInt::BigInt	.\dtoa.cpp	/^    BigInt() : sign(0) { }$/;"	f	struct:WTF::BigInt	access:public	signature:()
WTF::BigInt::append	.\dtoa.cpp	/^    void append(uint32_t w)$/;"	f	struct:WTF::BigInt	access:public	signature:(uint32_t w)
WTF::BigInt::clear	.\dtoa.cpp	/^    void clear()$/;"	f	struct:WTF::BigInt	access:public	signature:()
WTF::BigInt::m_words	.\dtoa.cpp	/^    Vector<uint32_t, 16> m_words;$/;"	m	struct:WTF::BigInt	file:	access:public
WTF::BigInt::resize	.\dtoa.cpp	/^    void resize(size_t s)$/;"	f	struct:WTF::BigInt	access:public	signature:(size_t s)
WTF::BigInt::sign	.\dtoa.cpp	/^    int sign;$/;"	m	struct:WTF::BigInt	file:	access:public
WTF::BigInt::size	.\dtoa.cpp	/^    size_t size() const$/;"	f	struct:WTF::BigInt	access:public	signature:() const
WTF::BigInt::words	.\dtoa.cpp	/^    const uint32_t* words() const$/;"	f	struct:WTF::BigInt	access:public	signature:() const
WTF::BigInt::words	.\dtoa.cpp	/^    uint32_t* words()$/;"	f	struct:WTF::BigInt	access:public	signature:()
WTF::BinarySearchMode	.\StdLibExtras.h	/^enum BinarySearchMode {$/;"	g	namespace:WTF
WTF::BinarySemaphore	.\threads\BinarySemaphore.h	/^class BinarySemaphore {$/;"	c	namespace:WTF
WTF::BinarySemaphore::BinarySemaphore	.\threads\BinarySemaphore.cpp	/^BinarySemaphore::BinarySemaphore()$/;"	f	class:WTF::BinarySemaphore	signature:()
WTF::BinarySemaphore::BinarySemaphore	.\threads\BinarySemaphore.h	/^    BinarySemaphore();$/;"	p	class:WTF::BinarySemaphore	access:public	signature:()
WTF::BinarySemaphore::BinarySemaphore	.\threads\win\BinarySemaphoreWin.cpp	/^BinarySemaphore::BinarySemaphore()$/;"	f	class:WTF::BinarySemaphore	signature:()
WTF::BinarySemaphore::WTF_MAKE_NONCOPYABLE	.\threads\BinarySemaphore.h	/^    WTF_MAKE_NONCOPYABLE(BinarySemaphore);$/;"	p	class:WTF::BinarySemaphore	access:private	signature:(BinarySemaphore)
WTF::BinarySemaphore::event	.\threads\BinarySemaphore.h	/^    HANDLE event() const { return m_event; }$/;"	f	class:WTF::BinarySemaphore	access:public	signature:() const
WTF::BinarySemaphore::m_condition	.\threads\BinarySemaphore.h	/^    ThreadCondition m_condition;$/;"	m	class:WTF::BinarySemaphore	access:private
WTF::BinarySemaphore::m_event	.\threads\BinarySemaphore.h	/^    HANDLE m_event;$/;"	m	class:WTF::BinarySemaphore	access:private
WTF::BinarySemaphore::m_isSet	.\threads\BinarySemaphore.h	/^    bool m_isSet;$/;"	m	class:WTF::BinarySemaphore	access:private
WTF::BinarySemaphore::m_mutex	.\threads\BinarySemaphore.h	/^    Mutex m_mutex;$/;"	m	class:WTF::BinarySemaphore	access:private
WTF::BinarySemaphore::signal	.\threads\BinarySemaphore.cpp	/^void BinarySemaphore::signal()$/;"	f	class:WTF::BinarySemaphore	signature:()
WTF::BinarySemaphore::signal	.\threads\BinarySemaphore.h	/^    void signal();$/;"	p	class:WTF::BinarySemaphore	access:public	signature:()
WTF::BinarySemaphore::signal	.\threads\win\BinarySemaphoreWin.cpp	/^void BinarySemaphore::signal()$/;"	f	class:WTF::BinarySemaphore	signature:()
WTF::BinarySemaphore::wait	.\threads\BinarySemaphore.cpp	/^bool BinarySemaphore::wait(double absoluteTime)$/;"	f	class:WTF::BinarySemaphore	signature:(double absoluteTime)
WTF::BinarySemaphore::wait	.\threads\BinarySemaphore.h	/^    bool wait(double absoluteTime);$/;"	p	class:WTF::BinarySemaphore	access:public	signature:(double absoluteTime)
WTF::BinarySemaphore::wait	.\threads\win\BinarySemaphoreWin.cpp	/^bool BinarySemaphore::wait(double absoluteTime)$/;"	f	class:WTF::BinarySemaphore	signature:(double absoluteTime)
WTF::BinarySemaphore::~BinarySemaphore	.\threads\BinarySemaphore.cpp	/^BinarySemaphore::~BinarySemaphore()$/;"	f	class:WTF::BinarySemaphore	signature:()
WTF::BinarySemaphore::~BinarySemaphore	.\threads\BinarySemaphore.h	/^    ~BinarySemaphore();$/;"	p	class:WTF::BinarySemaphore	access:public	signature:()
WTF::BinarySemaphore::~BinarySemaphore	.\threads\win\BinarySemaphoreWin.cpp	/^BinarySemaphore::~BinarySemaphore()$/;"	f	class:WTF::BinarySemaphore	signature:()
WTF::BitVector	.\BitVector.h	/^class BitVector {$/;"	c	namespace:WTF
WTF::BitVector::BitVector	.\BitVector.h	/^    BitVector()$/;"	f	class:WTF::BitVector	access:public	signature:()
WTF::BitVector::BitVector	.\BitVector.h	/^    BitVector(const BitVector& other)$/;"	f	class:WTF::BitVector	access:public	signature:(const BitVector& other)
WTF::BitVector::BitVector	.\BitVector.h	/^    explicit BitVector(size_t numBits)$/;"	f	class:WTF::BitVector	access:public	signature:(size_t numBits)
WTF::BitVector::OutOfLineBits	.\BitVector.h	/^    class OutOfLineBits {$/;"	c	class:WTF::BitVector	access:private
WTF::BitVector::OutOfLineBits::OutOfLineBits	.\BitVector.h	/^        OutOfLineBits(size_t numBits)$/;"	f	class:WTF::BitVector::OutOfLineBits	access:private	signature:(size_t numBits)
WTF::BitVector::OutOfLineBits::bits	.\BitVector.h	/^        const uintptr_t* bits() const { return bitwise_cast<const uintptr_t*>(this + 1); }$/;"	f	class:WTF::BitVector::OutOfLineBits	access:public	signature:() const
WTF::BitVector::OutOfLineBits::bits	.\BitVector.h	/^        uintptr_t* bits() { return bitwise_cast<uintptr_t*>(this + 1); }$/;"	f	class:WTF::BitVector::OutOfLineBits	access:public	signature:()
WTF::BitVector::OutOfLineBits::create	.\BitVector.cpp	/^BitVector::OutOfLineBits* BitVector::OutOfLineBits::create(size_t numBits)$/;"	f	class:WTF::BitVector::OutOfLineBits	signature:(size_t numBits)
WTF::BitVector::OutOfLineBits::create	.\BitVector.h	/^        static OutOfLineBits* create(size_t numBits);$/;"	p	class:WTF::BitVector::OutOfLineBits	access:public	signature:(size_t numBits)
WTF::BitVector::OutOfLineBits::destroy	.\BitVector.cpp	/^void BitVector::OutOfLineBits::destroy(OutOfLineBits* outOfLineBits)$/;"	f	class:WTF::BitVector::OutOfLineBits	signature:(OutOfLineBits* outOfLineBits)
WTF::BitVector::OutOfLineBits::destroy	.\BitVector.h	/^        static void destroy(OutOfLineBits*);$/;"	p	class:WTF::BitVector::OutOfLineBits	access:public	signature:(OutOfLineBits*)
WTF::BitVector::OutOfLineBits::m_numBits	.\BitVector.h	/^        size_t m_numBits;$/;"	m	class:WTF::BitVector::OutOfLineBits	access:private
WTF::BitVector::OutOfLineBits::numBits	.\BitVector.h	/^        size_t numBits() const { return m_numBits; }$/;"	f	class:WTF::BitVector::OutOfLineBits	access:public	signature:() const
WTF::BitVector::OutOfLineBits::numWords	.\BitVector.h	/^        size_t numWords() const { return (m_numBits + bitsInPointer() - 1) \/ bitsInPointer(); }$/;"	f	class:WTF::BitVector::OutOfLineBits	access:public	signature:() const
WTF::BitVector::bits	.\BitVector.h	/^    const uintptr_t* bits() const$/;"	f	class:WTF::BitVector	access:private	signature:() const
WTF::BitVector::bits	.\BitVector.h	/^    uintptr_t* bits()$/;"	f	class:WTF::BitVector	access:private	signature:()
WTF::BitVector::bitsInPointer	.\BitVector.h	/^    static unsigned bitsInPointer()$/;"	f	class:WTF::BitVector	access:private	signature:()
WTF::BitVector::byteCount	.\BitVector.h	/^    static size_t byteCount(size_t bitCount)$/;"	f	class:WTF::BitVector	access:private	signature:(size_t bitCount)
WTF::BitVector::clear	.\BitVector.h	/^    void clear(size_t bit)$/;"	f	class:WTF::BitVector	access:public	signature:(size_t bit)
WTF::BitVector::clearAll	.\BitVector.cpp	/^void BitVector::clearAll()$/;"	f	class:WTF::BitVector	signature:()
WTF::BitVector::clearAll	.\BitVector.h	/^    void clearAll();$/;"	p	class:WTF::BitVector	access:public	signature:()
WTF::BitVector::dump	.\BitVector.cpp	/^void BitVector::dump(FILE* out)$/;"	f	class:WTF::BitVector	signature:(FILE* out)
WTF::BitVector::dump	.\BitVector.h	/^    void dump(FILE* out);$/;"	p	class:WTF::BitVector	access:public	signature:(FILE* out)
WTF::BitVector::ensureSize	.\BitVector.h	/^    void ensureSize(size_t numBits)$/;"	f	class:WTF::BitVector	access:public	signature:(size_t numBits)
WTF::BitVector::get	.\BitVector.h	/^    bool get(size_t bit) const$/;"	f	class:WTF::BitVector	access:public	signature:(size_t bit) const
WTF::BitVector::isInline	.\BitVector.h	/^    bool isInline() const { return m_bitsOrPointer >> maxInlineBits(); }$/;"	f	class:WTF::BitVector	access:private	signature:() const
WTF::BitVector::m_bitsOrPointer	.\BitVector.h	/^    uintptr_t m_bitsOrPointer;$/;"	m	class:WTF::BitVector	access:private
WTF::BitVector::makeInlineBits	.\BitVector.h	/^    static uintptr_t makeInlineBits(uintptr_t bits)$/;"	f	class:WTF::BitVector	access:private	signature:(uintptr_t bits)
WTF::BitVector::maxInlineBits	.\BitVector.h	/^    static unsigned maxInlineBits()$/;"	f	class:WTF::BitVector	access:private	signature:()
WTF::BitVector::operator =	.\BitVector.h	/^    BitVector& operator=(const BitVector& other)$/;"	f	class:WTF::BitVector	access:public	signature:(const BitVector& other)
WTF::BitVector::outOfLineBits	.\BitVector.h	/^    OutOfLineBits* outOfLineBits() { return bitwise_cast<OutOfLineBits*>(m_bitsOrPointer << 1); }$/;"	f	class:WTF::BitVector	access:private	signature:()
WTF::BitVector::outOfLineBits	.\BitVector.h	/^    const OutOfLineBits* outOfLineBits() const { return bitwise_cast<const OutOfLineBits*>(m_bitsOrPointer << 1); }$/;"	f	class:WTF::BitVector	access:private	signature:() const
WTF::BitVector::quickClear	.\BitVector.h	/^    void quickClear(size_t bit)$/;"	f	class:WTF::BitVector	access:public	signature:(size_t bit)
WTF::BitVector::quickGet	.\BitVector.h	/^    bool quickGet(size_t bit) const$/;"	f	class:WTF::BitVector	access:public	signature:(size_t bit) const
WTF::BitVector::quickSet	.\BitVector.h	/^    void quickSet(size_t bit)$/;"	f	class:WTF::BitVector	access:public	signature:(size_t bit)
WTF::BitVector::quickSet	.\BitVector.h	/^    void quickSet(size_t bit, bool value)$/;"	f	class:WTF::BitVector	access:public	signature:(size_t bit, bool value)
WTF::BitVector::resize	.\BitVector.cpp	/^void BitVector::resize(size_t numBits)$/;"	f	class:WTF::BitVector	signature:(size_t numBits)
WTF::BitVector::resize	.\BitVector.h	/^    void resize(size_t numBits);$/;"	p	class:WTF::BitVector	access:public	signature:(size_t numBits)
WTF::BitVector::resizeOutOfLine	.\BitVector.cpp	/^void BitVector::resizeOutOfLine(size_t numBits)$/;"	f	class:WTF::BitVector	signature:(size_t numBits)
WTF::BitVector::resizeOutOfLine	.\BitVector.h	/^    void resizeOutOfLine(size_t numBits);$/;"	p	class:WTF::BitVector	access:private	signature:(size_t numBits)
WTF::BitVector::set	.\BitVector.h	/^    void set(size_t bit)$/;"	f	class:WTF::BitVector	access:public	signature:(size_t bit)
WTF::BitVector::set	.\BitVector.h	/^    void set(size_t bit, bool value)$/;"	f	class:WTF::BitVector	access:public	signature:(size_t bit, bool value)
WTF::BitVector::setSlow	.\BitVector.cpp	/^void BitVector::setSlow(const BitVector& other)$/;"	f	class:WTF::BitVector	signature:(const BitVector& other)
WTF::BitVector::setSlow	.\BitVector.h	/^    void setSlow(const BitVector& other);$/;"	p	class:WTF::BitVector	access:private	signature:(const BitVector& other)
WTF::BitVector::size	.\BitVector.h	/^    size_t size() const$/;"	f	class:WTF::BitVector	access:public	signature:() const
WTF::BitVector::~BitVector	.\BitVector.h	/^    ~BitVector()$/;"	f	class:WTF::BitVector	access:public	signature:()
WTF::Bitmap	.\Bitmap.h	/^class Bitmap {$/;"	c	namespace:WTF
WTF::Bitmap::Bitmap	.\Bitmap.h	/^    Bitmap();$/;"	p	class:WTF::Bitmap	access:public	signature:()
WTF::Bitmap::Bitmap	.\Bitmap.h	/^inline Bitmap<size, atomicMode>::Bitmap()$/;"	f	class:WTF::Bitmap	signature:()
WTF::Bitmap::WordType	.\Bitmap.h	/^    typedef uint32_t WordType;$/;"	t	class:WTF::Bitmap	access:private
WTF::Bitmap::bits	.\Bitmap.h	/^    FixedArray<WordType, words> bits;$/;"	m	class:WTF::Bitmap	access:private
WTF::Bitmap::clear	.\Bitmap.h	/^    void clear(size_t);$/;"	p	class:WTF::Bitmap	access:public	signature:(size_t)
WTF::Bitmap::clear	.\Bitmap.h	/^inline void Bitmap<size, atomicMode>::clear(size_t n)$/;"	f	class:WTF::Bitmap	signature:(size_t n)
WTF::Bitmap::clearAll	.\Bitmap.h	/^    void clearAll();$/;"	p	class:WTF::Bitmap	access:public	signature:()
WTF::Bitmap::clearAll	.\Bitmap.h	/^inline void Bitmap<size, atomicMode>::clearAll()$/;"	f	class:WTF::Bitmap	signature:()
WTF::Bitmap::concurrentTestAndClear	.\Bitmap.h	/^    bool concurrentTestAndClear(size_t);$/;"	p	class:WTF::Bitmap	access:public	signature:(size_t)
WTF::Bitmap::concurrentTestAndClear	.\Bitmap.h	/^inline bool Bitmap<size, atomicMode>::concurrentTestAndClear(size_t n)$/;"	f	class:WTF::Bitmap	signature:(size_t n)
WTF::Bitmap::concurrentTestAndSet	.\Bitmap.h	/^    bool concurrentTestAndSet(size_t);$/;"	p	class:WTF::Bitmap	access:public	signature:(size_t)
WTF::Bitmap::concurrentTestAndSet	.\Bitmap.h	/^inline bool Bitmap<size, atomicMode>::concurrentTestAndSet(size_t n)$/;"	f	class:WTF::Bitmap	signature:(size_t n)
WTF::Bitmap::count	.\Bitmap.h	/^    size_t count(size_t = 0) const;$/;"	p	class:WTF::Bitmap	access:public	signature:(size_t = 0) const
WTF::Bitmap::count	.\Bitmap.h	/^inline size_t Bitmap<size, atomicMode>::count(size_t start) const$/;"	f	class:WTF::Bitmap	signature:(size_t start) const
WTF::Bitmap::findRunOfZeros	.\Bitmap.h	/^    int64_t findRunOfZeros(size_t) const;$/;"	p	class:WTF::Bitmap	access:public	signature:(size_t) const
WTF::Bitmap::findRunOfZeros	.\Bitmap.h	/^inline int64_t Bitmap<size, atomicMode>::findRunOfZeros(size_t runLength) const$/;"	f	class:WTF::Bitmap	signature:(size_t runLength) const
WTF::Bitmap::get	.\Bitmap.h	/^    bool get(size_t) const;$/;"	p	class:WTF::Bitmap	access:public	signature:(size_t) const
WTF::Bitmap::get	.\Bitmap.h	/^inline bool Bitmap<size, atomicMode>::get(size_t n) const$/;"	f	class:WTF::Bitmap	signature:(size_t n) const
WTF::Bitmap::isEmpty	.\Bitmap.h	/^    size_t isEmpty() const;$/;"	p	class:WTF::Bitmap	access:public	signature:() const
WTF::Bitmap::isEmpty	.\Bitmap.h	/^inline size_t Bitmap<size, atomicMode>::isEmpty() const$/;"	f	class:WTF::Bitmap	signature:() const
WTF::Bitmap::isFull	.\Bitmap.h	/^    size_t isFull() const;$/;"	p	class:WTF::Bitmap	access:public	signature:() const
WTF::Bitmap::isFull	.\Bitmap.h	/^inline size_t Bitmap<size, atomicMode>::isFull() const$/;"	f	class:WTF::Bitmap	signature:() const
WTF::Bitmap::nextPossiblyUnset	.\Bitmap.h	/^    size_t nextPossiblyUnset(size_t) const;$/;"	p	class:WTF::Bitmap	access:public	signature:(size_t) const
WTF::Bitmap::nextPossiblyUnset	.\Bitmap.h	/^inline size_t Bitmap<size, atomicMode>::nextPossiblyUnset(size_t start) const$/;"	f	class:WTF::Bitmap	signature:(size_t start) const
WTF::Bitmap::one	.\Bitmap.h	/^    static const WordType one = 1;$/;"	m	class:WTF::Bitmap	access:private
WTF::Bitmap::set	.\Bitmap.h	/^    void set(size_t);$/;"	p	class:WTF::Bitmap	access:public	signature:(size_t)
WTF::Bitmap::set	.\Bitmap.h	/^inline void Bitmap<size, atomicMode>::set(size_t n)$/;"	f	class:WTF::Bitmap	signature:(size_t n)
WTF::Bitmap::testAndClear	.\Bitmap.h	/^    bool testAndClear(size_t);$/;"	p	class:WTF::Bitmap	access:public	signature:(size_t)
WTF::Bitmap::testAndClear	.\Bitmap.h	/^inline bool Bitmap<size, atomicMode>::testAndClear(size_t n)$/;"	f	class:WTF::Bitmap	signature:(size_t n)
WTF::Bitmap::testAndSet	.\Bitmap.h	/^    bool testAndSet(size_t);$/;"	p	class:WTF::Bitmap	access:public	signature:(size_t)
WTF::Bitmap::testAndSet	.\Bitmap.h	/^inline bool Bitmap<size, atomicMode>::testAndSet(size_t n)$/;"	f	class:WTF::Bitmap	signature:(size_t n)
WTF::Bitmap::wordSize	.\Bitmap.h	/^    static const WordType wordSize = sizeof(WordType) * 8;$/;"	m	class:WTF::Bitmap	access:private
WTF::Bitmap::words	.\Bitmap.h	/^    static const WordType words = (size + wordSize - 1) \/ wordSize;$/;"	m	class:WTF::Bitmap	access:private
WTF::BitmapAtomic	.\Bitmap.h	/^    BitmapAtomic$/;"	e	enum:WTF::BitmapAtomicMode
WTF::BitmapAtomicMode	.\Bitmap.h	/^enum BitmapAtomicMode {$/;"	g	namespace:WTF
WTF::BitmapNotAtomic	.\Bitmap.h	/^    BitmapNotAtomic,$/;"	e	enum:WTF::BitmapAtomicMode
WTF::BlockStack	.\BlockStack.h	/^template <typename T> class BlockStack {$/;"	c	namespace:WTF
WTF::BlockStack::BlockStack	.\BlockStack.h	/^    BlockStack();$/;"	p	class:WTF::BlockStack	access:public	signature:()
WTF::BlockStack::BlockStack	.\BlockStack.h	/^template <typename T> BlockStack<T>::BlockStack()$/;"	f	class:WTF::BlockStack	signature:()
WTF::BlockStack::blockLength	.\BlockStack.h	/^    static const size_t blockLength = blockSize \/ sizeof(T);$/;"	m	class:WTF::BlockStack	access:public
WTF::BlockStack::blockSize	.\BlockStack.h	/^    static const size_t blockSize = 4096;$/;"	m	class:WTF::BlockStack	access:public
WTF::BlockStack::blocks	.\BlockStack.h	/^    const Vector<T*>& blocks();$/;"	p	class:WTF::BlockStack	access:public	signature:()
WTF::BlockStack::blocks	.\BlockStack.h	/^template <typename T> inline const Vector<T*>& BlockStack<T>::blocks()$/;"	f	class:WTF::BlockStack	signature:()
WTF::BlockStack::grow	.\BlockStack.h	/^    T* grow();$/;"	p	class:WTF::BlockStack	access:public	signature:()
WTF::BlockStack::grow	.\BlockStack.h	/^template <typename T> T* BlockStack<T>::grow()$/;"	f	class:WTF::BlockStack	signature:()
WTF::BlockStack::m_blocks	.\BlockStack.h	/^    Vector<T*> m_blocks;$/;"	m	class:WTF::BlockStack	access:private
WTF::BlockStack::m_spareBlock	.\BlockStack.h	/^    T* m_spareBlock; \/\/ Used to avoid thrash at block boundaries.$/;"	m	class:WTF::BlockStack	access:private
WTF::BlockStack::shrink	.\BlockStack.h	/^    void shrink(T*);$/;"	p	class:WTF::BlockStack	access:public	signature:(T*)
WTF::BlockStack::shrink	.\BlockStack.h	/^template <typename T> void BlockStack<T>::shrink(T* newEnd)$/;"	f	class:WTF::BlockStack	signature:(T* newEnd)
WTF::BlockStack::~BlockStack	.\BlockStack.h	/^    ~BlockStack();$/;"	p	class:WTF::BlockStack	access:public	signature:()
WTF::BlockStack::~BlockStack	.\BlockStack.h	/^template <typename T> BlockStack<T>::~BlockStack()$/;"	f	class:WTF::BlockStack	signature:()
WTF::BloomFilter	.\BloomFilter.h	/^class BloomFilter {$/;"	c	namespace:WTF
WTF::BloomFilter::BloomFilter	.\BloomFilter.h	/^    BloomFilter() { clear(); }$/;"	f	class:WTF::BloomFilter	access:public	signature:()
WTF::BloomFilter::COMPILE_ASSERT	.\BloomFilter.h	/^    COMPILE_ASSERT(keyBits <= 16, bloom_filter_key_size);$/;"	p	class:WTF::BloomFilter	access:public	signature:(keyBits <= 16, bloom_filter_key_size)
WTF::BloomFilter::add	.\BloomFilter.h	/^    void add(const AtomicString& string) { add(string.impl()->existingHash()); }$/;"	f	class:WTF::BloomFilter	access:public	signature:(const AtomicString& string)
WTF::BloomFilter::add	.\BloomFilter.h	/^    void add(const String& string) { add(string.impl()->hash()); }$/;"	f	class:WTF::BloomFilter	access:public	signature:(const String& string)
WTF::BloomFilter::add	.\BloomFilter.h	/^    void add(unsigned hash);$/;"	p	class:WTF::BloomFilter	access:public	signature:(unsigned hash)
WTF::BloomFilter::add	.\BloomFilter.h	/^inline void BloomFilter<keyBits>::add(unsigned hash)$/;"	f	class:WTF::BloomFilter	signature:(unsigned hash)
WTF::BloomFilter::clear	.\BloomFilter.h	/^    void clear();$/;"	p	class:WTF::BloomFilter	access:public	signature:()
WTF::BloomFilter::clear	.\BloomFilter.h	/^inline void BloomFilter<keyBits>::clear()$/;"	f	class:WTF::BloomFilter	signature:()
WTF::BloomFilter::firstSlot	.\BloomFilter.h	/^    const uint8_t& firstSlot(unsigned hash) const { return m_table[hash & keyMask]; }$/;"	f	class:WTF::BloomFilter	access:private	signature:(unsigned hash) const
WTF::BloomFilter::firstSlot	.\BloomFilter.h	/^    uint8_t& firstSlot(unsigned hash) { return m_table[hash & keyMask]; }$/;"	f	class:WTF::BloomFilter	access:private	signature:(unsigned hash)
WTF::BloomFilter::isClear	.\BloomFilter.h	/^    bool isClear() const;$/;"	p	class:WTF::BloomFilter	access:public	signature:() const
WTF::BloomFilter::isClear	.\BloomFilter.h	/^bool BloomFilter<keyBits>::isClear() const$/;"	f	class:WTF::BloomFilter	signature:() const
WTF::BloomFilter::keyMask	.\BloomFilter.h	/^    static const unsigned keyMask = (1 << keyBits) - 1;$/;"	m	class:WTF::BloomFilter	access:public
WTF::BloomFilter::likelyEmpty	.\BloomFilter.h	/^    bool likelyEmpty() const;$/;"	p	class:WTF::BloomFilter	access:public	signature:() const
WTF::BloomFilter::likelyEmpty	.\BloomFilter.h	/^bool BloomFilter<keyBits>::likelyEmpty() const$/;"	f	class:WTF::BloomFilter	signature:() const
WTF::BloomFilter::m_table	.\BloomFilter.h	/^    uint8_t m_table[tableSize];$/;"	m	class:WTF::BloomFilter	access:private
WTF::BloomFilter::maximumCount	.\BloomFilter.h	/^    static uint8_t maximumCount() { return std::numeric_limits<uint8_t>::max(); }$/;"	f	class:WTF::BloomFilter	access:public	signature:()
WTF::BloomFilter::mayContain	.\BloomFilter.h	/^    bool mayContain(const AtomicString& string) const { return mayContain(string.impl()->existingHash()); }$/;"	f	class:WTF::BloomFilter	access:public	signature:(const AtomicString& string) const
WTF::BloomFilter::mayContain	.\BloomFilter.h	/^    bool mayContain(const String& string) const { return mayContain(string.impl()->hash()); }$/;"	f	class:WTF::BloomFilter	access:public	signature:(const String& string) const
WTF::BloomFilter::mayContain	.\BloomFilter.h	/^    bool mayContain(unsigned hash) const { return firstSlot(hash) && secondSlot(hash); }$/;"	f	class:WTF::BloomFilter	access:public	signature:(unsigned hash) const
WTF::BloomFilter::remove	.\BloomFilter.h	/^    void remove(const AtomicString& string) { remove(string.impl()->existingHash()); }$/;"	f	class:WTF::BloomFilter	access:public	signature:(const AtomicString& string)
WTF::BloomFilter::remove	.\BloomFilter.h	/^    void remove(const String& string) { remove(string.impl()->hash()); }$/;"	f	class:WTF::BloomFilter	access:public	signature:(const String& string)
WTF::BloomFilter::remove	.\BloomFilter.h	/^    void remove(unsigned hash);$/;"	p	class:WTF::BloomFilter	access:public	signature:(unsigned hash)
WTF::BloomFilter::remove	.\BloomFilter.h	/^inline void BloomFilter<keyBits>::remove(unsigned hash)$/;"	f	class:WTF::BloomFilter	signature:(unsigned hash)
WTF::BloomFilter::secondSlot	.\BloomFilter.h	/^    const uint8_t& secondSlot(unsigned hash) const { return m_table[(hash >> 16) & keyMask]; }$/;"	f	class:WTF::BloomFilter	access:private	signature:(unsigned hash) const
WTF::BloomFilter::secondSlot	.\BloomFilter.h	/^    uint8_t& secondSlot(unsigned hash) { return m_table[(hash >> 16) & keyMask]; }$/;"	f	class:WTF::BloomFilter	access:private	signature:(unsigned hash)
WTF::BloomFilter::tableSize	.\BloomFilter.h	/^    static const size_t tableSize = 1 << keyBits;$/;"	m	class:WTF::BloomFilter	access:public
WTF::BoundFunctionImpl	.\Functional.h	/^class BoundFunctionImpl<FunctionWrapper, R ()> : public FunctionImpl<typename FunctionWrapper::ResultType ()> {$/;"	c	namespace:WTF	inherits:FunctionImpl
WTF::BoundFunctionImpl	.\Functional.h	/^class BoundFunctionImpl<FunctionWrapper, R (P1)> : public FunctionImpl<typename FunctionWrapper::ResultType ()> {$/;"	c	namespace:WTF	inherits:FunctionImpl
WTF::BoundFunctionImpl	.\Functional.h	/^class BoundFunctionImpl<FunctionWrapper, R (P1, P2)> : public FunctionImpl<typename FunctionWrapper::ResultType ()> {$/;"	c	namespace:WTF	inherits:FunctionImpl
WTF::BoundFunctionImpl	.\Functional.h	/^class BoundFunctionImpl<FunctionWrapper, R (P1, P2, P3)> : public FunctionImpl<typename FunctionWrapper::ResultType ()> {$/;"	c	namespace:WTF	inherits:FunctionImpl
WTF::BoundFunctionImpl	.\Functional.h	/^class BoundFunctionImpl<FunctionWrapper, R (P1, P2, P3, P4)> : public FunctionImpl<typename FunctionWrapper::ResultType ()> {$/;"	c	namespace:WTF	inherits:FunctionImpl
WTF::BoundFunctionImpl	.\Functional.h	/^class BoundFunctionImpl<FunctionWrapper, R (P1, P2, P3, P4, P5)> : public FunctionImpl<typename FunctionWrapper::ResultType ()> {$/;"	c	namespace:WTF	inherits:FunctionImpl
WTF::BoundFunctionImpl	.\Functional.h	/^class BoundFunctionImpl<FunctionWrapper, R (P1, P2, P3, P4, P5, P6)> : public FunctionImpl<typename FunctionWrapper::ResultType ()> {$/;"	c	namespace:WTF	inherits:FunctionImpl
WTF::BoundFunctionImpl::BoundFunctionImpl	.\Functional.h	/^    BoundFunctionImpl(FunctionWrapper functionWrapper, const P1& p1)$/;"	f	class:WTF::BoundFunctionImpl	access:public	signature:(FunctionWrapper functionWrapper, const P1& p1)
WTF::BoundFunctionImpl::BoundFunctionImpl	.\Functional.h	/^    BoundFunctionImpl(FunctionWrapper functionWrapper, const P1& p1, const P2& p2)$/;"	f	class:WTF::BoundFunctionImpl	access:public	signature:(FunctionWrapper functionWrapper, const P1& p1, const P2& p2)
WTF::BoundFunctionImpl::BoundFunctionImpl	.\Functional.h	/^    BoundFunctionImpl(FunctionWrapper functionWrapper, const P1& p1, const P2& p2, const P3& p3)$/;"	f	class:WTF::BoundFunctionImpl	access:public	signature:(FunctionWrapper functionWrapper, const P1& p1, const P2& p2, const P3& p3)
WTF::BoundFunctionImpl::BoundFunctionImpl	.\Functional.h	/^    BoundFunctionImpl(FunctionWrapper functionWrapper, const P1& p1, const P2& p2, const P3& p3, const P4& p4)$/;"	f	class:WTF::BoundFunctionImpl	access:public	signature:(FunctionWrapper functionWrapper, const P1& p1, const P2& p2, const P3& p3, const P4& p4)
WTF::BoundFunctionImpl::BoundFunctionImpl	.\Functional.h	/^    BoundFunctionImpl(FunctionWrapper functionWrapper, const P1& p1, const P2& p2, const P3& p3, const P4& p4, const P5& p5)$/;"	f	class:WTF::BoundFunctionImpl	access:public	signature:(FunctionWrapper functionWrapper, const P1& p1, const P2& p2, const P3& p3, const P4& p4, const P5& p5)
WTF::BoundFunctionImpl::BoundFunctionImpl	.\Functional.h	/^    BoundFunctionImpl(FunctionWrapper functionWrapper, const P1& p1, const P2& p2, const P3& p3, const P4& p4, const P5& p5, const P6& p6)$/;"	f	class:WTF::BoundFunctionImpl	access:public	signature:(FunctionWrapper functionWrapper, const P1& p1, const P2& p2, const P3& p3, const P4& p4, const P5& p5, const P6& p6)
WTF::BoundFunctionImpl::BoundFunctionImpl	.\Functional.h	/^    explicit BoundFunctionImpl(FunctionWrapper functionWrapper)$/;"	f	class:WTF::BoundFunctionImpl	access:public	signature:(FunctionWrapper functionWrapper)
WTF::BoundFunctionImpl::m_functionWrapper	.\Functional.h	/^    FunctionWrapper m_functionWrapper;$/;"	m	class:WTF::BoundFunctionImpl	access:private
WTF::BoundFunctionImpl::m_p1	.\Functional.h	/^    typename ParamStorageTraits<P1>::StorageType m_p1;$/;"	m	class:WTF::BoundFunctionImpl	access:private
WTF::BoundFunctionImpl::m_p2	.\Functional.h	/^    typename ParamStorageTraits<P2>::StorageType m_p2;$/;"	m	class:WTF::BoundFunctionImpl	access:private
WTF::BoundFunctionImpl::m_p3	.\Functional.h	/^    typename ParamStorageTraits<P3>::StorageType m_p3;$/;"	m	class:WTF::BoundFunctionImpl	access:private
WTF::BoundFunctionImpl::m_p4	.\Functional.h	/^    typename ParamStorageTraits<P4>::StorageType m_p4;$/;"	m	class:WTF::BoundFunctionImpl	access:private
WTF::BoundFunctionImpl::m_p5	.\Functional.h	/^    typename ParamStorageTraits<P5>::StorageType m_p5;$/;"	m	class:WTF::BoundFunctionImpl	access:private
WTF::BoundFunctionImpl::m_p6	.\Functional.h	/^    typename ParamStorageTraits<P6>::StorageType m_p6;$/;"	m	class:WTF::BoundFunctionImpl	access:private
WTF::BoundFunctionImpl::operator ()	.\Functional.h	/^    virtual R operator()()$/;"	f	class:WTF::BoundFunctionImpl	access:public	signature:()
WTF::BoundFunctionImpl::operator ()	.\Functional.h	/^    virtual typename FunctionWrapper::ResultType operator()()$/;"	f	class:WTF::BoundFunctionImpl	access:public	signature:()
WTF::BoundFunctionImpl::~BoundFunctionImpl	.\Functional.h	/^    ~BoundFunctionImpl()$/;"	f	class:WTF::BoundFunctionImpl	access:public	signature:()
WTF::BoundsCheckElider	.\CheckedArithmetic.h	/^template <typename Target, typename Source> struct BoundsCheckElider<Target, Source, false> : public BoundsChecker<Target, Source> {$/;"	s	namespace:WTF	inherits:BoundsChecker
WTF::BoundsCheckElider	.\CheckedArithmetic.h	/^template <typename Target, typename Source> struct BoundsCheckElider<Target, Source, true> {$/;"	s	namespace:WTF
WTF::BoundsCheckElider::inBounds	.\CheckedArithmetic.h	/^    static bool inBounds(Source) { return true; }$/;"	f	struct:WTF::BoundsCheckElider	access:public	signature:(Source)
WTF::BoundsCheckedPointer	.\BoundsCheckedPointer.h	/^class BoundsCheckedPointer {$/;"	c	namespace:WTF
WTF::BoundsCheckedPointer::BoundsCheckedPointer	.\BoundsCheckedPointer.h	/^    BoundsCheckedPointer()$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:()
WTF::BoundsCheckedPointer::BoundsCheckedPointer	.\BoundsCheckedPointer.h	/^    BoundsCheckedPointer(T* pointer, T* begin, T* end)$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(T* pointer, T* begin, T* end)
WTF::BoundsCheckedPointer::BoundsCheckedPointer	.\BoundsCheckedPointer.h	/^    BoundsCheckedPointer(T* pointer, T* begin, size_t numElements)$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(T* pointer, T* begin, size_t numElements)
WTF::BoundsCheckedPointer::BoundsCheckedPointer	.\BoundsCheckedPointer.h	/^    BoundsCheckedPointer(T* pointer, T* end)$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(T* pointer, T* end)
WTF::BoundsCheckedPointer::BoundsCheckedPointer	.\BoundsCheckedPointer.h	/^    BoundsCheckedPointer(T* pointer, size_t numElements)$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(T* pointer, size_t numElements)
WTF::BoundsCheckedPointer::get	.\BoundsCheckedPointer.h	/^    T* get()$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:()
WTF::BoundsCheckedPointer::m_begin	.\BoundsCheckedPointer.h	/^    T* m_begin;$/;"	m	class:WTF::BoundsCheckedPointer	access:private
WTF::BoundsCheckedPointer::m_end	.\BoundsCheckedPointer.h	/^    T* m_end;$/;"	m	class:WTF::BoundsCheckedPointer	access:private
WTF::BoundsCheckedPointer::m_pointer	.\BoundsCheckedPointer.h	/^    T* m_pointer;$/;"	m	class:WTF::BoundsCheckedPointer	access:private
WTF::BoundsCheckedPointer::operator !	.\BoundsCheckedPointer.h	/^    BoundsCheckedPointer operator!()$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:()
WTF::BoundsCheckedPointer::operator !=	.\BoundsCheckedPointer.h	/^    bool operator!=(BoundsCheckedPointer other) const$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(BoundsCheckedPointer other) const
WTF::BoundsCheckedPointer::operator !=	.\BoundsCheckedPointer.h	/^    bool operator!=(T* other) const$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(T* other) const
WTF::BoundsCheckedPointer::operator *	.\BoundsCheckedPointer.h	/^    T& operator*()$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:()
WTF::BoundsCheckedPointer::operator *	.\BoundsCheckedPointer.h	/^    const T& operator*() const$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:() const
WTF::BoundsCheckedPointer::operator +	.\BoundsCheckedPointer.h	/^    BoundsCheckedPointer operator+(ptrdiff_t amount) const$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(ptrdiff_t amount) const
WTF::BoundsCheckedPointer::operator ++	.\BoundsCheckedPointer.h	/^    BoundsCheckedPointer operator++() \/\/ prefix$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:()
WTF::BoundsCheckedPointer::operator ++	.\BoundsCheckedPointer.h	/^    BoundsCheckedPointer operator++(int) \/\/ postfix$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(int)
WTF::BoundsCheckedPointer::operator +=	.\BoundsCheckedPointer.h	/^    BoundsCheckedPointer& operator+=(ptrdiff_t amount)$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(ptrdiff_t amount)
WTF::BoundsCheckedPointer::operator -	.\BoundsCheckedPointer.h	/^    BoundsCheckedPointer operator-(ptrdiff_t amount) const$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(ptrdiff_t amount) const
WTF::BoundsCheckedPointer::operator --	.\BoundsCheckedPointer.h	/^    BoundsCheckedPointer operator--() \/\/ prefix$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:()
WTF::BoundsCheckedPointer::operator --	.\BoundsCheckedPointer.h	/^    BoundsCheckedPointer operator--(int) \/\/ postfix$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(int)
WTF::BoundsCheckedPointer::operator -=	.\BoundsCheckedPointer.h	/^    BoundsCheckedPointer& operator-=(ptrdiff_t amount)$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(ptrdiff_t amount)
WTF::BoundsCheckedPointer::operator <	.\BoundsCheckedPointer.h	/^    bool operator<(BoundsCheckedPointer other) const$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(BoundsCheckedPointer other) const
WTF::BoundsCheckedPointer::operator <	.\BoundsCheckedPointer.h	/^    bool operator<(T* other) const$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(T* other) const
WTF::BoundsCheckedPointer::operator <=	.\BoundsCheckedPointer.h	/^    bool operator<=(BoundsCheckedPointer other) const$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(BoundsCheckedPointer other) const
WTF::BoundsCheckedPointer::operator <=	.\BoundsCheckedPointer.h	/^    bool operator<=(T* other) const$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(T* other) const
WTF::BoundsCheckedPointer::operator =	.\BoundsCheckedPointer.h	/^    BoundsCheckedPointer& operator=(T* value)$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(T* value)
WTF::BoundsCheckedPointer::operator ==	.\BoundsCheckedPointer.h	/^    bool operator==(BoundsCheckedPointer other) const$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(BoundsCheckedPointer other) const
WTF::BoundsCheckedPointer::operator ==	.\BoundsCheckedPointer.h	/^    bool operator==(T* other) const$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(T* other) const
WTF::BoundsCheckedPointer::operator >	.\BoundsCheckedPointer.h	/^    bool operator>(BoundsCheckedPointer other) const$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(BoundsCheckedPointer other) const
WTF::BoundsCheckedPointer::operator >	.\BoundsCheckedPointer.h	/^    bool operator>(T* other) const$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(T* other) const
WTF::BoundsCheckedPointer::operator >=	.\BoundsCheckedPointer.h	/^    bool operator>=(BoundsCheckedPointer other) const$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(BoundsCheckedPointer other) const
WTF::BoundsCheckedPointer::operator >=	.\BoundsCheckedPointer.h	/^    bool operator>=(T* other) const$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(T* other) const
WTF::BoundsCheckedPointer::operator []	.\BoundsCheckedPointer.h	/^    T& operator[](ptrdiff_t index)$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(ptrdiff_t index)
WTF::BoundsCheckedPointer::operator []	.\BoundsCheckedPointer.h	/^    const T& operator[](ptrdiff_t index) const$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(ptrdiff_t index) const
WTF::BoundsCheckedPointer::strcat	.\BoundsCheckedPointer.h	/^    BoundsCheckedPointer& strcat(const T* source)$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(const T* source)
WTF::BoundsCheckedPointer::validate	.\BoundsCheckedPointer.h	/^    void validate() const$/;"	f	class:WTF::BoundsCheckedPointer	access:private	signature:() const
WTF::BoundsCheckedPointer::validate	.\BoundsCheckedPointer.h	/^    void validate(T* pointer) const$/;"	f	class:WTF::BoundsCheckedPointer	access:private	signature:(T* pointer) const
WTF::BoundsChecker	.\CheckedArithmetic.h	/^template <typename Target, typename Source> struct BoundsChecker<Target, Source, false, false> {$/;"	s	namespace:WTF
WTF::BoundsChecker	.\CheckedArithmetic.h	/^template <typename Target, typename Source> struct BoundsChecker<Target, Source, false, true> {$/;"	s	namespace:WTF
WTF::BoundsChecker	.\CheckedArithmetic.h	/^template <typename Target, typename Source> struct BoundsChecker<Target, Source, true, false> {$/;"	s	namespace:WTF
WTF::BoundsChecker	.\CheckedArithmetic.h	/^template <typename Target, typename Source> struct BoundsChecker<Target, Source, true, true> {$/;"	s	namespace:WTF
WTF::BoundsChecker::inBounds	.\CheckedArithmetic.h	/^    static bool inBounds(Source value)$/;"	f	struct:WTF::BoundsChecker	access:public	signature:(Source value)
WTF::BumpPointerAllocator	.\BumpPointerAllocator.h	/^class BumpPointerAllocator {$/;"	c	namespace:WTF
WTF::BumpPointerAllocator::BumpPointerAllocator	.\BumpPointerAllocator.h	/^    BumpPointerAllocator()$/;"	f	class:WTF::BumpPointerAllocator	access:public	signature:()
WTF::BumpPointerAllocator::m_head	.\BumpPointerAllocator.h	/^    BumpPointerPool* m_head;$/;"	m	class:WTF::BumpPointerAllocator	access:private
WTF::BumpPointerAllocator::startAllocator	.\BumpPointerAllocator.h	/^    BumpPointerPool* startAllocator()$/;"	f	class:WTF::BumpPointerAllocator	access:public	signature:()
WTF::BumpPointerAllocator::stopAllocator	.\BumpPointerAllocator.h	/^    void stopAllocator()$/;"	f	class:WTF::BumpPointerAllocator	access:public	signature:()
WTF::BumpPointerAllocator::~BumpPointerAllocator	.\BumpPointerAllocator.h	/^    ~BumpPointerAllocator()$/;"	f	class:WTF::BumpPointerAllocator	access:public	signature:()
WTF::BumpPointerPool	.\BumpPointerAllocator.h	/^class BumpPointerPool {$/;"	c	namespace:WTF
WTF::BumpPointerPool::BumpPointerPool	.\BumpPointerAllocator.h	/^    BumpPointerPool(const PageAllocation& allocation)$/;"	f	class:WTF::BumpPointerPool	access:private	signature:(const PageAllocation& allocation)
WTF::BumpPointerPool::alloc	.\BumpPointerAllocator.h	/^    void* alloc(size_t size)$/;"	f	class:WTF::BumpPointerPool	access:public	signature:(size_t size)
WTF::BumpPointerPool::create	.\BumpPointerAllocator.h	/^    static BumpPointerPool* create(size_t minimumCapacity = 0)$/;"	f	class:WTF::BumpPointerPool	access:private	signature:(size_t minimumCapacity = 0)
WTF::BumpPointerPool::dealloc	.\BumpPointerAllocator.h	/^    BumpPointerPool* dealloc(void* position)$/;"	f	class:WTF::BumpPointerPool	access:public	signature:(void* position)
WTF::BumpPointerPool::deallocCrossPool	.\BumpPointerAllocator.h	/^    static BumpPointerPool* deallocCrossPool(BumpPointerPool* pool, void* position)$/;"	f	class:WTF::BumpPointerPool	access:private	signature:(BumpPointerPool* pool, void* position)
WTF::BumpPointerPool::destroy	.\BumpPointerAllocator.h	/^    void destroy()$/;"	f	class:WTF::BumpPointerPool	access:private	signature:()
WTF::BumpPointerPool::ensureCapacity	.\BumpPointerAllocator.h	/^    BumpPointerPool* ensureCapacity(size_t size)$/;"	f	class:WTF::BumpPointerPool	access:public	signature:(size_t size)
WTF::BumpPointerPool::ensureCapacityCrossPool	.\BumpPointerAllocator.h	/^    static BumpPointerPool* ensureCapacityCrossPool(BumpPointerPool* previousPool, size_t size)$/;"	f	class:WTF::BumpPointerPool	access:private	signature:(BumpPointerPool* previousPool, size_t size)
WTF::BumpPointerPool::m_allocation	.\BumpPointerAllocator.h	/^    PageAllocation m_allocation;$/;"	m	class:WTF::BumpPointerPool	access:private
WTF::BumpPointerPool::m_current	.\BumpPointerAllocator.h	/^    void* m_current;$/;"	m	class:WTF::BumpPointerPool	access:private
WTF::BumpPointerPool::m_next	.\BumpPointerAllocator.h	/^    BumpPointerPool* m_next;$/;"	m	class:WTF::BumpPointerPool	access:private
WTF::BumpPointerPool::m_previous	.\BumpPointerAllocator.h	/^    BumpPointerPool* m_previous;$/;"	m	class:WTF::BumpPointerPool	access:private
WTF::BumpPointerPool::m_start	.\BumpPointerAllocator.h	/^    void* m_start;$/;"	m	class:WTF::BumpPointerPool	access:private
WTF::BumpPointerPool::operator new	.\BumpPointerAllocator.h	/^    void* operator new(size_t size, const PageAllocation& allocation)$/;"	f	class:WTF::BumpPointerPool	access:private	signature:(size_t size, const PageAllocation& allocation)
WTF::BumpPointerPool::shrink	.\BumpPointerAllocator.h	/^    void shrink()$/;"	f	class:WTF::BumpPointerPool	access:private	signature:()
WTF::ByteArray	.\ByteArray.h	/^    class ByteArray : public RefCountedBase {$/;"	c	namespace:WTF	inherits:RefCountedBase
WTF::ByteArray::ByteArray	.\ByteArray.h	/^        ByteArray(size_t size)$/;"	f	class:WTF::ByteArray	access:private	signature:(size_t size)
WTF::ByteArray::clear	.\ByteArray.h	/^        void clear() { memset(m_data, 0, m_size); }$/;"	f	class:WTF::ByteArray	access:public	signature:()
WTF::ByteArray::create	.\ByteArray.cpp	/^PassRefPtr<ByteArray> ByteArray::create(size_t size)$/;"	f	class:WTF::ByteArray	signature:(size_t size)
WTF::ByteArray::create	.\ByteArray.h	/^        WTF_EXPORT_PRIVATE static PassRefPtr<ByteArray> create(size_t size);$/;"	p	class:WTF::ByteArray	access:public	signature:(size_t size)
WTF::ByteArray::data	.\ByteArray.h	/^        unsigned char* data() { return m_data; }$/;"	f	class:WTF::ByteArray	access:public	signature:()
WTF::ByteArray::deref	.\ByteArray.h	/^        void deref()$/;"	f	class:WTF::ByteArray	access:public	signature:()
WTF::ByteArray::get	.\ByteArray.h	/^        bool get(unsigned index, unsigned char& result) const$/;"	f	class:WTF::ByteArray	access:public	signature:(unsigned index, unsigned char& result) const
WTF::ByteArray::get	.\ByteArray.h	/^        unsigned char get(unsigned index) const$/;"	f	class:WTF::ByteArray	access:public	signature:(unsigned index) const
WTF::ByteArray::length	.\ByteArray.h	/^        unsigned length() const { return m_size; }$/;"	f	class:WTF::ByteArray	access:public	signature:() const
WTF::ByteArray::m_data	.\ByteArray.h	/^        unsigned char m_data[INT_MAX];$/;"	m	class:WTF::ByteArray	access:private
WTF::ByteArray::m_data	.\ByteArray.h	/^        unsigned char m_data[];$/;"	m	class:WTF::ByteArray	access:private
WTF::ByteArray::m_size	.\ByteArray.h	/^        size_t m_size;$/;"	m	class:WTF::ByteArray	access:private
WTF::ByteArray::offsetOfData	.\ByteArray.h	/^        static size_t offsetOfData() { return OBJECT_OFFSETOF(ByteArray, m_data); }$/;"	f	class:WTF::ByteArray	access:public	signature:()
WTF::ByteArray::offsetOfSize	.\ByteArray.h	/^        static size_t offsetOfSize() { return OBJECT_OFFSETOF(ByteArray, m_size); }$/;"	f	class:WTF::ByteArray	access:public	signature:()
WTF::ByteArray::set	.\ByteArray.h	/^        void set(unsigned index, double value)$/;"	f	class:WTF::ByteArray	access:public	signature:(unsigned index, double value)
WTF::ByteArray::set	.\ByteArray.h	/^        void set(unsigned index, unsigned char value)$/;"	f	class:WTF::ByteArray	access:public	signature:(unsigned index, unsigned char value)
WTF::ByteSizeForClass	.\FastMalloc.cpp	/^static ALWAYS_INLINE size_t ByteSizeForClass(size_t cl) {$/;"	f	namespace:WTF	file:	signature:(size_t cl)
WTF::CString	.\text\CString.h	/^class CString {$/;"	c	namespace:WTF
WTF::CString::CString	.\text\CString.cpp	/^CString::CString(const char* str)$/;"	f	class:WTF::CString	signature:(const char* str)
WTF::CString::CString	.\text\CString.cpp	/^CString::CString(const char* str, size_t length)$/;"	f	class:WTF::CString	signature:(const char* str, size_t length)
WTF::CString::CString	.\text\CString.h	/^    CString() { }$/;"	f	class:WTF::CString	access:public	signature:()
WTF::CString::CString	.\text\CString.h	/^    CString(CStringBuffer* buffer) : m_buffer(buffer) { }$/;"	f	class:WTF::CString	access:public	signature:(CStringBuffer* buffer)
WTF::CString::CString	.\text\CString.h	/^    WTF_EXPORT_PRIVATE CString(const char*);$/;"	p	class:WTF::CString	access:public	signature:(const char*)
WTF::CString::CString	.\text\CString.h	/^    WTF_EXPORT_PRIVATE CString(const char*, size_t length);$/;"	p	class:WTF::CString	access:public	signature:(const char*, size_t length)
WTF::CString::buffer	.\text\CString.h	/^    CStringBuffer* buffer() const { return m_buffer.get(); }$/;"	f	class:WTF::CString	access:public	signature:() const
WTF::CString::copyBufferIfNeeded	.\text\CString.cpp	/^void CString::copyBufferIfNeeded()$/;"	f	class:WTF::CString	signature:()
WTF::CString::copyBufferIfNeeded	.\text\CString.h	/^    void copyBufferIfNeeded();$/;"	p	class:WTF::CString	access:private	signature:()
WTF::CString::data	.\text\CString.h	/^    const char* data() const$/;"	f	class:WTF::CString	access:public	signature:() const
WTF::CString::init	.\text\CString.cpp	/^void CString::init(const char* str, size_t length)$/;"	f	class:WTF::CString	signature:(const char* str, size_t length)
WTF::CString::init	.\text\CString.h	/^    void init(const char*, size_t length);$/;"	p	class:WTF::CString	access:private	signature:(const char*, size_t length)
WTF::CString::isNull	.\text\CString.h	/^    bool isNull() const { return !m_buffer; }$/;"	f	class:WTF::CString	access:public	signature:() const
WTF::CString::length	.\text\CString.h	/^    size_t length() const$/;"	f	class:WTF::CString	access:public	signature:() const
WTF::CString::m_buffer	.\text\CString.h	/^    RefPtr<CStringBuffer> m_buffer;$/;"	m	class:WTF::CString	access:private
WTF::CString::mutableData	.\text\CString.cpp	/^char* CString::mutableData()$/;"	f	class:WTF::CString	signature:()
WTF::CString::mutableData	.\text\CString.h	/^    WTF_EXPORT_PRIVATE char* mutableData();$/;"	p	class:WTF::CString	access:public	signature:()
WTF::CString::newUninitialized	.\text\CString.cpp	/^CString CString::newUninitialized(size_t length, char*& characterBuffer)$/;"	f	class:WTF::CString	signature:(size_t length, char*& characterBuffer)
WTF::CString::newUninitialized	.\text\CString.h	/^    WTF_EXPORT_PRIVATE static CString newUninitialized(size_t length, char*& characterBuffer);$/;"	p	class:WTF::CString	access:public	signature:(size_t length, char*& characterBuffer)
WTF::CStringBuffer	.\text\CString.h	/^class CStringBuffer : public RefCounted<CStringBuffer> {$/;"	c	namespace:WTF	inherits:RefCounted
WTF::CStringBuffer::CStringBuffer	.\text\CString.h	/^    CStringBuffer(size_t length) : m_vector(length) { }$/;"	f	class:WTF::CStringBuffer	access:private	signature:(size_t length)
WTF::CStringBuffer::create	.\text\CString.h	/^    static PassRefPtr<CStringBuffer> create(size_t length) { return adoptRef(new CStringBuffer(length)); }$/;"	f	class:WTF::CStringBuffer	access:private	signature:(size_t length)
WTF::CStringBuffer::data	.\text\CString.h	/^    const char* data() { return m_vector.data(); }$/;"	f	class:WTF::CStringBuffer	access:public	signature:()
WTF::CStringBuffer::length	.\text\CString.h	/^    size_t length() { return m_vector.size(); }$/;"	f	class:WTF::CStringBuffer	access:public	signature:()
WTF::CStringBuffer::m_vector	.\text\CString.h	/^    Vector<char> m_vector;$/;"	m	class:WTF::CStringBuffer	access:private
WTF::CStringBuffer::mutableData	.\text\CString.h	/^    char* mutableData() { return m_vector.data(); }$/;"	f	class:WTF::CStringBuffer	access:private	signature:()
WTF::CStringTranslator	.\text\AtomicString.cpp	/^struct CStringTranslator {$/;"	s	namespace:WTF	file:
WTF::CStringTranslator::equal	.\text\AtomicString.cpp	/^    static inline bool equal(StringImpl* r, const LChar* s)$/;"	f	struct:WTF::CStringTranslator	access:public	signature:(StringImpl* r, const LChar* s)
WTF::CStringTranslator::hash	.\text\AtomicString.cpp	/^    static unsigned hash(const LChar* c)$/;"	f	struct:WTF::CStringTranslator	access:public	signature:(const LChar* c)
WTF::CStringTranslator::translate	.\text\AtomicString.cpp	/^    static void translate(StringImpl*& location, const LChar* const& c, unsigned hash)$/;"	f	struct:WTF::CStringTranslator	access:public	signature:(StringImpl*& location, const LChar* const& c, unsigned hash)
WTF::CaseFoldingHash	.\text\StringHash.h	/^    class CaseFoldingHash {$/;"	c	namespace:WTF
WTF::CaseFoldingHash::equal	.\text\StringHash.h	/^        static bool equal(const AtomicString& a, const AtomicString& b)$/;"	f	class:WTF::CaseFoldingHash	access:public	signature:(const AtomicString& a, const AtomicString& b)
WTF::CaseFoldingHash::equal	.\text\StringHash.h	/^        static bool equal(const RefPtr<StringImpl>& a, const RefPtr<StringImpl>& b)$/;"	f	class:WTF::CaseFoldingHash	access:public	signature:(const RefPtr<StringImpl>& a, const RefPtr<StringImpl>& b)
WTF::CaseFoldingHash::equal	.\text\StringHash.h	/^        static bool equal(const String& a, const String& b)$/;"	f	class:WTF::CaseFoldingHash	access:public	signature:(const String& a, const String& b)
WTF::CaseFoldingHash::equal	.\text\StringHash.h	/^        static bool equal(const StringImpl* a, const StringImpl* b)$/;"	f	class:WTF::CaseFoldingHash	access:public	signature:(const StringImpl* a, const StringImpl* b)
WTF::CaseFoldingHash::foldCase	.\text\StringHash.h	/^        template<typename T> static inline UChar foldCase(T ch)$/;"	f	class:WTF::CaseFoldingHash	access:public	signature:(T ch)
WTF::CaseFoldingHash::hash	.\text\StringHash.h	/^        static inline unsigned hash(const char* data, unsigned length)$/;"	f	class:WTF::CaseFoldingHash	access:public	signature:(const char* data, unsigned length)
WTF::CaseFoldingHash::hash	.\text\StringHash.h	/^        static unsigned hash(StringImpl* str)$/;"	f	class:WTF::CaseFoldingHash	access:public	signature:(StringImpl* str)
WTF::CaseFoldingHash::hash	.\text\StringHash.h	/^        static unsigned hash(const AtomicString& key)$/;"	f	class:WTF::CaseFoldingHash	access:public	signature:(const AtomicString& key)
WTF::CaseFoldingHash::hash	.\text\StringHash.h	/^        static unsigned hash(const LChar* data, unsigned length)$/;"	f	class:WTF::CaseFoldingHash	access:public	signature:(const LChar* data, unsigned length)
WTF::CaseFoldingHash::hash	.\text\StringHash.h	/^        static unsigned hash(const RefPtr<StringImpl>& key) $/;"	f	class:WTF::CaseFoldingHash	access:public	signature:(const RefPtr<StringImpl>& key)
WTF::CaseFoldingHash::hash	.\text\StringHash.h	/^        static unsigned hash(const String& key)$/;"	f	class:WTF::CaseFoldingHash	access:public	signature:(const String& key)
WTF::CaseFoldingHash::hash	.\text\StringHash.h	/^        static unsigned hash(const UChar* data, unsigned length)$/;"	f	class:WTF::CaseFoldingHash	access:public	signature:(const UChar* data, unsigned length)
WTF::CaseFoldingHash::safeToCompareToEmptyOrDeleted	.\text\StringHash.h	/^        static const bool safeToCompareToEmptyOrDeleted = false;$/;"	m	class:WTF::CaseFoldingHash	access:public
WTF::CharacterMatchFunctionPtr	.\text\StringImpl.h	/^typedef bool (*CharacterMatchFunctionPtr)(UChar);$/;"	t	namespace:WTF
WTF::CheckCachedSizeClass	.\FastMalloc.cpp	/^static inline bool CheckCachedSizeClass(void *ptr) {$/;"	f	namespace:WTF	file:	signature:(void *ptr)
WTF::CheckIfKernelSupportsTLS	.\FastMalloc.cpp	/^    static void CheckIfKernelSupportsTLS() {$/;"	f	namespace:WTF	file:	signature:()
WTF::Checked	.\CheckedArithmetic.h	/^template <typename T, class OverflowHandler> class Checked : public OverflowHandler {$/;"	c	namespace:WTF	inherits:OverflowHandler
WTF::Checked::Checked	.\CheckedArithmetic.h	/^    Checked()$/;"	f	class:WTF::Checked	access:public	signature:()
WTF::Checked::Checked	.\CheckedArithmetic.h	/^    Checked(ResultOverflowedTag)$/;"	f	class:WTF::Checked	access:public	signature:(ResultOverflowedTag)
WTF::Checked::Checked	.\CheckedArithmetic.h	/^    Checked(double);$/;"	p	class:WTF::Checked	access:private	signature:(double)
WTF::Checked::Checked	.\CheckedArithmetic.h	/^    Checked(float);$/;"	p	class:WTF::Checked	access:private	signature:(float)
WTF::Checked::Checked	.\CheckedArithmetic.h	/^    template <typename U, typename V> Checked(const Checked<U, V>& rhs)$/;"	f	class:WTF::Checked	access:public	signature:(const Checked<U, V>& rhs)
WTF::Checked::Checked	.\CheckedArithmetic.h	/^    template <typename U> Checked(U value)$/;"	f	class:WTF::Checked	access:public	signature:(U value)
WTF::Checked::Checked	.\CheckedArithmetic.h	/^    template <typename U> Checked(const Checked<U, OverflowHandler>& rhs)$/;"	f	class:WTF::Checked	access:public	signature:(const Checked<U, OverflowHandler>& rhs)
WTF::Checked::Checked	.\CheckedArithmetic.h	/^    template <typename V> Checked(const Checked<T, V>& rhs)$/;"	f	class:WTF::Checked	access:public	signature:(const Checked<T, V>& rhs)
WTF::Checked::UnspecifiedBoolType	.\CheckedArithmetic.h	/^    typedef void* (Checked::*UnspecifiedBoolType);$/;"	t	class:WTF::Checked	access:public
WTF::Checked::m_value	.\CheckedArithmetic.h	/^    T m_value;$/;"	m	class:WTF::Checked	access:private
WTF::Checked::operator !	.\CheckedArithmetic.h	/^    bool operator!() const$/;"	f	class:WTF::Checked	access:public	signature:() const
WTF::Checked::operator !=	.\CheckedArithmetic.h	/^    template <typename U> bool operator!=(U rhs)$/;"	f	class:WTF::Checked	access:public	signature:(U rhs)
WTF::Checked::operator *=	.\CheckedArithmetic.h	/^    template <typename U, typename V> const Checked operator*=(Checked<U, V> rhs)$/;"	f	class:WTF::Checked	access:public	signature:(Checked<U, V> rhs)
WTF::Checked::operator *=	.\CheckedArithmetic.h	/^    template <typename U> const Checked operator*=(U rhs)$/;"	f	class:WTF::Checked	access:public	signature:(U rhs)
WTF::Checked::operator ++	.\CheckedArithmetic.h	/^    const Checked operator++(int)$/;"	f	class:WTF::Checked	access:public	signature:(int)
WTF::Checked::operator ++	.\CheckedArithmetic.h	/^    const Checked& operator++()$/;"	f	class:WTF::Checked	access:public	signature:()
WTF::Checked::operator +=	.\CheckedArithmetic.h	/^    template <typename U, typename V> const Checked operator+=(Checked<U, V> rhs)$/;"	f	class:WTF::Checked	access:public	signature:(Checked<U, V> rhs)
WTF::Checked::operator +=	.\CheckedArithmetic.h	/^    template <typename U> const Checked operator+=(U rhs)$/;"	f	class:WTF::Checked	access:public	signature:(U rhs)
WTF::Checked::operator +=	.\CheckedArithmetic.h	/^    void operator+=(double);$/;"	p	class:WTF::Checked	access:private	signature:(double)
WTF::Checked::operator +=	.\CheckedArithmetic.h	/^    void operator+=(float);$/;"	p	class:WTF::Checked	access:private	signature:(float)
WTF::Checked::operator --	.\CheckedArithmetic.h	/^    const Checked operator--(int)$/;"	f	class:WTF::Checked	access:public	signature:(int)
WTF::Checked::operator --	.\CheckedArithmetic.h	/^    const Checked& operator--()$/;"	f	class:WTF::Checked	access:public	signature:()
WTF::Checked::operator -=	.\CheckedArithmetic.h	/^    template <typename U, typename V> const Checked operator-=(Checked<U, V> rhs)$/;"	f	class:WTF::Checked	access:public	signature:(Checked<U, V> rhs)
WTF::Checked::operator -=	.\CheckedArithmetic.h	/^    template <typename U> const Checked operator-=(U rhs)$/;"	f	class:WTF::Checked	access:public	signature:(U rhs)
WTF::Checked::operator -=	.\CheckedArithmetic.h	/^    void operator-=(double);$/;"	p	class:WTF::Checked	access:private	signature:(double)
WTF::Checked::operator -=	.\CheckedArithmetic.h	/^    void operator-=(float);$/;"	p	class:WTF::Checked	access:private	signature:(float)
WTF::Checked::operator =	.\CheckedArithmetic.h	/^    const Checked& operator=(Checked rhs)$/;"	f	class:WTF::Checked	access:public	signature:(Checked rhs)
WTF::Checked::operator =	.\CheckedArithmetic.h	/^    template <typename U, typename V> const Checked& operator=(const Checked<U, V>& rhs)$/;"	f	class:WTF::Checked	access:public	signature:(const Checked<U, V>& rhs)
WTF::Checked::operator =	.\CheckedArithmetic.h	/^    template <typename U> const Checked& operator=(U value)$/;"	f	class:WTF::Checked	access:public	signature:(U value)
WTF::Checked::operator =	.\CheckedArithmetic.h	/^    void operator=(double);$/;"	p	class:WTF::Checked	access:private	signature:(double)
WTF::Checked::operator =	.\CheckedArithmetic.h	/^    void operator=(float);$/;"	p	class:WTF::Checked	access:private	signature:(float)
WTF::Checked::operator ==	.\CheckedArithmetic.h	/^    template <typename U, typename V> const Checked operator==(Checked<U, V> rhs)$/;"	f	class:WTF::Checked	access:public	signature:(Checked<U, V> rhs)
WTF::Checked::operator ==	.\CheckedArithmetic.h	/^    template <typename U> bool operator==(U rhs)$/;"	f	class:WTF::Checked	access:public	signature:(U rhs)
WTF::Checked::operator ==	.\CheckedArithmetic.h	/^    template <typename V> bool operator==(Checked<T, V> rhs)$/;"	f	class:WTF::Checked	access:public	signature:(Checked<T, V> rhs)
WTF::Checked::operator UnspecifiedBoolType*	.\CheckedArithmetic.h	/^    operator UnspecifiedBoolType*() const$/;"	f	class:WTF::Checked	access:public	signature:() const
WTF::Checked::unsafeGet	.\CheckedArithmetic.h	/^    T unsafeGet() const$/;"	f	class:WTF::Checked	access:public	signature:() const
WTF::CheckedMallocResult	.\FastMalloc.cpp	/^static inline void* CheckedMallocResult(void *result)$/;"	f	namespace:WTF	file:	signature:(void *result)
WTF::ChromiumThreading	.\chromium\ChromiumThreading.h	/^class ChromiumThreading {$/;"	c	namespace:WTF
WTF::ChromiumThreading::callOnMainThread	.\chromium\ChromiumThreading.h	/^    static void callOnMainThread(void (*func)(void*), void* context);$/;"	p	class:WTF::ChromiumThreading	access:public	signature:(void (*func)(void*), void* context)
WTF::ClassIndex	.\FastMalloc.cpp	/^static inline int ClassIndex(size_t s) {$/;"	f	namespace:WTF	file:	signature:(size_t s)
WTF::Collator	.\unicode\Collator.h	/^    class Collator {$/;"	c	namespace:WTF
WTF::Collator::Collator	.\unicode\Collator.h	/^        WTF_EXPORT_PRIVATE Collator(const char* locale); \/\/ Parsing is lenient; e.g. language identifiers (such as "en-US") are accepted, too.$/;"	p	class:WTF::Collator	access:public	signature:(const char* locale)
WTF::Collator::Collator	.\unicode\CollatorDefault.cpp	/^Collator::Collator(const char*)$/;"	f	class:WTF::Collator	signature:(const char*)
WTF::Collator::Collator	.\unicode\icu\CollatorICU.cpp	/^Collator::Collator(const char* locale)$/;"	f	class:WTF::Collator	signature:(const char* locale)
WTF::Collator::Equal	.\unicode\Collator.h	/^        enum Result { Equal = 0, Greater = 1, Less = -1 };$/;"	e	enum:WTF::Collator::Result
WTF::Collator::Greater	.\unicode\Collator.h	/^        enum Result { Equal = 0, Greater = 1, Less = -1 };$/;"	e	enum:WTF::Collator::Result
WTF::Collator::Less	.\unicode\Collator.h	/^        enum Result { Equal = 0, Greater = 1, Less = -1 };$/;"	e	enum:WTF::Collator::Result
WTF::Collator::Result	.\unicode\Collator.h	/^        enum Result { Equal = 0, Greater = 1, Less = -1 };$/;"	g	class:WTF::Collator	access:public
WTF::Collator::WTF_MAKE_FAST_ALLOCATED	.\unicode\Collator.h	/^        WTF_MAKE_NONCOPYABLE(Collator); WTF_MAKE_FAST_ALLOCATED;$/;"	m	class:WTF::Collator	access:private
WTF::Collator::WTF_MAKE_NONCOPYABLE	.\unicode\Collator.h	/^        WTF_MAKE_NONCOPYABLE(Collator); WTF_MAKE_FAST_ALLOCATED;$/;"	p	class:WTF::Collator	access:private	signature:(Collator)
WTF::Collator::collate	.\unicode\Collator.h	/^        WTF_EXPORT_PRIVATE Result collate(const ::UChar*, size_t, const ::UChar*, size_t) const;$/;"	p	class:WTF::Collator	access:public	signature:(const ::UChar*, size_t, const ::UChar*, size_t) const
WTF::Collator::collate	.\unicode\CollatorDefault.cpp	/^Collator::Result Collator::collate(const UChar* lhs, size_t lhsLength, const UChar* rhs, size_t rhsLength) const$/;"	f	class:WTF::Collator	signature:(const UChar* lhs, size_t lhsLength, const UChar* rhs, size_t rhsLength) const
WTF::Collator::collate	.\unicode\icu\CollatorICU.cpp	/^Collator::Result Collator::collate(const UChar* lhs, size_t lhsLength, const UChar* rhs, size_t rhsLength) const$/;"	f	class:WTF::Collator	signature:(const UChar* lhs, size_t lhsLength, const UChar* rhs, size_t rhsLength) const
WTF::Collator::createCollator	.\unicode\Collator.h	/^        void createCollator() const;$/;"	p	class:WTF::Collator	access:private	signature:() const
WTF::Collator::createCollator	.\unicode\icu\CollatorICU.cpp	/^void Collator::createCollator() const$/;"	f	class:WTF::Collator	signature:() const
WTF::Collator::m_collator	.\unicode\Collator.h	/^        mutable UCollator* m_collator;$/;"	m	class:WTF::Collator	access:private
WTF::Collator::m_locale	.\unicode\Collator.h	/^        char* m_locale;$/;"	m	class:WTF::Collator	access:private
WTF::Collator::m_lowerFirst	.\unicode\Collator.h	/^        bool m_lowerFirst;$/;"	m	class:WTF::Collator	access:private
WTF::Collator::releaseCollator	.\unicode\Collator.h	/^        void releaseCollator();$/;"	p	class:WTF::Collator	access:private	signature:()
WTF::Collator::releaseCollator	.\unicode\icu\CollatorICU.cpp	/^void Collator::releaseCollator()$/;"	f	class:WTF::Collator	signature:()
WTF::Collator::setOrderLowerFirst	.\unicode\Collator.h	/^        WTF_EXPORT_PRIVATE void setOrderLowerFirst(bool);$/;"	p	class:WTF::Collator	access:public	signature:(bool)
WTF::Collator::setOrderLowerFirst	.\unicode\CollatorDefault.cpp	/^void Collator::setOrderLowerFirst(bool)$/;"	f	class:WTF::Collator	signature:(bool)
WTF::Collator::setOrderLowerFirst	.\unicode\icu\CollatorICU.cpp	/^void Collator::setOrderLowerFirst(bool lowerFirst)$/;"	f	class:WTF::Collator	signature:(bool lowerFirst)
WTF::Collator::userDefault	.\unicode\Collator.h	/^        static PassOwnPtr<Collator> userDefault();$/;"	p	class:WTF::Collator	access:public	signature:()
WTF::Collator::userDefault	.\unicode\CollatorDefault.cpp	/^PassOwnPtr<Collator> Collator::userDefault()$/;"	f	class:WTF::Collator	signature:()
WTF::Collator::userDefault	.\unicode\icu\CollatorICU.cpp	/^PassOwnPtr<Collator> Collator::userDefault()$/;"	f	class:WTF::Collator	signature:()
WTF::Collator::~Collator	.\unicode\Collator.h	/^        WTF_EXPORT_PRIVATE ~Collator();$/;"	p	class:WTF::Collator	access:public	signature:()
WTF::Collator::~Collator	.\unicode\CollatorDefault.cpp	/^Collator::~Collator()$/;"	f	class:WTF::Collator	signature:()
WTF::Collator::~Collator	.\unicode\icu\CollatorICU.cpp	/^Collator::~Collator()$/;"	f	class:WTF::Collator	signature:()
WTF::Complex	.\Complex.h	/^typedef std::complex<double> Complex;$/;"	t	namespace:WTF
WTF::Conditional	.\TypeTraits.h	/^    template <bool Predicate, class If, class Then> struct Conditional  { typedef If Type; };$/;"	s	namespace:WTF
WTF::Conditional	.\TypeTraits.h	/^    template <class If, class Then> struct Conditional<false, If, Then> { typedef Then Type; };$/;"	s	namespace:WTF
WTF::Conditional::Type	.\TypeTraits.h	/^    template <bool Predicate, class If, class Then> struct Conditional  { typedef If Type; };$/;"	t	struct:WTF::Conditional	access:public
WTF::Conditional::Type	.\TypeTraits.h	/^    template <class If, class Then> struct Conditional<false, If, Then> { typedef Then Type; };$/;"	t	struct:WTF::Conditional	access:public
WTF::CrashOnOverflow	.\CheckedArithmetic.h	/^class CrashOnOverflow {$/;"	c	namespace:WTF
WTF::CrashOnOverflow::clearOverflow	.\CheckedArithmetic.h	/^    void clearOverflow() { }$/;"	f	class:WTF::CrashOnOverflow	access:protected	signature:()
WTF::CrashOnOverflow::hasOverflowed	.\CheckedArithmetic.h	/^    bool hasOverflowed() const { return false; }$/;"	f	class:WTF::CrashOnOverflow	access:public	signature:() const
WTF::CrashOnOverflow::overflowed	.\CheckedArithmetic.h	/^    NO_RETURN_DUE_TO_CRASH void overflowed()$/;"	f	class:WTF::CrashOnOverflow	access:protected	signature:()
WTF::DLL_Init	.\FastMalloc.cpp	/^static inline void DLL_Init(Span* list) {$/;"	f	namespace:WTF	file:	signature:(Span* list)
WTF::DLL_IsEmpty	.\FastMalloc.cpp	/^static ALWAYS_INLINE bool DLL_IsEmpty(const Span* list) {$/;"	f	namespace:WTF	file:	signature:(const Span* list)
WTF::DLL_Length	.\FastMalloc.cpp	/^static int DLL_Length(const Span* list) {$/;"	f	namespace:WTF	file:	signature:(const Span* list)
WTF::DLL_Prepend	.\FastMalloc.cpp	/^static inline void DLL_Prepend(Span* list, Span* span) {$/;"	f	namespace:WTF	file:	signature:(Span* list, Span* span)
WTF::DLL_Remove	.\FastMalloc.cpp	/^static inline void DLL_Remove(Span* span) {$/;"	f	namespace:WTF	file:	signature:(Span* span)
WTF::DecayArray	.\TypeTraits.h	/^    template <class T> struct DecayArray {$/;"	s	namespace:WTF
WTF::DecayArray::Type	.\TypeTraits.h	/^        >::Type Type;$/;"	t	struct:WTF::DecayArray	access:public
WTF::DecayArray::U	.\TypeTraits.h	/^        typedef typename RemoveReference<T>::Type U;$/;"	t	struct:WTF::DecayArray	access:public
WTF::DecimalNumber	.\DecimalNumber.h	/^class DecimalNumber {$/;"	c	namespace:WTF
WTF::DecimalNumber::DecimalNumber	.\DecimalNumber.h	/^    DecimalNumber(double d)$/;"	f	class:WTF::DecimalNumber	access:public	signature:(double d)
WTF::DecimalNumber::DecimalNumber	.\DecimalNumber.h	/^    DecimalNumber(double d, RoundingDecimalPlacesType, unsigned decimalPlaces)$/;"	f	class:WTF::DecimalNumber	access:public	signature:(double d, RoundingDecimalPlacesType, unsigned decimalPlaces)
WTF::DecimalNumber::DecimalNumber	.\DecimalNumber.h	/^    DecimalNumber(double d, RoundingSignificantFiguresType, unsigned significantFigures)$/;"	f	class:WTF::DecimalNumber	access:public	signature:(double d, RoundingSignificantFiguresType, unsigned significantFigures)
WTF::DecimalNumber::bufferLengthForStringDecimal	.\DecimalNumber.cpp	/^unsigned DecimalNumber::bufferLengthForStringDecimal() const$/;"	f	class:WTF::DecimalNumber	signature:() const
WTF::DecimalNumber::bufferLengthForStringDecimal	.\DecimalNumber.h	/^    WTF_EXPORT_PRIVATE unsigned bufferLengthForStringDecimal() const;$/;"	p	class:WTF::DecimalNumber	access:public	signature:() const
WTF::DecimalNumber::bufferLengthForStringExponential	.\DecimalNumber.cpp	/^unsigned DecimalNumber::bufferLengthForStringExponential() const$/;"	f	class:WTF::DecimalNumber	signature:() const
WTF::DecimalNumber::bufferLengthForStringExponential	.\DecimalNumber.h	/^    WTF_EXPORT_PRIVATE unsigned bufferLengthForStringExponential() const;$/;"	p	class:WTF::DecimalNumber	access:public	signature:() const
WTF::DecimalNumber::exponent	.\DecimalNumber.h	/^    int exponent() const { return m_exponent; }$/;"	f	class:WTF::DecimalNumber	access:public	signature:() const
WTF::DecimalNumber::m_exponent	.\DecimalNumber.h	/^    int m_exponent;$/;"	m	class:WTF::DecimalNumber	access:private
WTF::DecimalNumber::m_precision	.\DecimalNumber.h	/^    unsigned m_precision;$/;"	m	class:WTF::DecimalNumber	access:private
WTF::DecimalNumber::m_sign	.\DecimalNumber.h	/^    bool m_sign;$/;"	m	class:WTF::DecimalNumber	access:private
WTF::DecimalNumber::m_significand	.\DecimalNumber.h	/^    DtoaBuffer m_significand;$/;"	m	class:WTF::DecimalNumber	access:private
WTF::DecimalNumber::precision	.\DecimalNumber.h	/^    unsigned precision() const { return m_precision; }$/;"	f	class:WTF::DecimalNumber	access:public	signature:() const
WTF::DecimalNumber::sign	.\DecimalNumber.h	/^    bool sign() const { return m_sign; }$/;"	f	class:WTF::DecimalNumber	access:public	signature:() const
WTF::DecimalNumber::significand	.\DecimalNumber.h	/^    const char* significand() const { return m_significand; } \/\/ significand contains precision characters, is not null-terminated.$/;"	f	class:WTF::DecimalNumber	access:public	signature:() const
WTF::DecimalNumber::toStringDecimal	.\DecimalNumber.cpp	/^unsigned DecimalNumber::toStringDecimal(UChar* buffer, unsigned bufferLength) const$/;"	f	class:WTF::DecimalNumber	signature:(UChar* buffer, unsigned bufferLength) const
WTF::DecimalNumber::toStringDecimal	.\DecimalNumber.h	/^    WTF_EXPORT_PRIVATE unsigned toStringDecimal(UChar* buffer, unsigned bufferLength) const;$/;"	p	class:WTF::DecimalNumber	access:public	signature:(UChar* buffer, unsigned bufferLength) const
WTF::DecimalNumber::toStringExponential	.\DecimalNumber.cpp	/^unsigned DecimalNumber::toStringExponential(UChar* buffer, unsigned bufferLength) const$/;"	f	class:WTF::DecimalNumber	signature:(UChar* buffer, unsigned bufferLength) const
WTF::DecimalNumber::toStringExponential	.\DecimalNumber.h	/^    WTF_EXPORT_PRIVATE unsigned toStringExponential(UChar* buffer, unsigned bufferLength) const;$/;"	p	class:WTF::DecimalNumber	access:public	signature:(UChar* buffer, unsigned bufferLength) const
WTF::Decoder	.\Decoder.h	/^class Decoder {$/;"	c	namespace:WTF
WTF::Decoder::Decoder	.\Decoder.h	/^    Decoder() { }$/;"	f	class:WTF::Decoder	access:protected	signature:()
WTF::Decoder::decodeBool	.\Decoder.h	/^    virtual bool decodeBool(bool&) = 0;$/;"	p	class:WTF::Decoder	access:public	signature:(bool&)
WTF::Decoder::decodeBytes	.\Decoder.h	/^    virtual bool decodeBytes(Vector<uint8_t>&) = 0;$/;"	p	class:WTF::Decoder	access:public	signature:(Vector<uint8_t>&)
WTF::Decoder::decodeDouble	.\Decoder.h	/^    virtual bool decodeDouble(double&) = 0;$/;"	p	class:WTF::Decoder	access:public	signature:(double&)
WTF::Decoder::decodeFloat	.\Decoder.h	/^    virtual bool decodeFloat(float&) = 0;$/;"	p	class:WTF::Decoder	access:public	signature:(float&)
WTF::Decoder::decodeInt32	.\Decoder.h	/^    virtual bool decodeInt32(int32_t&) = 0;$/;"	p	class:WTF::Decoder	access:public	signature:(int32_t&)
WTF::Decoder::decodeInt64	.\Decoder.h	/^    virtual bool decodeInt64(int64_t&) = 0;$/;"	p	class:WTF::Decoder	access:public	signature:(int64_t&)
WTF::Decoder::decodeString	.\Decoder.h	/^    virtual bool decodeString(String&) = 0;$/;"	p	class:WTF::Decoder	access:public	signature:(String&)
WTF::Decoder::decodeUInt32	.\Decoder.h	/^    virtual bool decodeUInt32(uint32_t&) = 0;$/;"	p	class:WTF::Decoder	access:public	signature:(uint32_t&)
WTF::Decoder::decodeUInt64	.\Decoder.h	/^    virtual bool decodeUInt64(uint64_t&) = 0;$/;"	p	class:WTF::Decoder	access:public	signature:(uint64_t&)
WTF::Decoder::~Decoder	.\Decoder.h	/^    virtual ~Decoder() { }$/;"	f	class:WTF::Decoder	access:protected	signature:()
WTF::DefaultHash	.\HashFunctions.h	/^    template<> struct DefaultHash<double> { typedef FloatHash<double> Hash; };$/;"	s	namespace:WTF
WTF::DefaultHash	.\HashFunctions.h	/^    template<> struct DefaultHash<float> { typedef FloatHash<float> Hash; };$/;"	s	namespace:WTF
WTF::DefaultHash	.\HashFunctions.h	/^    template<> struct DefaultHash<int> { typedef IntHash<unsigned> Hash; };$/;"	s	namespace:WTF
WTF::DefaultHash	.\HashFunctions.h	/^    template<> struct DefaultHash<long long> { typedef IntHash<unsigned long long> Hash; };$/;"	s	namespace:WTF
WTF::DefaultHash	.\HashFunctions.h	/^    template<> struct DefaultHash<long> { typedef IntHash<unsigned long> Hash; };$/;"	s	namespace:WTF
WTF::DefaultHash	.\HashFunctions.h	/^    template<> struct DefaultHash<short> { typedef IntHash<unsigned> Hash; };$/;"	s	namespace:WTF
WTF::DefaultHash	.\HashFunctions.h	/^    template<> struct DefaultHash<unsigned long long> { typedef IntHash<unsigned long long> Hash; };$/;"	s	namespace:WTF
WTF::DefaultHash	.\HashFunctions.h	/^    template<> struct DefaultHash<unsigned long> { typedef IntHash<unsigned long> Hash; };$/;"	s	namespace:WTF
WTF::DefaultHash	.\HashFunctions.h	/^    template<> struct DefaultHash<unsigned short> { typedef IntHash<unsigned> Hash; };$/;"	s	namespace:WTF
WTF::DefaultHash	.\HashFunctions.h	/^    template<> struct DefaultHash<unsigned> { typedef IntHash<unsigned> Hash; };$/;"	s	namespace:WTF
WTF::DefaultHash	.\HashFunctions.h	/^    template<> struct DefaultHash<wchar_t> { typedef IntHash<wchar_t> Hash; };$/;"	s	namespace:WTF
WTF::DefaultHash	.\HashFunctions.h	/^    template<typename P> struct DefaultHash<P*> { typedef PtrHash<P*> Hash; };$/;"	s	namespace:WTF
WTF::DefaultHash	.\HashFunctions.h	/^    template<typename P> struct DefaultHash<RefPtr<P> > { typedef PtrHash<RefPtr<P> > Hash; };$/;"	s	namespace:WTF
WTF::DefaultHash	.\HashFunctions.h	/^    template<typename T, typename U> struct DefaultHash<std::pair<T, U> > { typedef PairHash<T, U> Hash; };$/;"	s	namespace:WTF
WTF::DefaultHash	.\RetainPtr.h	/^    template<typename P> struct DefaultHash<RetainPtr<P> > { typedef PtrHash<RetainPtr<P> > Hash; };$/;"	s	namespace:WTF
WTF::DefaultHash	.\text\AtomicString.h	/^template<> struct DefaultHash<AtomicString> {$/;"	s	namespace:WTF
WTF::DefaultHash	.\text\StringImpl.h	/^template<> struct DefaultHash<RefPtr<StringImpl> > {$/;"	s	namespace:WTF
WTF::DefaultHash	.\text\StringImpl.h	/^template<> struct DefaultHash<StringImpl*> {$/;"	s	namespace:WTF
WTF::DefaultHash	.\text\WTFString.h	/^template<> struct DefaultHash<String> {$/;"	s	namespace:WTF
WTF::DefaultHash::Hash	.\HashFunctions.h	/^    template<> struct DefaultHash<double> { typedef FloatHash<double> Hash; };$/;"	t	struct:WTF::DefaultHash	access:public
WTF::DefaultHash::Hash	.\HashFunctions.h	/^    template<> struct DefaultHash<float> { typedef FloatHash<float> Hash; };$/;"	t	struct:WTF::DefaultHash	access:public
WTF::DefaultHash::Hash	.\HashFunctions.h	/^    template<> struct DefaultHash<int> { typedef IntHash<unsigned> Hash; };$/;"	t	struct:WTF::DefaultHash	access:public
WTF::DefaultHash::Hash	.\HashFunctions.h	/^    template<> struct DefaultHash<long long> { typedef IntHash<unsigned long long> Hash; };$/;"	t	struct:WTF::DefaultHash	access:public
WTF::DefaultHash::Hash	.\HashFunctions.h	/^    template<> struct DefaultHash<long> { typedef IntHash<unsigned long> Hash; };$/;"	t	struct:WTF::DefaultHash	access:public
WTF::DefaultHash::Hash	.\HashFunctions.h	/^    template<> struct DefaultHash<short> { typedef IntHash<unsigned> Hash; };$/;"	t	struct:WTF::DefaultHash	access:public
WTF::DefaultHash::Hash	.\HashFunctions.h	/^    template<> struct DefaultHash<unsigned long long> { typedef IntHash<unsigned long long> Hash; };$/;"	t	struct:WTF::DefaultHash	access:public
WTF::DefaultHash::Hash	.\HashFunctions.h	/^    template<> struct DefaultHash<unsigned long> { typedef IntHash<unsigned long> Hash; };$/;"	t	struct:WTF::DefaultHash	access:public
WTF::DefaultHash::Hash	.\HashFunctions.h	/^    template<> struct DefaultHash<unsigned short> { typedef IntHash<unsigned> Hash; };$/;"	t	struct:WTF::DefaultHash	access:public
WTF::DefaultHash::Hash	.\HashFunctions.h	/^    template<> struct DefaultHash<unsigned> { typedef IntHash<unsigned> Hash; };$/;"	t	struct:WTF::DefaultHash	access:public
WTF::DefaultHash::Hash	.\HashFunctions.h	/^    template<> struct DefaultHash<wchar_t> { typedef IntHash<wchar_t> Hash; };$/;"	t	struct:WTF::DefaultHash	access:public
WTF::DefaultHash::Hash	.\HashFunctions.h	/^    template<typename P> struct DefaultHash<P*> { typedef PtrHash<P*> Hash; };$/;"	t	struct:WTF::DefaultHash	access:public
WTF::DefaultHash::Hash	.\HashFunctions.h	/^    template<typename P> struct DefaultHash<RefPtr<P> > { typedef PtrHash<RefPtr<P> > Hash; };$/;"	t	struct:WTF::DefaultHash	access:public
WTF::DefaultHash::Hash	.\HashFunctions.h	/^    template<typename T, typename U> struct DefaultHash<std::pair<T, U> > { typedef PairHash<T, U> Hash; };$/;"	t	struct:WTF::DefaultHash	access:public
WTF::DefaultHash::Hash	.\RetainPtr.h	/^    template<typename P> struct DefaultHash<RetainPtr<P> > { typedef PtrHash<RetainPtr<P> > Hash; };$/;"	t	struct:WTF::DefaultHash	access:public
WTF::DefaultHash::Hash	.\text\AtomicString.h	/^    typedef AtomicStringHash Hash;$/;"	t	struct:WTF::DefaultHash	access:public
WTF::DefaultHash::Hash	.\text\StringImpl.h	/^    typedef StringHash Hash;$/;"	t	struct:WTF::DefaultHash	access:public
WTF::DefaultHash::Hash	.\text\WTFString.h	/^    typedef StringHash Hash;$/;"	t	struct:WTF::DefaultHash	access:public
WTF::DeleteSpan	.\FastMalloc.cpp	/^static inline void DeleteSpan(Span* span) {$/;"	f	namespace:WTF	file:	signature:(Span* span)
WTF::Deque	.\Deque.h	/^    class Deque {$/;"	c	namespace:WTF
WTF::Deque::Buffer	.\Deque.h	/^        typedef VectorBuffer<T, inlineCapacity> Buffer;$/;"	t	class:WTF::Deque	access:private
WTF::Deque::Deque	.\Deque.h	/^        Deque();$/;"	p	class:WTF::Deque	access:public	signature:()
WTF::Deque::Deque	.\Deque.h	/^        Deque(const Deque<T, inlineCapacity>&);$/;"	p	class:WTF::Deque	access:public	signature:(const Deque<T, inlineCapacity>&)
WTF::Deque::Deque	.\Deque.h	/^    inline Deque<T, inlineCapacity>::Deque()$/;"	f	class:WTF::Deque	signature:()
WTF::Deque::Deque	.\Deque.h	/^    inline Deque<T, inlineCapacity>::Deque(const Deque<T, inlineCapacity>& other)$/;"	f	class:WTF::Deque	signature:(const Deque<T, inlineCapacity>& other)
WTF::Deque::IteratorBase	.\Deque.h	/^        typedef DequeIteratorBase<T, inlineCapacity> IteratorBase;$/;"	t	class:WTF::Deque	access:private
WTF::Deque::Pass	.\Deque.h	/^        typedef PassTraits<T> Pass;$/;"	t	class:WTF::Deque	access:public
WTF::Deque::PassType	.\Deque.h	/^        typedef typename PassTraits<T>::PassType PassType;$/;"	t	class:WTF::Deque	access:public
WTF::Deque::TypeOperations	.\Deque.h	/^        typedef VectorTypeOperations<T> TypeOperations;$/;"	t	class:WTF::Deque	access:private
WTF::Deque::WTF_MAKE_FAST_ALLOCATED	.\Deque.h	/^        WTF_MAKE_FAST_ALLOCATED;$/;"	m	class:WTF::Deque	access:private
WTF::Deque::append	.\Deque.h	/^        template<typename U> void append(const U&);$/;"	p	class:WTF::Deque	access:public	signature:(const U&)
WTF::Deque::append	.\Deque.h	/^    inline void Deque<T, inlineCapacity>::append(const U& value)$/;"	f	class:WTF::Deque	signature:(const U& value)
WTF::Deque::begin	.\Deque.h	/^        const_iterator begin() const { return const_iterator(this, m_start); }$/;"	f	class:WTF::Deque	access:public	signature:() const
WTF::Deque::begin	.\Deque.h	/^        iterator begin() { return iterator(this, m_start); }$/;"	f	class:WTF::Deque	access:public	signature:()
WTF::Deque::checkIndexValidity	.\Deque.h	/^        void checkIndexValidity(size_t) const;$/;"	p	class:WTF::Deque	access:private	signature:(size_t) const
WTF::Deque::checkIndexValidity	.\Deque.h	/^    template<typename T, size_t inlineCapacity> inline void Deque<T, inlineCapacity>::checkIndexValidity(size_t) const { }$/;"	f	class:WTF::Deque	signature:(size_t) const
WTF::Deque::checkIndexValidity	.\Deque.h	/^    void Deque<T, inlineCapacity>::checkIndexValidity(size_t index) const$/;"	f	class:WTF::Deque	signature:(size_t index) const
WTF::Deque::checkValidity	.\Deque.h	/^        void checkValidity() const;$/;"	p	class:WTF::Deque	access:private	signature:() const
WTF::Deque::checkValidity	.\Deque.h	/^    template<typename T, size_t inlineCapacity> inline void Deque<T, inlineCapacity>::checkValidity() const { }$/;"	f	class:WTF::Deque	signature:() const
WTF::Deque::checkValidity	.\Deque.h	/^    void Deque<T, inlineCapacity>::checkValidity() const$/;"	f	class:WTF::Deque	signature:() const
WTF::Deque::clear	.\Deque.h	/^        void clear();$/;"	p	class:WTF::Deque	access:public	signature:()
WTF::Deque::clear	.\Deque.h	/^    inline void Deque<T, inlineCapacity>::clear()$/;"	f	class:WTF::Deque	signature:()
WTF::Deque::const_iterator	.\Deque.h	/^        typedef DequeConstIterator<T, inlineCapacity> const_iterator;$/;"	t	class:WTF::Deque	access:public
WTF::Deque::const_reverse_iterator	.\Deque.h	/^        typedef DequeConstReverseIterator<T, inlineCapacity> const_reverse_iterator;$/;"	t	class:WTF::Deque	access:public
WTF::Deque::destroyAll	.\Deque.h	/^        void destroyAll();$/;"	p	class:WTF::Deque	access:private	signature:()
WTF::Deque::destroyAll	.\Deque.h	/^    inline void Deque<T, inlineCapacity>::destroyAll()$/;"	f	class:WTF::Deque	signature:()
WTF::Deque::end	.\Deque.h	/^        const_iterator end() const { return const_iterator(this, m_end); }$/;"	f	class:WTF::Deque	access:public	signature:() const
WTF::Deque::end	.\Deque.h	/^        iterator end() { return iterator(this, m_end); }$/;"	f	class:WTF::Deque	access:public	signature:()
WTF::Deque::expandCapacity	.\Deque.h	/^        void expandCapacity();$/;"	p	class:WTF::Deque	access:private	signature:()
WTF::Deque::expandCapacity	.\Deque.h	/^    void Deque<T, inlineCapacity>::expandCapacity()$/;"	f	class:WTF::Deque	signature:()
WTF::Deque::expandCapacityIfNeeded	.\Deque.h	/^        void expandCapacityIfNeeded();$/;"	p	class:WTF::Deque	access:private	signature:()
WTF::Deque::expandCapacityIfNeeded	.\Deque.h	/^    inline void Deque<T, inlineCapacity>::expandCapacityIfNeeded()$/;"	f	class:WTF::Deque	signature:()
WTF::Deque::findIf	.\Deque.h	/^        iterator findIf(Predicate&);$/;"	p	class:WTF::Deque	access:public	signature:(Predicate&)
WTF::Deque::findIf	.\Deque.h	/^    inline DequeIterator<T, inlineCapacity> Deque<T, inlineCapacity>::findIf(Predicate& predicate)$/;"	f	class:WTF::Deque	signature:(Predicate& predicate)
WTF::Deque::first	.\Deque.h	/^        T& first() { ASSERT(m_start != m_end); return m_buffer.buffer()[m_start]; }$/;"	f	class:WTF::Deque	access:public	signature:()
WTF::Deque::first	.\Deque.h	/^        const T& first() const { ASSERT(m_start != m_end); return m_buffer.buffer()[m_start]; }$/;"	f	class:WTF::Deque	access:public	signature:() const
WTF::Deque::invalidateIterators	.\Deque.h	/^        void invalidateIterators();$/;"	p	class:WTF::Deque	access:private	signature:()
WTF::Deque::invalidateIterators	.\Deque.h	/^    template<typename T, size_t inlineCapacity> inline void Deque<T, inlineCapacity>::invalidateIterators() { }$/;"	f	class:WTF::Deque	signature:()
WTF::Deque::invalidateIterators	.\Deque.h	/^    void Deque<T, inlineCapacity>::invalidateIterators()$/;"	f	class:WTF::Deque	signature:()
WTF::Deque::isEmpty	.\Deque.h	/^        bool isEmpty() const { return m_start == m_end; }$/;"	f	class:WTF::Deque	access:public	signature:() const
WTF::Deque::iterator	.\Deque.h	/^        typedef DequeIterator<T, inlineCapacity> iterator;$/;"	t	class:WTF::Deque	access:public
WTF::Deque::last	.\Deque.h	/^        T& last() { ASSERT(m_start != m_end); return *(--end()); }$/;"	f	class:WTF::Deque	access:public	signature:()
WTF::Deque::last	.\Deque.h	/^        const T& last() const { ASSERT(m_start != m_end); return *(--end()); }$/;"	f	class:WTF::Deque	access:public	signature:() const
WTF::Deque::m_buffer	.\Deque.h	/^        Buffer m_buffer;$/;"	m	class:WTF::Deque	access:private
WTF::Deque::m_end	.\Deque.h	/^        size_t m_end;$/;"	m	class:WTF::Deque	access:private
WTF::Deque::m_iterators	.\Deque.h	/^        mutable IteratorBase* m_iterators;$/;"	m	class:WTF::Deque	access:private
WTF::Deque::m_start	.\Deque.h	/^        size_t m_start;$/;"	m	class:WTF::Deque	access:private
WTF::Deque::operator =	.\Deque.h	/^        Deque& operator=(const Deque<T, inlineCapacity>&);$/;"	p	class:WTF::Deque	access:public	signature:(const Deque<T, inlineCapacity>&)
WTF::Deque::operator =	.\Deque.h	/^    inline Deque<T, inlineCapacity>& Deque<T, inlineCapacity>::operator=(const Deque<T, inlineCapacity>& other)$/;"	f	class:WTF::Deque	signature:(const Deque<T, inlineCapacity>& other)
WTF::Deque::prepend	.\Deque.h	/^        template<typename U> void prepend(const U&);$/;"	p	class:WTF::Deque	access:public	signature:(const U&)
WTF::Deque::prepend	.\Deque.h	/^    inline void Deque<T, inlineCapacity>::prepend(const U& value)$/;"	f	class:WTF::Deque	signature:(const U& value)
WTF::Deque::rbegin	.\Deque.h	/^        const_reverse_iterator rbegin() const { return const_reverse_iterator(this, m_end); }$/;"	f	class:WTF::Deque	access:public	signature:() const
WTF::Deque::rbegin	.\Deque.h	/^        reverse_iterator rbegin() { return reverse_iterator(this, m_end); }$/;"	f	class:WTF::Deque	access:public	signature:()
WTF::Deque::remove	.\Deque.h	/^        void remove(const_iterator&);$/;"	p	class:WTF::Deque	access:public	signature:(const_iterator&)
WTF::Deque::remove	.\Deque.h	/^        void remove(iterator&);$/;"	p	class:WTF::Deque	access:public	signature:(iterator&)
WTF::Deque::remove	.\Deque.h	/^        void remove(size_t position);$/;"	p	class:WTF::Deque	access:private	signature:(size_t position)
WTF::Deque::remove	.\Deque.h	/^    inline void Deque<T, inlineCapacity>::remove(const_iterator& it)$/;"	f	class:WTF::Deque	signature:(const_iterator& it)
WTF::Deque::remove	.\Deque.h	/^    inline void Deque<T, inlineCapacity>::remove(iterator& it)$/;"	f	class:WTF::Deque	signature:(iterator& it)
WTF::Deque::remove	.\Deque.h	/^    inline void Deque<T, inlineCapacity>::remove(size_t position)$/;"	f	class:WTF::Deque	signature:(size_t position)
WTF::Deque::removeFirst	.\Deque.h	/^        void removeFirst();$/;"	p	class:WTF::Deque	access:public	signature:()
WTF::Deque::removeFirst	.\Deque.h	/^    inline void Deque<T, inlineCapacity>::removeFirst()$/;"	f	class:WTF::Deque	signature:()
WTF::Deque::rend	.\Deque.h	/^        const_reverse_iterator rend() const { return const_reverse_iterator(this, m_start); }$/;"	f	class:WTF::Deque	access:public	signature:() const
WTF::Deque::rend	.\Deque.h	/^        reverse_iterator rend() { return reverse_iterator(this, m_start); }$/;"	f	class:WTF::Deque	access:public	signature:()
WTF::Deque::reverse_iterator	.\Deque.h	/^        typedef DequeReverseIterator<T, inlineCapacity> reverse_iterator;$/;"	t	class:WTF::Deque	access:public
WTF::Deque::size	.\Deque.h	/^        size_t size() const { return m_start <= m_end ? m_end - m_start : m_end + m_buffer.capacity() - m_start; }$/;"	f	class:WTF::Deque	access:public	signature:() const
WTF::Deque::swap	.\Deque.h	/^        void swap(Deque<T, inlineCapacity>&);$/;"	p	class:WTF::Deque	access:public	signature:(Deque<T, inlineCapacity>&)
WTF::Deque::swap	.\Deque.h	/^    inline void Deque<T, inlineCapacity>::swap(Deque<T, inlineCapacity>& other)$/;"	f	class:WTF::Deque	signature:(Deque<T, inlineCapacity>& other)
WTF::Deque::takeFirst	.\Deque.h	/^        PassType takeFirst();$/;"	p	class:WTF::Deque	access:public	signature:()
WTF::Deque::takeFirst	.\Deque.h	/^    inline typename Deque<T, inlineCapacity>::PassType Deque<T, inlineCapacity>::takeFirst()$/;"	f	class:WTF::Deque	signature:()
WTF::Deque::~Deque	.\Deque.h	/^        ~Deque();$/;"	p	class:WTF::Deque	access:public	signature:()
WTF::Deque::~Deque	.\Deque.h	/^    inline Deque<T, inlineCapacity>::~Deque()$/;"	f	class:WTF::Deque	signature:()
WTF::DequeConstIterator	.\Deque.h	/^    class DequeConstIterator : public DequeIteratorBase<T, inlineCapacity> {$/;"	c	namespace:WTF	inherits:DequeIteratorBase
WTF::DequeConstIterator::Base	.\Deque.h	/^        typedef DequeIteratorBase<T, inlineCapacity> Base;$/;"	t	class:WTF::DequeConstIterator	access:private
WTF::DequeConstIterator::DequeConstIterator	.\Deque.h	/^        DequeConstIterator(const Deque<T, inlineCapacity>* deque, size_t index) : Base(deque, index) { }$/;"	f	class:WTF::DequeConstIterator	access:public	signature:(const Deque<T, inlineCapacity>* deque, size_t index)
WTF::DequeConstIterator::DequeConstIterator	.\Deque.h	/^        DequeConstIterator(const Iterator& other) : Base(other) { }$/;"	f	class:WTF::DequeConstIterator	access:public	signature:(const Iterator& other)
WTF::DequeConstIterator::DequeConstIterator	.\Deque.h	/^        DequeConstIterator(const NonConstIterator& other) : Base(other) { }$/;"	f	class:WTF::DequeConstIterator	access:public	signature:(const NonConstIterator& other)
WTF::DequeConstIterator::Iterator	.\Deque.h	/^        typedef DequeConstIterator<T, inlineCapacity> Iterator;$/;"	t	class:WTF::DequeConstIterator	access:private
WTF::DequeConstIterator::NonConstIterator	.\Deque.h	/^        typedef DequeIterator<T, inlineCapacity> NonConstIterator;$/;"	t	class:WTF::DequeConstIterator	access:private
WTF::DequeConstIterator::operator !=	.\Deque.h	/^        bool operator!=(const Iterator& other) const { return !Base::isEqual(other); }$/;"	f	class:WTF::DequeConstIterator	access:public	signature:(const Iterator& other) const
WTF::DequeConstIterator::operator *	.\Deque.h	/^        const T& operator*() const { return *Base::after(); }$/;"	f	class:WTF::DequeConstIterator	access:public	signature:() const
WTF::DequeConstIterator::operator ++	.\Deque.h	/^        Iterator& operator++() { Base::increment(); return *this; }$/;"	f	class:WTF::DequeConstIterator	access:public	signature:()
WTF::DequeConstIterator::operator --	.\Deque.h	/^        Iterator& operator--() { Base::decrement(); return *this; }$/;"	f	class:WTF::DequeConstIterator	access:public	signature:()
WTF::DequeConstIterator::operator ->	.\Deque.h	/^        const T* operator->() const { return Base::after(); }$/;"	f	class:WTF::DequeConstIterator	access:public	signature:() const
WTF::DequeConstIterator::operator =	.\Deque.h	/^        DequeConstIterator& operator=(const Iterator& other) { Base::assign(other); return *this; }$/;"	f	class:WTF::DequeConstIterator	access:public	signature:(const Iterator& other)
WTF::DequeConstIterator::operator =	.\Deque.h	/^        DequeConstIterator& operator=(const NonConstIterator& other) { Base::assign(other); return *this; }$/;"	f	class:WTF::DequeConstIterator	access:public	signature:(const NonConstIterator& other)
WTF::DequeConstIterator::operator ==	.\Deque.h	/^        bool operator==(const Iterator& other) const { return Base::isEqual(other); }$/;"	f	class:WTF::DequeConstIterator	access:public	signature:(const Iterator& other) const
WTF::DequeConstReverseIterator	.\Deque.h	/^    class DequeConstReverseIterator : public DequeIteratorBase<T, inlineCapacity> {$/;"	c	namespace:WTF	inherits:DequeIteratorBase
WTF::DequeConstReverseIterator::Base	.\Deque.h	/^        typedef DequeIteratorBase<T, inlineCapacity> Base;$/;"	t	class:WTF::DequeConstReverseIterator	access:private
WTF::DequeConstReverseIterator::DequeConstReverseIterator	.\Deque.h	/^        DequeConstReverseIterator(const Deque<T, inlineCapacity>* deque, size_t index) : Base(deque, index) { }$/;"	f	class:WTF::DequeConstReverseIterator	access:public	signature:(const Deque<T, inlineCapacity>* deque, size_t index)
WTF::DequeConstReverseIterator::DequeConstReverseIterator	.\Deque.h	/^        DequeConstReverseIterator(const Iterator& other) : Base(other) { }$/;"	f	class:WTF::DequeConstReverseIterator	access:public	signature:(const Iterator& other)
WTF::DequeConstReverseIterator::DequeConstReverseIterator	.\Deque.h	/^        DequeConstReverseIterator(const NonConstIterator& other) : Base(other) { }$/;"	f	class:WTF::DequeConstReverseIterator	access:public	signature:(const NonConstIterator& other)
WTF::DequeConstReverseIterator::Iterator	.\Deque.h	/^        typedef DequeConstReverseIterator<T, inlineCapacity> Iterator;$/;"	t	class:WTF::DequeConstReverseIterator	access:private
WTF::DequeConstReverseIterator::NonConstIterator	.\Deque.h	/^        typedef DequeReverseIterator<T, inlineCapacity> NonConstIterator;$/;"	t	class:WTF::DequeConstReverseIterator	access:private
WTF::DequeConstReverseIterator::operator !=	.\Deque.h	/^        bool operator!=(const Iterator& other) const { return !Base::isEqual(other); }$/;"	f	class:WTF::DequeConstReverseIterator	access:public	signature:(const Iterator& other) const
WTF::DequeConstReverseIterator::operator *	.\Deque.h	/^        const T& operator*() const { return *Base::before(); }$/;"	f	class:WTF::DequeConstReverseIterator	access:public	signature:() const
WTF::DequeConstReverseIterator::operator ++	.\Deque.h	/^        Iterator& operator++() { Base::decrement(); return *this; }$/;"	f	class:WTF::DequeConstReverseIterator	access:public	signature:()
WTF::DequeConstReverseIterator::operator --	.\Deque.h	/^        Iterator& operator--() { Base::increment(); return *this; }$/;"	f	class:WTF::DequeConstReverseIterator	access:public	signature:()
WTF::DequeConstReverseIterator::operator ->	.\Deque.h	/^        const T* operator->() const { return Base::before(); }$/;"	f	class:WTF::DequeConstReverseIterator	access:public	signature:() const
WTF::DequeConstReverseIterator::operator =	.\Deque.h	/^        DequeConstReverseIterator& operator=(const Iterator& other) { Base::assign(other); return *this; }$/;"	f	class:WTF::DequeConstReverseIterator	access:public	signature:(const Iterator& other)
WTF::DequeConstReverseIterator::operator =	.\Deque.h	/^        DequeConstReverseIterator& operator=(const NonConstIterator& other) { Base::assign(other); return *this; }$/;"	f	class:WTF::DequeConstReverseIterator	access:public	signature:(const NonConstIterator& other)
WTF::DequeConstReverseIterator::operator ==	.\Deque.h	/^        bool operator==(const Iterator& other) const { return Base::isEqual(other); }$/;"	f	class:WTF::DequeConstReverseIterator	access:public	signature:(const Iterator& other) const
WTF::DequeIterator	.\Deque.h	/^    class DequeIterator : public DequeIteratorBase<T, inlineCapacity> {$/;"	c	namespace:WTF	inherits:DequeIteratorBase
WTF::DequeIterator::Base	.\Deque.h	/^        typedef DequeIteratorBase<T, inlineCapacity> Base;$/;"	t	class:WTF::DequeIterator	access:private
WTF::DequeIterator::DequeIterator	.\Deque.h	/^        DequeIterator(Deque<T, inlineCapacity>* deque, size_t index) : Base(deque, index) { }$/;"	f	class:WTF::DequeIterator	access:public	signature:(Deque<T, inlineCapacity>* deque, size_t index)
WTF::DequeIterator::DequeIterator	.\Deque.h	/^        DequeIterator(const Iterator& other) : Base(other) { }$/;"	f	class:WTF::DequeIterator	access:public	signature:(const Iterator& other)
WTF::DequeIterator::Iterator	.\Deque.h	/^        typedef DequeIterator<T, inlineCapacity> Iterator;$/;"	t	class:WTF::DequeIterator	access:private
WTF::DequeIterator::operator !=	.\Deque.h	/^        bool operator!=(const Iterator& other) const { return !Base::isEqual(other); }$/;"	f	class:WTF::DequeIterator	access:public	signature:(const Iterator& other) const
WTF::DequeIterator::operator *	.\Deque.h	/^        T& operator*() const { return *Base::after(); }$/;"	f	class:WTF::DequeIterator	access:public	signature:() const
WTF::DequeIterator::operator ++	.\Deque.h	/^        Iterator& operator++() { Base::increment(); return *this; }$/;"	f	class:WTF::DequeIterator	access:public	signature:()
WTF::DequeIterator::operator --	.\Deque.h	/^        Iterator& operator--() { Base::decrement(); return *this; }$/;"	f	class:WTF::DequeIterator	access:public	signature:()
WTF::DequeIterator::operator ->	.\Deque.h	/^        T* operator->() const { return Base::after(); }$/;"	f	class:WTF::DequeIterator	access:public	signature:() const
WTF::DequeIterator::operator =	.\Deque.h	/^        DequeIterator& operator=(const Iterator& other) { Base::assign(other); return *this; }$/;"	f	class:WTF::DequeIterator	access:public	signature:(const Iterator& other)
WTF::DequeIterator::operator ==	.\Deque.h	/^        bool operator==(const Iterator& other) const { return Base::isEqual(other); }$/;"	f	class:WTF::DequeIterator	access:public	signature:(const Iterator& other) const
WTF::DequeIteratorBase	.\Deque.h	/^    class DequeIteratorBase {$/;"	c	namespace:WTF
WTF::DequeIteratorBase::Base	.\Deque.h	/^        typedef DequeIteratorBase<T, inlineCapacity> Base;$/;"	t	class:WTF::DequeIteratorBase	access:private
WTF::DequeIteratorBase::DequeIteratorBase	.\Deque.h	/^        DequeIteratorBase();$/;"	p	class:WTF::DequeIteratorBase	access:protected	signature:()
WTF::DequeIteratorBase::DequeIteratorBase	.\Deque.h	/^        DequeIteratorBase(const Base&);$/;"	p	class:WTF::DequeIteratorBase	access:protected	signature:(const Base&)
WTF::DequeIteratorBase::DequeIteratorBase	.\Deque.h	/^        DequeIteratorBase(const Deque<T, inlineCapacity>*, size_t);$/;"	p	class:WTF::DequeIteratorBase	access:protected	signature:(const Deque<T, inlineCapacity>*, size_t)
WTF::DequeIteratorBase::DequeIteratorBase	.\Deque.h	/^    inline DequeIteratorBase<T, inlineCapacity>::DequeIteratorBase()$/;"	f	class:WTF::DequeIteratorBase	signature:()
WTF::DequeIteratorBase::DequeIteratorBase	.\Deque.h	/^    inline DequeIteratorBase<T, inlineCapacity>::DequeIteratorBase(const Base& other)$/;"	f	class:WTF::DequeIteratorBase	signature:(const Base& other)
WTF::DequeIteratorBase::DequeIteratorBase	.\Deque.h	/^    inline DequeIteratorBase<T, inlineCapacity>::DequeIteratorBase(const Deque<T, inlineCapacity>* deque, size_t index)$/;"	f	class:WTF::DequeIteratorBase	signature:(const Deque<T, inlineCapacity>* deque, size_t index)
WTF::DequeIteratorBase::addToIteratorsList	.\Deque.h	/^        void addToIteratorsList();$/;"	p	class:WTF::DequeIteratorBase	access:private	signature:()
WTF::DequeIteratorBase::addToIteratorsList	.\Deque.h	/^    template<typename T, size_t inlineCapacity> inline void DequeIteratorBase<T, inlineCapacity>::addToIteratorsList() { }$/;"	f	class:WTF::DequeIteratorBase	signature:()
WTF::DequeIteratorBase::addToIteratorsList	.\Deque.h	/^    void DequeIteratorBase<T, inlineCapacity>::addToIteratorsList()$/;"	f	class:WTF::DequeIteratorBase	signature:()
WTF::DequeIteratorBase::after	.\Deque.h	/^        T* after() const;$/;"	p	class:WTF::DequeIteratorBase	access:protected	signature:() const
WTF::DequeIteratorBase::after	.\Deque.h	/^    inline T* DequeIteratorBase<T, inlineCapacity>::after() const$/;"	f	class:WTF::DequeIteratorBase	signature:() const
WTF::DequeIteratorBase::assign	.\Deque.h	/^        void assign(const Base& other) { *this = other; }$/;"	f	class:WTF::DequeIteratorBase	access:protected	signature:(const Base& other)
WTF::DequeIteratorBase::before	.\Deque.h	/^        T* before() const;$/;"	p	class:WTF::DequeIteratorBase	access:protected	signature:() const
WTF::DequeIteratorBase::before	.\Deque.h	/^    inline T* DequeIteratorBase<T, inlineCapacity>::before() const$/;"	f	class:WTF::DequeIteratorBase	signature:() const
WTF::DequeIteratorBase::checkValidity	.\Deque.h	/^        void checkValidity() const;$/;"	p	class:WTF::DequeIteratorBase	access:private	signature:() const
WTF::DequeIteratorBase::checkValidity	.\Deque.h	/^        void checkValidity(const Base&) const;$/;"	p	class:WTF::DequeIteratorBase	access:private	signature:(const Base&) const
WTF::DequeIteratorBase::checkValidity	.\Deque.h	/^    template<typename T, size_t inlineCapacity> inline void DequeIteratorBase<T, inlineCapacity>::checkValidity() const { }$/;"	f	class:WTF::DequeIteratorBase	signature:() const
WTF::DequeIteratorBase::checkValidity	.\Deque.h	/^    template<typename T, size_t inlineCapacity> inline void DequeIteratorBase<T, inlineCapacity>::checkValidity(const DequeIteratorBase<T, inlineCapacity>&) const { }$/;"	f	class:WTF::DequeIteratorBase	signature:(const DequeIteratorBase<T, inlineCapacity>&) const
WTF::DequeIteratorBase::checkValidity	.\Deque.h	/^    void DequeIteratorBase<T, inlineCapacity>::checkValidity() const$/;"	f	class:WTF::DequeIteratorBase	signature:() const
WTF::DequeIteratorBase::checkValidity	.\Deque.h	/^    void DequeIteratorBase<T, inlineCapacity>::checkValidity(const Base& other) const$/;"	f	class:WTF::DequeIteratorBase	signature:(const Base& other) const
WTF::DequeIteratorBase::decrement	.\Deque.h	/^        void decrement();$/;"	p	class:WTF::DequeIteratorBase	access:protected	signature:()
WTF::DequeIteratorBase::decrement	.\Deque.h	/^    inline void DequeIteratorBase<T, inlineCapacity>::decrement()$/;"	f	class:WTF::DequeIteratorBase	signature:()
WTF::DequeIteratorBase::increment	.\Deque.h	/^        void increment();$/;"	p	class:WTF::DequeIteratorBase	access:protected	signature:()
WTF::DequeIteratorBase::increment	.\Deque.h	/^    inline void DequeIteratorBase<T, inlineCapacity>::increment()$/;"	f	class:WTF::DequeIteratorBase	signature:()
WTF::DequeIteratorBase::isEqual	.\Deque.h	/^        bool isEqual(const Base&) const;$/;"	p	class:WTF::DequeIteratorBase	access:protected	signature:(const Base&) const
WTF::DequeIteratorBase::isEqual	.\Deque.h	/^    inline bool DequeIteratorBase<T, inlineCapacity>::isEqual(const Base& other) const$/;"	f	class:WTF::DequeIteratorBase	signature:(const Base& other) const
WTF::DequeIteratorBase::m_deque	.\Deque.h	/^        Deque<T, inlineCapacity>* m_deque;$/;"	m	class:WTF::DequeIteratorBase	access:private
WTF::DequeIteratorBase::m_index	.\Deque.h	/^        size_t m_index;$/;"	m	class:WTF::DequeIteratorBase	access:private
WTF::DequeIteratorBase::m_next	.\Deque.h	/^        mutable DequeIteratorBase* m_next;$/;"	m	class:WTF::DequeIteratorBase	access:private
WTF::DequeIteratorBase::m_previous	.\Deque.h	/^        mutable DequeIteratorBase* m_previous;$/;"	m	class:WTF::DequeIteratorBase	access:private
WTF::DequeIteratorBase::operator =	.\Deque.h	/^        Base& operator=(const Base&);$/;"	p	class:WTF::DequeIteratorBase	access:protected	signature:(const Base&)
WTF::DequeIteratorBase::operator =	.\Deque.h	/^    inline DequeIteratorBase<T, inlineCapacity>& DequeIteratorBase<T, inlineCapacity>::operator=(const Base& other)$/;"	f	class:WTF::DequeIteratorBase	signature:(const Base& other)
WTF::DequeIteratorBase::removeFromIteratorsList	.\Deque.h	/^        void removeFromIteratorsList();$/;"	p	class:WTF::DequeIteratorBase	access:private	signature:()
WTF::DequeIteratorBase::removeFromIteratorsList	.\Deque.h	/^    template<typename T, size_t inlineCapacity> inline void DequeIteratorBase<T, inlineCapacity>::removeFromIteratorsList() { }$/;"	f	class:WTF::DequeIteratorBase	signature:()
WTF::DequeIteratorBase::removeFromIteratorsList	.\Deque.h	/^    void DequeIteratorBase<T, inlineCapacity>::removeFromIteratorsList()$/;"	f	class:WTF::DequeIteratorBase	signature:()
WTF::DequeIteratorBase::~DequeIteratorBase	.\Deque.h	/^        ~DequeIteratorBase();$/;"	p	class:WTF::DequeIteratorBase	access:protected	signature:()
WTF::DequeIteratorBase::~DequeIteratorBase	.\Deque.h	/^    inline DequeIteratorBase<T, inlineCapacity>::~DequeIteratorBase()$/;"	f	class:WTF::DequeIteratorBase	signature:()
WTF::DequeReverseIterator	.\Deque.h	/^    class DequeReverseIterator : public DequeIteratorBase<T, inlineCapacity> {$/;"	c	namespace:WTF	inherits:DequeIteratorBase
WTF::DequeReverseIterator::Base	.\Deque.h	/^        typedef DequeIteratorBase<T, inlineCapacity> Base;$/;"	t	class:WTF::DequeReverseIterator	access:private
WTF::DequeReverseIterator::DequeReverseIterator	.\Deque.h	/^        DequeReverseIterator(const Deque<T, inlineCapacity>* deque, size_t index) : Base(deque, index) { }$/;"	f	class:WTF::DequeReverseIterator	access:public	signature:(const Deque<T, inlineCapacity>* deque, size_t index)
WTF::DequeReverseIterator::DequeReverseIterator	.\Deque.h	/^        DequeReverseIterator(const Iterator& other) : Base(other) { }$/;"	f	class:WTF::DequeReverseIterator	access:public	signature:(const Iterator& other)
WTF::DequeReverseIterator::Iterator	.\Deque.h	/^        typedef DequeReverseIterator<T, inlineCapacity> Iterator;$/;"	t	class:WTF::DequeReverseIterator	access:private
WTF::DequeReverseIterator::operator !=	.\Deque.h	/^        bool operator!=(const Iterator& other) const { return !Base::isEqual(other); }$/;"	f	class:WTF::DequeReverseIterator	access:public	signature:(const Iterator& other) const
WTF::DequeReverseIterator::operator *	.\Deque.h	/^        T& operator*() const { return *Base::before(); }$/;"	f	class:WTF::DequeReverseIterator	access:public	signature:() const
WTF::DequeReverseIterator::operator ++	.\Deque.h	/^        Iterator& operator++() { Base::decrement(); return *this; }$/;"	f	class:WTF::DequeReverseIterator	access:public	signature:()
WTF::DequeReverseIterator::operator --	.\Deque.h	/^        Iterator& operator--() { Base::increment(); return *this; }$/;"	f	class:WTF::DequeReverseIterator	access:public	signature:()
WTF::DequeReverseIterator::operator ->	.\Deque.h	/^        T* operator->() const { return Base::before(); }$/;"	f	class:WTF::DequeReverseIterator	access:public	signature:() const
WTF::DequeReverseIterator::operator =	.\Deque.h	/^        DequeReverseIterator& operator=(const Iterator& other) { Base::assign(other); return *this; }$/;"	f	class:WTF::DequeReverseIterator	access:public	signature:(const Iterator& other)
WTF::DequeReverseIterator::operator ==	.\Deque.h	/^        bool operator==(const Iterator& other) const { return Base::isEqual(other); }$/;"	f	class:WTF::DequeReverseIterator	access:public	signature:(const Iterator& other) const
WTF::DisallowTrailingJunk	.\dtoa.h	/^enum AllowTrailingJunkTag { DisallowTrailingJunk = 0, AllowTrailingJunk };$/;"	e	enum:WTF::AllowTrailingJunkTag
WTF::DisallowTrailingSpaces	.\dtoa.h	/^enum AllowTrailingSpacesTag { DisallowTrailingSpaces = 0, AllowTrailingSpaces };$/;"	e	enum:WTF::AllowTrailingSpacesTag
WTF::DoSampledAllocation	.\FastMalloc.cpp	/^static Span* DoSampledAllocation(size_t size) {$/;"	f	namespace:WTF	file:	signature:(size_t size)
WTF::DoublyLinkedList	.\DoublyLinkedList.h	/^template<typename T> class DoublyLinkedList {$/;"	c	namespace:WTF
WTF::DoublyLinkedList::DoublyLinkedList	.\DoublyLinkedList.h	/^    DoublyLinkedList();$/;"	p	class:WTF::DoublyLinkedList	access:public	signature:()
WTF::DoublyLinkedList::DoublyLinkedList	.\DoublyLinkedList.h	/^template<typename T> inline DoublyLinkedList<T>::DoublyLinkedList()$/;"	f	class:WTF::DoublyLinkedList	signature:()
WTF::DoublyLinkedList::append	.\DoublyLinkedList.h	/^    void append(T*);$/;"	p	class:WTF::DoublyLinkedList	access:public	signature:(T*)
WTF::DoublyLinkedList::append	.\DoublyLinkedList.h	/^template<typename T> inline void DoublyLinkedList<T>::append(T* node)$/;"	f	class:WTF::DoublyLinkedList	signature:(T* node)
WTF::DoublyLinkedList::clear	.\DoublyLinkedList.h	/^    void clear();$/;"	p	class:WTF::DoublyLinkedList	access:public	signature:()
WTF::DoublyLinkedList::clear	.\DoublyLinkedList.h	/^template<typename T> inline void DoublyLinkedList<T>::clear()$/;"	f	class:WTF::DoublyLinkedList	signature:()
WTF::DoublyLinkedList::head	.\DoublyLinkedList.h	/^    T* head() const;$/;"	p	class:WTF::DoublyLinkedList	access:public	signature:() const
WTF::DoublyLinkedList::head	.\DoublyLinkedList.h	/^template<typename T> inline T* DoublyLinkedList<T>::head() const$/;"	f	class:WTF::DoublyLinkedList	signature:() const
WTF::DoublyLinkedList::isEmpty	.\DoublyLinkedList.h	/^    bool isEmpty() const;$/;"	p	class:WTF::DoublyLinkedList	access:public	signature:() const
WTF::DoublyLinkedList::isEmpty	.\DoublyLinkedList.h	/^template<typename T> inline bool DoublyLinkedList<T>::isEmpty() const$/;"	f	class:WTF::DoublyLinkedList	signature:() const
WTF::DoublyLinkedList::m_head	.\DoublyLinkedList.h	/^    T* m_head;$/;"	m	class:WTF::DoublyLinkedList	access:private
WTF::DoublyLinkedList::m_tail	.\DoublyLinkedList.h	/^    T* m_tail;$/;"	m	class:WTF::DoublyLinkedList	access:private
WTF::DoublyLinkedList::push	.\DoublyLinkedList.h	/^    void push(T*);$/;"	p	class:WTF::DoublyLinkedList	access:public	signature:(T*)
WTF::DoublyLinkedList::push	.\DoublyLinkedList.h	/^template<typename T> inline void DoublyLinkedList<T>::push(T* node)$/;"	f	class:WTF::DoublyLinkedList	signature:(T* node)
WTF::DoublyLinkedList::remove	.\DoublyLinkedList.h	/^    void remove(T*);$/;"	p	class:WTF::DoublyLinkedList	access:public	signature:(T*)
WTF::DoublyLinkedList::remove	.\DoublyLinkedList.h	/^template<typename T> inline void DoublyLinkedList<T>::remove(T* node)$/;"	f	class:WTF::DoublyLinkedList	signature:(T* node)
WTF::DoublyLinkedList::removeHead	.\DoublyLinkedList.h	/^    T* removeHead();$/;"	p	class:WTF::DoublyLinkedList	access:public	signature:()
WTF::DoublyLinkedList::removeHead	.\DoublyLinkedList.h	/^template<typename T> inline T* DoublyLinkedList<T>::removeHead()$/;"	f	class:WTF::DoublyLinkedList	signature:()
WTF::DoublyLinkedList::size	.\DoublyLinkedList.h	/^    size_t size() const; \/\/ This is O(n).$/;"	p	class:WTF::DoublyLinkedList	access:public	signature:() const
WTF::DoublyLinkedList::size	.\DoublyLinkedList.h	/^template<typename T> inline size_t DoublyLinkedList<T>::size() const$/;"	f	class:WTF::DoublyLinkedList	signature:() const
WTF::DoublyLinkedList::tail	.\DoublyLinkedList.h	/^    T* tail() const;$/;"	p	class:WTF::DoublyLinkedList	access:public	signature:() const
WTF::DoublyLinkedList::tail	.\DoublyLinkedList.h	/^template<typename T> inline T* DoublyLinkedList<T>::tail() const$/;"	f	class:WTF::DoublyLinkedList	signature:() const
WTF::DoublyLinkedListNode	.\DoublyLinkedList.h	/^template<typename T> class DoublyLinkedListNode {$/;"	c	namespace:WTF
WTF::DoublyLinkedListNode::DoublyLinkedListNode	.\DoublyLinkedList.h	/^    DoublyLinkedListNode();$/;"	p	class:WTF::DoublyLinkedListNode	access:public	signature:()
WTF::DoublyLinkedListNode::DoublyLinkedListNode	.\DoublyLinkedList.h	/^template<typename T> inline DoublyLinkedListNode<T>::DoublyLinkedListNode()$/;"	f	class:WTF::DoublyLinkedListNode	signature:()
WTF::DoublyLinkedListNode::next	.\DoublyLinkedList.h	/^    T* next() const;$/;"	p	class:WTF::DoublyLinkedListNode	access:public	signature:() const
WTF::DoublyLinkedListNode::next	.\DoublyLinkedList.h	/^template<typename T> inline T* DoublyLinkedListNode<T>::next() const$/;"	f	class:WTF::DoublyLinkedListNode	signature:() const
WTF::DoublyLinkedListNode::prev	.\DoublyLinkedList.h	/^    T* prev() const;$/;"	p	class:WTF::DoublyLinkedListNode	access:public	signature:() const
WTF::DoublyLinkedListNode::prev	.\DoublyLinkedList.h	/^template<typename T> inline T* DoublyLinkedListNode<T>::prev() const$/;"	f	class:WTF::DoublyLinkedListNode	signature:() const
WTF::DoublyLinkedListNode::setNext	.\DoublyLinkedList.h	/^    void setNext(T*);$/;"	p	class:WTF::DoublyLinkedListNode	access:public	signature:(T*)
WTF::DoublyLinkedListNode::setNext	.\DoublyLinkedList.h	/^template<typename T> inline void DoublyLinkedListNode<T>::setNext(T* next)$/;"	f	class:WTF::DoublyLinkedListNode	signature:(T* next)
WTF::DoublyLinkedListNode::setPrev	.\DoublyLinkedList.h	/^    void setPrev(T*);$/;"	p	class:WTF::DoublyLinkedListNode	access:public	signature:(T*)
WTF::DoublyLinkedListNode::setPrev	.\DoublyLinkedList.h	/^template<typename T> inline void DoublyLinkedListNode<T>::setPrev(T* prev)$/;"	f	class:WTF::DoublyLinkedListNode	signature:(T* prev)
WTF::DtoaBuffer	.\dtoa.h	/^typedef char DtoaBuffer[80];$/;"	t	namespace:WTF
WTF::DumpStackTraces	.\FastMalloc.cpp	/^static void** DumpStackTraces() {$/;"	f	namespace:WTF	file:	signature:()
WTF::DumpStats	.\FastMalloc.cpp	/^static void DumpStats(TCMalloc_Printer* out, int level) {$/;"	f	namespace:WTF	file:	signature:(TCMalloc_Printer* out, int level)
WTF::Encoder	.\Encoder.h	/^class Encoder {$/;"	c	namespace:WTF
WTF::Encoder::Encoder	.\Encoder.h	/^    Encoder() { }$/;"	f	class:WTF::Encoder	access:protected	signature:()
WTF::Encoder::encodeBool	.\Encoder.h	/^    virtual void encodeBool(bool) = 0;$/;"	p	class:WTF::Encoder	access:public	signature:(bool)
WTF::Encoder::encodeBytes	.\Encoder.h	/^    virtual void encodeBytes(const uint8_t*, size_t) = 0;$/;"	p	class:WTF::Encoder	access:public	signature:(const uint8_t*, size_t)
WTF::Encoder::encodeDouble	.\Encoder.h	/^    virtual void encodeDouble(double) = 0;$/;"	p	class:WTF::Encoder	access:public	signature:(double)
WTF::Encoder::encodeFloat	.\Encoder.h	/^    virtual void encodeFloat(float) = 0;$/;"	p	class:WTF::Encoder	access:public	signature:(float)
WTF::Encoder::encodeInt32	.\Encoder.h	/^    virtual void encodeInt32(int32_t) = 0;$/;"	p	class:WTF::Encoder	access:public	signature:(int32_t)
WTF::Encoder::encodeInt64	.\Encoder.h	/^    virtual void encodeInt64(int64_t) = 0;$/;"	p	class:WTF::Encoder	access:public	signature:(int64_t)
WTF::Encoder::encodeString	.\Encoder.h	/^    virtual void encodeString(const String&) = 0;$/;"	p	class:WTF::Encoder	access:public	signature:(const String&)
WTF::Encoder::encodeUInt32	.\Encoder.h	/^    virtual void encodeUInt32(uint32_t) = 0;$/;"	p	class:WTF::Encoder	access:public	signature:(uint32_t)
WTF::Encoder::encodeUInt64	.\Encoder.h	/^    virtual void encodeUInt64(uint64_t) = 0;$/;"	p	class:WTF::Encoder	access:public	signature:(uint64_t)
WTF::Encoder::~Encoder	.\Encoder.h	/^    virtual ~Encoder() { }$/;"	f	class:WTF::Encoder	access:protected	signature:()
WTF::Event	.\FastMalloc.cpp	/^void Event(Span* span, char op, int v = 0) {$/;"	f	namespace:WTF	signature:(Span* span, char op, int v = 0)
WTF::ExtractStats	.\FastMalloc.cpp	/^static void ExtractStats(TCMallocStats* r, uint64_t* class_count) {$/;"	f	namespace:WTF	file:	signature:(TCMallocStats* r, uint64_t* class_count)
WTF::FastMallocStatistics	.\FastMalloc.h	/^    struct FastMallocStatistics {$/;"	s	namespace:WTF
WTF::FastMallocStatistics::committedVMBytes	.\FastMalloc.h	/^        size_t committedVMBytes;$/;"	m	struct:WTF::FastMallocStatistics	access:public
WTF::FastMallocStatistics::freeListBytes	.\FastMalloc.h	/^        size_t freeListBytes;$/;"	m	struct:WTF::FastMallocStatistics	access:public
WTF::FastMallocStatistics::reservedVMBytes	.\FastMalloc.h	/^        size_t reservedVMBytes;$/;"	m	struct:WTF::FastMallocStatistics	access:public
WTF::FastMallocZone	.\FastMalloc.cpp	/^class FastMallocZone {$/;"	c	namespace:WTF	file:
WTF::FastMallocZone::FastMallocZone	.\FastMalloc.cpp	/^    FastMallocZone(TCMalloc_PageHeap*, TCMalloc_ThreadCache**, TCMalloc_Central_FreeListPadded*, PageHeapAllocator<Span>*, PageHeapAllocator<TCMalloc_ThreadCache>*);$/;"	p	class:WTF::FastMallocZone	file:	access:private	signature:(TCMalloc_PageHeap*, TCMalloc_ThreadCache**, TCMalloc_Central_FreeListPadded*, PageHeapAllocator<Span>*, PageHeapAllocator<TCMalloc_ThreadCache>*)
WTF::FastMallocZone::FastMallocZone	.\FastMalloc.cpp	/^FastMallocZone::FastMallocZone(TCMalloc_PageHeap* pageHeap, TCMalloc_ThreadCache** threadHeaps, TCMalloc_Central_FreeListPadded* centralCaches, PageHeapAllocator<Span>* spanAllocator, PageHeapAllocator<TCMalloc_ThreadCache>* pageHeapAllocator)$/;"	f	class:WTF::FastMallocZone	signature:(TCMalloc_PageHeap* pageHeap, TCMalloc_ThreadCache** threadHeaps, TCMalloc_Central_FreeListPadded* centralCaches, PageHeapAllocator<Span>* spanAllocator, PageHeapAllocator<TCMalloc_ThreadCache>* pageHeapAllocator)
WTF::FastMallocZone::check	.\FastMalloc.cpp	/^    static boolean_t check(malloc_zone_t*) { return true; }$/;"	f	class:WTF::FastMallocZone	access:public	signature:(malloc_zone_t*)
WTF::FastMallocZone::enumerate	.\FastMalloc.cpp	/^    static kern_return_t enumerate(task_t, void*, unsigned typeMmask, vm_address_t zoneAddress, memory_reader_t, vm_range_recorder_t);$/;"	p	class:WTF::FastMallocZone	file:	access:public	signature:(task_t, void*, unsigned typeMmask, vm_address_t zoneAddress, memory_reader_t, vm_range_recorder_t)
WTF::FastMallocZone::enumerate	.\FastMalloc.cpp	/^kern_return_t FastMallocZone::enumerate(task_t task, void* context, unsigned typeMask, vm_address_t zoneAddress, memory_reader_t reader, vm_range_recorder_t recorder)$/;"	f	class:WTF::FastMallocZone	signature:(task_t task, void* context, unsigned typeMask, vm_address_t zoneAddress, memory_reader_t reader, vm_range_recorder_t recorder)
WTF::FastMallocZone::forceLock	.\FastMalloc.cpp	/^    static void forceLock(malloc_zone_t*) { }$/;"	f	class:WTF::FastMallocZone	access:public	signature:(malloc_zone_t*)
WTF::FastMallocZone::forceUnlock	.\FastMalloc.cpp	/^    static void forceUnlock(malloc_zone_t*) { }$/;"	f	class:WTF::FastMallocZone	access:public	signature:(malloc_zone_t*)
WTF::FastMallocZone::goodSize	.\FastMalloc.cpp	/^    static size_t goodSize(malloc_zone_t*, size_t size) { return size; }$/;"	f	class:WTF::FastMallocZone	access:public	signature:(malloc_zone_t*, size_t size)
WTF::FastMallocZone::init	.\FastMalloc.cpp	/^    static void init();$/;"	p	class:WTF::FastMallocZone	file:	access:public	signature:()
WTF::FastMallocZone::init	.\FastMalloc.cpp	/^void FastMallocZone::init()$/;"	f	class:WTF::FastMallocZone	signature:()
WTF::FastMallocZone::log	.\FastMalloc.cpp	/^    static void log(malloc_zone_t*, void*) { }$/;"	f	class:WTF::FastMallocZone	access:public	signature:(malloc_zone_t*, void*)
WTF::FastMallocZone::m_centralCaches	.\FastMalloc.cpp	/^    TCMalloc_Central_FreeListPadded* m_centralCaches;$/;"	m	class:WTF::FastMallocZone	file:	access:private
WTF::FastMallocZone::m_pageHeap	.\FastMalloc.cpp	/^    TCMalloc_PageHeap* m_pageHeap;$/;"	m	class:WTF::FastMallocZone	file:	access:private
WTF::FastMallocZone::m_pageHeapAllocator	.\FastMalloc.cpp	/^    PageHeapAllocator<TCMalloc_ThreadCache>* m_pageHeapAllocator;$/;"	m	class:WTF::FastMallocZone	file:	access:private
WTF::FastMallocZone::m_spanAllocator	.\FastMalloc.cpp	/^    PageHeapAllocator<Span>* m_spanAllocator;$/;"	m	class:WTF::FastMallocZone	file:	access:private
WTF::FastMallocZone::m_threadHeaps	.\FastMalloc.cpp	/^    TCMalloc_ThreadCache** m_threadHeaps;$/;"	m	class:WTF::FastMallocZone	file:	access:private
WTF::FastMallocZone::m_zone	.\FastMalloc.cpp	/^    malloc_zone_t m_zone;$/;"	m	class:WTF::FastMallocZone	file:	access:private
WTF::FastMallocZone::print	.\FastMalloc.cpp	/^    static void  print(malloc_zone_t*, boolean_t) { }$/;"	f	class:WTF::FastMallocZone	access:public	signature:(malloc_zone_t*, boolean_t)
WTF::FastMallocZone::size	.\FastMalloc.cpp	/^    static size_t size(malloc_zone_t*, const void*);$/;"	p	class:WTF::FastMallocZone	file:	access:private	signature:(malloc_zone_t*, const void*)
WTF::FastMallocZone::size	.\FastMalloc.cpp	/^size_t FastMallocZone::size(malloc_zone_t*, const void*)$/;"	f	class:WTF::FastMallocZone	signature:(malloc_zone_t*, const void*)
WTF::FastMallocZone::statistics	.\FastMalloc.cpp	/^    static void statistics(malloc_zone_t*, malloc_statistics_t* stats) { memset(stats, 0, sizeof(malloc_statistics_t)); }$/;"	f	class:WTF::FastMallocZone	access:public	signature:(malloc_zone_t*, malloc_statistics_t* stats)
WTF::FastMallocZone::zoneCalloc	.\FastMalloc.cpp	/^    static void* zoneCalloc(malloc_zone_t*, size_t numItems, size_t size);$/;"	p	class:WTF::FastMallocZone	file:	access:private	signature:(malloc_zone_t*, size_t numItems, size_t size)
WTF::FastMallocZone::zoneCalloc	.\FastMalloc.cpp	/^void* FastMallocZone::zoneCalloc(malloc_zone_t*, size_t, size_t)$/;"	f	class:WTF::FastMallocZone	signature:(malloc_zone_t*, size_t, size_t)
WTF::FastMallocZone::zoneDestroy	.\FastMalloc.cpp	/^    static void zoneDestroy(malloc_zone_t*) { }$/;"	f	class:WTF::FastMallocZone	file:	access:private	signature:(malloc_zone_t*)
WTF::FastMallocZone::zoneFree	.\FastMalloc.cpp	/^    static void zoneFree(malloc_zone_t*, void*);$/;"	p	class:WTF::FastMallocZone	file:	access:private	signature:(malloc_zone_t*, void*)
WTF::FastMallocZone::zoneFree	.\FastMalloc.cpp	/^void FastMallocZone::zoneFree(malloc_zone_t*, void* ptr)$/;"	f	class:WTF::FastMallocZone	signature:(malloc_zone_t*, void* ptr)
WTF::FastMallocZone::zoneMalloc	.\FastMalloc.cpp	/^    static void* zoneMalloc(malloc_zone_t*, size_t);$/;"	p	class:WTF::FastMallocZone	file:	access:private	signature:(malloc_zone_t*, size_t)
WTF::FastMallocZone::zoneMalloc	.\FastMalloc.cpp	/^void* FastMallocZone::zoneMalloc(malloc_zone_t*, size_t)$/;"	f	class:WTF::FastMallocZone	signature:(malloc_zone_t*, size_t)
WTF::FastMallocZone::zoneRealloc	.\FastMalloc.cpp	/^    static void* zoneRealloc(malloc_zone_t*, void*, size_t);$/;"	p	class:WTF::FastMallocZone	file:	access:private	signature:(malloc_zone_t*, void*, size_t)
WTF::FastMallocZone::zoneRealloc	.\FastMalloc.cpp	/^void* FastMallocZone::zoneRealloc(malloc_zone_t*, void*, size_t)$/;"	f	class:WTF::FastMallocZone	signature:(malloc_zone_t*, void*, size_t)
WTF::FastMallocZone::zoneValloc	.\FastMalloc.cpp	/^    static void* zoneValloc(malloc_zone_t*, size_t) { LOG_ERROR("valloc is not supported"); return 0; }$/;"	f	class:WTF::FastMallocZone	file:	access:private	signature:(malloc_zone_t*, size_t)
WTF::FixedArray	.\FixedArray.h	/^template <typename T, size_t Size> class FixedArray {$/;"	c	namespace:WTF
WTF::FixedArray::data	.\FixedArray.h	/^    T* data() { return m_data; }$/;"	f	class:WTF::FixedArray	access:public	signature:()
WTF::FixedArray::m_data	.\FixedArray.h	/^    T m_data[Size];$/;"	m	class:WTF::FixedArray	access:private
WTF::FixedArray::operator []	.\FixedArray.h	/^    T& operator[](size_t i)$/;"	f	class:WTF::FixedArray	access:public	signature:(size_t i)
WTF::FixedArray::operator []	.\FixedArray.h	/^    const T& operator[](size_t i) const$/;"	f	class:WTF::FixedArray	access:public	signature:(size_t i) const
WTF::FixedArray::size	.\FixedArray.h	/^    size_t size() const { return Size; }$/;"	f	class:WTF::FixedArray	access:public	signature:() const
WTF::Float32Array	.\Float32Array.h	/^class Float32Array : public TypedArrayBase<float> {$/;"	c	namespace:WTF	inherits:TypedArrayBase
WTF::Float32Array::Float32Array	.\Float32Array.h	/^    inline Float32Array(PassRefPtr<ArrayBuffer>,$/;"	p	class:WTF::Float32Array	access:private	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
WTF::Float32Array::Float32Array	.\Float32Array.h	/^Float32Array::Float32Array(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Float32Array	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
WTF::Float32Array::create	.\Float32Array.h	/^    static inline PassRefPtr<Float32Array> create(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length);$/;"	p	class:WTF::Float32Array	access:public	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
WTF::Float32Array::create	.\Float32Array.h	/^    static inline PassRefPtr<Float32Array> create(const float* array, unsigned length);$/;"	p	class:WTF::Float32Array	access:public	signature:(const float* array, unsigned length)
WTF::Float32Array::create	.\Float32Array.h	/^    static inline PassRefPtr<Float32Array> create(unsigned length);$/;"	p	class:WTF::Float32Array	access:public	signature:(unsigned length)
WTF::Float32Array::create	.\Float32Array.h	/^PassRefPtr<Float32Array> Float32Array::create(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Float32Array	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
WTF::Float32Array::create	.\Float32Array.h	/^PassRefPtr<Float32Array> Float32Array::create(const float* array, unsigned length)$/;"	f	class:WTF::Float32Array	signature:(const float* array, unsigned length)
WTF::Float32Array::create	.\Float32Array.h	/^PassRefPtr<Float32Array> Float32Array::create(unsigned length)$/;"	f	class:WTF::Float32Array	signature:(unsigned length)
WTF::Float32Array::isFloatArray	.\Float32Array.h	/^    virtual bool isFloatArray() const { return true; }$/;"	f	class:WTF::Float32Array	access:private	signature:() const
WTF::Float32Array::item	.\Float32Array.h	/^    float item(unsigned index) const$/;"	f	class:WTF::Float32Array	access:public	signature:(unsigned index) const
WTF::Float32Array::set	.\Float32Array.h	/^    bool set(TypedArrayBase<float>* array, unsigned offset) { return TypedArrayBase<float>::set(array, offset); }$/;"	f	class:WTF::Float32Array	access:public	signature:(TypedArrayBase<float>* array, unsigned offset)
WTF::Float32Array::set	.\Float32Array.h	/^    void set(unsigned index, double value)$/;"	f	class:WTF::Float32Array	access:public	signature:(unsigned index, double value)
WTF::Float32Array::subarray	.\Float32Array.h	/^    inline PassRefPtr<Float32Array> subarray(int start) const;$/;"	p	class:WTF::Float32Array	access:public	signature:(int start) const
WTF::Float32Array::subarray	.\Float32Array.h	/^    inline PassRefPtr<Float32Array> subarray(int start, int end) const;$/;"	p	class:WTF::Float32Array	access:public	signature:(int start, int end) const
WTF::Float32Array::subarray	.\Float32Array.h	/^PassRefPtr<Float32Array> Float32Array::subarray(int start) const$/;"	f	class:WTF::Float32Array	signature:(int start) const
WTF::Float32Array::subarray	.\Float32Array.h	/^PassRefPtr<Float32Array> Float32Array::subarray(int start, int end) const$/;"	f	class:WTF::Float32Array	signature:(int start, int end) const
WTF::Float64Array	.\Float64Array.h	/^class Float64Array : public TypedArrayBase<double> {$/;"	c	namespace:WTF	inherits:TypedArrayBase
WTF::Float64Array::Float64Array	.\Float64Array.h	/^    inline Float64Array(PassRefPtr<ArrayBuffer>,$/;"	p	class:WTF::Float64Array	access:private	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
WTF::Float64Array::Float64Array	.\Float64Array.h	/^Float64Array::Float64Array(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Float64Array	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
WTF::Float64Array::create	.\Float64Array.h	/^    static inline PassRefPtr<Float64Array> create(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length);$/;"	p	class:WTF::Float64Array	access:public	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
WTF::Float64Array::create	.\Float64Array.h	/^    static inline PassRefPtr<Float64Array> create(const double* array, unsigned length);$/;"	p	class:WTF::Float64Array	access:public	signature:(const double* array, unsigned length)
WTF::Float64Array::create	.\Float64Array.h	/^    static inline PassRefPtr<Float64Array> create(unsigned length);$/;"	p	class:WTF::Float64Array	access:public	signature:(unsigned length)
WTF::Float64Array::create	.\Float64Array.h	/^PassRefPtr<Float64Array> Float64Array::create(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Float64Array	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
WTF::Float64Array::create	.\Float64Array.h	/^PassRefPtr<Float64Array> Float64Array::create(const double* array, unsigned length)$/;"	f	class:WTF::Float64Array	signature:(const double* array, unsigned length)
WTF::Float64Array::create	.\Float64Array.h	/^PassRefPtr<Float64Array> Float64Array::create(unsigned length)$/;"	f	class:WTF::Float64Array	signature:(unsigned length)
WTF::Float64Array::isDoubleArray	.\Float64Array.h	/^    virtual bool isDoubleArray() const { return true; }$/;"	f	class:WTF::Float64Array	access:private	signature:() const
WTF::Float64Array::item	.\Float64Array.h	/^    double item(unsigned index) const$/;"	f	class:WTF::Float64Array	access:public	signature:(unsigned index) const
WTF::Float64Array::set	.\Float64Array.h	/^    bool set(TypedArrayBase<double>* array, unsigned offset) { return TypedArrayBase<double>::set(array, offset); }$/;"	f	class:WTF::Float64Array	access:public	signature:(TypedArrayBase<double>* array, unsigned offset)
WTF::Float64Array::set	.\Float64Array.h	/^    void set(unsigned index, double value)$/;"	f	class:WTF::Float64Array	access:public	signature:(unsigned index, double value)
WTF::Float64Array::subarray	.\Float64Array.h	/^    inline PassRefPtr<Float64Array> subarray(int start) const;$/;"	p	class:WTF::Float64Array	access:public	signature:(int start) const
WTF::Float64Array::subarray	.\Float64Array.h	/^    inline PassRefPtr<Float64Array> subarray(int start, int end) const;$/;"	p	class:WTF::Float64Array	access:public	signature:(int start, int end) const
WTF::Float64Array::subarray	.\Float64Array.h	/^PassRefPtr<Float64Array> Float64Array::subarray(int start) const$/;"	f	class:WTF::Float64Array	signature:(int start) const
WTF::Float64Array::subarray	.\Float64Array.h	/^PassRefPtr<Float64Array> Float64Array::subarray(int start, int end) const$/;"	f	class:WTF::Float64Array	signature:(int start, int end) const
WTF::FloatConversionFlags	.\text\WTFString.h	/^enum FloatConversionFlags {$/;"	g	namespace:WTF
WTF::FloatHash	.\HashFunctions.h	/^    template<typename T> struct FloatHash {$/;"	s	namespace:WTF
WTF::FloatHash::equal	.\HashFunctions.h	/^        static bool equal(T a, T b) { return a == b; }$/;"	f	struct:WTF::FloatHash	access:public	signature:(T a, T b)
WTF::FloatHash::hash	.\HashFunctions.h	/^        static unsigned hash(T key)$/;"	f	struct:WTF::FloatHash	access:public	signature:(T key)
WTF::FloatHash::safeToCompareToEmptyOrDeleted	.\HashFunctions.h	/^        static const bool safeToCompareToEmptyOrDeleted = true;$/;"	m	struct:WTF::FloatHash	access:public
WTF::FloatHashTraits	.\HashTraits.h	/^    template<typename T> struct FloatHashTraits : GenericHashTraits<T> {$/;"	s	namespace:WTF	inherits:GenericHashTraits
WTF::FloatHashTraits::constructDeletedValue	.\HashTraits.h	/^        static void constructDeletedValue(T& slot) { slot = -std::numeric_limits<T>::infinity(); }$/;"	f	struct:WTF::FloatHashTraits	access:public	signature:(T& slot)
WTF::FloatHashTraits::emptyValue	.\HashTraits.h	/^        static T emptyValue() { return std::numeric_limits<T>::infinity(); }$/;"	f	struct:WTF::FloatHashTraits	access:public	signature:()
WTF::FloatHashTraits::isDeletedValue	.\HashTraits.h	/^        static bool isDeletedValue(T value) { return value == -std::numeric_limits<T>::infinity(); }$/;"	f	struct:WTF::FloatHashTraits	access:public	signature:(T value)
WTF::FloatHashTraits::needsDestruction	.\HashTraits.h	/^        static const bool needsDestruction = false;$/;"	m	struct:WTF::FloatHashTraits	access:public
WTF::FreeObjectFinder	.\FastMalloc.cpp	/^class FreeObjectFinder {$/;"	c	namespace:WTF	file:
WTF::FreeObjectFinder::FreeObjectFinder	.\FastMalloc.cpp	/^    FreeObjectFinder(const RemoteMemoryReader& reader) : m_reader(reader) { }$/;"	f	class:WTF::FreeObjectFinder	access:public	signature:(const RemoteMemoryReader& reader)
WTF::FreeObjectFinder::findFreeObjects	.\FastMalloc.cpp	/^    void findFreeObjects(TCMalloc_Central_FreeListPadded* centralFreeList, size_t numSizes, TCMalloc_Central_FreeListPadded* remoteCentralFreeList)$/;"	f	class:WTF::FreeObjectFinder	access:public	signature:(TCMalloc_Central_FreeListPadded* centralFreeList, size_t numSizes, TCMalloc_Central_FreeListPadded* remoteCentralFreeList)
WTF::FreeObjectFinder::findFreeObjects	.\FastMalloc.cpp	/^    void findFreeObjects(TCMalloc_ThreadCache* threadCache)$/;"	f	class:WTF::FreeObjectFinder	access:public	signature:(TCMalloc_ThreadCache* threadCache)
WTF::FreeObjectFinder::freeObjectCount	.\FastMalloc.cpp	/^    size_t freeObjectCount() const { return m_freeObjects.size(); }$/;"	f	class:WTF::FreeObjectFinder	access:public	signature:() const
WTF::FreeObjectFinder::isFreeObject	.\FastMalloc.cpp	/^    bool isFreeObject(vm_address_t ptr) const { return isFreeObject(reinterpret_cast<void*>(ptr)); }$/;"	f	class:WTF::FreeObjectFinder	access:public	signature:(vm_address_t ptr) const
WTF::FreeObjectFinder::isFreeObject	.\FastMalloc.cpp	/^    bool isFreeObject(void* ptr) const { return m_freeObjects.contains(ptr); }$/;"	f	class:WTF::FreeObjectFinder	access:public	signature:(void* ptr) const
WTF::FreeObjectFinder::m_freeObjects	.\FastMalloc.cpp	/^    HashSet<void*> m_freeObjects;$/;"	m	class:WTF::FreeObjectFinder	file:	access:private
WTF::FreeObjectFinder::m_reader	.\FastMalloc.cpp	/^    const RemoteMemoryReader& m_reader;$/;"	m	class:WTF::FreeObjectFinder	file:	access:private
WTF::FreeObjectFinder::visit	.\FastMalloc.cpp	/^    void visit(void* ptr) { m_freeObjects.add(ptr); }$/;"	f	class:WTF::FreeObjectFinder	access:public	signature:(void* ptr)
WTF::Function	.\Functional.h	/^class Function<R ()> : public FunctionBase {$/;"	c	namespace:WTF	inherits:FunctionBase
WTF::Function::Function	.\Functional.h	/^    Function()$/;"	f	class:WTF::Function	access:public	signature:()
WTF::Function::Function	.\Functional.h	/^    Function(PassRefPtr<FunctionImpl<R ()> > impl)$/;"	f	class:WTF::Function	access:public	signature:(PassRefPtr<FunctionImpl<R ()> > impl)
WTF::Function::operator ()	.\Functional.h	/^    R operator()() const$/;"	f	class:WTF::Function	access:public	signature:() const
WTF::Function::operator BlockType	.\Functional.h	/^    operator BlockType() const$/;"	f	class:WTF::Function	access:public	signature:() const
WTF::FunctionBase	.\Functional.h	/^class FunctionBase {$/;"	c	namespace:WTF
WTF::FunctionBase::FunctionBase	.\Functional.h	/^    FunctionBase()$/;"	f	class:WTF::FunctionBase	access:protected	signature:()
WTF::FunctionBase::FunctionBase	.\Functional.h	/^    explicit FunctionBase(PassRefPtr<FunctionImplBase> impl)$/;"	f	class:WTF::FunctionBase	access:protected	signature:(PassRefPtr<FunctionImplBase> impl)
WTF::FunctionBase::impl	.\Functional.h	/^    template<typename FunctionType> FunctionImpl<FunctionType>* impl() const$/;"	f	class:WTF::FunctionBase	access:protected	signature:() const
WTF::FunctionBase::isNull	.\Functional.h	/^    bool isNull() const$/;"	f	class:WTF::FunctionBase	access:public	signature:() const
WTF::FunctionBase::m_impl	.\Functional.h	/^    RefPtr<FunctionImplBase> m_impl;$/;"	m	class:WTF::FunctionBase	access:private
WTF::FunctionImpl	.\Functional.h	/^class FunctionImpl<R ()> : public FunctionImplBase {$/;"	c	namespace:WTF	inherits:FunctionImplBase
WTF::FunctionImpl::operator ()	.\Functional.h	/^    virtual R operator()() = 0;$/;"	p	class:WTF::FunctionImpl	access:public	signature:()
WTF::FunctionImplBase	.\Functional.h	/^class FunctionImplBase : public ThreadSafeRefCounted<FunctionImplBase> {$/;"	c	namespace:WTF	inherits:ThreadSafeRefCounted
WTF::FunctionImplBase::~FunctionImplBase	.\Functional.h	/^    virtual ~FunctionImplBase() { }$/;"	f	class:WTF::FunctionImplBase	access:public	signature:()
WTF::FunctionQueue	.\MainThread.cpp	/^typedef Deque<FunctionWithContext> FunctionQueue;$/;"	t	namespace:WTF	file:
WTF::FunctionWithContext	.\MainThread.cpp	/^struct FunctionWithContext {$/;"	s	namespace:WTF	file:
WTF::FunctionWithContext::FunctionWithContext	.\MainThread.cpp	/^    FunctionWithContext(MainThreadFunction* function = 0, void* context = 0, ThreadCondition* syncFlag = 0)$/;"	f	struct:WTF::FunctionWithContext	access:public	signature:(MainThreadFunction* function = 0, void* context = 0, ThreadCondition* syncFlag = 0)
WTF::FunctionWithContext::context	.\MainThread.cpp	/^    void* context;$/;"	m	struct:WTF::FunctionWithContext	file:	access:public
WTF::FunctionWithContext::function	.\MainThread.cpp	/^    MainThreadFunction* function;$/;"	m	struct:WTF::FunctionWithContext	file:	access:public
WTF::FunctionWithContext::operator ==	.\MainThread.cpp	/^    bool operator == (const FunctionWithContext& o)$/;"	f	struct:WTF::FunctionWithContext	access:public	signature:(const FunctionWithContext& o)
WTF::FunctionWithContext::syncFlag	.\MainThread.cpp	/^    ThreadCondition* syncFlag;$/;"	m	struct:WTF::FunctionWithContext	file:	access:public
WTF::FunctionWithContextFinder	.\MainThread.cpp	/^class FunctionWithContextFinder {$/;"	c	namespace:WTF	file:
WTF::FunctionWithContextFinder::FunctionWithContextFinder	.\MainThread.cpp	/^    FunctionWithContextFinder(const FunctionWithContext& m) : m(m) {}$/;"	f	class:WTF::FunctionWithContextFinder	access:public	signature:(const FunctionWithContext& m)
WTF::FunctionWithContextFinder::m	.\MainThread.cpp	/^    FunctionWithContext m;$/;"	m	class:WTF::FunctionWithContextFinder	file:	access:public
WTF::FunctionWithContextFinder::operator ()	.\MainThread.cpp	/^    bool operator() (FunctionWithContext& o) { return o == m; }$/;"	f	class:WTF::FunctionWithContextFinder	access:public	signature:(FunctionWithContext& o)
WTF::FunctionWrapper	.\Functional.h	/^class FunctionWrapper<R (*)()> {$/;"	c	namespace:WTF
WTF::FunctionWrapper	.\Functional.h	/^class FunctionWrapper<R (*)(P1)> {$/;"	c	namespace:WTF
WTF::FunctionWrapper	.\Functional.h	/^class FunctionWrapper<R (*)(P1, P2)> {$/;"	c	namespace:WTF
WTF::FunctionWrapper	.\Functional.h	/^class FunctionWrapper<R (*)(P1, P2, P3)> {$/;"	c	namespace:WTF
WTF::FunctionWrapper	.\Functional.h	/^class FunctionWrapper<R (C::*)()> {$/;"	c	namespace:WTF
WTF::FunctionWrapper	.\Functional.h	/^class FunctionWrapper<R (C::*)(P1)> {$/;"	c	namespace:WTF
WTF::FunctionWrapper	.\Functional.h	/^class FunctionWrapper<R (C::*)(P1, P2)> {$/;"	c	namespace:WTF
WTF::FunctionWrapper	.\Functional.h	/^class FunctionWrapper<R (C::*)(P1, P2, P3)> {$/;"	c	namespace:WTF
WTF::FunctionWrapper	.\Functional.h	/^class FunctionWrapper<R (C::*)(P1, P2, P3, P4)> {$/;"	c	namespace:WTF
WTF::FunctionWrapper	.\Functional.h	/^class FunctionWrapper<R (C::*)(P1, P2, P3, P4, P5)> {$/;"	c	namespace:WTF
WTF::FunctionWrapper::FunctionWrapper	.\Functional.h	/^    explicit FunctionWrapper(R (*function)())$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(R (function)))
WTF::FunctionWrapper::FunctionWrapper	.\Functional.h	/^    explicit FunctionWrapper(R (*function)(P1))$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(R (function)P1))
WTF::FunctionWrapper::FunctionWrapper	.\Functional.h	/^    explicit FunctionWrapper(R (*function)(P1, P2))$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(R (function)P1, P2))
WTF::FunctionWrapper::FunctionWrapper	.\Functional.h	/^    explicit FunctionWrapper(R (*function)(P1, P2, P3))$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(R (function)P1, P2, P3))
WTF::FunctionWrapper::R	.\Functional.h	/^    explicit FunctionWrapper(R (C::*function)())$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(C::*function)
WTF::FunctionWrapper::R	.\Functional.h	/^    explicit FunctionWrapper(R (C::*function)(P1))$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(C::*function)
WTF::FunctionWrapper::R	.\Functional.h	/^    explicit FunctionWrapper(R (C::*function)(P1, P2))$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(C::*function)
WTF::FunctionWrapper::R	.\Functional.h	/^    explicit FunctionWrapper(R (C::*function)(P1, P2, P3))$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(C::*function)
WTF::FunctionWrapper::R	.\Functional.h	/^    explicit FunctionWrapper(R (C::*function)(P1, P2, P3, P4))$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(C::*function)
WTF::FunctionWrapper::R	.\Functional.h	/^    explicit FunctionWrapper(R (C::*function)(P1, P2, P3, P4, P5))$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(C::*function)
WTF::FunctionWrapper::ResultType	.\Functional.h	/^    typedef R ResultType;$/;"	t	class:WTF::FunctionWrapper	access:public
WTF::FunctionWrapper::m_function	.\Functional.h	/^    R (*m_function)();$/;"	m	class:WTF::FunctionWrapper	access:private
WTF::FunctionWrapper::m_function	.\Functional.h	/^    R (*m_function)(P1);$/;"	m	class:WTF::FunctionWrapper	access:private
WTF::FunctionWrapper::m_function	.\Functional.h	/^    R (*m_function)(P1, P2);$/;"	m	class:WTF::FunctionWrapper	access:private
WTF::FunctionWrapper::m_function	.\Functional.h	/^    R (*m_function)(P1, P2, P3);$/;"	m	class:WTF::FunctionWrapper	access:private
WTF::FunctionWrapper::m_function	.\Functional.h	/^    R (C::*m_function)();$/;"	m	class:WTF::FunctionWrapper	access:private
WTF::FunctionWrapper::m_function	.\Functional.h	/^    R (C::*m_function)(P1);$/;"	m	class:WTF::FunctionWrapper	access:private
WTF::FunctionWrapper::m_function	.\Functional.h	/^    R (C::*m_function)(P1, P2);$/;"	m	class:WTF::FunctionWrapper	access:private
WTF::FunctionWrapper::m_function	.\Functional.h	/^    R (C::*m_function)(P1, P2, P3);$/;"	m	class:WTF::FunctionWrapper	access:private
WTF::FunctionWrapper::m_function	.\Functional.h	/^    R (C::*m_function)(P1, P2, P3, P4);$/;"	m	class:WTF::FunctionWrapper	access:private
WTF::FunctionWrapper::m_function	.\Functional.h	/^    R (C::*m_function)(P1, P2, P3, P4, P5);$/;"	m	class:WTF::FunctionWrapper	access:private
WTF::FunctionWrapper::operator ()	.\Functional.h	/^    R operator()()$/;"	f	class:WTF::FunctionWrapper	access:public	signature:()
WTF::FunctionWrapper::operator ()	.\Functional.h	/^    R operator()(C* c)$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(C* c)
WTF::FunctionWrapper::operator ()	.\Functional.h	/^    R operator()(C* c, P1 p1)$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(C* c, P1 p1)
WTF::FunctionWrapper::operator ()	.\Functional.h	/^    R operator()(C* c, P1 p1, P2 p2)$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(C* c, P1 p1, P2 p2)
WTF::FunctionWrapper::operator ()	.\Functional.h	/^    R operator()(C* c, P1 p1, P2 p2, P3 p3)$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(C* c, P1 p1, P2 p2, P3 p3)
WTF::FunctionWrapper::operator ()	.\Functional.h	/^    R operator()(C* c, P1 p1, P2 p2, P3 p3, P4 p4)$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(C* c, P1 p1, P2 p2, P3 p3, P4 p4)
WTF::FunctionWrapper::operator ()	.\Functional.h	/^    R operator()(C* c, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(C* c, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
WTF::FunctionWrapper::operator ()	.\Functional.h	/^    R operator()(P1 p1)$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(P1 p1)
WTF::FunctionWrapper::operator ()	.\Functional.h	/^    R operator()(P1 p1, P2 p2)$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(P1 p1, P2 p2)
WTF::FunctionWrapper::operator ()	.\Functional.h	/^    R operator()(P1 p1, P2 p2, P3 p3)$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(P1 p1, P2 p2, P3 p3)
WTF::FunctionWrapper::shouldRefFirstParameter	.\Functional.h	/^    static const bool shouldRefFirstParameter = HasRefAndDeref<C>::value;$/;"	m	class:WTF::FunctionWrapper	access:public
WTF::FunctionWrapper::shouldRefFirstParameter	.\Functional.h	/^    static const bool shouldRefFirstParameter = false;$/;"	m	class:WTF::FunctionWrapper	access:public
WTF::GOwnPtr	.\gobject\GOwnPtr.h	/^template <typename T> class GOwnPtr {$/;"	c	namespace:WTF
WTF::GOwnPtr::GOwnPtr	.\gobject\GOwnPtr.h	/^    explicit GOwnPtr(T* ptr = 0) : m_ptr(ptr) { }$/;"	f	class:WTF::GOwnPtr	access:public	signature:(T* ptr = 0)
WTF::GOwnPtr::GOwnPtr::UnspecifiedBoolType	.\gobject\GOwnPtr.h	/^    typedef T* GOwnPtr::*UnspecifiedBoolType;$/;"	t	class:WTF::GOwnPtr::GOwnPtr	access:public
WTF::GOwnPtr::WTF_MAKE_NONCOPYABLE	.\gobject\GOwnPtr.h	/^    WTF_MAKE_NONCOPYABLE(GOwnPtr);$/;"	p	class:WTF::GOwnPtr	access:private	signature:(GOwnPtr)
WTF::GOwnPtr::clear	.\gobject\GOwnPtr.h	/^    void clear()$/;"	f	class:WTF::GOwnPtr	access:public	signature:()
WTF::GOwnPtr::get	.\gobject\GOwnPtr.h	/^    T* get() const { return m_ptr; }$/;"	f	class:WTF::GOwnPtr	access:public	signature:() const
WTF::GOwnPtr::m_ptr	.\gobject\GOwnPtr.h	/^    T* m_ptr;$/;"	m	class:WTF::GOwnPtr	access:private
WTF::GOwnPtr::operator !	.\gobject\GOwnPtr.h	/^    bool operator!() const { return !m_ptr; }$/;"	f	class:WTF::GOwnPtr	access:public	signature:() const
WTF::GOwnPtr::operator *	.\gobject\GOwnPtr.h	/^    T& operator*() const$/;"	f	class:WTF::GOwnPtr	access:public	signature:() const
WTF::GOwnPtr::operator ->	.\gobject\GOwnPtr.h	/^    T* operator->() const$/;"	f	class:WTF::GOwnPtr	access:public	signature:() const
WTF::GOwnPtr::operator UnspecifiedBoolType	.\gobject\GOwnPtr.h	/^    operator UnspecifiedBoolType() const { return m_ptr ? &GOwnPtr::m_ptr : 0; }$/;"	f	class:WTF::GOwnPtr	access:public	signature:() const
WTF::GOwnPtr::outPtr	.\gobject\GOwnPtr.h	/^    T*& outPtr()$/;"	f	class:WTF::GOwnPtr	access:public	signature:()
WTF::GOwnPtr::release	.\gobject\GOwnPtr.h	/^    T* release()$/;"	f	class:WTF::GOwnPtr	access:public	signature:()
WTF::GOwnPtr::set	.\gobject\GOwnPtr.h	/^    void set(T* ptr)$/;"	f	class:WTF::GOwnPtr	access:public	signature:(T* ptr)
WTF::GOwnPtr::swap	.\gobject\GOwnPtr.h	/^    void swap(GOwnPtr& o) { std::swap(m_ptr, o.m_ptr); }$/;"	f	class:WTF::GOwnPtr	access:public	signature:(GOwnPtr& o)
WTF::GOwnPtr::~GOwnPtr	.\gobject\GOwnPtr.h	/^    ~GOwnPtr() { freeOwnedGPtr(m_ptr); }$/;"	f	class:WTF::GOwnPtr	access:public	signature:()
WTF::GRefPtr	.\gobject\GRefPtr.h	/^template <typename T> class GRefPtr {$/;"	c	namespace:WTF
WTF::GRefPtr::GRefPtr	.\gobject\GRefPtr.h	/^    GRefPtr() : m_ptr(0) { }$/;"	f	class:WTF::GRefPtr	access:public	signature:()
WTF::GRefPtr::GRefPtr	.\gobject\GRefPtr.h	/^    GRefPtr(HashTableDeletedValueType) : m_ptr(hashTableDeletedValue()) { }$/;"	f	class:WTF::GRefPtr	access:public	signature:(HashTableDeletedValueType)
WTF::GRefPtr::GRefPtr	.\gobject\GRefPtr.h	/^    GRefPtr(T* ptr)$/;"	f	class:WTF::GRefPtr	access:public	signature:(T* ptr)
WTF::GRefPtr::GRefPtr	.\gobject\GRefPtr.h	/^    GRefPtr(T* ptr, GRefPtrAdoptType) : m_ptr(ptr) {}$/;"	f	class:WTF::GRefPtr	access:private	signature:(T* ptr, GRefPtrAdoptType)
WTF::GRefPtr::GRefPtr	.\gobject\GRefPtr.h	/^    GRefPtr(const GRefPtr& o)$/;"	f	class:WTF::GRefPtr	access:public	signature:(const GRefPtr& o)
WTF::GRefPtr::GRefPtr	.\gobject\GRefPtr.h	/^    template <typename U> GRefPtr(const GRefPtr<U>& o)$/;"	f	class:WTF::GRefPtr	access:public	signature:(const GRefPtr<U>& o)
WTF::GRefPtr::GRefPtr::UnspecifiedBoolType	.\gobject\GRefPtr.h	/^    typedef T* GRefPtr::*UnspecifiedBoolType;$/;"	t	class:WTF::GRefPtr::GRefPtr	access:public
WTF::GRefPtr::adoptGRef	.\gobject\GRefPtr.h	/^    friend GRefPtr adoptGRef<T>(T*);$/;"	p	class:WTF::GRefPtr	access:friend	signature:(T*)
WTF::GRefPtr::clear	.\gobject\GRefPtr.h	/^    void clear()$/;"	f	class:WTF::GRefPtr	access:public	signature:()
WTF::GRefPtr::get	.\gobject\GRefPtr.h	/^    T* get() const { return m_ptr; }$/;"	f	class:WTF::GRefPtr	access:public	signature:() const
WTF::GRefPtr::hashTableDeletedValue	.\gobject\GRefPtr.h	/^    static T* hashTableDeletedValue() { return reinterpret_cast<T*>(-1); }$/;"	f	class:WTF::GRefPtr	access:private	signature:()
WTF::GRefPtr::isHashTableDeletedValue	.\gobject\GRefPtr.h	/^    bool isHashTableDeletedValue() const { return m_ptr == hashTableDeletedValue(); }$/;"	f	class:WTF::GRefPtr	access:public	signature:() const
WTF::GRefPtr::m_ptr	.\gobject\GRefPtr.h	/^    T* m_ptr;$/;"	m	class:WTF::GRefPtr	access:private
WTF::GRefPtr::operator !	.\gobject\GRefPtr.h	/^    bool operator!() const { return !m_ptr; }$/;"	f	class:WTF::GRefPtr	access:public	signature:() const
WTF::GRefPtr::operator *	.\gobject\GRefPtr.h	/^    T& operator*() const { return *m_ptr; }$/;"	f	class:WTF::GRefPtr	access:public	signature:() const
WTF::GRefPtr::operator ->	.\gobject\GRefPtr.h	/^    ALWAYS_INLINE T* operator->() const { return m_ptr; }$/;"	f	class:WTF::GRefPtr	access:public	signature:() const
WTF::GRefPtr::operator =	.\gobject\GRefPtr.h	/^    GRefPtr& operator=(T*);$/;"	p	class:WTF::GRefPtr	access:public	signature:(T*)
WTF::GRefPtr::operator =	.\gobject\GRefPtr.h	/^    GRefPtr& operator=(const GRefPtr&);$/;"	p	class:WTF::GRefPtr	access:public	signature:(const GRefPtr&)
WTF::GRefPtr::operator =	.\gobject\GRefPtr.h	/^    template <typename U> GRefPtr& operator=(const GRefPtr<U>&);$/;"	p	class:WTF::GRefPtr	access:public	signature:(const GRefPtr<U>&)
WTF::GRefPtr::operator =	.\gobject\GRefPtr.h	/^template <typename T> inline GRefPtr<T>& GRefPtr<T>::operator=(T* optr)$/;"	f	class:WTF::GRefPtr	signature:(T* optr)
WTF::GRefPtr::operator =	.\gobject\GRefPtr.h	/^template <typename T> inline GRefPtr<T>& GRefPtr<T>::operator=(const GRefPtr<T>& o)$/;"	f	class:WTF::GRefPtr	signature:(const GRefPtr<T>& o)
WTF::GRefPtr::operator UnspecifiedBoolType	.\gobject\GRefPtr.h	/^    operator UnspecifiedBoolType() const { return m_ptr ? &GRefPtr::m_ptr : 0; }$/;"	f	class:WTF::GRefPtr	access:public	signature:() const
WTF::GRefPtr::swap	.\gobject\GRefPtr.h	/^    void swap(GRefPtr&);$/;"	p	class:WTF::GRefPtr	access:public	signature:(GRefPtr&)
WTF::GRefPtr::swap	.\gobject\GRefPtr.h	/^template <class T> inline void GRefPtr<T>::swap(GRefPtr<T>& o)$/;"	f	class:WTF::GRefPtr	signature:(GRefPtr<T>& o)
WTF::GRefPtr::~GRefPtr	.\gobject\GRefPtr.h	/^    ~GRefPtr()$/;"	f	class:WTF::GRefPtr	access:public	signature:()
WTF::GRefPtrAdopt	.\gobject\GRefPtr.h	/^enum GRefPtrAdoptType { GRefPtrAdopt };$/;"	e	enum:WTF::GRefPtrAdoptType
WTF::GRefPtrAdoptType	.\gobject\GRefPtr.h	/^enum GRefPtrAdoptType { GRefPtrAdopt };$/;"	g	namespace:WTF
WTF::GVariant	.\gobject\GRefPtr.cpp	/^} GVariant; $/;"	t	namespace:WTF	typeref:struct:WTF::_GVariant	file:
WTF::GenericHashTraits	.\HashTraits.h	/^    template<typename T> struct GenericHashTraits : GenericHashTraitsBase<IsInteger<T>::value, T> {$/;"	s	namespace:WTF	inherits:GenericHashTraitsBase
WTF::GenericHashTraits::EmptyValueType	.\HashTraits.h	/^        typedef T EmptyValueType;$/;"	t	struct:WTF::GenericHashTraits	access:public
WTF::GenericHashTraits::PassInType	.\HashTraits.h	/^        typedef const T& PassInType;$/;"	t	struct:WTF::GenericHashTraits	access:public
WTF::GenericHashTraits::PassOutType	.\HashTraits.h	/^        typedef T PassOutType;$/;"	t	struct:WTF::GenericHashTraits	access:public
WTF::GenericHashTraits::PeekType	.\HashTraits.h	/^        typedef T PeekType;$/;"	t	struct:WTF::GenericHashTraits	access:public
WTF::GenericHashTraits::TraitType	.\HashTraits.h	/^        typedef T TraitType;$/;"	t	struct:WTF::GenericHashTraits	access:public
WTF::GenericHashTraits::emptyValue	.\HashTraits.h	/^        static T emptyValue() { return T(); }$/;"	f	struct:WTF::GenericHashTraits	access:public	signature:()
WTF::GenericHashTraits::passOut	.\HashTraits.h	/^        static PassOutType passOut(const T& value) { return value; }$/;"	f	struct:WTF::GenericHashTraits	access:public	signature:(const T& value)
WTF::GenericHashTraits::peek	.\HashTraits.h	/^        static PeekType peek(const T& value) { return value; }$/;"	f	struct:WTF::GenericHashTraits	access:public	signature:(const T& value)
WTF::GenericHashTraits::store	.\HashTraits.h	/^        static void store(const T& value, T& storage) { storage = value; }$/;"	f	struct:WTF::GenericHashTraits	access:public	signature:(const T& value, T& storage)
WTF::GenericHashTraitsBase	.\HashTraits.h	/^    template<typename T> struct GenericHashTraitsBase<false, T> {$/;"	s	namespace:WTF
WTF::GenericHashTraitsBase	.\HashTraits.h	/^    template<typename T> struct GenericHashTraitsBase<true, T> : GenericHashTraitsBase<false, T> {$/;"	s	namespace:WTF	inherits:GenericHashTraitsBase
WTF::GenericHashTraitsBase::constructDeletedValue	.\HashTraits.h	/^        static void constructDeletedValue(T& slot) { slot = static_cast<T>(-1); }$/;"	f	struct:WTF::GenericHashTraitsBase	access:public	signature:(T& slot)
WTF::GenericHashTraitsBase::emptyValueIsZero	.\HashTraits.h	/^        static const bool emptyValueIsZero = false;$/;"	m	struct:WTF::GenericHashTraitsBase	access:public
WTF::GenericHashTraitsBase::emptyValueIsZero	.\HashTraits.h	/^        static const bool emptyValueIsZero = true;$/;"	m	struct:WTF::GenericHashTraitsBase	access:public
WTF::GenericHashTraitsBase::isDeletedValue	.\HashTraits.h	/^        static bool isDeletedValue(T value) { return value == static_cast<T>(-1); }$/;"	f	struct:WTF::GenericHashTraitsBase	access:public	signature:(T value)
WTF::GenericHashTraitsBase::minimumTableSize	.\HashTraits.h	/^        static const int minimumTableSize = 64;$/;"	m	struct:WTF::GenericHashTraitsBase	access:public
WTF::GenericHashTraitsBase::needsDestruction	.\HashTraits.h	/^        static const bool needsDestruction = false;$/;"	m	struct:WTF::GenericHashTraitsBase	access:public
WTF::GenericHashTraitsBase::needsDestruction	.\HashTraits.h	/^        static const bool needsDestruction = true;$/;"	m	struct:WTF::GenericHashTraitsBase	access:public
WTF::HasRefAndDeref	.\Functional.h	/^class HasRefAndDeref {$/;"	c	namespace:WTF
WTF::HasRefAndDeref::Base	.\Functional.h	/^    struct Base : public T, public BaseMixin { };$/;"	s	class:WTF::HasRefAndDeref	inherits:T,BaseMixin	access:private
WTF::HasRefAndDeref::BaseMixin	.\Functional.h	/^    struct BaseMixin {$/;"	s	class:WTF::HasRefAndDeref	access:private
WTF::HasRefAndDeref::BaseMixin::deref	.\Functional.h	/^        void deref();$/;"	p	struct:WTF::HasRefAndDeref::BaseMixin	access:public	signature:()
WTF::HasRefAndDeref::BaseMixin::ref	.\Functional.h	/^        void ref();$/;"	p	struct:WTF::HasRefAndDeref::BaseMixin	access:public	signature:()
WTF::HasRefAndDeref::NoType	.\Functional.h	/^    struct NoType {$/;"	s	class:WTF::HasRefAndDeref	access:private
WTF::HasRefAndDeref::NoType::padding	.\Functional.h	/^        char padding[8];$/;"	m	struct:WTF::HasRefAndDeref::NoType	access:public
WTF::HasRefAndDeref::TypeChecker	.\Functional.h	/^    TypeChecker { };$/;"	s	class:WTF::HasRefAndDeref	access:private
WTF::HasRefAndDeref::YesType	.\Functional.h	/^    typedef char YesType;$/;"	t	class:WTF::HasRefAndDeref	access:private
WTF::HasRefAndDeref::derefCheck	.\Functional.h	/^    static NoType derefCheck(U*, TypeChecker<void (BaseMixin::*)(), &U::deref>* = 0);$/;"	p	class:WTF::HasRefAndDeref	access:private	signature:(U*, TypeChecker<void (BaseMixin::*)(), &U::deref>* = 0)
WTF::HasRefAndDeref::derefCheck	.\Functional.h	/^    static YesType derefCheck(...);$/;"	p	class:WTF::HasRefAndDeref	access:private	signature:(....)
WTF::HasRefAndDeref::refCheck	.\Functional.h	/^    static NoType refCheck(U*, TypeChecker<void (BaseMixin::*)(), &U::ref>* = 0);$/;"	p	class:WTF::HasRefAndDeref	access:private	signature:(U*, TypeChecker<void (BaseMixin::*)(), &U::ref>* = 0)
WTF::HasRefAndDeref::refCheck	.\Functional.h	/^    static YesType refCheck(...);$/;"	p	class:WTF::HasRefAndDeref	access:private	signature:(....)
WTF::HasRefAndDeref::value	.\Functional.h	/^    static const bool value = sizeof(refCheck(static_cast<Base*>(0))) == sizeof(YesType) && sizeof(derefCheck(static_cast<Base*>(0))) == sizeof(YesType);$/;"	m	class:WTF::HasRefAndDeref	access:public
WTF::HasTrivialConstructor	.\TypeTraits.h	/^        template <> struct HasTrivialConstructor<const volatile wchar_t> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^        template <> struct HasTrivialConstructor<const wchar_t> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^        template <> struct HasTrivialConstructor<volatile wchar_t> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^        template <> struct HasTrivialConstructor<wchar_t> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<bool> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const bool> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const double> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const float> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const long double> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const signed char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const signed int> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const signed long long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const signed long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const signed short> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const unsigned char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const unsigned int> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const unsigned long long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const unsigned long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const unsigned short> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const volatile bool> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const volatile char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const volatile double> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const volatile float> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const volatile long double> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const volatile signed char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const volatile signed int> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const volatile signed long long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const volatile signed long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const volatile signed short> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const volatile unsigned char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const volatile unsigned int> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const volatile unsigned long long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const volatile unsigned long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<const volatile unsigned short> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<double> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<float> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<long double> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<signed char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<signed int> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<signed long long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<signed long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<signed short> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<unsigned char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<unsigned int> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<unsigned long long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<unsigned long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<unsigned short> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<volatile bool> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<volatile char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<volatile double> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<volatile float> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<volatile long double> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<volatile signed char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<volatile signed int> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<volatile signed long long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<volatile signed long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<volatile signed short> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<volatile unsigned char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<volatile unsigned int> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<volatile unsigned long long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<volatile unsigned long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <> struct HasTrivialConstructor<volatile unsigned short> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <typename T> struct HasTrivialConstructor : public IntegralConstant<bool, __has_trivial_constructor(T)>{ };$/;"	s	namespace:WTF	inherits:IntegralConstant
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <typename T> struct HasTrivialConstructor : public false_type{ };$/;"	s	namespace:WTF	inherits:false_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template <typename T> struct HasTrivialConstructor<T*> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialConstructor	.\TypeTraits.h	/^    template<typename T> struct HasTrivialConstructor : public std::tr1::has_trivial_constructor<T> { };$/;"	s	namespace:WTF	inherits:std::tr1::has_trivial_constructor
WTF::HasTrivialDestructor	.\TypeTraits.h	/^        template <> struct HasTrivialDestructor<const volatile wchar_t> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^        template <> struct HasTrivialDestructor<const wchar_t> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^        template <> struct HasTrivialDestructor<volatile wchar_t> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^        template <> struct HasTrivialDestructor<wchar_t> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<bool> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const bool> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const double> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const float> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const long double> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const signed char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const signed int> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const signed long long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const signed long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const signed short> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const unsigned char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const unsigned int> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const unsigned long long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const unsigned long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const unsigned short> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const volatile bool> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const volatile char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const volatile double> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const volatile float> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const volatile long double> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const volatile signed char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const volatile signed int> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const volatile signed long long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const volatile signed long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const volatile signed short> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const volatile unsigned char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const volatile unsigned int> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const volatile unsigned long long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const volatile unsigned long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<const volatile unsigned short> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<double> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<float> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<long double> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<signed char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<signed int> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<signed long long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<signed long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<signed short> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<unsigned char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<unsigned int> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<unsigned long long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<unsigned long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<unsigned short> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<volatile bool> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<volatile char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<volatile double> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<volatile float> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<volatile long double> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<volatile signed char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<volatile signed int> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<volatile signed long long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<volatile signed long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<volatile signed short> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<volatile unsigned char> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<volatile unsigned int> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<volatile unsigned long long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<volatile unsigned long> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <> struct HasTrivialDestructor<volatile unsigned short> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <typename T> struct HasTrivialDestructor : public IntegralConstant<bool, __has_trivial_destructor(T)>{ };$/;"	s	namespace:WTF	inherits:IntegralConstant
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <typename T> struct HasTrivialDestructor : public false_type{ };$/;"	s	namespace:WTF	inherits:false_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template <typename T> struct HasTrivialDestructor<T*> : public true_type{ };$/;"	s	namespace:WTF	inherits:true_type
WTF::HasTrivialDestructor	.\TypeTraits.h	/^    template<typename T> struct HasTrivialDestructor : public std::tr1::has_trivial_destructor<T> { };$/;"	s	namespace:WTF	inherits:std::tr1::has_trivial_destructor
WTF::HashAndCharacters	.\text\AtomicString.cpp	/^struct HashAndCharacters {$/;"	s	namespace:WTF	file:
WTF::HashAndCharacters::characters	.\text\AtomicString.cpp	/^    const UChar* characters;$/;"	m	struct:WTF::HashAndCharacters	file:	access:public
WTF::HashAndCharacters::hash	.\text\AtomicString.cpp	/^    unsigned hash;$/;"	m	struct:WTF::HashAndCharacters	file:	access:public
WTF::HashAndCharacters::length	.\text\AtomicString.cpp	/^    unsigned length;$/;"	m	struct:WTF::HashAndCharacters	file:	access:public
WTF::HashAndCharactersTranslator	.\text\AtomicString.cpp	/^struct HashAndCharactersTranslator {$/;"	s	namespace:WTF	file:
WTF::HashAndCharactersTranslator::equal	.\text\AtomicString.cpp	/^    static bool equal(StringImpl* const& string, const HashAndCharacters& buffer)$/;"	f	struct:WTF::HashAndCharactersTranslator	access:public	signature:(StringImpl* const& string, const HashAndCharacters& buffer)
WTF::HashAndCharactersTranslator::hash	.\text\AtomicString.cpp	/^    static unsigned hash(const HashAndCharacters& buffer)$/;"	f	struct:WTF::HashAndCharactersTranslator	access:public	signature:(const HashAndCharacters& buffer)
WTF::HashAndCharactersTranslator::translate	.\text\AtomicString.cpp	/^    static void translate(StringImpl*& location, const HashAndCharacters& buffer, unsigned hash)$/;"	f	struct:WTF::HashAndCharactersTranslator	access:public	signature:(StringImpl*& location, const HashAndCharacters& buffer, unsigned hash)
WTF::HashAndUTF8Characters	.\text\AtomicString.cpp	/^struct HashAndUTF8Characters {$/;"	s	namespace:WTF	file:
WTF::HashAndUTF8Characters::characters	.\text\AtomicString.cpp	/^    const char* characters;$/;"	m	struct:WTF::HashAndUTF8Characters	file:	access:public
WTF::HashAndUTF8Characters::hash	.\text\AtomicString.cpp	/^    unsigned hash;$/;"	m	struct:WTF::HashAndUTF8Characters	file:	access:public
WTF::HashAndUTF8Characters::length	.\text\AtomicString.cpp	/^    unsigned length;$/;"	m	struct:WTF::HashAndUTF8Characters	file:	access:public
WTF::HashAndUTF8Characters::utf16Length	.\text\AtomicString.cpp	/^    unsigned utf16Length;$/;"	m	struct:WTF::HashAndUTF8Characters	file:	access:public
WTF::HashAndUTF8CharactersTranslator	.\text\AtomicString.cpp	/^struct HashAndUTF8CharactersTranslator {$/;"	s	namespace:WTF	file:
WTF::HashAndUTF8CharactersTranslator::equal	.\text\AtomicString.cpp	/^    static bool equal(StringImpl* const& string, const HashAndUTF8Characters& buffer)$/;"	f	struct:WTF::HashAndUTF8CharactersTranslator	access:public	signature:(StringImpl* const& string, const HashAndUTF8Characters& buffer)
WTF::HashAndUTF8CharactersTranslator::hash	.\text\AtomicString.cpp	/^    static unsigned hash(const HashAndUTF8Characters& buffer)$/;"	f	struct:WTF::HashAndUTF8CharactersTranslator	access:public	signature:(const HashAndUTF8Characters& buffer)
WTF::HashAndUTF8CharactersTranslator::translate	.\text\AtomicString.cpp	/^    static void translate(StringImpl*& location, const HashAndUTF8Characters& buffer, unsigned hash)$/;"	f	struct:WTF::HashAndUTF8CharactersTranslator	access:public	signature:(StringImpl*& location, const HashAndUTF8Characters& buffer, unsigned hash)
WTF::HashCountedSet	.\HashCountedSet.h	/^        typename Traits = HashTraits<Value> > class HashCountedSet {$/;"	c	namespace:WTF
WTF::HashCountedSet::HashCountedSet	.\HashCountedSet.h	/^        HashCountedSet() {}$/;"	f	class:WTF::HashCountedSet	access:public	signature:()
WTF::HashCountedSet::ImplType	.\HashCountedSet.h	/^        typedef HashMap<Value, unsigned, HashFunctions, Traits> ImplType;$/;"	t	class:WTF::HashCountedSet	access:private
WTF::HashCountedSet::ValueType	.\HashCountedSet.h	/^        typedef Value ValueType;$/;"	t	class:WTF::HashCountedSet	access:public
WTF::HashCountedSet::WTF_MAKE_FAST_ALLOCATED	.\HashCountedSet.h	/^        WTF_MAKE_FAST_ALLOCATED;$/;"	m	class:WTF::HashCountedSet	access:private
WTF::HashCountedSet::add	.\HashCountedSet.h	/^        std::pair<iterator, bool> add(const ValueType&);$/;"	p	class:WTF::HashCountedSet	access:public	signature:(const ValueType&)
WTF::HashCountedSet::add	.\HashCountedSet.h	/^    inline std::pair<typename HashCountedSet<Value, HashFunctions, Traits>::iterator, bool> HashCountedSet<Value, HashFunctions, Traits>::add(const ValueType &value)$/;"	f	class:WTF::HashCountedSet	signature:(const ValueType &value)
WTF::HashCountedSet::begin	.\HashCountedSet.h	/^        const_iterator begin() const;$/;"	p	class:WTF::HashCountedSet	access:public	signature:() const
WTF::HashCountedSet::begin	.\HashCountedSet.h	/^        iterator begin();$/;"	p	class:WTF::HashCountedSet	access:public	signature:()
WTF::HashCountedSet::begin	.\HashCountedSet.h	/^    inline typename HashCountedSet<Value, HashFunctions, Traits>::const_iterator HashCountedSet<Value, HashFunctions, Traits>::begin() const$/;"	f	class:WTF::HashCountedSet	signature:() const
WTF::HashCountedSet::begin	.\HashCountedSet.h	/^    inline typename HashCountedSet<Value, HashFunctions, Traits>::iterator HashCountedSet<Value, HashFunctions, Traits>::begin()$/;"	f	class:WTF::HashCountedSet	signature:()
WTF::HashCountedSet::capacity	.\HashCountedSet.h	/^        int capacity() const;$/;"	p	class:WTF::HashCountedSet	access:public	signature:() const
WTF::HashCountedSet::capacity	.\HashCountedSet.h	/^    inline int HashCountedSet<Value, HashFunctions, Traits>::capacity() const$/;"	f	class:WTF::HashCountedSet	signature:() const
WTF::HashCountedSet::clear	.\HashCountedSet.h	/^        void clear();$/;"	p	class:WTF::HashCountedSet	access:public	signature:()
WTF::HashCountedSet::clear	.\HashCountedSet.h	/^    inline void HashCountedSet<Value, HashFunctions, Traits>::clear()$/;"	f	class:WTF::HashCountedSet	signature:()
WTF::HashCountedSet::const_iterator	.\HashCountedSet.h	/^        typedef typename ImplType::const_iterator const_iterator;$/;"	t	class:WTF::HashCountedSet	access:public
WTF::HashCountedSet::contains	.\HashCountedSet.h	/^        bool contains(const ValueType&) const;$/;"	p	class:WTF::HashCountedSet	access:public	signature:(const ValueType&) const
WTF::HashCountedSet::contains	.\HashCountedSet.h	/^    inline bool HashCountedSet<Value, HashFunctions, Traits>::contains(const ValueType& value) const$/;"	f	class:WTF::HashCountedSet	signature:(const ValueType& value) const
WTF::HashCountedSet::count	.\HashCountedSet.h	/^        unsigned count(const ValueType&) const;$/;"	p	class:WTF::HashCountedSet	access:public	signature:(const ValueType&) const
WTF::HashCountedSet::count	.\HashCountedSet.h	/^    inline unsigned HashCountedSet<Value, HashFunctions, Traits>::count(const ValueType& value) const$/;"	f	class:WTF::HashCountedSet	signature:(const ValueType& value) const
WTF::HashCountedSet::end	.\HashCountedSet.h	/^        const_iterator end() const;$/;"	p	class:WTF::HashCountedSet	access:public	signature:() const
WTF::HashCountedSet::end	.\HashCountedSet.h	/^        iterator end();$/;"	p	class:WTF::HashCountedSet	access:public	signature:()
WTF::HashCountedSet::end	.\HashCountedSet.h	/^    inline typename HashCountedSet<Value, HashFunctions, Traits>::const_iterator HashCountedSet<Value, HashFunctions, Traits>::end() const$/;"	f	class:WTF::HashCountedSet	signature:() const
WTF::HashCountedSet::end	.\HashCountedSet.h	/^    inline typename HashCountedSet<Value, HashFunctions, Traits>::iterator HashCountedSet<Value, HashFunctions, Traits>::end()$/;"	f	class:WTF::HashCountedSet	signature:()
WTF::HashCountedSet::find	.\HashCountedSet.h	/^        const_iterator find(const ValueType&) const;$/;"	p	class:WTF::HashCountedSet	access:public	signature:(const ValueType&) const
WTF::HashCountedSet::find	.\HashCountedSet.h	/^        iterator find(const ValueType&);$/;"	p	class:WTF::HashCountedSet	access:public	signature:(const ValueType&)
WTF::HashCountedSet::find	.\HashCountedSet.h	/^    inline typename HashCountedSet<Value, HashFunctions, Traits>::const_iterator HashCountedSet<Value, HashFunctions, Traits>::find(const ValueType& value) const$/;"	f	class:WTF::HashCountedSet	signature:(const ValueType& value) const
WTF::HashCountedSet::find	.\HashCountedSet.h	/^    inline typename HashCountedSet<Value, HashFunctions, Traits>::iterator HashCountedSet<Value, HashFunctions, Traits>::find(const ValueType& value)$/;"	f	class:WTF::HashCountedSet	signature:(const ValueType& value)
WTF::HashCountedSet::isEmpty	.\HashCountedSet.h	/^        bool isEmpty() const;$/;"	p	class:WTF::HashCountedSet	access:public	signature:() const
WTF::HashCountedSet::isEmpty	.\HashCountedSet.h	/^    inline bool HashCountedSet<Value, HashFunctions, Traits>::isEmpty() const$/;"	f	class:WTF::HashCountedSet	signature:() const
WTF::HashCountedSet::iterator	.\HashCountedSet.h	/^        typedef typename ImplType::iterator iterator;$/;"	t	class:WTF::HashCountedSet	access:public
WTF::HashCountedSet::m_impl	.\HashCountedSet.h	/^        ImplType m_impl;$/;"	m	class:WTF::HashCountedSet	access:private
WTF::HashCountedSet::remove	.\HashCountedSet.h	/^        bool remove(const ValueType&);$/;"	p	class:WTF::HashCountedSet	access:public	signature:(const ValueType&)
WTF::HashCountedSet::remove	.\HashCountedSet.h	/^        bool remove(iterator);$/;"	p	class:WTF::HashCountedSet	access:public	signature:(iterator)
WTF::HashCountedSet::remove	.\HashCountedSet.h	/^    inline bool HashCountedSet<Value, HashFunctions, Traits>::remove(const ValueType& value)$/;"	f	class:WTF::HashCountedSet	signature:(const ValueType& value)
WTF::HashCountedSet::remove	.\HashCountedSet.h	/^    inline bool HashCountedSet<Value, HashFunctions, Traits>::remove(iterator it)$/;"	f	class:WTF::HashCountedSet	signature:(iterator it)
WTF::HashCountedSet::removeAll	.\HashCountedSet.h	/^        void removeAll(const ValueType&);$/;"	p	class:WTF::HashCountedSet	access:public	signature:(const ValueType&)
WTF::HashCountedSet::removeAll	.\HashCountedSet.h	/^        void removeAll(iterator);$/;"	p	class:WTF::HashCountedSet	access:public	signature:(iterator)
WTF::HashCountedSet::removeAll	.\HashCountedSet.h	/^    inline void HashCountedSet<Value, HashFunctions, Traits>::removeAll(const ValueType& value)$/;"	f	class:WTF::HashCountedSet	signature:(const ValueType& value)
WTF::HashCountedSet::removeAll	.\HashCountedSet.h	/^    inline void HashCountedSet<Value, HashFunctions, Traits>::removeAll(iterator it)$/;"	f	class:WTF::HashCountedSet	signature:(iterator it)
WTF::HashCountedSet::size	.\HashCountedSet.h	/^        int size() const;$/;"	p	class:WTF::HashCountedSet	access:public	signature:() const
WTF::HashCountedSet::size	.\HashCountedSet.h	/^    inline int HashCountedSet<Value, HashFunctions, Traits>::size() const$/;"	f	class:WTF::HashCountedSet	signature:() const
WTF::HashItemKnownGood	.\HashTable.h	/^    typedef enum { HashItemKnownGood } HashItemKnownGoodTag;$/;"	e	enum:WTF::__anon8
WTF::HashItemKnownGoodTag	.\HashTable.h	/^    typedef enum { HashItemKnownGood } HashItemKnownGoodTag;$/;"	t	namespace:WTF	typeref:enum:WTF::__anon8
WTF::HashMap	.\HashMap.h	/^    class HashMap {$/;"	c	namespace:WTF
WTF::HashMap	.\RefPtrHashMap.h	/^    class HashMap<RefPtr<T>, MappedArg, HashArg, KeyTraitsArg, MappedTraitsArg> {$/;"	c	namespace:WTF
WTF::HashMap::HashFunctions	.\HashMap.h	/^        typedef HashArg HashFunctions;$/;"	t	class:WTF::HashMap	access:private
WTF::HashMap::HashFunctions	.\RefPtrHashMap.h	/^        typedef HashArg HashFunctions;$/;"	t	class:WTF::HashMap	access:private
WTF::HashMap::HashMap::inlineGet	.\RefPtrHashMap.h	/^    inline HashMap<RefPtr<T>, U, V, W, MappedTraits>::inlineGet(RawKeyType key) const$/;"	f	class:WTF::HashMap::HashMap	signature:(RawKeyType key) const
WTF::HashMap::HashMapKeysProxy	.\HashMap.h	/^        class HashMapKeysProxy : private HashMap {$/;"	c	class:WTF::HashMap	inherits:HashMap	access:private
WTF::HashMap::HashMapKeysProxy::HashMapKeysProxy	.\HashMap.h	/^            HashMapKeysProxy();$/;"	p	class:WTF::HashMap::HashMapKeysProxy	access:private	signature:()
WTF::HashMap::HashMapKeysProxy::HashMapKeysProxy	.\HashMap.h	/^            HashMapKeysProxy(const HashMapKeysProxy&);$/;"	p	class:WTF::HashMap::HashMapKeysProxy	access:private	signature:(const HashMapKeysProxy&)
WTF::HashMap::HashMapKeysProxy::begin	.\HashMap.h	/^            const_iterator begin() const$/;"	f	class:WTF::HashMap::HashMapKeysProxy	access:public	signature:() const
WTF::HashMap::HashMapKeysProxy::begin	.\HashMap.h	/^            iterator begin()$/;"	f	class:WTF::HashMap::HashMapKeysProxy	access:public	signature:()
WTF::HashMap::HashMapKeysProxy::const_iterator	.\HashMap.h	/^            typedef typename HashMap::const_iterator::Keys const_iterator;$/;"	t	class:WTF::HashMap::HashMapKeysProxy	access:public
WTF::HashMap::HashMapKeysProxy::end	.\HashMap.h	/^            const_iterator end() const$/;"	f	class:WTF::HashMap::HashMapKeysProxy	access:public	signature:() const
WTF::HashMap::HashMapKeysProxy::end	.\HashMap.h	/^            iterator end()$/;"	f	class:WTF::HashMap::HashMapKeysProxy	access:public	signature:()
WTF::HashMap::HashMapKeysProxy::iterator	.\HashMap.h	/^            typedef typename HashMap::iterator::Keys iterator;$/;"	t	class:WTF::HashMap::HashMapKeysProxy	access:public
WTF::HashMap::HashMapKeysProxy::operator =	.\HashMap.h	/^            HashMapKeysProxy& operator=(const HashMapKeysProxy&);$/;"	p	class:WTF::HashMap::HashMapKeysProxy	access:private	signature:(const HashMapKeysProxy&)
WTF::HashMap::HashMapKeysProxy::~HashMapKeysProxy	.\HashMap.h	/^            ~HashMapKeysProxy();$/;"	p	class:WTF::HashMap::HashMapKeysProxy	access:private	signature:()
WTF::HashMap::HashMapValuesProxy	.\HashMap.h	/^        class HashMapValuesProxy : private HashMap {$/;"	c	class:WTF::HashMap	inherits:HashMap	access:private
WTF::HashMap::HashMapValuesProxy::HashMapValuesProxy	.\HashMap.h	/^            HashMapValuesProxy();$/;"	p	class:WTF::HashMap::HashMapValuesProxy	access:private	signature:()
WTF::HashMap::HashMapValuesProxy::HashMapValuesProxy	.\HashMap.h	/^            HashMapValuesProxy(const HashMapValuesProxy&);$/;"	p	class:WTF::HashMap::HashMapValuesProxy	access:private	signature:(const HashMapValuesProxy&)
WTF::HashMap::HashMapValuesProxy::begin	.\HashMap.h	/^            const_iterator begin() const$/;"	f	class:WTF::HashMap::HashMapValuesProxy	access:public	signature:() const
WTF::HashMap::HashMapValuesProxy::begin	.\HashMap.h	/^            iterator begin()$/;"	f	class:WTF::HashMap::HashMapValuesProxy	access:public	signature:()
WTF::HashMap::HashMapValuesProxy::const_iterator	.\HashMap.h	/^            typedef typename HashMap::const_iterator::Values const_iterator;$/;"	t	class:WTF::HashMap::HashMapValuesProxy	access:public
WTF::HashMap::HashMapValuesProxy::end	.\HashMap.h	/^            const_iterator end() const$/;"	f	class:WTF::HashMap::HashMapValuesProxy	access:public	signature:() const
WTF::HashMap::HashMapValuesProxy::end	.\HashMap.h	/^            iterator end()$/;"	f	class:WTF::HashMap::HashMapValuesProxy	access:public	signature:()
WTF::HashMap::HashMapValuesProxy::iterator	.\HashMap.h	/^            typedef typename HashMap::iterator::Values iterator;$/;"	t	class:WTF::HashMap::HashMapValuesProxy	access:public
WTF::HashMap::HashMapValuesProxy::operator =	.\HashMap.h	/^            HashMapValuesProxy& operator=(const HashMapValuesProxy&);$/;"	p	class:WTF::HashMap::HashMapValuesProxy	access:private	signature:(const HashMapValuesProxy&)
WTF::HashMap::HashMapValuesProxy::~HashMapValuesProxy	.\HashMap.h	/^            ~HashMapValuesProxy();$/;"	p	class:WTF::HashMap::HashMapValuesProxy	access:private	signature:()
WTF::HashMap::HashTableType	.\HashMap.h	/^            HashFunctions, ValueTraits, KeyTraits> HashTableType;$/;"	t	class:WTF::HashMap	access:private
WTF::HashMap::HashTableType	.\RefPtrHashMap.h	/^            HashFunctions, ValueTraits, KeyTraits> HashTableType;$/;"	t	class:WTF::HashMap	access:private
WTF::HashMap::KeyTraits	.\HashMap.h	/^        typedef KeyTraitsArg KeyTraits;$/;"	t	class:WTF::HashMap	access:private
WTF::HashMap::KeyTraits	.\RefPtrHashMap.h	/^        typedef KeyTraitsArg KeyTraits;$/;"	t	class:WTF::HashMap	access:private
WTF::HashMap::KeyType	.\HashMap.h	/^        typedef typename KeyTraits::TraitType KeyType;$/;"	t	class:WTF::HashMap	access:public
WTF::HashMap::KeyType	.\RefPtrHashMap.h	/^        typedef typename KeyTraits::TraitType KeyType;$/;"	t	class:WTF::HashMap	access:public
WTF::HashMap::MappedPassInReferenceType	.\HashMap.h	/^        typedef typename ReferenceTypeMaker<MappedPassInType>::ReferenceType MappedPassInReferenceType;$/;"	t	class:WTF::HashMap	access:private
WTF::HashMap::MappedPassInReferenceType	.\RefPtrHashMap.h	/^        typedef typename ReferenceTypeMaker<MappedPassInType>::ReferenceType MappedPassInReferenceType;$/;"	t	class:WTF::HashMap	access:private
WTF::HashMap::MappedPassInType	.\HashMap.h	/^        typedef typename MappedTraits::PassInType MappedPassInType;$/;"	t	class:WTF::HashMap	access:private
WTF::HashMap::MappedPassInType	.\RefPtrHashMap.h	/^        typedef typename MappedTraits::PassInType MappedPassInType;$/;"	t	class:WTF::HashMap	access:private
WTF::HashMap::MappedPassOutType	.\HashMap.h	/^        typedef typename MappedTraits::PassOutType MappedPassOutType;$/;"	t	class:WTF::HashMap	access:private
WTF::HashMap::MappedPassOutType	.\RefPtrHashMap.h	/^        typedef typename MappedTraits::PassOutType MappedPassOutType;$/;"	t	class:WTF::HashMap	access:private
WTF::HashMap::MappedPeekType	.\HashMap.h	/^        typedef typename MappedTraits::PeekType MappedPeekType;$/;"	t	class:WTF::HashMap	access:private
WTF::HashMap::MappedPeekType	.\RefPtrHashMap.h	/^        typedef typename MappedTraits::PeekType MappedPeekType;$/;"	t	class:WTF::HashMap	access:private
WTF::HashMap::MappedTraits	.\HashMap.h	/^        typedef MappedTraitsArg MappedTraits;$/;"	t	class:WTF::HashMap	access:private
WTF::HashMap::MappedTraits	.\RefPtrHashMap.h	/^        typedef MappedTraitsArg MappedTraits;$/;"	t	class:WTF::HashMap	access:private
WTF::HashMap::MappedType	.\HashMap.h	/^        typedef typename MappedTraits::TraitType MappedType;$/;"	t	class:WTF::HashMap	access:public
WTF::HashMap::MappedType	.\RefPtrHashMap.h	/^        typedef typename MappedTraits::TraitType MappedType;$/;"	t	class:WTF::HashMap	access:public
WTF::HashMap::RawKeyType	.\RefPtrHashMap.h	/^        typedef T* RawKeyType;$/;"	t	class:WTF::HashMap	access:public
WTF::HashMap::Translator	.\RefPtrHashMap.h	/^            Translator;$/;"	t	class:WTF::HashMap	access:private
WTF::HashMap::ValueTraits	.\HashMap.h	/^        typedef PairHashTraits<KeyTraits, MappedTraits> ValueTraits;$/;"	t	class:WTF::HashMap	access:private
WTF::HashMap::ValueTraits	.\RefPtrHashMap.h	/^        typedef PairHashTraits<KeyTraits, MappedTraits> ValueTraits;$/;"	t	class:WTF::HashMap	access:private
WTF::HashMap::ValueType	.\HashMap.h	/^        typedef typename ValueTraits::TraitType ValueType;$/;"	t	class:WTF::HashMap	access:public
WTF::HashMap::ValueType	.\RefPtrHashMap.h	/^        typedef typename ValueTraits::TraitType ValueType;$/;"	t	class:WTF::HashMap	access:public
WTF::HashMap::WTF_MAKE_FAST_ALLOCATED	.\HashMap.h	/^        WTF_MAKE_FAST_ALLOCATED;$/;"	m	class:WTF::HashMap	access:private
WTF::HashMap::WTF_MAKE_FAST_ALLOCATED	.\RefPtrHashMap.h	/^        WTF_MAKE_FAST_ALLOCATED;$/;"	m	class:WTF::HashMap	access:private
WTF::HashMap::add	.\HashMap.h	/^        pair<iterator, bool> add(const KeyType&, MappedPassInType); $/;"	p	class:WTF::HashMap	access:public	signature:(const KeyType&, MappedPassInType)
WTF::HashMap::add	.\HashMap.h	/^        template<typename T, typename HashTranslator> pair<iterator, bool> add(const T&, MappedPassInType);$/;"	p	class:WTF::HashMap	access:public	signature:(const T&, MappedPassInType)
WTF::HashMap::add	.\HashMap.h	/^    HashMap<T, U, V, W, X>::add(const KeyType& key, MappedPassInType mapped)$/;"	f	class:WTF::HashMap	signature:(const KeyType& key, MappedPassInType mapped)
WTF::HashMap::add	.\HashMap.h	/^    HashMap<T, U, V, W, X>::add(const TYPE& key, MappedPassInType value)$/;"	f	class:WTF::HashMap	signature:(const TYPE& key, MappedPassInType value)
WTF::HashMap::add	.\RefPtrHashMap.h	/^        pair<iterator, bool> add(RawKeyType, MappedPassInType); $/;"	p	class:WTF::HashMap	access:public	signature:(RawKeyType, MappedPassInType)
WTF::HashMap::add	.\RefPtrHashMap.h	/^        pair<iterator, bool> add(const KeyType&, MappedPassInType); $/;"	p	class:WTF::HashMap	access:public	signature:(const KeyType&, MappedPassInType)
WTF::HashMap::add	.\RefPtrHashMap.h	/^    HashMap<RefPtr<T>, U, V, W, X>::add(RawKeyType key, MappedPassInType mapped)$/;"	f	class:WTF::HashMap	signature:(RawKeyType key, MappedPassInType mapped)
WTF::HashMap::add	.\RefPtrHashMap.h	/^    HashMap<RefPtr<T>, U, V, W, X>::add(const KeyType& key, MappedPassInType mapped)$/;"	f	class:WTF::HashMap	signature:(const KeyType& key, MappedPassInType mapped)
WTF::HashMap::begin	.\HashMap.h	/^        const_iterator begin() const;$/;"	p	class:WTF::HashMap	access:public	signature:() const
WTF::HashMap::begin	.\HashMap.h	/^        iterator begin();$/;"	p	class:WTF::HashMap	access:public	signature:()
WTF::HashMap::begin	.\HashMap.h	/^    inline typename HashMap<T, U, V, W, X>::const_iterator HashMap<T, U, V, W, X>::begin() const$/;"	f	class:WTF::HashMap	signature:() const
WTF::HashMap::begin	.\HashMap.h	/^    inline typename HashMap<T, U, V, W, X>::iterator HashMap<T, U, V, W, X>::begin()$/;"	f	class:WTF::HashMap	signature:()
WTF::HashMap::begin	.\RefPtrHashMap.h	/^        const_iterator begin() const;$/;"	p	class:WTF::HashMap	access:public	signature:() const
WTF::HashMap::begin	.\RefPtrHashMap.h	/^        iterator begin();$/;"	p	class:WTF::HashMap	access:public	signature:()
WTF::HashMap::begin	.\RefPtrHashMap.h	/^    inline typename HashMap<RefPtr<T>, U, V, W, X>::const_iterator HashMap<RefPtr<T>, U, V, W, X>::begin() const$/;"	f	class:WTF::HashMap	signature:() const
WTF::HashMap::begin	.\RefPtrHashMap.h	/^    inline typename HashMap<RefPtr<T>, U, V, W, X>::iterator HashMap<RefPtr<T>, U, V, W, X>::begin()$/;"	f	class:WTF::HashMap	signature:()
WTF::HashMap::capacity	.\HashMap.h	/^        int capacity() const;$/;"	p	class:WTF::HashMap	access:public	signature:() const
WTF::HashMap::capacity	.\HashMap.h	/^    inline int HashMap<T, U, V, W, X>::capacity() const$/;"	f	class:WTF::HashMap	signature:() const
WTF::HashMap::capacity	.\RefPtrHashMap.h	/^        int capacity() const;$/;"	p	class:WTF::HashMap	access:public	signature:() const
WTF::HashMap::capacity	.\RefPtrHashMap.h	/^    inline int HashMap<RefPtr<T>, U, V, W, X>::capacity() const$/;"	f	class:WTF::HashMap	signature:() const
WTF::HashMap::checkConsistency	.\HashMap.h	/^        void checkConsistency() const;$/;"	p	class:WTF::HashMap	access:public	signature:() const
WTF::HashMap::checkConsistency	.\HashMap.h	/^    inline void HashMap<T, U, V, W, X>::checkConsistency() const$/;"	f	class:WTF::HashMap	signature:() const
WTF::HashMap::clear	.\HashMap.h	/^        void clear();$/;"	p	class:WTF::HashMap	access:public	signature:()
WTF::HashMap::clear	.\HashMap.h	/^    inline void HashMap<T, U, V, W, X>::clear()$/;"	f	class:WTF::HashMap	signature:()
WTF::HashMap::clear	.\RefPtrHashMap.h	/^        void clear();$/;"	p	class:WTF::HashMap	access:public	signature:()
WTF::HashMap::clear	.\RefPtrHashMap.h	/^    inline void HashMap<RefPtr<T>, U, V, W, X>::clear()$/;"	f	class:WTF::HashMap	signature:()
WTF::HashMap::const_iterator	.\HashMap.h	/^        typedef HashTableConstIteratorAdapter<HashTableType, ValueType> const_iterator;$/;"	t	class:WTF::HashMap	access:public
WTF::HashMap::const_iterator	.\RefPtrHashMap.h	/^        typedef HashTableConstIteratorAdapter<HashTableType, ValueType> const_iterator;$/;"	t	class:WTF::HashMap	access:public
WTF::HashMap::contains	.\HashMap.h	/^        bool contains(const KeyType&) const;$/;"	p	class:WTF::HashMap	access:public	signature:(const KeyType&) const
WTF::HashMap::contains	.\HashMap.h	/^        template<typename T, typename HashTranslator> bool contains(const T&) const;$/;"	p	class:WTF::HashMap	access:public	signature:(const T&) const
WTF::HashMap::contains	.\HashMap.h	/^    HashMap<T, U, V, W, X>::contains(const TYPE& value) const$/;"	f	class:WTF::HashMap	signature:(const TYPE& value) const
WTF::HashMap::contains	.\HashMap.h	/^    inline bool HashMap<T, U, V, W, X>::contains(const KeyType& key) const$/;"	f	class:WTF::HashMap	signature:(const KeyType& key) const
WTF::HashMap::contains	.\RefPtrHashMap.h	/^        bool contains(RawKeyType) const;$/;"	p	class:WTF::HashMap	access:public	signature:(RawKeyType) const
WTF::HashMap::contains	.\RefPtrHashMap.h	/^        bool contains(const KeyType&) const;$/;"	p	class:WTF::HashMap	access:public	signature:(const KeyType&) const
WTF::HashMap::contains	.\RefPtrHashMap.h	/^    inline bool HashMap<RefPtr<T>, U, V, W, X>::contains(RawKeyType key) const$/;"	f	class:WTF::HashMap	signature:(RawKeyType key) const
WTF::HashMap::contains	.\RefPtrHashMap.h	/^    inline bool HashMap<RefPtr<T>, U, V, W, X>::contains(const KeyType& key) const$/;"	f	class:WTF::HashMap	signature:(const KeyType& key) const
WTF::HashMap::end	.\HashMap.h	/^        const_iterator end() const;$/;"	p	class:WTF::HashMap	access:public	signature:() const
WTF::HashMap::end	.\HashMap.h	/^        iterator end();$/;"	p	class:WTF::HashMap	access:public	signature:()
WTF::HashMap::end	.\HashMap.h	/^    inline typename HashMap<T, U, V, W, X>::const_iterator HashMap<T, U, V, W, X>::end() const$/;"	f	class:WTF::HashMap	signature:() const
WTF::HashMap::end	.\HashMap.h	/^    inline typename HashMap<T, U, V, W, X>::iterator HashMap<T, U, V, W, X>::end()$/;"	f	class:WTF::HashMap	signature:()
WTF::HashMap::end	.\RefPtrHashMap.h	/^        const_iterator end() const;$/;"	p	class:WTF::HashMap	access:public	signature:() const
WTF::HashMap::end	.\RefPtrHashMap.h	/^        iterator end();$/;"	p	class:WTF::HashMap	access:public	signature:()
WTF::HashMap::end	.\RefPtrHashMap.h	/^    inline typename HashMap<RefPtr<T>, U, V, W, X>::const_iterator HashMap<RefPtr<T>, U, V, W, X>::end() const$/;"	f	class:WTF::HashMap	signature:() const
WTF::HashMap::end	.\RefPtrHashMap.h	/^    inline typename HashMap<RefPtr<T>, U, V, W, X>::iterator HashMap<RefPtr<T>, U, V, W, X>::end()$/;"	f	class:WTF::HashMap	signature:()
WTF::HashMap::find	.\HashMap.h	/^        const_iterator find(const KeyType&) const;$/;"	p	class:WTF::HashMap	access:public	signature:(const KeyType&) const
WTF::HashMap::find	.\HashMap.h	/^        iterator find(const KeyType&);$/;"	p	class:WTF::HashMap	access:public	signature:(const KeyType&)
WTF::HashMap::find	.\HashMap.h	/^        template<typename T, typename HashTranslator> const_iterator find(const T&) const;$/;"	p	class:WTF::HashMap	access:public	signature:(const T&) const
WTF::HashMap::find	.\HashMap.h	/^        template<typename T, typename HashTranslator> iterator find(const T&);$/;"	p	class:WTF::HashMap	access:public	signature:(const T&)
WTF::HashMap::find	.\HashMap.h	/^    HashMap<T, U, V, W, X>::find(const TYPE& value) const$/;"	f	class:WTF::HashMap	signature:(const TYPE& value) const
WTF::HashMap::find	.\HashMap.h	/^    HashMap<T, U, V, W, X>::find(const TYPE& value)$/;"	f	class:WTF::HashMap	signature:(const TYPE& value)
WTF::HashMap::find	.\HashMap.h	/^    inline typename HashMap<T, U, V, W, X>::const_iterator HashMap<T, U, V, W, X>::find(const KeyType& key) const$/;"	f	class:WTF::HashMap	signature:(const KeyType& key) const
WTF::HashMap::find	.\HashMap.h	/^    inline typename HashMap<T, U, V, W, X>::iterator HashMap<T, U, V, W, X>::find(const KeyType& key)$/;"	f	class:WTF::HashMap	signature:(const KeyType& key)
WTF::HashMap::find	.\RefPtrHashMap.h	/^        const_iterator find(RawKeyType) const;$/;"	p	class:WTF::HashMap	access:public	signature:(RawKeyType) const
WTF::HashMap::find	.\RefPtrHashMap.h	/^        const_iterator find(const KeyType&) const;$/;"	p	class:WTF::HashMap	access:public	signature:(const KeyType&) const
WTF::HashMap::find	.\RefPtrHashMap.h	/^        iterator find(RawKeyType);$/;"	p	class:WTF::HashMap	access:public	signature:(RawKeyType)
WTF::HashMap::find	.\RefPtrHashMap.h	/^        iterator find(const KeyType&);$/;"	p	class:WTF::HashMap	access:public	signature:(const KeyType&)
WTF::HashMap::find	.\RefPtrHashMap.h	/^    inline typename HashMap<RefPtr<T>, U, V, W, X>::const_iterator HashMap<RefPtr<T>, U, V, W, X>::find(RawKeyType key) const$/;"	f	class:WTF::HashMap	signature:(RawKeyType key) const
WTF::HashMap::find	.\RefPtrHashMap.h	/^    inline typename HashMap<RefPtr<T>, U, V, W, X>::const_iterator HashMap<RefPtr<T>, U, V, W, X>::find(const KeyType& key) const$/;"	f	class:WTF::HashMap	signature:(const KeyType& key) const
WTF::HashMap::find	.\RefPtrHashMap.h	/^    inline typename HashMap<RefPtr<T>, U, V, W, X>::iterator HashMap<RefPtr<T>, U, V, W, X>::find(RawKeyType key)$/;"	f	class:WTF::HashMap	signature:(RawKeyType key)
WTF::HashMap::find	.\RefPtrHashMap.h	/^    inline typename HashMap<RefPtr<T>, U, V, W, X>::iterator HashMap<RefPtr<T>, U, V, W, X>::find(const KeyType& key)$/;"	f	class:WTF::HashMap	signature:(const KeyType& key)
WTF::HashMap::get	.\HashMap.h	/^        MappedPeekType get(const KeyType&) const;$/;"	p	class:WTF::HashMap	access:public	signature:(const KeyType&) const
WTF::HashMap::get	.\HashMap.h	/^    HashMap<T, U, V, W, MappedTraits>::get(const KeyType& key) const$/;"	f	class:WTF::HashMap	signature:(const KeyType& key) const
WTF::HashMap::get	.\RefPtrHashMap.h	/^        MappedPeekType get(RawKeyType) const;$/;"	p	class:WTF::HashMap	access:public	signature:(RawKeyType) const
WTF::HashMap::get	.\RefPtrHashMap.h	/^        MappedPeekType get(const KeyType&) const;$/;"	p	class:WTF::HashMap	access:public	signature:(const KeyType&) const
WTF::HashMap::get	.\RefPtrHashMap.h	/^    HashMap<RefPtr<T>, U, V, W, MappedTraits>::get(RawKeyType key) const$/;"	f	class:WTF::HashMap	signature:(RawKeyType key) const
WTF::HashMap::get	.\RefPtrHashMap.h	/^    HashMap<RefPtr<T>, U, V, W, MappedTraits>::get(const KeyType& key) const$/;"	f	class:WTF::HashMap	signature:(const KeyType& key) const
WTF::HashMap::inlineAdd	.\HashMap.h	/^        pair<iterator, bool> inlineAdd(const KeyType&, MappedPassInReferenceType);$/;"	p	class:WTF::HashMap	access:private	signature:(const KeyType&, MappedPassInReferenceType)
WTF::HashMap::inlineAdd	.\HashMap.h	/^    HashMap<T, U, V, W, X>::inlineAdd(const KeyType& key, MappedPassInReferenceType mapped) $/;"	f	class:WTF::HashMap	signature:(const KeyType& key, MappedPassInReferenceType mapped)
WTF::HashMap::inlineAdd	.\RefPtrHashMap.h	/^        pair<iterator, bool> inlineAdd(RawKeyType, MappedPassInReferenceType);$/;"	p	class:WTF::HashMap	access:private	signature:(RawKeyType, MappedPassInReferenceType)
WTF::HashMap::inlineAdd	.\RefPtrHashMap.h	/^        pair<iterator, bool> inlineAdd(const KeyType&, MappedPassInReferenceType);$/;"	p	class:WTF::HashMap	access:private	signature:(const KeyType&, MappedPassInReferenceType)
WTF::HashMap::inlineAdd	.\RefPtrHashMap.h	/^    HashMap<RefPtr<T>, U, V, W, X>::inlineAdd(RawKeyType key, MappedPassInReferenceType mapped) $/;"	f	class:WTF::HashMap	signature:(RawKeyType key, MappedPassInReferenceType mapped)
WTF::HashMap::inlineAdd	.\RefPtrHashMap.h	/^    HashMap<RefPtr<T>, U, V, W, X>::inlineAdd(const KeyType& key, MappedPassInReferenceType mapped) $/;"	f	class:WTF::HashMap	signature:(const KeyType& key, MappedPassInReferenceType mapped)
WTF::HashMap::inlineGet	.\RefPtrHashMap.h	/^        MappedPeekType inlineGet(RawKeyType) const;$/;"	p	class:WTF::HashMap	access:public	signature:(RawKeyType) const
WTF::HashMap::isEmpty	.\HashMap.h	/^        bool isEmpty() const;$/;"	p	class:WTF::HashMap	access:public	signature:() const
WTF::HashMap::isEmpty	.\HashMap.h	/^    inline bool HashMap<T, U, V, W, X>::isEmpty() const$/;"	f	class:WTF::HashMap	signature:() const
WTF::HashMap::isEmpty	.\RefPtrHashMap.h	/^        bool isEmpty() const;$/;"	p	class:WTF::HashMap	access:public	signature:() const
WTF::HashMap::isEmpty	.\RefPtrHashMap.h	/^    inline bool HashMap<RefPtr<T>, U, V, W, X>::isEmpty() const$/;"	f	class:WTF::HashMap	signature:() const
WTF::HashMap::iterator	.\HashMap.h	/^        typedef HashTableIteratorAdapter<HashTableType, ValueType> iterator;$/;"	t	class:WTF::HashMap	access:public
WTF::HashMap::iterator	.\RefPtrHashMap.h	/^        typedef HashTableIteratorAdapter<HashTableType, ValueType> iterator;$/;"	t	class:WTF::HashMap	access:public
WTF::HashMap::keys	.\HashMap.h	/^        HashMapKeysProxy& keys() { return static_cast<HashMapKeysProxy&>(*this); }$/;"	f	class:WTF::HashMap	access:public	signature:()
WTF::HashMap::keys	.\HashMap.h	/^        const HashMapKeysProxy& keys() const { return static_cast<const HashMapKeysProxy&>(*this); }$/;"	f	class:WTF::HashMap	access:public	signature:() const
WTF::HashMap::m_impl	.\HashMap.h	/^        HashTableType m_impl;$/;"	m	class:WTF::HashMap	access:private
WTF::HashMap::m_impl	.\RefPtrHashMap.h	/^        HashTableType m_impl;$/;"	m	class:WTF::HashMap	access:private
WTF::HashMap::remove	.\HashMap.h	/^        void remove(const KeyType&);$/;"	p	class:WTF::HashMap	access:public	signature:(const KeyType&)
WTF::HashMap::remove	.\HashMap.h	/^        void remove(iterator);$/;"	p	class:WTF::HashMap	access:public	signature:(iterator)
WTF::HashMap::remove	.\HashMap.h	/^    inline void HashMap<T, U, V, W, X>::remove(const KeyType& key)$/;"	f	class:WTF::HashMap	signature:(const KeyType& key)
WTF::HashMap::remove	.\HashMap.h	/^    inline void HashMap<T, U, V, W, X>::remove(iterator it)$/;"	f	class:WTF::HashMap	signature:(iterator it)
WTF::HashMap::remove	.\RefPtrHashMap.h	/^        void remove(RawKeyType);$/;"	p	class:WTF::HashMap	access:public	signature:(RawKeyType)
WTF::HashMap::remove	.\RefPtrHashMap.h	/^        void remove(const KeyType&);$/;"	p	class:WTF::HashMap	access:public	signature:(const KeyType&)
WTF::HashMap::remove	.\RefPtrHashMap.h	/^        void remove(iterator);$/;"	p	class:WTF::HashMap	access:public	signature:(iterator)
WTF::HashMap::remove	.\RefPtrHashMap.h	/^    inline void HashMap<RefPtr<T>, U, V, W, X>::remove(RawKeyType key)$/;"	f	class:WTF::HashMap	signature:(RawKeyType key)
WTF::HashMap::remove	.\RefPtrHashMap.h	/^    inline void HashMap<RefPtr<T>, U, V, W, X>::remove(const KeyType& key)$/;"	f	class:WTF::HashMap	signature:(const KeyType& key)
WTF::HashMap::remove	.\RefPtrHashMap.h	/^    inline void HashMap<RefPtr<T>, U, V, W, X>::remove(iterator it)$/;"	f	class:WTF::HashMap	signature:(iterator it)
WTF::HashMap::set	.\HashMap.h	/^        pair<iterator, bool> set(const KeyType&, MappedPassInType); $/;"	p	class:WTF::HashMap	access:public	signature:(const KeyType&, MappedPassInType)
WTF::HashMap::set	.\HashMap.h	/^    HashMap<T, U, V, W, X>::set(const KeyType& key, MappedPassInType mapped) $/;"	f	class:WTF::HashMap	signature:(const KeyType& key, MappedPassInType mapped)
WTF::HashMap::set	.\RefPtrHashMap.h	/^        pair<iterator, bool> set(RawKeyType, MappedPassInType); $/;"	p	class:WTF::HashMap	access:public	signature:(RawKeyType, MappedPassInType)
WTF::HashMap::set	.\RefPtrHashMap.h	/^        pair<iterator, bool> set(const KeyType&, MappedPassInType); $/;"	p	class:WTF::HashMap	access:public	signature:(const KeyType&, MappedPassInType)
WTF::HashMap::set	.\RefPtrHashMap.h	/^    HashMap<RefPtr<T>, U, V, W, X>::set(RawKeyType key, MappedPassInType mapped) $/;"	f	class:WTF::HashMap	signature:(RawKeyType key, MappedPassInType mapped)
WTF::HashMap::set	.\RefPtrHashMap.h	/^    HashMap<RefPtr<T>, U, V, W, X>::set(const KeyType& key, MappedPassInType mapped) $/;"	f	class:WTF::HashMap	signature:(const KeyType& key, MappedPassInType mapped)
WTF::HashMap::size	.\HashMap.h	/^        int size() const;$/;"	p	class:WTF::HashMap	access:public	signature:() const
WTF::HashMap::size	.\HashMap.h	/^    inline int HashMap<T, U, V, W, X>::size() const$/;"	f	class:WTF::HashMap	signature:() const
WTF::HashMap::size	.\RefPtrHashMap.h	/^        int size() const;$/;"	p	class:WTF::HashMap	access:public	signature:() const
WTF::HashMap::size	.\RefPtrHashMap.h	/^    inline int HashMap<RefPtr<T>, U, V, W, X>::size() const$/;"	f	class:WTF::HashMap	signature:() const
WTF::HashMap::swap	.\HashMap.h	/^        void swap(HashMap&);$/;"	p	class:WTF::HashMap	access:public	signature:(HashMap&)
WTF::HashMap::swap	.\HashMap.h	/^    inline void HashMap<T, U, V, W, X>::swap(HashMap& other)$/;"	f	class:WTF::HashMap	signature:(HashMap& other)
WTF::HashMap::swap	.\RefPtrHashMap.h	/^        void swap(HashMap&);$/;"	p	class:WTF::HashMap	access:public	signature:(HashMap&)
WTF::HashMap::swap	.\RefPtrHashMap.h	/^    inline void HashMap<RefPtr<T>, U, V, W, X>::swap(HashMap& other)$/;"	f	class:WTF::HashMap	signature:(HashMap& other)
WTF::HashMap::take	.\HashMap.h	/^        MappedPassOutType take(const KeyType&); \/\/ efficient combination of get with remove$/;"	p	class:WTF::HashMap	access:public	signature:(const KeyType&)
WTF::HashMap::take	.\HashMap.h	/^    HashMap<T, U, V, W, MappedTraits>::take(const KeyType& key)$/;"	f	class:WTF::HashMap	signature:(const KeyType& key)
WTF::HashMap::take	.\RefPtrHashMap.h	/^        MappedPassOutType take(RawKeyType); \/\/ efficient combination of get with remove$/;"	p	class:WTF::HashMap	access:public	signature:(RawKeyType)
WTF::HashMap::take	.\RefPtrHashMap.h	/^        MappedPassOutType take(const KeyType&); \/\/ efficient combination of get with remove$/;"	p	class:WTF::HashMap	access:public	signature:(const KeyType&)
WTF::HashMap::take	.\RefPtrHashMap.h	/^    HashMap<RefPtr<T>, U, V, W, MappedTraits>::take(RawKeyType key)$/;"	f	class:WTF::HashMap	signature:(RawKeyType key)
WTF::HashMap::take	.\RefPtrHashMap.h	/^    HashMap<RefPtr<T>, U, V, W, MappedTraits>::take(const KeyType& key)$/;"	f	class:WTF::HashMap	signature:(const KeyType& key)
WTF::HashMap::values	.\HashMap.h	/^        HashMapValuesProxy& values() { return static_cast<HashMapValuesProxy&>(*this); }$/;"	f	class:WTF::HashMap	access:public	signature:()
WTF::HashMap::values	.\HashMap.h	/^        const HashMapValuesProxy& values() const { return static_cast<const HashMapValuesProxy&>(*this); }$/;"	f	class:WTF::HashMap	access:public	signature:() const
WTF::HashMapTranslator	.\HashMap.h	/^    struct HashMapTranslator {$/;"	s	namespace:WTF
WTF::HashMapTranslator::equal	.\HashMap.h	/^        template<typename T, typename U> static bool equal(const T& a, const U& b) { return HashFunctions::equal(a, b); }$/;"	f	struct:WTF::HashMapTranslator	access:public	signature:(const T& a, const U& b)
WTF::HashMapTranslator::hash	.\HashMap.h	/^        template<typename T> static unsigned hash(const T& key) { return HashFunctions::hash(key); }$/;"	f	struct:WTF::HashMapTranslator	access:public	signature:(const T& key)
WTF::HashMapTranslator::translate	.\HashMap.h	/^        template<typename T, typename U, typename V> static void translate(T& location, const U& key, const V& mapped)$/;"	f	struct:WTF::HashMapTranslator	access:public	signature:(T& location, const U& key, const V& mapped)
WTF::HashMapTranslatorAdapter	.\HashMap.h	/^    struct HashMapTranslatorAdapter {$/;"	s	namespace:WTF
WTF::HashMapTranslatorAdapter::equal	.\HashMap.h	/^        template<typename T, typename U> static bool equal(const T& a, const U& b) { return Translator::equal(a, b); }$/;"	f	struct:WTF::HashMapTranslatorAdapter	access:public	signature:(const T& a, const U& b)
WTF::HashMapTranslatorAdapter::hash	.\HashMap.h	/^        template<typename T> static unsigned hash(const T& key) { return Translator::hash(key); }$/;"	f	struct:WTF::HashMapTranslatorAdapter	access:public	signature:(const T& key)
WTF::HashMapTranslatorAdapter::translate	.\HashMap.h	/^        template<typename T, typename U, typename V> static void translate(T& location, const U& key, const V& mapped, unsigned hashCode)$/;"	f	struct:WTF::HashMapTranslatorAdapter	access:public	signature:(T& location, const U& key, const V& mapped, unsigned hashCode)
WTF::HashSet	.\HashSet.h	/^        typename TraitsArg = HashTraits<ValueArg> > class HashSet {$/;"	c	namespace:WTF
WTF::HashSet::HashFunctions	.\HashSet.h	/^        typedef HashArg HashFunctions;$/;"	t	class:WTF::HashSet	access:private
WTF::HashSet::HashSet::find	.\HashSet.h	/^    inline HashSet<Value, HashFunctions, Traits>::find(const T& value) const$/;"	f	class:WTF::HashSet::HashSet	signature:(const T& value) const
WTF::HashSet::HashTableType	.\HashSet.h	/^            HashFunctions, ValueTraits, ValueTraits> HashTableType;$/;"	t	class:WTF::HashSet	access:private
WTF::HashSet::ValueTraits	.\HashSet.h	/^        typedef TraitsArg ValueTraits;$/;"	t	class:WTF::HashSet	access:private
WTF::HashSet::ValueType	.\HashSet.h	/^        typedef typename ValueTraits::TraitType ValueType;$/;"	t	class:WTF::HashSet	access:public
WTF::HashSet::WTF_MAKE_FAST_ALLOCATED	.\HashSet.h	/^        WTF_MAKE_FAST_ALLOCATED;$/;"	m	class:WTF::HashSet	access:private
WTF::HashSet::add	.\HashSet.h	/^        pair<iterator, bool> add(const ValueType&);$/;"	p	class:WTF::HashSet	access:public	signature:(const ValueType&)
WTF::HashSet::add	.\HashSet.h	/^        template<typename T, typename HashTranslator> pair<iterator, bool> add(const T&);$/;"	p	class:WTF::HashSet	access:public	signature:(const T&)
WTF::HashSet::add	.\HashSet.h	/^    HashSet<Value, HashFunctions, Traits>::add(const T& value)$/;"	f	class:WTF::HashSet	signature:(const T& value)
WTF::HashSet::add	.\HashSet.h	/^    inline pair<typename HashSet<T, U, V>::iterator, bool> HashSet<T, U, V>::add(const ValueType& value)$/;"	f	class:WTF::HashSet	signature:(const ValueType& value)
WTF::HashSet::begin	.\HashSet.h	/^        iterator begin() const;$/;"	p	class:WTF::HashSet	access:public	signature:() const
WTF::HashSet::begin	.\HashSet.h	/^    inline typename HashSet<T, U, V>::iterator HashSet<T, U, V>::begin() const$/;"	f	class:WTF::HashSet	signature:() const
WTF::HashSet::capacity	.\HashSet.h	/^        int capacity() const;$/;"	p	class:WTF::HashSet	access:public	signature:() const
WTF::HashSet::capacity	.\HashSet.h	/^    inline int HashSet<T, U, V>::capacity() const$/;"	f	class:WTF::HashSet	signature:() const
WTF::HashSet::clear	.\HashSet.h	/^        void clear();$/;"	p	class:WTF::HashSet	access:public	signature:()
WTF::HashSet::clear	.\HashSet.h	/^    inline void HashSet<T, U, V>::clear()$/;"	f	class:WTF::HashSet	signature:()
WTF::HashSet::const_iterator	.\HashSet.h	/^        typedef HashTableConstIteratorAdapter<HashTableType, ValueType> const_iterator;$/;"	t	class:WTF::HashSet	access:public
WTF::HashSet::contains	.\HashSet.h	/^        bool contains(const ValueType&) const;$/;"	p	class:WTF::HashSet	access:public	signature:(const ValueType&) const
WTF::HashSet::contains	.\HashSet.h	/^        template<typename T, typename HashTranslator> bool contains(const T&) const;$/;"	p	class:WTF::HashSet	access:public	signature:(const T&) const
WTF::HashSet::contains	.\HashSet.h	/^    inline bool HashSet<T, U, V>::contains(const ValueType& value) const$/;"	f	class:WTF::HashSet	signature:(const ValueType& value) const
WTF::HashSet::contains	.\HashSet.h	/^    inline bool HashSet<Value, HashFunctions, Traits>::contains(const T& value) const$/;"	f	class:WTF::HashSet	signature:(const T& value) const
WTF::HashSet::deleteAllValues	.\HashSet.h	/^        friend void deleteAllValues<>(const HashSet&);$/;"	p	class:WTF::HashSet	access:friend	signature:(const HashSet&)
WTF::HashSet::end	.\HashSet.h	/^        iterator end() const;$/;"	p	class:WTF::HashSet	access:public	signature:() const
WTF::HashSet::end	.\HashSet.h	/^    inline typename HashSet<T, U, V>::iterator HashSet<T, U, V>::end() const$/;"	f	class:WTF::HashSet	signature:() const
WTF::HashSet::fastDeleteAllValues	.\HashSet.h	/^        friend void fastDeleteAllValues<>(const HashSet&);$/;"	p	class:WTF::HashSet	access:friend	signature:(const HashSet&)
WTF::HashSet::find	.\HashSet.h	/^        iterator find(const ValueType&) const;$/;"	p	class:WTF::HashSet	access:public	signature:(const ValueType&) const
WTF::HashSet::find	.\HashSet.h	/^        template<typename T, typename HashTranslator> iterator find(const T&) const;$/;"	p	class:WTF::HashSet	access:public	signature:(const T&) const
WTF::HashSet::find	.\HashSet.h	/^    inline typename HashSet<T, U, V>::iterator HashSet<T, U, V>::find(const ValueType& value) const$/;"	f	class:WTF::HashSet	signature:(const ValueType& value) const
WTF::HashSet::isEmpty	.\HashSet.h	/^        bool isEmpty() const;$/;"	p	class:WTF::HashSet	access:public	signature:() const
WTF::HashSet::isEmpty	.\HashSet.h	/^    inline bool HashSet<T, U, V>::isEmpty() const$/;"	f	class:WTF::HashSet	signature:() const
WTF::HashSet::iterator	.\HashSet.h	/^        typedef HashTableConstIteratorAdapter<HashTableType, ValueType> iterator;$/;"	t	class:WTF::HashSet	access:public
WTF::HashSet::m_impl	.\HashSet.h	/^        HashTableType m_impl;$/;"	m	class:WTF::HashSet	access:private
WTF::HashSet::remove	.\HashSet.h	/^        void remove(const ValueType&);$/;"	p	class:WTF::HashSet	access:public	signature:(const ValueType&)
WTF::HashSet::remove	.\HashSet.h	/^        void remove(iterator);$/;"	p	class:WTF::HashSet	access:public	signature:(iterator)
WTF::HashSet::remove	.\HashSet.h	/^    inline void HashSet<T, U, V>::remove(const ValueType& value)$/;"	f	class:WTF::HashSet	signature:(const ValueType& value)
WTF::HashSet::remove	.\HashSet.h	/^    inline void HashSet<T, U, V>::remove(iterator it)$/;"	f	class:WTF::HashSet	signature:(iterator it)
WTF::HashSet::size	.\HashSet.h	/^        int size() const;$/;"	p	class:WTF::HashSet	access:public	signature:() const
WTF::HashSet::size	.\HashSet.h	/^    inline int HashSet<T, U, V>::size() const$/;"	f	class:WTF::HashSet	signature:() const
WTF::HashSet::swap	.\HashSet.h	/^        void swap(HashSet&);$/;"	p	class:WTF::HashSet	access:public	signature:(HashSet&)
WTF::HashSet::swap	.\HashSet.h	/^    inline void HashSet<T, U, V>::swap(HashSet& other)$/;"	f	class:WTF::HashSet	signature:(HashSet& other)
WTF::HashSetTranslatorAdapter	.\HashSet.h	/^    struct HashSetTranslatorAdapter {$/;"	s	namespace:WTF
WTF::HashSetTranslatorAdapter::equal	.\HashSet.h	/^        template<typename T, typename U> static bool equal(const T& a, const U& b) { return Translator::equal(a, b); }$/;"	f	struct:WTF::HashSetTranslatorAdapter	access:public	signature:(const T& a, const U& b)
WTF::HashSetTranslatorAdapter::hash	.\HashSet.h	/^        template<typename T> static unsigned hash(const T& key) { return Translator::hash(key); }$/;"	f	struct:WTF::HashSetTranslatorAdapter	access:public	signature:(const T& key)
WTF::HashSetTranslatorAdapter::translate	.\HashSet.h	/^        template<typename T, typename U> static void translate(T& location, const U& key, const U&, unsigned hashCode)$/;"	f	struct:WTF::HashSetTranslatorAdapter	access:public	signature:(T& location, const U& key, const U&, unsigned hashCode)
WTF::HashTable	.\HashTable.h	/^    class HashTable {$/;"	c	namespace:WTF
WTF::HashTable::FullLookupType	.\HashTable.h	/^        typedef pair<LookupType, unsigned> FullLookupType;$/;"	t	class:WTF::HashTable	access:private
WTF::HashTable::HashTable	.\HashTable.h	/^        HashTable();$/;"	p	class:WTF::HashTable	access:public	signature:()
WTF::HashTable::HashTable	.\HashTable.h	/^        HashTable(const HashTable&);$/;"	p	class:WTF::HashTable	access:public	signature:(const HashTable&)
WTF::HashTable::HashTable	.\HashTable.h	/^    HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::HashTable(const HashTable& other)$/;"	f	class:WTF::HashTable	signature:(const HashTable& other)
WTF::HashTable::HashTable	.\HashTable.h	/^    inline HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::HashTable()$/;"	f	class:WTF::HashTable	signature:()
WTF::HashTable::IdentityTranslatorType	.\HashTable.h	/^        typedef IdentityHashTranslator<HashFunctions> IdentityTranslatorType;$/;"	t	class:WTF::HashTable	access:public
WTF::HashTable::KeyType	.\HashTable.h	/^        typedef Key KeyType;$/;"	t	class:WTF::HashTable	access:public
WTF::HashTable::LookupType	.\HashTable.h	/^        typedef pair<ValueType*, bool> LookupType;$/;"	t	class:WTF::HashTable	access:private
WTF::HashTable::ValueTraits	.\HashTable.h	/^        typedef Traits ValueTraits;$/;"	t	class:WTF::HashTable	access:public
WTF::HashTable::ValueType	.\HashTable.h	/^        typedef Value ValueType;$/;"	t	class:WTF::HashTable	access:public
WTF::HashTable::add	.\HashTable.h	/^        pair<iterator, bool> add(const ValueType& value) { return add<IdentityTranslatorType>(Extractor::extract(value), value); }$/;"	f	class:WTF::HashTable	access:public	signature:(const ValueType& value)
WTF::HashTable::add	.\HashTable.h	/^        template<typename HashTranslator, typename T, typename Extra> pair<iterator, bool> add(const T& key, const Extra&);$/;"	p	class:WTF::HashTable	access:public	signature:(const T& key, const Extra&)
WTF::HashTable::add	.\HashTable.h	/^    inline pair<typename HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::iterator, bool> HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::add(const T& key, const Extra& extra)$/;"	f	class:WTF::HashTable	signature:(const T& key, const Extra& extra)
WTF::HashTable::addPassingHashCode	.\HashTable.h	/^        template<typename HashTranslator, typename T, typename Extra> pair<iterator, bool> addPassingHashCode(const T& key, const Extra&);$/;"	p	class:WTF::HashTable	access:public	signature:(const T& key, const Extra&)
WTF::HashTable::addPassingHashCode	.\HashTable.h	/^    inline pair<typename HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::iterator, bool> HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::addPassingHashCode(const T& key, const Extra& extra)$/;"	f	class:WTF::HashTable	signature:(const T& key, const Extra& extra)
WTF::HashTable::allocateTable	.\HashTable.h	/^        static ValueType* allocateTable(int size);$/;"	p	class:WTF::HashTable	access:private	signature:(int size)
WTF::HashTable::allocateTable	.\HashTable.h	/^    Value* HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::allocateTable(int size)$/;"	f	class:WTF::HashTable	signature:(int size)
WTF::HashTable::begin	.\HashTable.h	/^        const_iterator begin() const { return makeConstIterator(m_table); }$/;"	f	class:WTF::HashTable	access:public	signature:() const
WTF::HashTable::begin	.\HashTable.h	/^        iterator begin() { return makeIterator(m_table); }$/;"	f	class:WTF::HashTable	access:public	signature:()
WTF::HashTable::capacity	.\HashTable.h	/^        int capacity() const { return m_tableSize; }$/;"	f	class:WTF::HashTable	access:public	signature:() const
WTF::HashTable::checkKey	.\HashTable.h	/^        template<typename HashTranslator, typename T> void checkKey(const T&);$/;"	p	class:WTF::HashTable	access:private	signature:(const T&)
WTF::HashTable::checkKey	.\HashTable.h	/^    inline void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::checkKey(const T&)$/;"	f	class:WTF::HashTable	signature:(const T&)
WTF::HashTable::checkKey	.\HashTable.h	/^    void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::checkKey(const T& key)$/;"	f	class:WTF::HashTable	signature:(const T& key)
WTF::HashTable::checkTableConsistency	.\HashTable.h	/^        static void checkTableConsistency() { }$/;"	f	class:WTF::HashTable	access:public	signature:()
WTF::HashTable::checkTableConsistency	.\HashTable.h	/^        void checkTableConsistency() const;$/;"	p	class:WTF::HashTable	access:public	signature:() const
WTF::HashTable::checkTableConsistency	.\HashTable.h	/^    void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::checkTableConsistency() const$/;"	f	class:WTF::HashTable	signature:() const
WTF::HashTable::checkTableConsistencyExceptSize	.\HashTable.h	/^        static void checkTableConsistencyExceptSize() { }$/;"	f	class:WTF::HashTable	access:private	signature:()
WTF::HashTable::checkTableConsistencyExceptSize	.\HashTable.h	/^        void checkTableConsistencyExceptSize() const;$/;"	p	class:WTF::HashTable	access:private	signature:() const
WTF::HashTable::checkTableConsistencyExceptSize	.\HashTable.h	/^    void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::checkTableConsistencyExceptSize() const$/;"	f	class:WTF::HashTable	signature:() const
WTF::HashTable::clear	.\HashTable.h	/^        void clear();$/;"	p	class:WTF::HashTable	access:public	signature:()
WTF::HashTable::clear	.\HashTable.h	/^    void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::clear()$/;"	f	class:WTF::HashTable	signature:()
WTF::HashTable::const_iterator	.\HashTable.h	/^        typedef HashTableConstIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits> const_iterator;$/;"	t	class:WTF::HashTable	access:public
WTF::HashTable::contains	.\HashTable.h	/^        bool contains(const KeyType& key) const { return contains<IdentityTranslatorType>(key); }$/;"	f	class:WTF::HashTable	access:public	signature:(const KeyType& key) const
WTF::HashTable::contains	.\HashTable.h	/^        template<typename HashTranslator, typename T> bool contains(const T&) const;$/;"	p	class:WTF::HashTable	access:public	signature:(const T&) const
WTF::HashTable::contains	.\HashTable.h	/^    bool HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::contains(const T& key) const$/;"	f	class:WTF::HashTable	signature:(const T& key) const
WTF::HashTable::deallocateTable	.\HashTable.h	/^        static void deallocateTable(ValueType* table, int size);$/;"	p	class:WTF::HashTable	access:private	signature:(ValueType* table, int size)
WTF::HashTable::deallocateTable	.\HashTable.h	/^    void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::deallocateTable(ValueType* table, int size)$/;"	f	class:WTF::HashTable	signature:(ValueType* table, int size)
WTF::HashTable::deleteBucket	.\HashTable.h	/^        static void deleteBucket(ValueType& bucket) { bucket.~ValueType(); Traits::constructDeletedValue(bucket); }$/;"	f	class:WTF::HashTable	access:private	signature:(ValueType& bucket)
WTF::HashTable::end	.\HashTable.h	/^        const_iterator end() const { return makeKnownGoodConstIterator(m_table + m_tableSize); }$/;"	f	class:WTF::HashTable	access:public	signature:() const
WTF::HashTable::end	.\HashTable.h	/^        iterator end() { return makeKnownGoodIterator(m_table + m_tableSize); }$/;"	f	class:WTF::HashTable	access:public	signature:()
WTF::HashTable::expand	.\HashTable.h	/^        void expand();$/;"	p	class:WTF::HashTable	access:private	signature:()
WTF::HashTable::expand	.\HashTable.h	/^    void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::expand()$/;"	f	class:WTF::HashTable	signature:()
WTF::HashTable::find	.\HashTable.h	/^        const_iterator find(const KeyType& key) const { return find<IdentityTranslatorType>(key); }$/;"	f	class:WTF::HashTable	access:public	signature:(const KeyType& key) const
WTF::HashTable::find	.\HashTable.h	/^        iterator find(const KeyType& key) { return find<IdentityTranslatorType>(key); }$/;"	f	class:WTF::HashTable	access:public	signature:(const KeyType& key)
WTF::HashTable::find	.\HashTable.h	/^        template<typename HashTranslator, typename T> const_iterator find(const T&) const;$/;"	p	class:WTF::HashTable	access:public	signature:(const T&) const
WTF::HashTable::find	.\HashTable.h	/^        template<typename HashTranslator, typename T> iterator find(const T&);$/;"	p	class:WTF::HashTable	access:public	signature:(const T&)
WTF::HashTable::find	.\HashTable.h	/^    typename HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::const_iterator HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::find(const T& key) const$/;"	f	class:WTF::HashTable	signature:(const T& key) const
WTF::HashTable::find	.\HashTable.h	/^    typename HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::iterator HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::find(const T& key)$/;"	f	class:WTF::HashTable	signature:(const T& key)
WTF::HashTable::fullLookupForWriting	.\HashTable.h	/^        template<typename HashTranslator, typename T> FullLookupType fullLookupForWriting(const T&);$/;"	p	class:WTF::HashTable	access:private	signature:(const T&)
WTF::HashTable::fullLookupForWriting	.\HashTable.h	/^    inline typename HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::FullLookupType HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::fullLookupForWriting(const T& key)$/;"	f	class:WTF::HashTable	signature:(const T& key)
WTF::HashTable::initializeBucket	.\HashTable.h	/^        static void initializeBucket(ValueType& bucket);$/;"	p	class:WTF::HashTable	access:private	signature:(ValueType& bucket)
WTF::HashTable::initializeBucket	.\HashTable.h	/^    inline void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::initializeBucket(ValueType& bucket)$/;"	f	class:WTF::HashTable	signature:(ValueType& bucket)
WTF::HashTable::internalCheckTableConsistency	.\HashTable.h	/^        static void internalCheckTableConsistency() { }$/;"	f	class:WTF::HashTable	access:public	signature:()
WTF::HashTable::internalCheckTableConsistency	.\HashTable.h	/^        void internalCheckTableConsistency() const { checkTableConsistency(); }$/;"	f	class:WTF::HashTable	access:public	signature:() const
WTF::HashTable::internalCheckTableConsistencyExceptSize	.\HashTable.h	/^        static void internalCheckTableConsistencyExceptSize() { }$/;"	f	class:WTF::HashTable	access:public	signature:()
WTF::HashTable::internalCheckTableConsistencyExceptSize	.\HashTable.h	/^        void internalCheckTableConsistencyExceptSize() const { checkTableConsistencyExceptSize(); }$/;"	f	class:WTF::HashTable	access:public	signature:() const
WTF::HashTable::invalidateIterators	.\HashTable.h	/^        static void invalidateIterators() { }$/;"	f	class:WTF::HashTable	access:private	signature:()
WTF::HashTable::invalidateIterators	.\HashTable.h	/^        void invalidateIterators();$/;"	p	class:WTF::HashTable	access:private	signature:()
WTF::HashTable::invalidateIterators	.\HashTable.h	/^    void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::invalidateIterators()$/;"	f	class:WTF::HashTable	signature:()
WTF::HashTable::isDeletedBucket	.\HashTable.h	/^        static bool isDeletedBucket(const ValueType& value) { return KeyTraits::isDeletedValue(Extractor::extract(value)); }$/;"	f	class:WTF::HashTable	access:public	signature:(const ValueType& value)
WTF::HashTable::isEmpty	.\HashTable.h	/^        bool isEmpty() const { return !m_keyCount; }$/;"	f	class:WTF::HashTable	access:public	signature:() const
WTF::HashTable::isEmptyBucket	.\HashTable.h	/^        static bool isEmptyBucket(const ValueType& value) { return Extractor::extract(value) == KeyTraits::emptyValue(); }$/;"	f	class:WTF::HashTable	access:public	signature:(const ValueType& value)
WTF::HashTable::isEmptyOrDeletedBucket	.\HashTable.h	/^        static bool isEmptyOrDeletedBucket(const ValueType& value) { return isEmptyBucket(value) || isDeletedBucket(value); }$/;"	f	class:WTF::HashTable	access:public	signature:(const ValueType& value)
WTF::HashTable::iterator	.\HashTable.h	/^        typedef HashTableIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits> iterator;$/;"	t	class:WTF::HashTable	access:public
WTF::HashTable::lookup	.\HashTable.h	/^        ValueType* lookup(const Key& key) { return lookup<IdentityTranslatorType>(key); }$/;"	f	class:WTF::HashTable	access:public	signature:(const Key& key)
WTF::HashTable::lookup	.\HashTable.h	/^        template<typename HashTranslator, typename T> ValueType* lookup(const T&);$/;"	p	class:WTF::HashTable	access:public	signature:(const T&)
WTF::HashTable::lookup	.\HashTable.h	/^    inline Value* HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::lookup(const T& key)$/;"	f	class:WTF::HashTable	signature:(const T& key)
WTF::HashTable::lookupForWriting	.\HashTable.h	/^        LookupType lookupForWriting(const Key& key) { return lookupForWriting<IdentityTranslatorType>(key); };$/;"	f	class:WTF::HashTable	access:private	signature:(const Key& key)
WTF::HashTable::lookupForWriting	.\HashTable.h	/^        template<typename HashTranslator, typename T> LookupType lookupForWriting(const T&);$/;"	p	class:WTF::HashTable	access:private	signature:(const T&)
WTF::HashTable::lookupForWriting	.\HashTable.h	/^    inline typename HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::LookupType HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::lookupForWriting(const T& key)$/;"	f	class:WTF::HashTable	signature:(const T& key)
WTF::HashTable::m_deletedCount	.\HashTable.h	/^        int m_deletedCount;$/;"	m	class:WTF::HashTable	access:private
WTF::HashTable::m_iterators	.\HashTable.h	/^        mutable const_iterator* m_iterators;$/;"	m	class:WTF::HashTable	access:public
WTF::HashTable::m_keyCount	.\HashTable.h	/^        int m_keyCount;$/;"	m	class:WTF::HashTable	access:private
WTF::HashTable::m_maxLoad	.\HashTable.h	/^        static const int m_maxLoad = 2;$/;"	m	class:WTF::HashTable	access:private
WTF::HashTable::m_minLoad	.\HashTable.h	/^        static const int m_minLoad = 6;$/;"	m	class:WTF::HashTable	access:private
WTF::HashTable::m_mutex	.\HashTable.h	/^        mutable Mutex m_mutex;$/;"	m	class:WTF::HashTable	access:public
WTF::HashTable::m_table	.\HashTable.h	/^        ValueType* m_table;$/;"	m	class:WTF::HashTable	access:private
WTF::HashTable::m_tableSize	.\HashTable.h	/^        int m_tableSize;$/;"	m	class:WTF::HashTable	access:private
WTF::HashTable::m_tableSizeMask	.\HashTable.h	/^        int m_tableSizeMask;$/;"	m	class:WTF::HashTable	access:private
WTF::HashTable::makeConstIterator	.\HashTable.h	/^        const_iterator makeConstIterator(ValueType* pos) const { return const_iterator(this, pos, m_table + m_tableSize); }$/;"	f	class:WTF::HashTable	access:private	signature:(ValueType* pos) const
WTF::HashTable::makeIterator	.\HashTable.h	/^        iterator makeIterator(ValueType* pos) { return iterator(this, pos, m_table + m_tableSize); }$/;"	f	class:WTF::HashTable	access:private	signature:(ValueType* pos)
WTF::HashTable::makeKnownGoodConstIterator	.\HashTable.h	/^        const_iterator makeKnownGoodConstIterator(ValueType* pos) const { return const_iterator(this, pos, m_table + m_tableSize, HashItemKnownGood); }$/;"	f	class:WTF::HashTable	access:private	signature:(ValueType* pos) const
WTF::HashTable::makeKnownGoodIterator	.\HashTable.h	/^        iterator makeKnownGoodIterator(ValueType* pos) { return iterator(this, pos, m_table + m_tableSize, HashItemKnownGood); }$/;"	f	class:WTF::HashTable	access:private	signature:(ValueType* pos)
WTF::HashTable::makeLookupResult	.\HashTable.h	/^        FullLookupType makeLookupResult(ValueType* position, bool found, unsigned hash)$/;"	f	class:WTF::HashTable	access:private	signature:(ValueType* position, bool found, unsigned hash)
WTF::HashTable::mustRehashInPlace	.\HashTable.h	/^        bool mustRehashInPlace() const { return m_keyCount * m_minLoad < m_tableSize * 2; }$/;"	f	class:WTF::HashTable	access:private	signature:() const
WTF::HashTable::operator =	.\HashTable.h	/^        HashTable& operator=(const HashTable&);$/;"	p	class:WTF::HashTable	access:public	signature:(const HashTable&)
WTF::HashTable::operator =	.\HashTable.h	/^    HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>& HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::operator=(const HashTable& other)$/;"	f	class:WTF::HashTable	signature:(const HashTable& other)
WTF::HashTable::rehash	.\HashTable.h	/^        void rehash(int newTableSize);$/;"	p	class:WTF::HashTable	access:private	signature:(int newTableSize)
WTF::HashTable::rehash	.\HashTable.h	/^    void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::rehash(int newTableSize)$/;"	f	class:WTF::HashTable	signature:(int newTableSize)
WTF::HashTable::reinsert	.\HashTable.h	/^        void reinsert(ValueType&);$/;"	p	class:WTF::HashTable	access:private	signature:(ValueType&)
WTF::HashTable::reinsert	.\HashTable.h	/^    inline void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::reinsert(ValueType& entry)$/;"	f	class:WTF::HashTable	signature:(ValueType& entry)
WTF::HashTable::remove	.\HashTable.h	/^        void remove(ValueType*);$/;"	p	class:WTF::HashTable	access:private	signature:(ValueType*)
WTF::HashTable::remove	.\HashTable.h	/^        void remove(const KeyType&);$/;"	p	class:WTF::HashTable	access:public	signature:(const KeyType&)
WTF::HashTable::remove	.\HashTable.h	/^        void remove(iterator);$/;"	p	class:WTF::HashTable	access:public	signature:(iterator)
WTF::HashTable::remove	.\HashTable.h	/^    inline void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::remove(const KeyType& key)$/;"	f	class:WTF::HashTable	signature:(const KeyType& key)
WTF::HashTable::remove	.\HashTable.h	/^    inline void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::remove(iterator it)$/;"	f	class:WTF::HashTable	signature:(iterator it)
WTF::HashTable::remove	.\HashTable.h	/^    void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::remove(ValueType* pos)$/;"	f	class:WTF::HashTable	signature:(ValueType* pos)
WTF::HashTable::removeAndInvalidate	.\HashTable.h	/^        void removeAndInvalidate(ValueType*);$/;"	p	class:WTF::HashTable	access:private	signature:(ValueType*)
WTF::HashTable::removeAndInvalidate	.\HashTable.h	/^    void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::removeAndInvalidate(ValueType* pos)$/;"	f	class:WTF::HashTable	signature:(ValueType* pos)
WTF::HashTable::removeAndInvalidateWithoutEntryConsistencyCheck	.\HashTable.h	/^        void removeAndInvalidateWithoutEntryConsistencyCheck(ValueType*);$/;"	p	class:WTF::HashTable	access:private	signature:(ValueType*)
WTF::HashTable::removeAndInvalidateWithoutEntryConsistencyCheck	.\HashTable.h	/^    void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::removeAndInvalidateWithoutEntryConsistencyCheck(ValueType* pos)$/;"	f	class:WTF::HashTable	signature:(ValueType* pos)
WTF::HashTable::removeWithoutEntryConsistencyCheck	.\HashTable.h	/^        void removeWithoutEntryConsistencyCheck(const_iterator);$/;"	p	class:WTF::HashTable	access:public	signature:(const_iterator)
WTF::HashTable::removeWithoutEntryConsistencyCheck	.\HashTable.h	/^        void removeWithoutEntryConsistencyCheck(iterator);$/;"	p	class:WTF::HashTable	access:public	signature:(iterator)
WTF::HashTable::removeWithoutEntryConsistencyCheck	.\HashTable.h	/^    inline void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::removeWithoutEntryConsistencyCheck(const_iterator it)$/;"	f	class:WTF::HashTable	signature:(const_iterator it)
WTF::HashTable::removeWithoutEntryConsistencyCheck	.\HashTable.h	/^    inline void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::removeWithoutEntryConsistencyCheck(iterator it)$/;"	f	class:WTF::HashTable	signature:(iterator it)
WTF::HashTable::shouldExpand	.\HashTable.h	/^        bool shouldExpand() const { return (m_keyCount + m_deletedCount) * m_maxLoad >= m_tableSize; }$/;"	f	class:WTF::HashTable	access:private	signature:() const
WTF::HashTable::shouldShrink	.\HashTable.h	/^        bool shouldShrink() const { return m_keyCount * m_minLoad < m_tableSize && m_tableSize > KeyTraits::minimumTableSize; }$/;"	f	class:WTF::HashTable	access:private	signature:() const
WTF::HashTable::shrink	.\HashTable.h	/^        void shrink() { rehash(m_tableSize \/ 2); }$/;"	f	class:WTF::HashTable	access:private	signature:()
WTF::HashTable::size	.\HashTable.h	/^        int size() const { return m_keyCount; }$/;"	f	class:WTF::HashTable	access:public	signature:() const
WTF::HashTable::swap	.\HashTable.h	/^        void swap(HashTable&);$/;"	p	class:WTF::HashTable	access:public	signature:(HashTable&)
WTF::HashTable::swap	.\HashTable.h	/^    void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::swap(HashTable& other)$/;"	f	class:WTF::HashTable	signature:(HashTable& other)
WTF::HashTable::~HashTable	.\HashTable.h	/^        ~HashTable() $/;"	f	class:WTF::HashTable	access:public	signature:()
WTF::HashTableBucketInitializer	.\HashTable.h	/^    template<> struct HashTableBucketInitializer<false> {$/;"	s	namespace:WTF
WTF::HashTableBucketInitializer	.\HashTable.h	/^    template<> struct HashTableBucketInitializer<true> {$/;"	s	namespace:WTF
WTF::HashTableBucketInitializer::initialize	.\HashTable.h	/^        template<typename Traits, typename Value> static void initialize(Value& bucket)$/;"	f	struct:WTF::HashTableBucketInitializer	access:public	signature:(Value& bucket)
WTF::HashTableConstIterator	.\HashTable.h	/^    class HashTableConstIterator {$/;"	c	namespace:WTF
WTF::HashTableConstIterator::HashTableConstIterator	.\HashTable.h	/^        HashTableConstIterator()$/;"	f	class:WTF::HashTableConstIterator	access:public	signature:()
WTF::HashTableConstIterator::HashTableConstIterator	.\HashTable.h	/^        HashTableConstIterator(const HashTableType* table, PointerType position, PointerType endPosition)$/;"	f	class:WTF::HashTableConstIterator	access:private	signature:(const HashTableType* table, PointerType position, PointerType endPosition)
WTF::HashTableConstIterator::HashTableConstIterator	.\HashTable.h	/^        HashTableConstIterator(const HashTableType* table, PointerType position, PointerType endPosition, HashItemKnownGoodTag)$/;"	f	class:WTF::HashTableConstIterator	access:private	signature:(const HashTableType* table, PointerType position, PointerType endPosition, HashItemKnownGoodTag)
WTF::HashTableConstIterator::HashTableConstIterator	.\HashTable.h	/^        HashTableConstIterator(const const_iterator& other)$/;"	f	class:WTF::HashTableConstIterator	access:public	signature:(const const_iterator& other)
WTF::HashTableConstIterator::HashTableType	.\HashTable.h	/^        typedef HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits> HashTableType;$/;"	t	class:WTF::HashTableConstIterator	access:private
WTF::HashTableConstIterator::PointerType	.\HashTable.h	/^        typedef const ValueType* PointerType;$/;"	t	class:WTF::HashTableConstIterator	access:private
WTF::HashTableConstIterator::ReferenceType	.\HashTable.h	/^        typedef const ValueType& ReferenceType;$/;"	t	class:WTF::HashTableConstIterator	access:private
WTF::HashTableConstIterator::ValueType	.\HashTable.h	/^        typedef Value ValueType;$/;"	t	class:WTF::HashTableConstIterator	access:private
WTF::HashTableConstIterator::checkValidity	.\HashTable.h	/^        void checkValidity() const$/;"	f	class:WTF::HashTableConstIterator	access:private	signature:() const
WTF::HashTableConstIterator::checkValidity	.\HashTable.h	/^        void checkValidity(const const_iterator& other) const$/;"	f	class:WTF::HashTableConstIterator	access:private	signature:(const const_iterator& other) const
WTF::HashTableConstIterator::checkValidity	.\HashTable.h	/^        void checkValidity(const const_iterator&) const { }$/;"	f	class:WTF::HashTableConstIterator	access:private	signature:(const const_iterator&) const
WTF::HashTableConstIterator::const_iterator	.\HashTable.h	/^        typedef HashTableConstIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits> const_iterator;$/;"	t	class:WTF::HashTableConstIterator	access:private
WTF::HashTableConstIterator::get	.\HashTable.h	/^        PointerType get() const$/;"	f	class:WTF::HashTableConstIterator	access:public	signature:() const
WTF::HashTableConstIterator::iterator	.\HashTable.h	/^        typedef HashTableIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits> iterator;$/;"	t	class:WTF::HashTableConstIterator	access:private
WTF::HashTableConstIterator::m_endPosition	.\HashTable.h	/^        PointerType m_endPosition;$/;"	m	class:WTF::HashTableConstIterator	access:private
WTF::HashTableConstIterator::m_next	.\HashTable.h	/^        mutable const_iterator* m_next;$/;"	m	class:WTF::HashTableConstIterator	access:public
WTF::HashTableConstIterator::m_position	.\HashTable.h	/^        PointerType m_position;$/;"	m	class:WTF::HashTableConstIterator	access:private
WTF::HashTableConstIterator::m_previous	.\HashTable.h	/^        mutable const_iterator* m_previous;$/;"	m	class:WTF::HashTableConstIterator	access:public
WTF::HashTableConstIterator::m_table	.\HashTable.h	/^        mutable const HashTableType* m_table;$/;"	m	class:WTF::HashTableConstIterator	access:public
WTF::HashTableConstIterator::operator !=	.\HashTable.h	/^        bool operator!=(const const_iterator& other) const$/;"	f	class:WTF::HashTableConstIterator	access:public	signature:(const const_iterator& other) const
WTF::HashTableConstIterator::operator !=	.\HashTable.h	/^        bool operator!=(const iterator& other) const$/;"	f	class:WTF::HashTableConstIterator	access:public	signature:(const iterator& other) const
WTF::HashTableConstIterator::operator *	.\HashTable.h	/^        ReferenceType operator*() const { return *get(); }$/;"	f	class:WTF::HashTableConstIterator	access:public	signature:() const
WTF::HashTableConstIterator::operator ++	.\HashTable.h	/^        const_iterator& operator++()$/;"	f	class:WTF::HashTableConstIterator	access:public	signature:()
WTF::HashTableConstIterator::operator ->	.\HashTable.h	/^        PointerType operator->() const { return get(); }$/;"	f	class:WTF::HashTableConstIterator	access:public	signature:() const
WTF::HashTableConstIterator::operator =	.\HashTable.h	/^        const_iterator& operator=(const const_iterator& other)$/;"	f	class:WTF::HashTableConstIterator	access:public	signature:(const const_iterator& other)
WTF::HashTableConstIterator::operator ==	.\HashTable.h	/^        bool operator==(const const_iterator& other) const$/;"	f	class:WTF::HashTableConstIterator	access:public	signature:(const const_iterator& other) const
WTF::HashTableConstIterator::operator ==	.\HashTable.h	/^        bool operator==(const iterator& other) const$/;"	f	class:WTF::HashTableConstIterator	access:public	signature:(const iterator& other) const
WTF::HashTableConstIterator::skipEmptyBuckets	.\HashTable.h	/^        void skipEmptyBuckets()$/;"	f	class:WTF::HashTableConstIterator	access:private	signature:()
WTF::HashTableConstIterator::~HashTableConstIterator	.\HashTable.h	/^        ~HashTableConstIterator()$/;"	f	class:WTF::HashTableConstIterator	access:public	signature:()
WTF::HashTableConstIteratorAdapter	.\HashIterators.h	/^    template<typename HashTableType, typename KeyType, typename MappedType> struct HashTableConstIteratorAdapter<HashTableType, std::pair<KeyType, MappedType> > {$/;"	s	namespace:WTF
WTF::HashTableConstIteratorAdapter	.\HashTable.h	/^    template<typename HashTableType, typename ValueType> struct HashTableConstIteratorAdapter {$/;"	s	namespace:WTF
WTF::HashTableConstIteratorAdapter::HashTableConstIteratorAdapter	.\HashIterators.h	/^        HashTableConstIteratorAdapter() {}$/;"	f	struct:WTF::HashTableConstIteratorAdapter	access:public	signature:()
WTF::HashTableConstIteratorAdapter::HashTableConstIteratorAdapter	.\HashIterators.h	/^        HashTableConstIteratorAdapter(const typename HashTableType::const_iterator& impl) : m_impl(impl) {}$/;"	f	struct:WTF::HashTableConstIteratorAdapter	access:public	signature:(const typename HashTableType::const_iterator& impl)
WTF::HashTableConstIteratorAdapter::HashTableConstIteratorAdapter	.\HashTable.h	/^        HashTableConstIteratorAdapter() {}$/;"	f	struct:WTF::HashTableConstIteratorAdapter	access:public	signature:()
WTF::HashTableConstIteratorAdapter::HashTableConstIteratorAdapter	.\HashTable.h	/^        HashTableConstIteratorAdapter(const typename HashTableType::const_iterator& impl) : m_impl(impl) {}$/;"	f	struct:WTF::HashTableConstIteratorAdapter	access:public	signature:(const typename HashTableType::const_iterator& impl)
WTF::HashTableConstIteratorAdapter::Keys	.\HashIterators.h	/^        typedef HashTableConstKeysIterator<HashTableType, KeyType, MappedType> Keys;$/;"	t	struct:WTF::HashTableConstIteratorAdapter	access:public
WTF::HashTableConstIteratorAdapter::ValueType	.\HashIterators.h	/^        typedef std::pair<KeyType, MappedType> ValueType;$/;"	t	struct:WTF::HashTableConstIteratorAdapter	access:private
WTF::HashTableConstIteratorAdapter::Values	.\HashIterators.h	/^        typedef HashTableConstValuesIterator<HashTableType, KeyType, MappedType> Values;$/;"	t	struct:WTF::HashTableConstIteratorAdapter	access:public
WTF::HashTableConstIteratorAdapter::get	.\HashIterators.h	/^        const ValueType* get() const { return (const ValueType*)m_impl.get(); }$/;"	f	struct:WTF::HashTableConstIteratorAdapter	access:public	signature:() const
WTF::HashTableConstIteratorAdapter::get	.\HashTable.h	/^        const ValueType* get() const { return (const ValueType*)m_impl.get(); }$/;"	f	struct:WTF::HashTableConstIteratorAdapter	access:public	signature:() const
WTF::HashTableConstIteratorAdapter::keys	.\HashIterators.h	/^        Keys keys() { return Keys(*this); }$/;"	f	struct:WTF::HashTableConstIteratorAdapter	access:public	signature:()
WTF::HashTableConstIteratorAdapter::m_impl	.\HashIterators.h	/^        typename HashTableType::const_iterator m_impl;$/;"	m	struct:WTF::HashTableConstIteratorAdapter	access:public
WTF::HashTableConstIteratorAdapter::m_impl	.\HashTable.h	/^        typename HashTableType::const_iterator m_impl;$/;"	m	struct:WTF::HashTableConstIteratorAdapter	access:public
WTF::HashTableConstIteratorAdapter::operator *	.\HashIterators.h	/^        const ValueType& operator*() const { return *get(); }$/;"	f	struct:WTF::HashTableConstIteratorAdapter	access:public	signature:() const
WTF::HashTableConstIteratorAdapter::operator *	.\HashTable.h	/^        const ValueType& operator*() const { return *get(); }$/;"	f	struct:WTF::HashTableConstIteratorAdapter	access:public	signature:() const
WTF::HashTableConstIteratorAdapter::operator ++	.\HashIterators.h	/^        HashTableConstIteratorAdapter& operator++() { ++m_impl; return *this; }$/;"	f	struct:WTF::HashTableConstIteratorAdapter	access:public	signature:()
WTF::HashTableConstIteratorAdapter::operator ++	.\HashTable.h	/^        HashTableConstIteratorAdapter& operator++() { ++m_impl; return *this; }$/;"	f	struct:WTF::HashTableConstIteratorAdapter	access:public	signature:()
WTF::HashTableConstIteratorAdapter::operator ->	.\HashIterators.h	/^        const ValueType* operator->() const { return get(); }$/;"	f	struct:WTF::HashTableConstIteratorAdapter	access:public	signature:() const
WTF::HashTableConstIteratorAdapter::operator ->	.\HashTable.h	/^        const ValueType* operator->() const { return get(); }$/;"	f	struct:WTF::HashTableConstIteratorAdapter	access:public	signature:() const
WTF::HashTableConstIteratorAdapter::values	.\HashIterators.h	/^        Values values() { return Values(*this); }$/;"	f	struct:WTF::HashTableConstIteratorAdapter	access:public	signature:()
WTF::HashTableConstKeysIterator	.\HashIterators.h	/^    template<typename HashTableType, typename KeyType, typename MappedType> struct HashTableConstKeysIterator {$/;"	s	namespace:WTF
WTF::HashTableConstKeysIterator::ConstIterator	.\HashIterators.h	/^        typedef HashTableConstIteratorAdapter<HashTableType, std::pair<KeyType, MappedType> > ConstIterator;$/;"	t	struct:WTF::HashTableConstKeysIterator	access:private
WTF::HashTableConstKeysIterator::HashTableConstKeysIterator	.\HashIterators.h	/^        HashTableConstKeysIterator(const ConstIterator& impl) : m_impl(impl) {}$/;"	f	struct:WTF::HashTableConstKeysIterator	access:public	signature:(const ConstIterator& impl)
WTF::HashTableConstKeysIterator::get	.\HashIterators.h	/^        const KeyType* get() const { return &(m_impl.get()->first); }$/;"	f	struct:WTF::HashTableConstKeysIterator	access:public	signature:() const
WTF::HashTableConstKeysIterator::m_impl	.\HashIterators.h	/^        ConstIterator m_impl;$/;"	m	struct:WTF::HashTableConstKeysIterator	access:public
WTF::HashTableConstKeysIterator::operator *	.\HashIterators.h	/^        const KeyType& operator*() const { return *get(); }$/;"	f	struct:WTF::HashTableConstKeysIterator	access:public	signature:() const
WTF::HashTableConstKeysIterator::operator ++	.\HashIterators.h	/^        HashTableConstKeysIterator& operator++() { ++m_impl; return *this; }$/;"	f	struct:WTF::HashTableConstKeysIterator	access:public	signature:()
WTF::HashTableConstKeysIterator::operator ->	.\HashIterators.h	/^        const KeyType* operator->() const { return get(); }$/;"	f	struct:WTF::HashTableConstKeysIterator	access:public	signature:() const
WTF::HashTableConstValuesIterator	.\HashIterators.h	/^    template<typename HashTableType, typename KeyType, typename MappedType> struct HashTableConstValuesIterator {$/;"	s	namespace:WTF
WTF::HashTableConstValuesIterator::ConstIterator	.\HashIterators.h	/^        typedef HashTableConstIteratorAdapter<HashTableType, std::pair<KeyType, MappedType> > ConstIterator;$/;"	t	struct:WTF::HashTableConstValuesIterator	access:private
WTF::HashTableConstValuesIterator::HashTableConstValuesIterator	.\HashIterators.h	/^        HashTableConstValuesIterator(const ConstIterator& impl) : m_impl(impl) {}$/;"	f	struct:WTF::HashTableConstValuesIterator	access:public	signature:(const ConstIterator& impl)
WTF::HashTableConstValuesIterator::get	.\HashIterators.h	/^        const MappedType* get() const { return &(m_impl.get()->second); }$/;"	f	struct:WTF::HashTableConstValuesIterator	access:public	signature:() const
WTF::HashTableConstValuesIterator::m_impl	.\HashIterators.h	/^        ConstIterator m_impl;$/;"	m	struct:WTF::HashTableConstValuesIterator	access:public
WTF::HashTableConstValuesIterator::operator *	.\HashIterators.h	/^        const MappedType& operator*() const { return *get(); }$/;"	f	struct:WTF::HashTableConstValuesIterator	access:public	signature:() const
WTF::HashTableConstValuesIterator::operator ++	.\HashIterators.h	/^        HashTableConstValuesIterator& operator++() { ++m_impl; return *this; }$/;"	f	struct:WTF::HashTableConstValuesIterator	access:public	signature:()
WTF::HashTableConstValuesIterator::operator ->	.\HashIterators.h	/^        const MappedType* operator->() const { return get(); }$/;"	f	struct:WTF::HashTableConstValuesIterator	access:public	signature:() const
WTF::HashTableDeletedValue	.\RefPtr.h	/^    enum HashTableDeletedValueType { HashTableDeletedValue };$/;"	e	enum:WTF::HashTableDeletedValueType
WTF::HashTableDeletedValueType	.\RefPtr.h	/^    enum HashTableDeletedValueType { HashTableDeletedValue };$/;"	g	namespace:WTF
WTF::HashTableIterator	.\HashTable.h	/^    class HashTableIterator {$/;"	c	namespace:WTF
WTF::HashTableIterator::HashTableIterator	.\HashTable.h	/^        HashTableIterator() { }$/;"	f	class:WTF::HashTableIterator	access:public	signature:()
WTF::HashTableIterator::HashTableIterator	.\HashTable.h	/^        HashTableIterator(HashTableType* table, PointerType pos, PointerType end) : m_iterator(table, pos, end) { }$/;"	f	class:WTF::HashTableIterator	access:private	signature:(HashTableType* table, PointerType pos, PointerType end)
WTF::HashTableIterator::HashTableIterator	.\HashTable.h	/^        HashTableIterator(HashTableType* table, PointerType pos, PointerType end, HashItemKnownGoodTag tag) : m_iterator(table, pos, end, tag) { }$/;"	f	class:WTF::HashTableIterator	access:private	signature:(HashTableType* table, PointerType pos, PointerType end, HashItemKnownGoodTag tag)
WTF::HashTableIterator::HashTableType	.\HashTable.h	/^        typedef HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits> HashTableType;$/;"	t	class:WTF::HashTableIterator	access:private
WTF::HashTableIterator::PointerType	.\HashTable.h	/^        typedef ValueType* PointerType;$/;"	t	class:WTF::HashTableIterator	access:private
WTF::HashTableIterator::ReferenceType	.\HashTable.h	/^        typedef ValueType& ReferenceType;$/;"	t	class:WTF::HashTableIterator	access:private
WTF::HashTableIterator::ValueType	.\HashTable.h	/^        typedef Value ValueType;$/;"	t	class:WTF::HashTableIterator	access:private
WTF::HashTableIterator::const_iterator	.\HashTable.h	/^        typedef HashTableConstIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits> const_iterator;$/;"	t	class:WTF::HashTableIterator	access:private
WTF::HashTableIterator::get	.\HashTable.h	/^        PointerType get() const { return const_cast<PointerType>(m_iterator.get()); }$/;"	f	class:WTF::HashTableIterator	access:public	signature:() const
WTF::HashTableIterator::iterator	.\HashTable.h	/^        typedef HashTableIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits> iterator;$/;"	t	class:WTF::HashTableIterator	access:private
WTF::HashTableIterator::m_iterator	.\HashTable.h	/^        const_iterator m_iterator;$/;"	m	class:WTF::HashTableIterator	access:private
WTF::HashTableIterator::operator !=	.\HashTable.h	/^        bool operator!=(const const_iterator& other) const { return m_iterator != other; }$/;"	f	class:WTF::HashTableIterator	access:public	signature:(const const_iterator& other) const
WTF::HashTableIterator::operator !=	.\HashTable.h	/^        bool operator!=(const iterator& other) const { return m_iterator != other.m_iterator; }$/;"	f	class:WTF::HashTableIterator	access:public	signature:(const iterator& other) const
WTF::HashTableIterator::operator *	.\HashTable.h	/^        ReferenceType operator*() const { return *get(); }$/;"	f	class:WTF::HashTableIterator	access:public	signature:() const
WTF::HashTableIterator::operator ++	.\HashTable.h	/^        iterator& operator++() { ++m_iterator; return *this; }$/;"	f	class:WTF::HashTableIterator	access:public	signature:()
WTF::HashTableIterator::operator ->	.\HashTable.h	/^        PointerType operator->() const { return get(); }$/;"	f	class:WTF::HashTableIterator	access:public	signature:() const
WTF::HashTableIterator::operator ==	.\HashTable.h	/^        bool operator==(const const_iterator& other) const { return m_iterator == other; }$/;"	f	class:WTF::HashTableIterator	access:public	signature:(const const_iterator& other) const
WTF::HashTableIterator::operator ==	.\HashTable.h	/^        bool operator==(const iterator& other) const { return m_iterator == other.m_iterator; }$/;"	f	class:WTF::HashTableIterator	access:public	signature:(const iterator& other) const
WTF::HashTableIterator::operator const_iterator	.\HashTable.h	/^        operator const_iterator() const { return m_iterator; }$/;"	f	class:WTF::HashTableIterator	access:public	signature:() const
WTF::HashTableIteratorAdapter	.\HashIterators.h	/^    template<typename HashTableType, typename KeyType, typename MappedType> struct HashTableIteratorAdapter<HashTableType, std::pair<KeyType, MappedType> > {$/;"	s	namespace:WTF
WTF::HashTableIteratorAdapter	.\HashTable.h	/^    template<typename HashTableType, typename ValueType> struct HashTableIteratorAdapter {$/;"	s	namespace:WTF
WTF::HashTableIteratorAdapter::HashTableIteratorAdapter	.\HashIterators.h	/^        HashTableIteratorAdapter() {}$/;"	f	struct:WTF::HashTableIteratorAdapter	access:public	signature:()
WTF::HashTableIteratorAdapter::HashTableIteratorAdapter	.\HashIterators.h	/^        HashTableIteratorAdapter(const typename HashTableType::iterator& impl) : m_impl(impl) {}$/;"	f	struct:WTF::HashTableIteratorAdapter	access:public	signature:(const typename HashTableType::iterator& impl)
WTF::HashTableIteratorAdapter::HashTableIteratorAdapter	.\HashTable.h	/^        HashTableIteratorAdapter() {}$/;"	f	struct:WTF::HashTableIteratorAdapter	access:public	signature:()
WTF::HashTableIteratorAdapter::HashTableIteratorAdapter	.\HashTable.h	/^        HashTableIteratorAdapter(const typename HashTableType::iterator& impl) : m_impl(impl) {}$/;"	f	struct:WTF::HashTableIteratorAdapter	access:public	signature:(const typename HashTableType::iterator& impl)
WTF::HashTableIteratorAdapter::Keys	.\HashIterators.h	/^        typedef HashTableKeysIterator<HashTableType, KeyType, MappedType> Keys;$/;"	t	struct:WTF::HashTableIteratorAdapter	access:public
WTF::HashTableIteratorAdapter::ValueType	.\HashIterators.h	/^        typedef std::pair<KeyType, MappedType> ValueType;$/;"	t	struct:WTF::HashTableIteratorAdapter	access:private
WTF::HashTableIteratorAdapter::Values	.\HashIterators.h	/^        typedef HashTableValuesIterator<HashTableType, KeyType, MappedType> Values;$/;"	t	struct:WTF::HashTableIteratorAdapter	access:public
WTF::HashTableIteratorAdapter::get	.\HashIterators.h	/^        ValueType* get() const { return (ValueType*)m_impl.get(); }$/;"	f	struct:WTF::HashTableIteratorAdapter	access:public	signature:() const
WTF::HashTableIteratorAdapter::get	.\HashTable.h	/^        ValueType* get() const { return (ValueType*)m_impl.get(); }$/;"	f	struct:WTF::HashTableIteratorAdapter	access:public	signature:() const
WTF::HashTableIteratorAdapter::keys	.\HashIterators.h	/^        Keys keys() { return Keys(*this); }$/;"	f	struct:WTF::HashTableIteratorAdapter	access:public	signature:()
WTF::HashTableIteratorAdapter::m_impl	.\HashIterators.h	/^        typename HashTableType::iterator m_impl;$/;"	m	struct:WTF::HashTableIteratorAdapter	access:public
WTF::HashTableIteratorAdapter::m_impl	.\HashTable.h	/^        typename HashTableType::iterator m_impl;$/;"	m	struct:WTF::HashTableIteratorAdapter	access:public
WTF::HashTableIteratorAdapter::operator *	.\HashIterators.h	/^        ValueType& operator*() const { return *get(); }$/;"	f	struct:WTF::HashTableIteratorAdapter	access:public	signature:() const
WTF::HashTableIteratorAdapter::operator *	.\HashTable.h	/^        ValueType& operator*() const { return *get(); }$/;"	f	struct:WTF::HashTableIteratorAdapter	access:public	signature:() const
WTF::HashTableIteratorAdapter::operator ++	.\HashIterators.h	/^        HashTableIteratorAdapter& operator++() { ++m_impl; return *this; }$/;"	f	struct:WTF::HashTableIteratorAdapter	access:public	signature:()
WTF::HashTableIteratorAdapter::operator ++	.\HashTable.h	/^        HashTableIteratorAdapter& operator++() { ++m_impl; return *this; }$/;"	f	struct:WTF::HashTableIteratorAdapter	access:public	signature:()
WTF::HashTableIteratorAdapter::operator ->	.\HashIterators.h	/^        ValueType* operator->() const { return get(); }$/;"	f	struct:WTF::HashTableIteratorAdapter	access:public	signature:() const
WTF::HashTableIteratorAdapter::operator ->	.\HashTable.h	/^        ValueType* operator->() const { return get(); }$/;"	f	struct:WTF::HashTableIteratorAdapter	access:public	signature:() const
WTF::HashTableIteratorAdapter::operator HashTableConstIteratorAdapter<HashTableType, ValueType>	.\HashIterators.h	/^        operator HashTableConstIteratorAdapter<HashTableType, ValueType>() {$/;"	f	struct:WTF::HashTableIteratorAdapter	access:public	signature:()
WTF::HashTableIteratorAdapter::operator HashTableConstIteratorAdapter<HashTableType, ValueType>	.\HashTable.h	/^        operator HashTableConstIteratorAdapter<HashTableType, ValueType>() {$/;"	f	struct:WTF::HashTableIteratorAdapter	access:public	signature:()
WTF::HashTableIteratorAdapter::values	.\HashIterators.h	/^        Values values() { return Values(*this); }$/;"	f	struct:WTF::HashTableIteratorAdapter	access:public	signature:()
WTF::HashTableKeysIterator	.\HashIterators.h	/^    template<typename HashTableType, typename KeyType, typename MappedType> struct HashTableKeysIterator {$/;"	s	namespace:WTF
WTF::HashTableKeysIterator::ConstIterator	.\HashIterators.h	/^        typedef HashTableConstIteratorAdapter<HashTableType, std::pair<KeyType, MappedType> > ConstIterator;$/;"	t	struct:WTF::HashTableKeysIterator	access:private
WTF::HashTableKeysIterator::HashTableKeysIterator	.\HashIterators.h	/^        HashTableKeysIterator(const Iterator& impl) : m_impl(impl) {}$/;"	f	struct:WTF::HashTableKeysIterator	access:public	signature:(const Iterator& impl)
WTF::HashTableKeysIterator::Iterator	.\HashIterators.h	/^        typedef HashTableIteratorAdapter<HashTableType, std::pair<KeyType, MappedType> > Iterator;$/;"	t	struct:WTF::HashTableKeysIterator	access:private
WTF::HashTableKeysIterator::get	.\HashIterators.h	/^        KeyType* get() const { return &(m_impl.get()->first); }$/;"	f	struct:WTF::HashTableKeysIterator	access:public	signature:() const
WTF::HashTableKeysIterator::m_impl	.\HashIterators.h	/^        Iterator m_impl;$/;"	m	struct:WTF::HashTableKeysIterator	access:public
WTF::HashTableKeysIterator::operator *	.\HashIterators.h	/^        KeyType& operator*() const { return *get(); }$/;"	f	struct:WTF::HashTableKeysIterator	access:public	signature:() const
WTF::HashTableKeysIterator::operator ++	.\HashIterators.h	/^        HashTableKeysIterator& operator++() { ++m_impl; return *this; }$/;"	f	struct:WTF::HashTableKeysIterator	access:public	signature:()
WTF::HashTableKeysIterator::operator ->	.\HashIterators.h	/^        KeyType* operator->() const { return get(); }$/;"	f	struct:WTF::HashTableKeysIterator	access:public	signature:() const
WTF::HashTableKeysIterator::operator HashTableConstKeysIterator<HashTableType, KeyType, MappedType>	.\HashIterators.h	/^        operator HashTableConstKeysIterator<HashTableType, KeyType, MappedType>() {$/;"	f	struct:WTF::HashTableKeysIterator	access:public	signature:()
WTF::HashTableStats	.\HashTable.h	/^    struct HashTableStats {$/;"	s	namespace:WTF
WTF::HashTableStats::collisionGraph	.\HashTable.cpp	/^int HashTableStats::collisionGraph[4096];$/;"	m	class:WTF::HashTableStats	file:
WTF::HashTableStats::collisionGraph	.\HashTable.h	/^        static int collisionGraph[4096];$/;"	m	struct:WTF::HashTableStats	access:public
WTF::HashTableStats::maxCollisions	.\HashTable.cpp	/^int HashTableStats::maxCollisions;$/;"	m	class:WTF::HashTableStats	file:
WTF::HashTableStats::maxCollisions	.\HashTable.h	/^        static int maxCollisions;$/;"	m	struct:WTF::HashTableStats	access:public
WTF::HashTableStats::numAccesses	.\HashTable.cpp	/^int HashTableStats::numAccesses;$/;"	m	class:WTF::HashTableStats	file:
WTF::HashTableStats::numAccesses	.\HashTable.h	/^        static int numAccesses;$/;"	m	struct:WTF::HashTableStats	access:public
WTF::HashTableStats::numCollisions	.\HashTable.cpp	/^int HashTableStats::numCollisions;$/;"	m	class:WTF::HashTableStats	file:
WTF::HashTableStats::numCollisions	.\HashTable.h	/^        static int numCollisions;$/;"	m	struct:WTF::HashTableStats	access:public
WTF::HashTableStats::numRehashes	.\HashTable.cpp	/^int HashTableStats::numRehashes;$/;"	m	class:WTF::HashTableStats	file:
WTF::HashTableStats::numRehashes	.\HashTable.h	/^        static int numRehashes;$/;"	m	struct:WTF::HashTableStats	access:public
WTF::HashTableStats::numReinserts	.\HashTable.cpp	/^int HashTableStats::numReinserts;$/;"	m	class:WTF::HashTableStats	file:
WTF::HashTableStats::numReinserts	.\HashTable.h	/^        static int numReinserts;$/;"	m	struct:WTF::HashTableStats	access:public
WTF::HashTableStats::numRemoves	.\HashTable.cpp	/^int HashTableStats::numRemoves;$/;"	m	class:WTF::HashTableStats	file:
WTF::HashTableStats::numRemoves	.\HashTable.h	/^        static int numRemoves;$/;"	m	struct:WTF::HashTableStats	access:public
WTF::HashTableStats::recordCollisionAtCount	.\HashTable.cpp	/^void HashTableStats::recordCollisionAtCount(int count)$/;"	f	class:WTF::HashTableStats	signature:(int count)
WTF::HashTableStats::recordCollisionAtCount	.\HashTable.h	/^        static void recordCollisionAtCount(int count);$/;"	p	struct:WTF::HashTableStats	access:public	signature:(int count)
WTF::HashTableStats::~HashTableStats	.\HashTable.cpp	/^HashTableStats::~HashTableStats()$/;"	f	class:WTF::HashTableStats	signature:()
WTF::HashTableStats::~HashTableStats	.\HashTable.h	/^        ~HashTableStats();$/;"	p	struct:WTF::HashTableStats	access:public	signature:()
WTF::HashTableValuesIterator	.\HashIterators.h	/^    template<typename HashTableType, typename KeyType, typename MappedType> struct HashTableValuesIterator {$/;"	s	namespace:WTF
WTF::HashTableValuesIterator::ConstIterator	.\HashIterators.h	/^        typedef HashTableConstIteratorAdapter<HashTableType, std::pair<KeyType, MappedType> > ConstIterator;$/;"	t	struct:WTF::HashTableValuesIterator	access:private
WTF::HashTableValuesIterator::HashTableValuesIterator	.\HashIterators.h	/^        HashTableValuesIterator(const Iterator& impl) : m_impl(impl) {}$/;"	f	struct:WTF::HashTableValuesIterator	access:public	signature:(const Iterator& impl)
WTF::HashTableValuesIterator::Iterator	.\HashIterators.h	/^        typedef HashTableIteratorAdapter<HashTableType, std::pair<KeyType, MappedType> > Iterator;$/;"	t	struct:WTF::HashTableValuesIterator	access:private
WTF::HashTableValuesIterator::get	.\HashIterators.h	/^        MappedType* get() const { return &(m_impl.get()->second); }$/;"	f	struct:WTF::HashTableValuesIterator	access:public	signature:() const
WTF::HashTableValuesIterator::m_impl	.\HashIterators.h	/^        Iterator m_impl;$/;"	m	struct:WTF::HashTableValuesIterator	access:public
WTF::HashTableValuesIterator::operator *	.\HashIterators.h	/^        MappedType& operator*() const { return *get(); }$/;"	f	struct:WTF::HashTableValuesIterator	access:public	signature:() const
WTF::HashTableValuesIterator::operator ++	.\HashIterators.h	/^        HashTableValuesIterator& operator++() { ++m_impl; return *this; }$/;"	f	struct:WTF::HashTableValuesIterator	access:public	signature:()
WTF::HashTableValuesIterator::operator ->	.\HashIterators.h	/^        MappedType* operator->() const { return get(); }$/;"	f	struct:WTF::HashTableValuesIterator	access:public	signature:() const
WTF::HashTableValuesIterator::operator HashTableConstValuesIterator<HashTableType, KeyType, MappedType>	.\HashIterators.h	/^        operator HashTableConstValuesIterator<HashTableType, KeyType, MappedType>() {$/;"	f	struct:WTF::HashTableValuesIterator	access:public	signature:()
WTF::HashTraits	.\HashTraits.h	/^    struct HashTraits<pair<First, Second> > : public PairHashTraits<HashTraits<First>, HashTraits<Second> > { };$/;"	s	namespace:WTF	inherits:PairHashTraits
WTF::HashTraits	.\HashTraits.h	/^    template<> struct HashTraits<String> : SimpleClassHashTraits<String> { };$/;"	s	namespace:WTF	inherits:SimpleClassHashTraits
WTF::HashTraits	.\HashTraits.h	/^    template<> struct HashTraits<double> : FloatHashTraits<double> { };$/;"	s	namespace:WTF	inherits:FloatHashTraits
WTF::HashTraits	.\HashTraits.h	/^    template<> struct HashTraits<float> : FloatHashTraits<float> { };$/;"	s	namespace:WTF	inherits:FloatHashTraits
WTF::HashTraits	.\HashTraits.h	/^    template<typename P> struct HashTraits<OwnPtr<P> > : SimpleClassHashTraits<OwnPtr<P> > {$/;"	s	namespace:WTF	inherits:SimpleClassHashTraits
WTF::HashTraits	.\HashTraits.h	/^    template<typename P> struct HashTraits<P*> : GenericHashTraits<P*> {$/;"	s	namespace:WTF	inherits:GenericHashTraits
WTF::HashTraits	.\HashTraits.h	/^    template<typename P> struct HashTraits<RefPtr<P> > : SimpleClassHashTraits<RefPtr<P> > {$/;"	s	namespace:WTF	inherits:SimpleClassHashTraits
WTF::HashTraits	.\HashTraits.h	/^    template<typename T> struct HashTraits : GenericHashTraits<T> { };$/;"	s	namespace:WTF	inherits:GenericHashTraits
WTF::HashTraits	.\RetainPtr.h	/^    template<typename P> struct HashTraits<RetainPtr<P> > : SimpleClassHashTraits<RetainPtr<P> > { };$/;"	s	namespace:WTF	inherits:SimpleClassHashTraits
WTF::HashTraits	.\text\AtomicStringHash.h	/^    template<> struct HashTraits<WTF::AtomicString> : GenericHashTraits<WTF::AtomicString> {$/;"	s	namespace:WTF	inherits:GenericHashTraits
WTF::HashTraits::EmptyValueType	.\HashTraits.h	/^        typedef std::nullptr_t EmptyValueType;$/;"	t	struct:WTF::HashTraits	access:public
WTF::HashTraits::PassInType	.\HashTraits.h	/^        typedef PassOwnPtr<P> PassInType;$/;"	t	struct:WTF::HashTraits	access:public
WTF::HashTraits::PassInType	.\HashTraits.h	/^        typedef PassRefPtr<P> PassInType;$/;"	t	struct:WTF::HashTraits	access:public
WTF::HashTraits::PassOutType	.\HashTraits.h	/^        typedef PassOwnPtr<P> PassOutType;$/;"	t	struct:WTF::HashTraits	access:public
WTF::HashTraits::PeekType	.\HashTraits.h	/^        typedef typename OwnPtr<P>::PtrType PeekType;$/;"	t	struct:WTF::HashTraits	access:public
WTF::HashTraits::constructDeletedValue	.\HashTraits.h	/^        static void constructDeletedValue(P*& slot) { slot = reinterpret_cast<P*>(-1); }$/;"	f	struct:WTF::HashTraits	access:public	signature:(P*& slot)
WTF::HashTraits::constructDeletedValue	.\text\AtomicStringHash.h	/^        static void constructDeletedValue(WTF::AtomicString& slot) { new (NotNull, &slot) WTF::AtomicString(HashTableDeletedValue); }$/;"	f	struct:WTF::HashTraits	access:public	signature:(WTF::AtomicString& slot)
WTF::HashTraits::emptyValue	.\HashTraits.h	/^        static EmptyValueType emptyValue() { return nullptr; }$/;"	f	struct:WTF::HashTraits	access:public	signature:()
WTF::HashTraits::emptyValueIsZero	.\HashTraits.h	/^        static const bool emptyValueIsZero = true;$/;"	m	struct:WTF::HashTraits	access:public
WTF::HashTraits::emptyValueIsZero	.\text\AtomicStringHash.h	/^        static const bool emptyValueIsZero = true;$/;"	m	struct:WTF::HashTraits	access:public
WTF::HashTraits::isDeletedValue	.\HashTraits.h	/^        static bool isDeletedValue(P* value) { return value == reinterpret_cast<P*>(-1); }$/;"	f	struct:WTF::HashTraits	access:public	signature:(P* value)
WTF::HashTraits::isDeletedValue	.\text\AtomicStringHash.h	/^        static bool isDeletedValue(const WTF::AtomicString& slot) { return slot.isHashTableDeletedValue(); }$/;"	f	struct:WTF::HashTraits	access:public	signature:(const WTF::AtomicString& slot)
WTF::HashTraits::needsDestruction	.\HashTraits.h	/^        static const bool needsDestruction = false;$/;"	m	struct:WTF::HashTraits	access:public
WTF::HashTraits::passOut	.\HashTraits.h	/^        static PassOwnPtr<P> passOut(OwnPtr<P>& value) { return value.release(); }$/;"	f	struct:WTF::HashTraits	access:public	signature:(OwnPtr<P>& value)
WTF::HashTraits::passOut	.\HashTraits.h	/^        static PassOwnPtr<P> passOut(std::nullptr_t) { return nullptr; }$/;"	f	struct:WTF::HashTraits	access:public	signature:(std::nullptr_t)
WTF::HashTraits::peek	.\HashTraits.h	/^        static PeekType peek(const OwnPtr<P>& value) { return value.get(); }$/;"	f	struct:WTF::HashTraits	access:public	signature:(const OwnPtr<P>& value)
WTF::HashTraits::peek	.\HashTraits.h	/^        static PeekType peek(std::nullptr_t) { return 0; }$/;"	f	struct:WTF::HashTraits	access:public	signature:(std::nullptr_t)
WTF::HashTraits::store	.\HashTraits.h	/^        static void store(PassOwnPtr<P> value, OwnPtr<P>& storage) { storage = value; }$/;"	f	struct:WTF::HashTraits	access:public	signature:(PassOwnPtr<P> value, OwnPtr<P>& storage)
WTF::HashTraits::store	.\HashTraits.h	/^        static void store(PassRefPtr<P> value, RefPtr<P>& storage) { storage = value; }$/;"	f	struct:WTF::HashTraits	access:public	signature:(PassRefPtr<P> value, RefPtr<P>& storage)
WTF::HexConversionMode	.\HexNumber.h	/^enum HexConversionMode {$/;"	g	namespace:WTF
WTF::IdentityExtractor	.\HashSet.h	/^    struct IdentityExtractor {$/;"	s	namespace:WTF
WTF::IdentityExtractor::extract	.\HashSet.h	/^        template<typename T> static const T& extract(const T& t) { return t; }$/;"	f	struct:WTF::IdentityExtractor	access:public	signature:(const T& t)
WTF::IdentityHashTranslator	.\HashTable.h	/^    template<typename HashFunctions> class IdentityHashTranslator {$/;"	c	namespace:WTF
WTF::IdentityHashTranslator::equal	.\HashTable.h	/^        template<typename T> static bool equal(const T& a, const T& b) { return HashFunctions::equal(a, b); }$/;"	f	class:WTF::IdentityHashTranslator	access:public	signature:(const T& a, const T& b)
WTF::IdentityHashTranslator::hash	.\HashTable.h	/^        template<typename T> static unsigned hash(const T& key) { return HashFunctions::hash(key); }$/;"	f	class:WTF::IdentityHashTranslator	access:public	signature:(const T& key)
WTF::IdentityHashTranslator::translate	.\HashTable.h	/^        template<typename T, typename U> static void translate(T& location, const U&, const T& value) { location = value; }$/;"	f	class:WTF::IdentityHashTranslator	access:public	signature:(T& location, const U&, const T& value)
WTF::InitSizeClasses	.\FastMalloc.cpp	/^static void InitSizeClasses() {$/;"	f	namespace:WTF	file:	signature:()
WTF::Int16Array	.\Int16Array.h	/^class Int16Array : public IntegralTypedArrayBase<short> {$/;"	c	namespace:WTF	inherits:IntegralTypedArrayBase
WTF::Int16Array::Int16Array	.\Int16Array.h	/^    inline Int16Array(PassRefPtr<ArrayBuffer>,$/;"	p	class:WTF::Int16Array	access:private	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
WTF::Int16Array::Int16Array	.\Int16Array.h	/^Int16Array::Int16Array(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Int16Array	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
WTF::Int16Array::create	.\Int16Array.h	/^    static inline PassRefPtr<Int16Array> create(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length);$/;"	p	class:WTF::Int16Array	access:public	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
WTF::Int16Array::create	.\Int16Array.h	/^    static inline PassRefPtr<Int16Array> create(const short* array, unsigned length);$/;"	p	class:WTF::Int16Array	access:public	signature:(const short* array, unsigned length)
WTF::Int16Array::create	.\Int16Array.h	/^    static inline PassRefPtr<Int16Array> create(unsigned length);$/;"	p	class:WTF::Int16Array	access:public	signature:(unsigned length)
WTF::Int16Array::create	.\Int16Array.h	/^PassRefPtr<Int16Array> Int16Array::create(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Int16Array	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
WTF::Int16Array::create	.\Int16Array.h	/^PassRefPtr<Int16Array> Int16Array::create(const short* array, unsigned length)$/;"	f	class:WTF::Int16Array	signature:(const short* array, unsigned length)
WTF::Int16Array::create	.\Int16Array.h	/^PassRefPtr<Int16Array> Int16Array::create(unsigned length)$/;"	f	class:WTF::Int16Array	signature:(unsigned length)
WTF::Int16Array::isShortArray	.\Int16Array.h	/^    virtual bool isShortArray() const { return true; }$/;"	f	class:WTF::Int16Array	access:private	signature:() const
WTF::Int16Array::set	.\Int16Array.h	/^    bool set(TypedArrayBase<short>* array, unsigned offset) { return TypedArrayBase<short>::set(array, offset); }$/;"	f	class:WTF::Int16Array	access:public	signature:(TypedArrayBase<short>* array, unsigned offset)
WTF::Int16Array::set	.\Int16Array.h	/^    void set(unsigned index, double value) { IntegralTypedArrayBase<short>::set(index, value); }$/;"	f	class:WTF::Int16Array	access:public	signature:(unsigned index, double value)
WTF::Int16Array::subarray	.\Int16Array.h	/^    inline PassRefPtr<Int16Array> subarray(int start) const;$/;"	p	class:WTF::Int16Array	access:public	signature:(int start) const
WTF::Int16Array::subarray	.\Int16Array.h	/^    inline PassRefPtr<Int16Array> subarray(int start, int end) const;$/;"	p	class:WTF::Int16Array	access:public	signature:(int start, int end) const
WTF::Int16Array::subarray	.\Int16Array.h	/^PassRefPtr<Int16Array> Int16Array::subarray(int start) const$/;"	f	class:WTF::Int16Array	signature:(int start) const
WTF::Int16Array::subarray	.\Int16Array.h	/^PassRefPtr<Int16Array> Int16Array::subarray(int start, int end) const$/;"	f	class:WTF::Int16Array	signature:(int start, int end) const
WTF::Int32Array	.\Int32Array.h	/^class Int32Array : public IntegralTypedArrayBase<int> {$/;"	c	namespace:WTF	inherits:IntegralTypedArrayBase
WTF::Int32Array::Int32Array	.\Int32Array.h	/^    inline Int32Array(PassRefPtr<ArrayBuffer>,$/;"	p	class:WTF::Int32Array	access:private	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
WTF::Int32Array::Int32Array	.\Int32Array.h	/^Int32Array::Int32Array(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Int32Array	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
WTF::Int32Array::create	.\Int32Array.h	/^    static inline PassRefPtr<Int32Array> create(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length);$/;"	p	class:WTF::Int32Array	access:public	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
WTF::Int32Array::create	.\Int32Array.h	/^    static inline PassRefPtr<Int32Array> create(const int* array, unsigned length);$/;"	p	class:WTF::Int32Array	access:public	signature:(const int* array, unsigned length)
WTF::Int32Array::create	.\Int32Array.h	/^    static inline PassRefPtr<Int32Array> create(unsigned length);$/;"	p	class:WTF::Int32Array	access:public	signature:(unsigned length)
WTF::Int32Array::create	.\Int32Array.h	/^PassRefPtr<Int32Array> Int32Array::create(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Int32Array	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
WTF::Int32Array::create	.\Int32Array.h	/^PassRefPtr<Int32Array> Int32Array::create(const int* array, unsigned length)$/;"	f	class:WTF::Int32Array	signature:(const int* array, unsigned length)
WTF::Int32Array::create	.\Int32Array.h	/^PassRefPtr<Int32Array> Int32Array::create(unsigned length)$/;"	f	class:WTF::Int32Array	signature:(unsigned length)
WTF::Int32Array::isIntArray	.\Int32Array.h	/^    virtual bool isIntArray() const { return true; }$/;"	f	class:WTF::Int32Array	access:private	signature:() const
WTF::Int32Array::set	.\Int32Array.h	/^    bool set(TypedArrayBase<int>* array, unsigned offset) { return TypedArrayBase<int>::set(array, offset); }$/;"	f	class:WTF::Int32Array	access:public	signature:(TypedArrayBase<int>* array, unsigned offset)
WTF::Int32Array::set	.\Int32Array.h	/^    void set(unsigned index, double value) { IntegralTypedArrayBase<int>::set(index, value); }$/;"	f	class:WTF::Int32Array	access:public	signature:(unsigned index, double value)
WTF::Int32Array::subarray	.\Int32Array.h	/^    inline PassRefPtr<Int32Array> subarray(int start) const;$/;"	p	class:WTF::Int32Array	access:public	signature:(int start) const
WTF::Int32Array::subarray	.\Int32Array.h	/^    inline PassRefPtr<Int32Array> subarray(int start, int end) const;$/;"	p	class:WTF::Int32Array	access:public	signature:(int start, int end) const
WTF::Int32Array::subarray	.\Int32Array.h	/^PassRefPtr<Int32Array> Int32Array::subarray(int start) const$/;"	f	class:WTF::Int32Array	signature:(int start) const
WTF::Int32Array::subarray	.\Int32Array.h	/^PassRefPtr<Int32Array> Int32Array::subarray(int start, int end) const$/;"	f	class:WTF::Int32Array	signature:(int start, int end) const
WTF::Int8Array	.\Int8Array.h	/^class Int8Array : public IntegralTypedArrayBase<signed char> {$/;"	c	namespace:WTF	inherits:IntegralTypedArrayBase
WTF::Int8Array::Int8Array	.\Int8Array.h	/^    inline Int8Array(PassRefPtr<ArrayBuffer>,$/;"	p	class:WTF::Int8Array	access:private	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
WTF::Int8Array::Int8Array	.\Int8Array.h	/^Int8Array::Int8Array(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Int8Array	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
WTF::Int8Array::create	.\Int8Array.h	/^    static inline PassRefPtr<Int8Array> create(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length);$/;"	p	class:WTF::Int8Array	access:public	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
WTF::Int8Array::create	.\Int8Array.h	/^    static inline PassRefPtr<Int8Array> create(const signed char* array, unsigned length);$/;"	p	class:WTF::Int8Array	access:public	signature:(const signed char* array, unsigned length)
WTF::Int8Array::create	.\Int8Array.h	/^    static inline PassRefPtr<Int8Array> create(unsigned length);$/;"	p	class:WTF::Int8Array	access:public	signature:(unsigned length)
WTF::Int8Array::create	.\Int8Array.h	/^PassRefPtr<Int8Array> Int8Array::create(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Int8Array	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
WTF::Int8Array::create	.\Int8Array.h	/^PassRefPtr<Int8Array> Int8Array::create(const signed char* array, unsigned length)$/;"	f	class:WTF::Int8Array	signature:(const signed char* array, unsigned length)
WTF::Int8Array::create	.\Int8Array.h	/^PassRefPtr<Int8Array> Int8Array::create(unsigned length)$/;"	f	class:WTF::Int8Array	signature:(unsigned length)
WTF::Int8Array::isByteArray	.\Int8Array.h	/^    virtual bool isByteArray() const { return true; }$/;"	f	class:WTF::Int8Array	access:private	signature:() const
WTF::Int8Array::set	.\Int8Array.h	/^    bool set(TypedArrayBase<signed char>* array, unsigned offset) { return TypedArrayBase<signed char>::set(array, offset); }$/;"	f	class:WTF::Int8Array	access:public	signature:(TypedArrayBase<signed char>* array, unsigned offset)
WTF::Int8Array::set	.\Int8Array.h	/^    void set(unsigned index, double value) { IntegralTypedArrayBase<signed char>::set(index, value); }$/;"	f	class:WTF::Int8Array	access:public	signature:(unsigned index, double value)
WTF::Int8Array::subarray	.\Int8Array.h	/^    inline PassRefPtr<Int8Array> subarray(int start) const;$/;"	p	class:WTF::Int8Array	access:public	signature:(int start) const
WTF::Int8Array::subarray	.\Int8Array.h	/^    inline PassRefPtr<Int8Array> subarray(int start, int end) const;$/;"	p	class:WTF::Int8Array	access:public	signature:(int start, int end) const
WTF::Int8Array::subarray	.\Int8Array.h	/^PassRefPtr<Int8Array> Int8Array::subarray(int start) const$/;"	f	class:WTF::Int8Array	signature:(int start) const
WTF::Int8Array::subarray	.\Int8Array.h	/^PassRefPtr<Int8Array> Int8Array::subarray(int start, int end) const$/;"	f	class:WTF::Int8Array	signature:(int start, int end) const
WTF::IntArray	.\TypeTraits.cpp	/^typedef int IntArray[];$/;"	t	namespace:WTF	file:
WTF::IntArraySized	.\TypeTraits.cpp	/^typedef int IntArraySized[4];$/;"	t	namespace:WTF	file:
WTF::IntHash	.\HashFunctions.h	/^    template<typename T> struct IntHash {$/;"	s	namespace:WTF
WTF::IntHash::equal	.\HashFunctions.h	/^        static bool equal(T a, T b) { return a == b; }$/;"	f	struct:WTF::IntHash	access:public	signature:(T a, T b)
WTF::IntHash::hash	.\HashFunctions.h	/^        static unsigned hash(T key) { return intHash(static_cast<typename IntTypes<sizeof(T)>::UnsignedType>(key)); }$/;"	f	struct:WTF::IntHash	access:public	signature:(T key)
WTF::IntHash::safeToCompareToEmptyOrDeleted	.\HashFunctions.h	/^        static const bool safeToCompareToEmptyOrDeleted = true;$/;"	m	struct:WTF::IntHash	access:public
WTF::IntTypes	.\HashFunctions.h	/^    template<> struct IntTypes<1> { typedef int8_t SignedType; typedef uint8_t UnsignedType; };$/;"	s	namespace:WTF
WTF::IntTypes	.\HashFunctions.h	/^    template<> struct IntTypes<2> { typedef int16_t SignedType; typedef uint16_t UnsignedType; };$/;"	s	namespace:WTF
WTF::IntTypes	.\HashFunctions.h	/^    template<> struct IntTypes<4> { typedef int32_t SignedType; typedef uint32_t UnsignedType; };$/;"	s	namespace:WTF
WTF::IntTypes	.\HashFunctions.h	/^    template<> struct IntTypes<8> { typedef int64_t SignedType; typedef uint64_t UnsignedType; };$/;"	s	namespace:WTF
WTF::IntTypes::SignedType	.\HashFunctions.h	/^    template<> struct IntTypes<1> { typedef int8_t SignedType; typedef uint8_t UnsignedType; };$/;"	t	struct:WTF::IntTypes	access:public
WTF::IntTypes::SignedType	.\HashFunctions.h	/^    template<> struct IntTypes<2> { typedef int16_t SignedType; typedef uint16_t UnsignedType; };$/;"	t	struct:WTF::IntTypes	access:public
WTF::IntTypes::SignedType	.\HashFunctions.h	/^    template<> struct IntTypes<4> { typedef int32_t SignedType; typedef uint32_t UnsignedType; };$/;"	t	struct:WTF::IntTypes	access:public
WTF::IntTypes::SignedType	.\HashFunctions.h	/^    template<> struct IntTypes<8> { typedef int64_t SignedType; typedef uint64_t UnsignedType; };$/;"	t	struct:WTF::IntTypes	access:public
WTF::IntTypes::UnsignedType	.\HashFunctions.h	/^    template<> struct IntTypes<1> { typedef int8_t SignedType; typedef uint8_t UnsignedType; };$/;"	t	struct:WTF::IntTypes	access:public
WTF::IntTypes::UnsignedType	.\HashFunctions.h	/^    template<> struct IntTypes<2> { typedef int16_t SignedType; typedef uint16_t UnsignedType; };$/;"	t	struct:WTF::IntTypes	access:public
WTF::IntTypes::UnsignedType	.\HashFunctions.h	/^    template<> struct IntTypes<4> { typedef int32_t SignedType; typedef uint32_t UnsignedType; };$/;"	t	struct:WTF::IntTypes	access:public
WTF::IntTypes::UnsignedType	.\HashFunctions.h	/^    template<> struct IntTypes<8> { typedef int64_t SignedType; typedef uint64_t UnsignedType; };$/;"	t	struct:WTF::IntTypes	access:public
WTF::IntegralConstant	.\TypeTraits.h	/^    struct IntegralConstant {$/;"	s	namespace:WTF
WTF::IntegralConstant::type	.\TypeTraits.h	/^        typedef IntegralConstant<T, v> type;$/;"	t	struct:WTF::IntegralConstant	access:public
WTF::IntegralConstant::value	.\TypeTraits.h	/^        static const T value = v;$/;"	m	struct:WTF::IntegralConstant	access:public
WTF::IntegralConstant::value_type	.\TypeTraits.h	/^        typedef T value_type;$/;"	t	struct:WTF::IntegralConstant	access:public
WTF::IntegralTypedArrayBase	.\IntegralTypedArrayBase.h	/^class IntegralTypedArrayBase : public TypedArrayBase<T> {$/;"	c	namespace:WTF	inherits:TypedArrayBase
WTF::IntegralTypedArrayBase::IntegralTypedArrayBase	.\IntegralTypedArrayBase.h	/^    IntegralTypedArrayBase(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::IntegralTypedArrayBase	access:protected	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
WTF::IntegralTypedArrayBase::item	.\IntegralTypedArrayBase.h	/^    T item(unsigned index) const$/;"	f	class:WTF::IntegralTypedArrayBase	access:public	signature:(unsigned index) const
WTF::IntegralTypedArrayBase::set	.\IntegralTypedArrayBase.h	/^    void set(unsigned index, double value)$/;"	f	class:WTF::IntegralTypedArrayBase	access:public	signature:(unsigned index, double value)
WTF::Internal	.\FastAllocBase.h	/^    namespace Internal {$/;"	n	namespace:WTF
WTF::Internal	.\FastMalloc.cpp	/^namespace Internal {$/;"	n	namespace:WTF	file:
WTF::Internal	.\FastMalloc.h	/^    namespace Internal {$/;"	n	namespace:WTF
WTF::Internal	.\HexNumber.h	/^namespace Internal {$/;"	n	namespace:WTF
WTF::Internal	.\wince\FastMallocWinCE.h	/^    namespace Internal {$/;"	n	namespace:WTF
WTF::Internal::AllocType	.\FastMalloc.h	/^        enum AllocType {                    \/\/ Start with an unusual number instead of zero, because zero is common.$/;"	g	namespace:WTF::Internal
WTF::Internal::AllocType	.\wince\FastMallocWinCE.h	/^        enum AllocType {                    \/\/ Start with an unusual number instead of zero, because zero is common.$/;"	g	namespace:WTF::Internal
WTF::Internal::AllocTypeClassNew	.\FastMalloc.h	/^            AllocTypeClassNew,              \/\/ Encompasses class operator new from FastAllocBase.$/;"	e	enum:WTF::Internal::AllocType
WTF::Internal::AllocTypeClassNew	.\wince\FastMallocWinCE.h	/^            AllocTypeClassNew,              \/\/ Encompasses class operator new from FastAllocBase.$/;"	e	enum:WTF::Internal::AllocType
WTF::Internal::AllocTypeClassNewArray	.\FastMalloc.h	/^            AllocTypeClassNewArray,         \/\/ Encompasses class operator new[] from FastAllocBase.$/;"	e	enum:WTF::Internal::AllocType
WTF::Internal::AllocTypeClassNewArray	.\wince\FastMallocWinCE.h	/^            AllocTypeClassNewArray,         \/\/ Encompasses class operator new[] from FastAllocBase.$/;"	e	enum:WTF::Internal::AllocType
WTF::Internal::AllocTypeFastNew	.\FastMalloc.h	/^            AllocTypeFastNew,               \/\/ Encompasses fastNew.$/;"	e	enum:WTF::Internal::AllocType
WTF::Internal::AllocTypeFastNew	.\wince\FastMallocWinCE.h	/^            AllocTypeFastNew,               \/\/ Encompasses fastNew.$/;"	e	enum:WTF::Internal::AllocType
WTF::Internal::AllocTypeFastNewArray	.\FastMalloc.h	/^            AllocTypeFastNewArray,          \/\/ Encompasses fastNewArray.$/;"	e	enum:WTF::Internal::AllocType
WTF::Internal::AllocTypeFastNewArray	.\wince\FastMallocWinCE.h	/^            AllocTypeFastNewArray,          \/\/ Encompasses fastNewArray.$/;"	e	enum:WTF::Internal::AllocType
WTF::Internal::AllocTypeMalloc	.\FastMalloc.h	/^            AllocTypeMalloc = 0x375d6750,   \/\/ Encompasses fastMalloc, fastZeroedMalloc, fastCalloc, fastRealloc.$/;"	e	enum:WTF::Internal::AllocType
WTF::Internal::AllocTypeMalloc	.\wince\FastMallocWinCE.h	/^            AllocTypeMalloc = 0x375d6750,   \/\/ Encompasses fastMalloc, fastZeroedMalloc, fastCalloc, fastRealloc.$/;"	e	enum:WTF::Internal::AllocType
WTF::Internal::AllocTypeNew	.\FastMalloc.h	/^            AllocTypeNew,                   \/\/ Encompasses global operator new.$/;"	e	enum:WTF::Internal::AllocType
WTF::Internal::AllocTypeNew	.\wince\FastMallocWinCE.h	/^            AllocTypeNew,                   \/\/ Encompasses global operator new.$/;"	e	enum:WTF::Internal::AllocType
WTF::Internal::AllocTypeNewArray	.\FastMalloc.h	/^            AllocTypeNewArray               \/\/ Encompasses global operator new[].$/;"	e	enum:WTF::Internal::AllocType
WTF::Internal::AllocTypeNewArray	.\wince\FastMallocWinCE.h	/^            AllocTypeNewArray               \/\/ Encompasses global operator new[].$/;"	e	enum:WTF::Internal::AllocType
WTF::Internal::ArraySize	.\FastAllocBase.h	/^        union ArraySize {$/;"	u	namespace:WTF::Internal
WTF::Internal::ArraySize::size	.\FastAllocBase.h	/^            AllocAlignmentInteger* size;$/;"	m	union:WTF::Internal::ArraySize	access:public
WTF::Internal::ArraySize::t	.\FastAllocBase.h	/^            T* t;$/;"	m	union:WTF::Internal::ArraySize	access:public
WTF::Internal::DeleteArrayImpl	.\FastAllocBase.h	/^        struct DeleteArrayImpl {$/;"	s	namespace:WTF::Internal
WTF::Internal::DeleteArrayImpl	.\FastAllocBase.h	/^        struct DeleteArrayImpl<T, false> {$/;"	s	namespace:WTF::Internal
WTF::Internal::DeleteArrayImpl::fastDeleteArray	.\FastAllocBase.h	/^            static void fastDeleteArray(T* p)$/;"	f	struct:WTF::Internal::DeleteArrayImpl	access:public	signature:(T* p)
WTF::Internal::DeleteArrayImpl::fastDeleteArray	.\FastAllocBase.h	/^            static void fastDeleteArray(void* p)$/;"	f	struct:WTF::Internal::DeleteArrayImpl	access:public	signature:(void* p)
WTF::Internal::NewArrayImpl	.\FastAllocBase.h	/^        struct NewArrayImpl {$/;"	s	namespace:WTF::Internal
WTF::Internal::NewArrayImpl	.\FastAllocBase.h	/^        struct NewArrayImpl<T, false, false> {$/;"	s	namespace:WTF::Internal
WTF::Internal::NewArrayImpl	.\FastAllocBase.h	/^        struct NewArrayImpl<T, false, true> {$/;"	s	namespace:WTF::Internal
WTF::Internal::NewArrayImpl	.\FastAllocBase.h	/^        struct NewArrayImpl<T, true, false> {$/;"	s	namespace:WTF::Internal
WTF::Internal::NewArrayImpl::fastNewArray	.\FastAllocBase.h	/^            static T* fastNewArray(size_t count)$/;"	f	struct:WTF::Internal::NewArrayImpl	access:public	signature:(size_t count)
WTF::Internal::NonNullDeleteArrayImpl	.\FastAllocBase.h	/^        struct NonNullDeleteArrayImpl {$/;"	s	namespace:WTF::Internal
WTF::Internal::NonNullDeleteArrayImpl	.\FastAllocBase.h	/^        struct NonNullDeleteArrayImpl<T, false> {$/;"	s	namespace:WTF::Internal
WTF::Internal::NonNullDeleteArrayImpl::fastNonNullDeleteArray	.\FastAllocBase.h	/^            static void fastNonNullDeleteArray(T* p)$/;"	f	struct:WTF::Internal::NonNullDeleteArrayImpl	access:public	signature:(T* p)
WTF::Internal::NonNullDeleteArrayImpl::fastNonNullDeleteArray	.\FastAllocBase.h	/^            static void fastNonNullDeleteArray(void* p)$/;"	f	struct:WTF::Internal::NonNullDeleteArrayImpl	access:public	signature:(void* p)
WTF::Internal::ValidationBufferSize	.\FastMalloc.h	/^        static const int ValidationBufferSize = sizeof(ValidationHeader) + sizeof(ValidationTag);$/;"	v
WTF::Internal::ValidationHeader	.\FastMalloc.h	/^        struct ValidationHeader {$/;"	s	namespace:WTF::Internal
WTF::Internal::ValidationHeader::m_alignment	.\FastMalloc.h	/^            unsigned m_alignment;$/;"	m	struct:WTF::Internal::ValidationHeader	access:public
WTF::Internal::ValidationHeader::m_prefix	.\FastMalloc.h	/^            ValidationTag m_prefix;$/;"	m	struct:WTF::Internal::ValidationHeader	access:public
WTF::Internal::ValidationHeader::m_size	.\FastMalloc.h	/^            unsigned m_size;$/;"	m	struct:WTF::Internal::ValidationHeader	access:public
WTF::Internal::ValidationHeader::m_type	.\FastMalloc.h	/^            AllocType m_type;$/;"	m	struct:WTF::Internal::ValidationHeader	access:public
WTF::Internal::ValidationPrefix	.\FastMalloc.h	/^            ValidationPrefix = 0xf00df00d,$/;"	e	enum:WTF::Internal::__anon7
WTF::Internal::ValidationSuffix	.\FastMalloc.h	/^            ValidationSuffix = 0x0badf00d$/;"	e	enum:WTF::Internal::__anon7
WTF::Internal::ValidationTag	.\FastMalloc.h	/^        typedef unsigned ValidationTag;$/;"	t	namespace:WTF::Internal
WTF::Internal::fastMallocMatchFailed	.\FastMalloc.cpp	/^NO_RETURN_DUE_TO_CRASH void fastMallocMatchFailed(void*)$/;"	f	namespace:WTF::Internal	signature:(void*)
WTF::Internal::fastMallocMatchFailed	.\FastMalloc.cpp	/^WTF_EXPORT_PRIVATE void fastMallocMatchFailed(void*);$/;"	p	namespace:WTF::Internal	file:	signature:(void*)
WTF::Internal::fastMallocMatchFailed	.\FastMalloc.h	/^        void fastMallocMatchFailed(void* p);$/;"	p	namespace:WTF::Internal	signature:(void* p)
WTF::Internal::fastMallocMatchFailed	.\wince\FastMallocWinCE.h	/^        void fastMallocMatchFailed(void* p);$/;"	p	namespace:WTF::Internal	signature:(void* p)
WTF::Internal::fastMallocMatchValidationType	.\FastMalloc.h	/^        inline AllocType fastMallocMatchValidationType(void* p)$/;"	f	namespace:WTF::Internal	signature:(void* p)
WTF::Internal::fastMallocMatchValidationType	.\wince\FastMallocWinCE.h	/^        inline AllocType fastMallocMatchValidationType(const void* p)$/;"	f	namespace:WTF::Internal	signature:(const void* p)
WTF::Internal::fastMallocMatchValidationValue	.\wince\FastMallocWinCE.h	/^        inline AllocAlignmentInteger* fastMallocMatchValidationValue(void* p)$/;"	f	namespace:WTF::Internal	signature:(void* p)
WTF::Internal::fastMallocValidationHeader	.\FastMalloc.h	/^        inline ValidationHeader* fastMallocValidationHeader(void* p)$/;"	f	namespace:WTF::Internal	signature:(void* p)
WTF::Internal::fastMallocValidationSuffix	.\FastMalloc.h	/^        inline ValidationTag* fastMallocValidationSuffix(void* p)$/;"	f	namespace:WTF::Internal	signature:(void* p)
WTF::Internal::hexDigitsForMode	.\HexNumber.h	/^static const char* hexDigitsForMode(HexConversionMode mode)$/;"	f	namespace:WTF::Internal	signature:(HexConversionMode mode)
WTF::Internal::setFastMallocMatchValidationType	.\FastMalloc.h	/^        inline void setFastMallocMatchValidationType(void* p, AllocType allocType)$/;"	f	namespace:WTF::Internal	signature:(void* p, AllocType allocType)
WTF::Internal::setFastMallocMatchValidationType	.\wince\FastMallocWinCE.h	/^        inline void setFastMallocMatchValidationType(void* p, AllocType allocType)$/;"	f	namespace:WTF::Internal	signature:(void* p, AllocType allocType)
WTF::IsArithmetic	.\TypeTraits.h	/^    template<typename T> struct IsArithmetic     { static const bool value = IsInteger<T>::value || IsFloatingPoint<T>::value; };$/;"	s	namespace:WTF
WTF::IsArithmetic::value	.\TypeTraits.h	/^    template<typename T> struct IsArithmetic     { static const bool value = IsInteger<T>::value || IsFloatingPoint<T>::value; };$/;"	m	struct:WTF::IsArithmetic	access:public
WTF::IsArray	.\TypeTraits.h	/^    template <class T, size_t N> struct IsArray<T[N]> {$/;"	s	namespace:WTF
WTF::IsArray	.\TypeTraits.h	/^    template <class T> struct IsArray {$/;"	s	namespace:WTF
WTF::IsArray	.\TypeTraits.h	/^    template <class T> struct IsArray<T[]> {$/;"	s	namespace:WTF
WTF::IsArray::value	.\TypeTraits.h	/^        static const bool value = false;$/;"	m	struct:WTF::IsArray	access:public
WTF::IsArray::value	.\TypeTraits.h	/^        static const bool value = true;$/;"	m	struct:WTF::IsArray	access:public
WTF::IsConvertibleToInteger	.\TypeTraits.h	/^    template<typename T> class IsConvertibleToInteger {$/;"	c	namespace:WTF
WTF::IsConvertibleToInteger::IsConvertibleToDouble	.\TypeTraits.h	/^        template<typename U> class IsConvertibleToDouble<false, U> {$/;"	c	class:WTF::IsConvertibleToInteger	access:private
WTF::IsConvertibleToInteger::IsConvertibleToDouble	.\TypeTraits.h	/^        template<typename U> class IsConvertibleToDouble<true, U> {$/;"	c	class:WTF::IsConvertibleToInteger	access:private
WTF::IsConvertibleToInteger::IsConvertibleToDouble::NoType	.\TypeTraits.h	/^            struct NoType {$/;"	s	class:WTF::IsConvertibleToInteger::IsConvertibleToDouble	access:private
WTF::IsConvertibleToInteger::IsConvertibleToDouble::NoType::padding	.\TypeTraits.h	/^                char padding[8];$/;"	m	struct:WTF::IsConvertibleToInteger::IsConvertibleToDouble::NoType	access:public
WTF::IsConvertibleToInteger::IsConvertibleToDouble::YesType	.\TypeTraits.h	/^            typedef char YesType;$/;"	t	class:WTF::IsConvertibleToInteger::IsConvertibleToDouble	access:private
WTF::IsConvertibleToInteger::IsConvertibleToDouble::floatCheck	.\TypeTraits.h	/^            static NoType floatCheck(...);$/;"	p	class:WTF::IsConvertibleToInteger::IsConvertibleToDouble	access:private	signature:(....)
WTF::IsConvertibleToInteger::IsConvertibleToDouble::floatCheck	.\TypeTraits.h	/^            static YesType floatCheck(long double);$/;"	p	class:WTF::IsConvertibleToInteger::IsConvertibleToDouble	access:private	signature:(long double)
WTF::IsConvertibleToInteger::IsConvertibleToDouble::t	.\TypeTraits.h	/^            static T& t;$/;"	m	class:WTF::IsConvertibleToInteger::IsConvertibleToDouble	access:private
WTF::IsConvertibleToInteger::IsConvertibleToDouble::value	.\TypeTraits.h	/^            static const bool value = false;$/;"	m	class:WTF::IsConvertibleToInteger::IsConvertibleToDouble	access:public
WTF::IsConvertibleToInteger::IsConvertibleToDouble::value	.\TypeTraits.h	/^            static const bool value = sizeof(floatCheck(t)) == sizeof(YesType);$/;"	m	class:WTF::IsConvertibleToInteger::IsConvertibleToDouble	access:public
WTF::IsConvertibleToInteger::value	.\TypeTraits.h	/^        static const bool value = IsInteger<T>::value || IsConvertibleToDouble<!IsInteger<T>::value, T>::value;$/;"	m	class:WTF::IsConvertibleToInteger	access:public
WTF::IsConvertibleToIntegerCheck	.\TypeTraits.cpp	/^enum IsConvertibleToIntegerCheck { };$/;"	g	namespace:WTF	file:
WTF::IsFloatingPoint	.\TypeTraits.h	/^    template<> struct IsFloatingPoint<double>       { static const bool value = true; };$/;"	s	namespace:WTF
WTF::IsFloatingPoint	.\TypeTraits.h	/^    template<> struct IsFloatingPoint<float>        { static const bool value = true; };$/;"	s	namespace:WTF
WTF::IsFloatingPoint	.\TypeTraits.h	/^    template<> struct IsFloatingPoint<long double>  { static const bool value = true; };$/;"	s	namespace:WTF
WTF::IsFloatingPoint	.\TypeTraits.h	/^    template<typename T> struct IsFloatingPoint     { static const bool value = false; };$/;"	s	namespace:WTF
WTF::IsFloatingPoint::value	.\TypeTraits.h	/^    template<> struct IsFloatingPoint<double>       { static const bool value = true; };$/;"	m	struct:WTF::IsFloatingPoint	access:public
WTF::IsFloatingPoint::value	.\TypeTraits.h	/^    template<> struct IsFloatingPoint<float>        { static const bool value = true; };$/;"	m	struct:WTF::IsFloatingPoint	access:public
WTF::IsFloatingPoint::value	.\TypeTraits.h	/^    template<> struct IsFloatingPoint<long double>  { static const bool value = true; };$/;"	m	struct:WTF::IsFloatingPoint	access:public
WTF::IsFloatingPoint::value	.\TypeTraits.h	/^    template<typename T> struct IsFloatingPoint     { static const bool value = false; };$/;"	m	struct:WTF::IsFloatingPoint	access:public
WTF::IsInteger	.\TypeTraits.h	/^    template<> struct IsInteger<bool>               { static const bool value = true; };$/;"	s	namespace:WTF
WTF::IsInteger	.\TypeTraits.h	/^    template<> struct IsInteger<char>               { static const bool value = true; };$/;"	s	namespace:WTF
WTF::IsInteger	.\TypeTraits.h	/^    template<> struct IsInteger<int>                { static const bool value = true; };$/;"	s	namespace:WTF
WTF::IsInteger	.\TypeTraits.h	/^    template<> struct IsInteger<long long>          { static const bool value = true; };$/;"	s	namespace:WTF
WTF::IsInteger	.\TypeTraits.h	/^    template<> struct IsInteger<long>               { static const bool value = true; };$/;"	s	namespace:WTF
WTF::IsInteger	.\TypeTraits.h	/^    template<> struct IsInteger<short>              { static const bool value = true; };$/;"	s	namespace:WTF
WTF::IsInteger	.\TypeTraits.h	/^    template<> struct IsInteger<signed char>        { static const bool value = true; };$/;"	s	namespace:WTF
WTF::IsInteger	.\TypeTraits.h	/^    template<> struct IsInteger<unsigned char>      { static const bool value = true; };$/;"	s	namespace:WTF
WTF::IsInteger	.\TypeTraits.h	/^    template<> struct IsInteger<unsigned int>       { static const bool value = true; };$/;"	s	namespace:WTF
WTF::IsInteger	.\TypeTraits.h	/^    template<> struct IsInteger<unsigned long long> { static const bool value = true; };$/;"	s	namespace:WTF
WTF::IsInteger	.\TypeTraits.h	/^    template<> struct IsInteger<unsigned long>      { static const bool value = true; };$/;"	s	namespace:WTF
WTF::IsInteger	.\TypeTraits.h	/^    template<> struct IsInteger<unsigned short>     { static const bool value = true; };$/;"	s	namespace:WTF
WTF::IsInteger	.\TypeTraits.h	/^    template<> struct IsInteger<wchar_t>            { static const bool value = true; };$/;"	s	namespace:WTF
WTF::IsInteger	.\TypeTraits.h	/^    template<typename T> struct IsInteger           { static const bool value = false; };$/;"	s	namespace:WTF
WTF::IsInteger::value	.\TypeTraits.h	/^    template<> struct IsInteger<bool>               { static const bool value = true; };$/;"	m	struct:WTF::IsInteger	access:public
WTF::IsInteger::value	.\TypeTraits.h	/^    template<> struct IsInteger<char>               { static const bool value = true; };$/;"	m	struct:WTF::IsInteger	access:public
WTF::IsInteger::value	.\TypeTraits.h	/^    template<> struct IsInteger<int>                { static const bool value = true; };$/;"	m	struct:WTF::IsInteger	access:public
WTF::IsInteger::value	.\TypeTraits.h	/^    template<> struct IsInteger<long long>          { static const bool value = true; };$/;"	m	struct:WTF::IsInteger	access:public
WTF::IsInteger::value	.\TypeTraits.h	/^    template<> struct IsInteger<long>               { static const bool value = true; };$/;"	m	struct:WTF::IsInteger	access:public
WTF::IsInteger::value	.\TypeTraits.h	/^    template<> struct IsInteger<short>              { static const bool value = true; };$/;"	m	struct:WTF::IsInteger	access:public
WTF::IsInteger::value	.\TypeTraits.h	/^    template<> struct IsInteger<signed char>        { static const bool value = true; };$/;"	m	struct:WTF::IsInteger	access:public
WTF::IsInteger::value	.\TypeTraits.h	/^    template<> struct IsInteger<unsigned char>      { static const bool value = true; };$/;"	m	struct:WTF::IsInteger	access:public
WTF::IsInteger::value	.\TypeTraits.h	/^    template<> struct IsInteger<unsigned int>       { static const bool value = true; };$/;"	m	struct:WTF::IsInteger	access:public
WTF::IsInteger::value	.\TypeTraits.h	/^    template<> struct IsInteger<unsigned long long> { static const bool value = true; };$/;"	m	struct:WTF::IsInteger	access:public
WTF::IsInteger::value	.\TypeTraits.h	/^    template<> struct IsInteger<unsigned long>      { static const bool value = true; };$/;"	m	struct:WTF::IsInteger	access:public
WTF::IsInteger::value	.\TypeTraits.h	/^    template<> struct IsInteger<unsigned short>     { static const bool value = true; };$/;"	m	struct:WTF::IsInteger	access:public
WTF::IsInteger::value	.\TypeTraits.h	/^    template<> struct IsInteger<wchar_t>            { static const bool value = true; };$/;"	m	struct:WTF::IsInteger	access:public
WTF::IsInteger::value	.\TypeTraits.h	/^    template<typename T> struct IsInteger           { static const bool value = false; };$/;"	m	struct:WTF::IsInteger	access:public
WTF::IsPod	.\TypeTraits.h	/^    template <typename P> struct IsPod<P*>       { static const bool value = true; };$/;"	s	namespace:WTF
WTF::IsPod	.\TypeTraits.h	/^    template <typename T> struct IsPod           { static const bool value = IsArithmetic<T>::value; };$/;"	s	namespace:WTF
WTF::IsPod::value	.\TypeTraits.h	/^    template <typename P> struct IsPod<P*>       { static const bool value = true; };$/;"	m	struct:WTF::IsPod	access:public
WTF::IsPod::value	.\TypeTraits.h	/^    template <typename T> struct IsPod           { static const bool value = IsArithmetic<T>::value; };$/;"	m	struct:WTF::IsPod	access:public
WTF::IsSameType	.\TypeTraits.h	/^    template <typename T, typename U> struct IsSameType {$/;"	s	namespace:WTF
WTF::IsSameType	.\TypeTraits.h	/^    template <typename T> struct IsSameType<T, T> {$/;"	s	namespace:WTF
WTF::IsSameType::value	.\TypeTraits.h	/^        static const bool value = false;$/;"	m	struct:WTF::IsSameType	access:public
WTF::IsSameType::value	.\TypeTraits.h	/^        static const bool value = true;$/;"	m	struct:WTF::IsSameType	access:public
WTF::IsSubclass	.\TypeTraits.h	/^    template <typename T, typename U> class IsSubclass {$/;"	c	namespace:WTF
WTF::IsSubclass::NoType	.\TypeTraits.h	/^        struct NoType {$/;"	s	class:WTF::IsSubclass	access:private
WTF::IsSubclass::NoType::padding	.\TypeTraits.h	/^            char padding[8];$/;"	m	struct:WTF::IsSubclass::NoType	access:public
WTF::IsSubclass::YesType	.\TypeTraits.h	/^        typedef char YesType;$/;"	t	class:WTF::IsSubclass	access:private
WTF::IsSubclass::subclassCheck	.\TypeTraits.h	/^        static NoType subclassCheck(...);$/;"	p	class:WTF::IsSubclass	access:private	signature:(....)
WTF::IsSubclass::subclassCheck	.\TypeTraits.h	/^        static YesType subclassCheck(U*);$/;"	p	class:WTF::IsSubclass	access:private	signature:(U*)
WTF::IsSubclass::t	.\TypeTraits.h	/^        static T* t;$/;"	m	class:WTF::IsSubclass	access:private
WTF::IsSubclass::value	.\TypeTraits.h	/^        static const bool value = sizeof(subclassCheck(t)) == sizeof(YesType);$/;"	m	class:WTF::IsSubclass	access:public
WTF::IsSubclassOfTemplate	.\TypeTraits.h	/^    template <typename T, template<class V> class U> class IsSubclassOfTemplate {$/;"	c	namespace:WTF
WTF::IsSubclassOfTemplate::NoType	.\TypeTraits.h	/^        struct NoType {$/;"	s	class:WTF::IsSubclassOfTemplate	access:private
WTF::IsSubclassOfTemplate::NoType::padding	.\TypeTraits.h	/^            char padding[8];$/;"	m	struct:WTF::IsSubclassOfTemplate::NoType	access:public
WTF::IsSubclassOfTemplate::YesType	.\TypeTraits.h	/^        typedef char YesType;$/;"	t	class:WTF::IsSubclassOfTemplate	access:private
WTF::IsSubclassOfTemplate::subclassCheck	.\TypeTraits.h	/^        static NoType subclassCheck(...);$/;"	p	class:WTF::IsSubclassOfTemplate	access:private	signature:(....)
WTF::IsSubclassOfTemplate::subclassCheck	.\TypeTraits.h	/^        template<typename W> static YesType subclassCheck(U<W>*);$/;"	p	class:WTF::IsSubclassOfTemplate	access:private	signature:(U<W>*)
WTF::IsSubclassOfTemplate::t	.\TypeTraits.h	/^        static T* t;$/;"	m	class:WTF::IsSubclassOfTemplate	access:private
WTF::IsSubclassOfTemplate::value	.\TypeTraits.h	/^        static const bool value = sizeof(subclassCheck(t)) == sizeof(YesType);$/;"	m	class:WTF::IsSubclassOfTemplate	access:public
WTF::IsWhiteSpaceFunctionPtr	.\text\StringImpl.h	/^typedef bool (*IsWhiteSpaceFunctionPtr)(UChar);$/;"	t	namespace:WTF
WTF::KB	.\StdLibExtras.h	/^static const size_t KB = 1024;$/;"	v
WTF::KernelSupportsTLS	.\FastMalloc.cpp	/^  static inline bool KernelSupportsTLS() {$/;"	f	namespace:WTF	file:	signature:()
WTF::KeyMustBePresentInArray	.\StdLibExtras.h	/^    KeyMustBePresentInArray,$/;"	e	enum:WTF::BinarySearchMode
WTF::KeyMustNotBePresentInArray	.\StdLibExtras.h	/^    KeyMustNotBePresentInArray$/;"	e	enum:WTF::BinarySearchMode
WTF::KnownZone	.\DateMath.cpp	/^static const struct KnownZone {$/;"	s	namespace:WTF	file:
WTF::KnownZone::tzName	.\DateMath.cpp	/^        char tzName[4];$/;"	m	struct:WTF::KnownZone	file:	access:public
WTF::KnownZone::tzOffset	.\DateMath.cpp	/^    int tzOffset;$/;"	m	struct:WTF::KnownZone	file:	access:public
WTF::Length	.\FastMalloc.cpp	/^typedef uintptr_t Length;$/;"	t	namespace:WTF	file:
WTF::LgFloor	.\FastMalloc.cpp	/^static inline int LgFloor(size_t n) {$/;"	f	namespace:WTF	file:	signature:(size_t n)
WTF::ListHashSet	.\ListHashSet.h	/^    template<typename ValueArg, size_t inlineCapacity = 256, typename HashArg = typename DefaultHash<ValueArg>::Hash> class ListHashSet {$/;"	c	namespace:WTF
WTF::ListHashSet::BaseTranslator	.\ListHashSet.h	/^        typedef ListHashSetTranslator<HashArg> BaseTranslator;$/;"	t	class:WTF::ListHashSet	access:private
WTF::ListHashSet::HashFunctions	.\ListHashSet.h	/^        typedef HashArg HashFunctions;$/;"	t	class:WTF::ListHashSet	access:private
WTF::ListHashSet::ImplType	.\ListHashSet.h	/^        typedef HashTable<Node*, Node*, IdentityExtractor, NodeHash, NodeTraits, NodeTraits> ImplType;$/;"	t	class:WTF::ListHashSet	access:private
WTF::ListHashSet::ImplTypeConstIterator	.\ListHashSet.h	/^        typedef HashTableConstIterator<Node*, Node*, IdentityExtractor, NodeHash, NodeTraits, NodeTraits> ImplTypeConstIterator;$/;"	t	class:WTF::ListHashSet	access:private
WTF::ListHashSet::ImplTypeIterator	.\ListHashSet.h	/^        typedef HashTableIterator<Node*, Node*, IdentityExtractor, NodeHash, NodeTraits, NodeTraits> ImplTypeIterator;$/;"	t	class:WTF::ListHashSet	access:private
WTF::ListHashSet::ListHashSet	.\ListHashSet.h	/^        ListHashSet();$/;"	p	class:WTF::ListHashSet	access:public	signature:()
WTF::ListHashSet::ListHashSet	.\ListHashSet.h	/^        ListHashSet(const ListHashSet&);$/;"	p	class:WTF::ListHashSet	access:public	signature:(const ListHashSet&)
WTF::ListHashSet::ListHashSet	.\ListHashSet.h	/^    inline ListHashSet<T, inlineCapacity, U>::ListHashSet()$/;"	f	class:WTF::ListHashSet	signature:()
WTF::ListHashSet::ListHashSet	.\ListHashSet.h	/^    inline ListHashSet<T, inlineCapacity, U>::ListHashSet(const ListHashSet& other)$/;"	f	class:WTF::ListHashSet	signature:(const ListHashSet& other)
WTF::ListHashSet::Node	.\ListHashSet.h	/^        typedef ListHashSetNode<ValueArg, inlineCapacity> Node;$/;"	t	class:WTF::ListHashSet	access:private
WTF::ListHashSet::NodeAllocator	.\ListHashSet.h	/^        typedef ListHashSetNodeAllocator<ValueArg, inlineCapacity> NodeAllocator;$/;"	t	class:WTF::ListHashSet	access:private
WTF::ListHashSet::NodeHash	.\ListHashSet.h	/^        typedef ListHashSetNodeHashFunctions<HashArg> NodeHash;$/;"	t	class:WTF::ListHashSet	access:private
WTF::ListHashSet::NodeTraits	.\ListHashSet.h	/^        typedef HashTraits<Node*> NodeTraits;$/;"	t	class:WTF::ListHashSet	access:private
WTF::ListHashSet::ValueType	.\ListHashSet.h	/^        typedef ValueArg ValueType;$/;"	t	class:WTF::ListHashSet	access:public
WTF::ListHashSet::WTF_MAKE_FAST_ALLOCATED	.\ListHashSet.h	/^        WTF_MAKE_FAST_ALLOCATED;$/;"	m	class:WTF::ListHashSet	access:private
WTF::ListHashSet::add	.\ListHashSet.h	/^        pair<iterator, bool> add(const ValueType&);$/;"	p	class:WTF::ListHashSet	access:public	signature:(const ValueType&)
WTF::ListHashSet::add	.\ListHashSet.h	/^    pair<typename ListHashSet<T, inlineCapacity, U>::iterator, bool> ListHashSet<T, inlineCapacity, U>::add(const ValueType &value)$/;"	f	class:WTF::ListHashSet	signature:(const ValueType &value)
WTF::ListHashSet::appendNode	.\ListHashSet.h	/^        void appendNode(Node*);$/;"	p	class:WTF::ListHashSet	access:private	signature:(Node*)
WTF::ListHashSet::appendNode	.\ListHashSet.h	/^    void ListHashSet<T, inlineCapacity, U>::appendNode(Node* node)$/;"	f	class:WTF::ListHashSet	signature:(Node* node)
WTF::ListHashSet::begin	.\ListHashSet.h	/^        const_iterator begin() const;$/;"	p	class:WTF::ListHashSet	access:public	signature:() const
WTF::ListHashSet::begin	.\ListHashSet.h	/^        iterator begin();$/;"	p	class:WTF::ListHashSet	access:public	signature:()
WTF::ListHashSet::begin	.\ListHashSet.h	/^    inline typename ListHashSet<T, inlineCapacity, U>::const_iterator ListHashSet<T, inlineCapacity, U>::begin() const$/;"	f	class:WTF::ListHashSet	signature:() const
WTF::ListHashSet::begin	.\ListHashSet.h	/^    inline typename ListHashSet<T, inlineCapacity, U>::iterator ListHashSet<T, inlineCapacity, U>::begin()$/;"	f	class:WTF::ListHashSet	signature:()
WTF::ListHashSet::capacity	.\ListHashSet.h	/^        int capacity() const;$/;"	p	class:WTF::ListHashSet	access:public	signature:() const
WTF::ListHashSet::capacity	.\ListHashSet.h	/^    inline int ListHashSet<T, inlineCapacity, U>::capacity() const$/;"	f	class:WTF::ListHashSet	signature:() const
WTF::ListHashSet::clear	.\ListHashSet.h	/^        void clear();$/;"	p	class:WTF::ListHashSet	access:public	signature:()
WTF::ListHashSet::clear	.\ListHashSet.h	/^    inline void ListHashSet<T, inlineCapacity, U>::clear()$/;"	f	class:WTF::ListHashSet	signature:()
WTF::ListHashSet::const_iterator	.\ListHashSet.h	/^        typedef ListHashSetConstIterator<ValueType, inlineCapacity, HashArg> const_iterator;$/;"	t	class:WTF::ListHashSet	access:public
WTF::ListHashSet::const_reverse_iterator	.\ListHashSet.h	/^        typedef ListHashSetConstReverseIterator<ValueType, inlineCapacity, HashArg> const_reverse_iterator;$/;"	t	class:WTF::ListHashSet	access:public
WTF::ListHashSet::contains	.\ListHashSet.h	/^        bool contains(const ValueType&) const;$/;"	p	class:WTF::ListHashSet	access:public	signature:(const ValueType&) const
WTF::ListHashSet::contains	.\ListHashSet.h	/^        template<typename T, typename HashTranslator> bool contains(const T&) const;$/;"	p	class:WTF::ListHashSet	access:public	signature:(const T&) const
WTF::ListHashSet::contains	.\ListHashSet.h	/^    inline bool ListHashSet<T, inlineCapacity, U>::contains(const ValueType& value) const$/;"	f	class:WTF::ListHashSet	signature:(const ValueType& value) const
WTF::ListHashSet::contains	.\ListHashSet.h	/^    inline bool ListHashSet<ValueType, inlineCapacity, U>::contains(const T& value) const$/;"	f	class:WTF::ListHashSet	signature:(const T& value) const
WTF::ListHashSet::deleteAllNodes	.\ListHashSet.h	/^        void deleteAllNodes();$/;"	p	class:WTF::ListHashSet	access:private	signature:()
WTF::ListHashSet::deleteAllNodes	.\ListHashSet.h	/^    void ListHashSet<T, inlineCapacity, U>::deleteAllNodes()$/;"	f	class:WTF::ListHashSet	signature:()
WTF::ListHashSet::deleteAllValues	.\ListHashSet.h	/^        friend void deleteAllValues<>(const ListHashSet&);$/;"	p	class:WTF::ListHashSet	access:friend	signature:(const ListHashSet&)
WTF::ListHashSet::end	.\ListHashSet.h	/^        const_iterator end() const;$/;"	p	class:WTF::ListHashSet	access:public	signature:() const
WTF::ListHashSet::end	.\ListHashSet.h	/^        iterator end();$/;"	p	class:WTF::ListHashSet	access:public	signature:()
WTF::ListHashSet::end	.\ListHashSet.h	/^    inline typename ListHashSet<T, inlineCapacity, U>::const_iterator ListHashSet<T, inlineCapacity, U>::end() const$/;"	f	class:WTF::ListHashSet	signature:() const
WTF::ListHashSet::end	.\ListHashSet.h	/^    inline typename ListHashSet<T, inlineCapacity, U>::iterator ListHashSet<T, inlineCapacity, U>::end()$/;"	f	class:WTF::ListHashSet	signature:()
WTF::ListHashSet::find	.\ListHashSet.h	/^        const_iterator find(const ValueType&) const;$/;"	p	class:WTF::ListHashSet	access:public	signature:(const ValueType&) const
WTF::ListHashSet::find	.\ListHashSet.h	/^        iterator find(const ValueType&);$/;"	p	class:WTF::ListHashSet	access:public	signature:(const ValueType&)
WTF::ListHashSet::find	.\ListHashSet.h	/^        template<typename T, typename HashTranslator> const_iterator find(const T&) const;$/;"	p	class:WTF::ListHashSet	access:public	signature:(const T&) const
WTF::ListHashSet::find	.\ListHashSet.h	/^        template<typename T, typename HashTranslator> iterator find(const T&);$/;"	p	class:WTF::ListHashSet	access:public	signature:(const T&)
WTF::ListHashSet::find	.\ListHashSet.h	/^    inline typename ListHashSet<T, inlineCapacity, U>::const_iterator ListHashSet<T, inlineCapacity, U>::find(const ValueType& value) const$/;"	f	class:WTF::ListHashSet	signature:(const ValueType& value) const
WTF::ListHashSet::find	.\ListHashSet.h	/^    inline typename ListHashSet<T, inlineCapacity, U>::iterator ListHashSet<T, inlineCapacity, U>::find(const ValueType& value)$/;"	f	class:WTF::ListHashSet	signature:(const ValueType& value)
WTF::ListHashSet::find	.\ListHashSet.h	/^    inline typename ListHashSet<ValueType, inlineCapacity, U>::const_iterator ListHashSet<ValueType, inlineCapacity, U>::find(const T& value) const$/;"	f	class:WTF::ListHashSet	signature:(const T& value) const
WTF::ListHashSet::find	.\ListHashSet.h	/^    inline typename ListHashSet<ValueType, inlineCapacity, U>::iterator ListHashSet<ValueType, inlineCapacity, U>::find(const T& value)$/;"	f	class:WTF::ListHashSet	signature:(const T& value)
WTF::ListHashSet::first	.\ListHashSet.h	/^        ValueType& first();$/;"	p	class:WTF::ListHashSet	access:public	signature:()
WTF::ListHashSet::first	.\ListHashSet.h	/^        const ValueType& first() const;$/;"	p	class:WTF::ListHashSet	access:public	signature:() const
WTF::ListHashSet::first	.\ListHashSet.h	/^    inline T& ListHashSet<T, inlineCapacity, U>::first()$/;"	f	class:WTF::ListHashSet	signature:()
WTF::ListHashSet::first	.\ListHashSet.h	/^    inline const T& ListHashSet<T, inlineCapacity, U>::first() const$/;"	f	class:WTF::ListHashSet	signature:() const
WTF::ListHashSet::insertBefore	.\ListHashSet.h	/^        pair<iterator, bool> insertBefore(const ValueType& beforeValue, const ValueType& newValue);$/;"	p	class:WTF::ListHashSet	access:public	signature:(const ValueType& beforeValue, const ValueType& newValue)
WTF::ListHashSet::insertBefore	.\ListHashSet.h	/^        pair<iterator, bool> insertBefore(iterator it, const ValueType&);$/;"	p	class:WTF::ListHashSet	access:public	signature:(iterator it, const ValueType&)
WTF::ListHashSet::insertBefore	.\ListHashSet.h	/^    pair<typename ListHashSet<T, inlineCapacity, U>::iterator, bool> ListHashSet<T, inlineCapacity, U>::insertBefore(const ValueType& beforeValue, const ValueType& newValue)$/;"	f	class:WTF::ListHashSet	signature:(const ValueType& beforeValue, const ValueType& newValue)
WTF::ListHashSet::insertBefore	.\ListHashSet.h	/^    pair<typename ListHashSet<T, inlineCapacity, U>::iterator, bool> ListHashSet<T, inlineCapacity, U>::insertBefore(iterator it, const ValueType& newValue)$/;"	f	class:WTF::ListHashSet	signature:(iterator it, const ValueType& newValue)
WTF::ListHashSet::insertNodeBefore	.\ListHashSet.h	/^        void insertNodeBefore(Node* beforeNode, Node* newNode);$/;"	p	class:WTF::ListHashSet	access:private	signature:(Node* beforeNode, Node* newNode)
WTF::ListHashSet::insertNodeBefore	.\ListHashSet.h	/^    void ListHashSet<T, inlineCapacity, U>::insertNodeBefore(Node* beforeNode, Node* newNode)$/;"	f	class:WTF::ListHashSet	signature:(Node* beforeNode, Node* newNode)
WTF::ListHashSet::isEmpty	.\ListHashSet.h	/^        bool isEmpty() const;$/;"	p	class:WTF::ListHashSet	access:public	signature:() const
WTF::ListHashSet::isEmpty	.\ListHashSet.h	/^    inline bool ListHashSet<T, inlineCapacity, U>::isEmpty() const$/;"	f	class:WTF::ListHashSet	signature:() const
WTF::ListHashSet::iterator	.\ListHashSet.h	/^        typedef ListHashSetIterator<ValueType, inlineCapacity, HashArg> iterator;$/;"	t	class:WTF::ListHashSet	access:public
WTF::ListHashSet::last	.\ListHashSet.h	/^        ValueType& last();$/;"	p	class:WTF::ListHashSet	access:public	signature:()
WTF::ListHashSet::last	.\ListHashSet.h	/^        const ValueType& last() const;$/;"	p	class:WTF::ListHashSet	access:public	signature:() const
WTF::ListHashSet::last	.\ListHashSet.h	/^    inline T& ListHashSet<T, inlineCapacity, U>::last()$/;"	f	class:WTF::ListHashSet	signature:()
WTF::ListHashSet::last	.\ListHashSet.h	/^    inline const T& ListHashSet<T, inlineCapacity, U>::last() const$/;"	f	class:WTF::ListHashSet	signature:() const
WTF::ListHashSet::m_allocator	.\ListHashSet.h	/^        OwnPtr<NodeAllocator> m_allocator;$/;"	m	class:WTF::ListHashSet	access:private
WTF::ListHashSet::m_head	.\ListHashSet.h	/^        Node* m_head;$/;"	m	class:WTF::ListHashSet	access:private
WTF::ListHashSet::m_impl	.\ListHashSet.h	/^        ImplType m_impl;$/;"	m	class:WTF::ListHashSet	access:private
WTF::ListHashSet::m_tail	.\ListHashSet.h	/^        Node* m_tail;$/;"	m	class:WTF::ListHashSet	access:private
WTF::ListHashSet::makeConstIterator	.\ListHashSet.h	/^        const_iterator makeConstIterator(Node*) const;$/;"	p	class:WTF::ListHashSet	access:private	signature:(Node*) const
WTF::ListHashSet::makeConstIterator	.\ListHashSet.h	/^    inline ListHashSetConstIterator<T, inlineCapacity, U> ListHashSet<T, inlineCapacity, U>::makeConstIterator(Node* position) const$/;"	f	class:WTF::ListHashSet	signature:(Node* position) const
WTF::ListHashSet::makeConstReverseIterator	.\ListHashSet.h	/^        const_reverse_iterator makeConstReverseIterator(Node*) const;$/;"	p	class:WTF::ListHashSet	access:private	signature:(Node*) const
WTF::ListHashSet::makeConstReverseIterator	.\ListHashSet.h	/^    inline ListHashSetConstReverseIterator<T, inlineCapacity, U> ListHashSet<T, inlineCapacity, U>::makeConstReverseIterator(Node* position) const$/;"	f	class:WTF::ListHashSet	signature:(Node* position) const
WTF::ListHashSet::makeIterator	.\ListHashSet.h	/^        iterator makeIterator(Node*);$/;"	p	class:WTF::ListHashSet	access:private	signature:(Node*)
WTF::ListHashSet::makeIterator	.\ListHashSet.h	/^    inline ListHashSetIterator<T, inlineCapacity, U> ListHashSet<T, inlineCapacity, U>::makeIterator(Node* position) $/;"	f	class:WTF::ListHashSet	signature:(Node* position)
WTF::ListHashSet::makeReverseIterator	.\ListHashSet.h	/^        reverse_iterator makeReverseIterator(Node*);$/;"	p	class:WTF::ListHashSet	access:private	signature:(Node*)
WTF::ListHashSet::makeReverseIterator	.\ListHashSet.h	/^    inline ListHashSetReverseIterator<T, inlineCapacity, U> ListHashSet<T, inlineCapacity, U>::makeReverseIterator(Node* position) $/;"	f	class:WTF::ListHashSet	signature:(Node* position)
WTF::ListHashSet::operator =	.\ListHashSet.h	/^        ListHashSet& operator=(const ListHashSet&);$/;"	p	class:WTF::ListHashSet	access:public	signature:(const ListHashSet&)
WTF::ListHashSet::operator =	.\ListHashSet.h	/^    inline ListHashSet<T, inlineCapacity, U>& ListHashSet<T, inlineCapacity, U>::operator=(const ListHashSet& other)$/;"	f	class:WTF::ListHashSet	signature:(const ListHashSet& other)
WTF::ListHashSet::rbegin	.\ListHashSet.h	/^        const_reverse_iterator rbegin() const;$/;"	p	class:WTF::ListHashSet	access:public	signature:() const
WTF::ListHashSet::rbegin	.\ListHashSet.h	/^        reverse_iterator rbegin();$/;"	p	class:WTF::ListHashSet	access:public	signature:()
WTF::ListHashSet::rbegin	.\ListHashSet.h	/^    inline typename ListHashSet<T, inlineCapacity, U>::const_reverse_iterator ListHashSet<T, inlineCapacity, U>::rbegin() const$/;"	f	class:WTF::ListHashSet	signature:() const
WTF::ListHashSet::rbegin	.\ListHashSet.h	/^    inline typename ListHashSet<T, inlineCapacity, U>::reverse_iterator ListHashSet<T, inlineCapacity, U>::rbegin()$/;"	f	class:WTF::ListHashSet	signature:()
WTF::ListHashSet::remove	.\ListHashSet.h	/^        void remove(const ValueType&);$/;"	p	class:WTF::ListHashSet	access:public	signature:(const ValueType&)
WTF::ListHashSet::remove	.\ListHashSet.h	/^        void remove(iterator);$/;"	p	class:WTF::ListHashSet	access:public	signature:(iterator)
WTF::ListHashSet::remove	.\ListHashSet.h	/^    inline void ListHashSet<T, inlineCapacity, U>::remove(const ValueType& value)$/;"	f	class:WTF::ListHashSet	signature:(const ValueType& value)
WTF::ListHashSet::remove	.\ListHashSet.h	/^    inline void ListHashSet<T, inlineCapacity, U>::remove(iterator it)$/;"	f	class:WTF::ListHashSet	signature:(iterator it)
WTF::ListHashSet::removeLast	.\ListHashSet.h	/^        void removeLast();$/;"	p	class:WTF::ListHashSet	access:public	signature:()
WTF::ListHashSet::removeLast	.\ListHashSet.h	/^    inline void ListHashSet<T, inlineCapacity, U>::removeLast()$/;"	f	class:WTF::ListHashSet	signature:()
WTF::ListHashSet::rend	.\ListHashSet.h	/^        const_reverse_iterator rend() const;$/;"	p	class:WTF::ListHashSet	access:public	signature:() const
WTF::ListHashSet::rend	.\ListHashSet.h	/^        reverse_iterator rend();$/;"	p	class:WTF::ListHashSet	access:public	signature:()
WTF::ListHashSet::rend	.\ListHashSet.h	/^    inline typename ListHashSet<T, inlineCapacity, U>::const_reverse_iterator ListHashSet<T, inlineCapacity, U>::rend() const$/;"	f	class:WTF::ListHashSet	signature:() const
WTF::ListHashSet::rend	.\ListHashSet.h	/^    inline typename ListHashSet<T, inlineCapacity, U>::reverse_iterator ListHashSet<T, inlineCapacity, U>::rend()$/;"	f	class:WTF::ListHashSet	signature:()
WTF::ListHashSet::reverse_iterator	.\ListHashSet.h	/^        typedef ListHashSetReverseIterator<ValueType, inlineCapacity, HashArg> reverse_iterator;$/;"	t	class:WTF::ListHashSet	access:public
WTF::ListHashSet::size	.\ListHashSet.h	/^        int size() const;$/;"	p	class:WTF::ListHashSet	access:public	signature:() const
WTF::ListHashSet::size	.\ListHashSet.h	/^    inline int ListHashSet<T, inlineCapacity, U>::size() const$/;"	f	class:WTF::ListHashSet	signature:() const
WTF::ListHashSet::swap	.\ListHashSet.h	/^        void swap(ListHashSet&);$/;"	p	class:WTF::ListHashSet	access:public	signature:(ListHashSet&)
WTF::ListHashSet::swap	.\ListHashSet.h	/^    inline void ListHashSet<T, inlineCapacity, U>::swap(ListHashSet& other)$/;"	f	class:WTF::ListHashSet	signature:(ListHashSet& other)
WTF::ListHashSet::unlinkAndDelete	.\ListHashSet.h	/^        void unlinkAndDelete(Node*);$/;"	p	class:WTF::ListHashSet	access:private	signature:(Node*)
WTF::ListHashSet::unlinkAndDelete	.\ListHashSet.h	/^    void ListHashSet<T, inlineCapacity, U>::unlinkAndDelete(Node* node)$/;"	f	class:WTF::ListHashSet	signature:(Node* node)
WTF::ListHashSet::~ListHashSet	.\ListHashSet.h	/^        ~ListHashSet();$/;"	p	class:WTF::ListHashSet	access:public	signature:()
WTF::ListHashSet::~ListHashSet	.\ListHashSet.h	/^    inline ListHashSet<T, inlineCapacity, U>::~ListHashSet()$/;"	f	class:WTF::ListHashSet	signature:()
WTF::ListHashSetConstIterator	.\ListHashSet.h	/^    template<typename ValueArg, size_t inlineCapacity, typename HashArg> class ListHashSetConstIterator {$/;"	c	namespace:WTF
WTF::ListHashSetConstIterator::ListHashSetConstIterator	.\ListHashSet.h	/^        ListHashSetConstIterator()$/;"	f	class:WTF::ListHashSetConstIterator	access:public	signature:()
WTF::ListHashSetConstIterator::ListHashSetConstIterator	.\ListHashSet.h	/^        ListHashSetConstIterator(const ListHashSetType* set, Node* position)$/;"	f	class:WTF::ListHashSetConstIterator	access:private	signature:(const ListHashSetType* set, Node* position)
WTF::ListHashSetConstIterator::ListHashSetType	.\ListHashSet.h	/^        typedef ListHashSet<ValueArg, inlineCapacity, HashArg> ListHashSetType;$/;"	t	class:WTF::ListHashSetConstIterator	access:private
WTF::ListHashSetConstIterator::Node	.\ListHashSet.h	/^        typedef ListHashSetNode<ValueArg, inlineCapacity> Node;$/;"	t	class:WTF::ListHashSetConstIterator	access:private
WTF::ListHashSetConstIterator::PointerType	.\ListHashSet.h	/^        typedef const ValueType* PointerType;$/;"	t	class:WTF::ListHashSetConstIterator	access:private
WTF::ListHashSetConstIterator::ReferenceType	.\ListHashSet.h	/^        typedef const ValueType& ReferenceType;$/;"	t	class:WTF::ListHashSetConstIterator	access:private
WTF::ListHashSetConstIterator::ValueType	.\ListHashSet.h	/^        typedef ValueArg ValueType;$/;"	t	class:WTF::ListHashSetConstIterator	access:private
WTF::ListHashSetConstIterator::const_iterator	.\ListHashSet.h	/^        typedef ListHashSetConstIterator<ValueArg, inlineCapacity, HashArg> const_iterator;$/;"	t	class:WTF::ListHashSetConstIterator	access:private
WTF::ListHashSetConstIterator::get	.\ListHashSet.h	/^        PointerType get() const$/;"	f	class:WTF::ListHashSetConstIterator	access:public	signature:() const
WTF::ListHashSetConstIterator::iterator	.\ListHashSet.h	/^        typedef ListHashSetIterator<ValueArg, inlineCapacity, HashArg> iterator;$/;"	t	class:WTF::ListHashSetConstIterator	access:private
WTF::ListHashSetConstIterator::m_position	.\ListHashSet.h	/^        Node* m_position;$/;"	m	class:WTF::ListHashSetConstIterator	access:private
WTF::ListHashSetConstIterator::m_set	.\ListHashSet.h	/^        const ListHashSetType* m_set;$/;"	m	class:WTF::ListHashSetConstIterator	access:private
WTF::ListHashSetConstIterator::node	.\ListHashSet.h	/^        Node* node() { return m_position; }$/;"	f	class:WTF::ListHashSetConstIterator	access:private	signature:()
WTF::ListHashSetConstIterator::operator !=	.\ListHashSet.h	/^        bool operator!=(const const_iterator& other) const$/;"	f	class:WTF::ListHashSetConstIterator	access:public	signature:(const const_iterator& other) const
WTF::ListHashSetConstIterator::operator *	.\ListHashSet.h	/^        ReferenceType operator*() const { return *get(); }$/;"	f	class:WTF::ListHashSetConstIterator	access:public	signature:() const
WTF::ListHashSetConstIterator::operator ++	.\ListHashSet.h	/^        const_iterator& operator++()$/;"	f	class:WTF::ListHashSetConstIterator	access:public	signature:()
WTF::ListHashSetConstIterator::operator --	.\ListHashSet.h	/^        const_iterator& operator--()$/;"	f	class:WTF::ListHashSetConstIterator	access:public	signature:()
WTF::ListHashSetConstIterator::operator ->	.\ListHashSet.h	/^        PointerType operator->() const { return get(); }$/;"	f	class:WTF::ListHashSetConstIterator	access:public	signature:() const
WTF::ListHashSetConstIterator::operator ==	.\ListHashSet.h	/^        bool operator==(const const_iterator& other) const$/;"	f	class:WTF::ListHashSetConstIterator	access:public	signature:(const const_iterator& other) const
WTF::ListHashSetConstReverseIterator	.\ListHashSet.h	/^    template<typename ValueArg, size_t inlineCapacity, typename HashArg> class ListHashSetConstReverseIterator {$/;"	c	namespace:WTF
WTF::ListHashSetConstReverseIterator::ListHashSetConstReverseIterator	.\ListHashSet.h	/^        ListHashSetConstReverseIterator()$/;"	f	class:WTF::ListHashSetConstReverseIterator	access:public	signature:()
WTF::ListHashSetConstReverseIterator::ListHashSetConstReverseIterator	.\ListHashSet.h	/^        ListHashSetConstReverseIterator(const ListHashSetType* set, Node* position)$/;"	f	class:WTF::ListHashSetConstReverseIterator	access:private	signature:(const ListHashSetType* set, Node* position)
WTF::ListHashSetConstReverseIterator::ListHashSetType	.\ListHashSet.h	/^        typedef ListHashSet<ValueArg, inlineCapacity, HashArg> ListHashSetType;$/;"	t	class:WTF::ListHashSetConstReverseIterator	access:private
WTF::ListHashSetConstReverseIterator::Node	.\ListHashSet.h	/^        typedef ListHashSetNode<ValueArg, inlineCapacity> Node;$/;"	t	class:WTF::ListHashSetConstReverseIterator	access:private
WTF::ListHashSetConstReverseIterator::PointerType	.\ListHashSet.h	/^        typedef const ValueType* PointerType;$/;"	t	class:WTF::ListHashSetConstReverseIterator	access:private
WTF::ListHashSetConstReverseIterator::ReferenceType	.\ListHashSet.h	/^        typedef const ValueType& ReferenceType;$/;"	t	class:WTF::ListHashSetConstReverseIterator	access:private
WTF::ListHashSetConstReverseIterator::ValueType	.\ListHashSet.h	/^        typedef ValueArg ValueType;$/;"	t	class:WTF::ListHashSetConstReverseIterator	access:private
WTF::ListHashSetConstReverseIterator::const_reverse_iterator	.\ListHashSet.h	/^        typedef ListHashSetConstReverseIterator<ValueArg, inlineCapacity, HashArg> const_reverse_iterator;$/;"	t	class:WTF::ListHashSetConstReverseIterator	access:private
WTF::ListHashSetConstReverseIterator::get	.\ListHashSet.h	/^        PointerType get() const$/;"	f	class:WTF::ListHashSetConstReverseIterator	access:public	signature:() const
WTF::ListHashSetConstReverseIterator::m_position	.\ListHashSet.h	/^        Node* m_position;$/;"	m	class:WTF::ListHashSetConstReverseIterator	access:private
WTF::ListHashSetConstReverseIterator::m_set	.\ListHashSet.h	/^        const ListHashSetType* m_set;$/;"	m	class:WTF::ListHashSetConstReverseIterator	access:private
WTF::ListHashSetConstReverseIterator::node	.\ListHashSet.h	/^        Node* node() { return m_position; }$/;"	f	class:WTF::ListHashSetConstReverseIterator	access:private	signature:()
WTF::ListHashSetConstReverseIterator::operator !=	.\ListHashSet.h	/^        bool operator!=(const const_reverse_iterator& other) const$/;"	f	class:WTF::ListHashSetConstReverseIterator	access:public	signature:(const const_reverse_iterator& other) const
WTF::ListHashSetConstReverseIterator::operator *	.\ListHashSet.h	/^        ReferenceType operator*() const { return *get(); }$/;"	f	class:WTF::ListHashSetConstReverseIterator	access:public	signature:() const
WTF::ListHashSetConstReverseIterator::operator ++	.\ListHashSet.h	/^        const_reverse_iterator& operator++()$/;"	f	class:WTF::ListHashSetConstReverseIterator	access:public	signature:()
WTF::ListHashSetConstReverseIterator::operator --	.\ListHashSet.h	/^        const_reverse_iterator& operator--()$/;"	f	class:WTF::ListHashSetConstReverseIterator	access:public	signature:()
WTF::ListHashSetConstReverseIterator::operator ->	.\ListHashSet.h	/^        PointerType operator->() const { return get(); }$/;"	f	class:WTF::ListHashSetConstReverseIterator	access:public	signature:() const
WTF::ListHashSetConstReverseIterator::operator ==	.\ListHashSet.h	/^        bool operator==(const const_reverse_iterator& other) const$/;"	f	class:WTF::ListHashSetConstReverseIterator	access:public	signature:(const const_reverse_iterator& other) const
WTF::ListHashSetConstReverseIterator::reverse_iterator	.\ListHashSet.h	/^        typedef ListHashSetReverseIterator<ValueArg, inlineCapacity, HashArg> reverse_iterator;$/;"	t	class:WTF::ListHashSetConstReverseIterator	access:private
WTF::ListHashSetIterator	.\ListHashSet.h	/^    template<typename ValueArg, size_t inlineCapacity, typename HashArg> class ListHashSetIterator {$/;"	c	namespace:WTF
WTF::ListHashSetIterator::ListHashSetIterator	.\ListHashSet.h	/^        ListHashSetIterator() { }$/;"	f	class:WTF::ListHashSetIterator	access:public	signature:()
WTF::ListHashSetIterator::ListHashSetIterator	.\ListHashSet.h	/^        ListHashSetIterator(const ListHashSetType* set, Node* position) : m_iterator(set, position) { }$/;"	f	class:WTF::ListHashSetIterator	access:private	signature:(const ListHashSetType* set, Node* position)
WTF::ListHashSetIterator::ListHashSetType	.\ListHashSet.h	/^        typedef ListHashSet<ValueArg, inlineCapacity, HashArg> ListHashSetType;$/;"	t	class:WTF::ListHashSetIterator	access:private
WTF::ListHashSetIterator::Node	.\ListHashSet.h	/^        typedef ListHashSetNode<ValueArg, inlineCapacity> Node;$/;"	t	class:WTF::ListHashSetIterator	access:private
WTF::ListHashSetIterator::PointerType	.\ListHashSet.h	/^        typedef ValueType* PointerType;$/;"	t	class:WTF::ListHashSetIterator	access:private
WTF::ListHashSetIterator::ReferenceType	.\ListHashSet.h	/^        typedef ValueType& ReferenceType;$/;"	t	class:WTF::ListHashSetIterator	access:private
WTF::ListHashSetIterator::ValueType	.\ListHashSet.h	/^        typedef ValueArg ValueType;$/;"	t	class:WTF::ListHashSetIterator	access:private
WTF::ListHashSetIterator::const_iterator	.\ListHashSet.h	/^        typedef ListHashSetConstIterator<ValueArg, inlineCapacity, HashArg> const_iterator;$/;"	t	class:WTF::ListHashSetIterator	access:private
WTF::ListHashSetIterator::get	.\ListHashSet.h	/^        PointerType get() const { return const_cast<PointerType>(m_iterator.get()); }$/;"	f	class:WTF::ListHashSetIterator	access:public	signature:() const
WTF::ListHashSetIterator::iterator	.\ListHashSet.h	/^        typedef ListHashSetIterator<ValueArg, inlineCapacity, HashArg> iterator;$/;"	t	class:WTF::ListHashSetIterator	access:private
WTF::ListHashSetIterator::m_iterator	.\ListHashSet.h	/^        const_iterator m_iterator;$/;"	m	class:WTF::ListHashSetIterator	access:private
WTF::ListHashSetIterator::node	.\ListHashSet.h	/^        Node* node() { return m_iterator.node(); }$/;"	f	class:WTF::ListHashSetIterator	access:private	signature:()
WTF::ListHashSetIterator::operator !=	.\ListHashSet.h	/^        bool operator!=(const iterator& other) const { return m_iterator != other.m_iterator; }$/;"	f	class:WTF::ListHashSetIterator	access:public	signature:(const iterator& other) const
WTF::ListHashSetIterator::operator *	.\ListHashSet.h	/^        ReferenceType operator*() const { return *get(); }$/;"	f	class:WTF::ListHashSetIterator	access:public	signature:() const
WTF::ListHashSetIterator::operator ++	.\ListHashSet.h	/^        iterator& operator++() { ++m_iterator; return *this; }$/;"	f	class:WTF::ListHashSetIterator	access:public	signature:()
WTF::ListHashSetIterator::operator --	.\ListHashSet.h	/^        iterator& operator--() { --m_iterator; return *this; }$/;"	f	class:WTF::ListHashSetIterator	access:public	signature:()
WTF::ListHashSetIterator::operator ->	.\ListHashSet.h	/^        PointerType operator->() const { return get(); }$/;"	f	class:WTF::ListHashSetIterator	access:public	signature:() const
WTF::ListHashSetIterator::operator ==	.\ListHashSet.h	/^        bool operator==(const iterator& other) const { return m_iterator == other.m_iterator; }$/;"	f	class:WTF::ListHashSetIterator	access:public	signature:(const iterator& other) const
WTF::ListHashSetIterator::operator const_iterator	.\ListHashSet.h	/^        operator const_iterator() const { return m_iterator; }$/;"	f	class:WTF::ListHashSetIterator	access:public	signature:() const
WTF::ListHashSetNode	.\ListHashSet.h	/^    template<typename ValueArg, size_t inlineCapacity> struct ListHashSetNode {$/;"	s	namespace:WTF
WTF::ListHashSetNode::ListHashSetNode	.\ListHashSet.h	/^        ListHashSetNode(ValueArg value)$/;"	f	struct:WTF::ListHashSetNode	access:public	signature:(ValueArg value)
WTF::ListHashSetNode::NodeAllocator	.\ListHashSet.h	/^        typedef ListHashSetNodeAllocator<ValueArg, inlineCapacity> NodeAllocator;$/;"	t	struct:WTF::ListHashSetNode	access:public
WTF::ListHashSetNode::destroy	.\ListHashSet.h	/^        void destroy(NodeAllocator* allocator)$/;"	f	struct:WTF::ListHashSetNode	access:public	signature:(NodeAllocator* allocator)
WTF::ListHashSetNode::m_isAllocated	.\ListHashSet.h	/^        bool m_isAllocated;$/;"	m	struct:WTF::ListHashSetNode	access:public
WTF::ListHashSetNode::m_next	.\ListHashSet.h	/^        ListHashSetNode* m_next;$/;"	m	struct:WTF::ListHashSetNode	access:public
WTF::ListHashSetNode::m_prev	.\ListHashSet.h	/^        ListHashSetNode* m_prev;$/;"	m	struct:WTF::ListHashSetNode	access:public
WTF::ListHashSetNode::m_value	.\ListHashSet.h	/^        ValueArg m_value;$/;"	m	struct:WTF::ListHashSetNode	access:public
WTF::ListHashSetNode::operator new	.\ListHashSet.h	/^        void* operator new(size_t, NodeAllocator* allocator)$/;"	f	struct:WTF::ListHashSetNode	access:public	signature:(size_t, NodeAllocator* allocator)
WTF::ListHashSetNodeAllocator	.\ListHashSet.h	/^    template<typename ValueArg, size_t inlineCapacity> struct ListHashSetNodeAllocator {$/;"	s	namespace:WTF
WTF::ListHashSetNodeAllocator::ListHashSetNodeAllocator	.\ListHashSet.h	/^        ListHashSetNodeAllocator() $/;"	f	struct:WTF::ListHashSetNodeAllocator	access:public	signature:()
WTF::ListHashSetNodeAllocator::Node	.\ListHashSet.h	/^        typedef ListHashSetNode<ValueArg, inlineCapacity> Node;$/;"	t	struct:WTF::ListHashSetNodeAllocator	access:public
WTF::ListHashSetNodeAllocator::NodeAllocator	.\ListHashSet.h	/^        typedef ListHashSetNodeAllocator<ValueArg, inlineCapacity> NodeAllocator;$/;"	t	struct:WTF::ListHashSetNodeAllocator	access:public
WTF::ListHashSetNodeAllocator::__anon9::forAlignment	.\ListHashSet.h	/^            double forAlignment;$/;"	m	union:WTF::ListHashSetNodeAllocator::__anon9	access:public
WTF::ListHashSetNodeAllocator::__anon9::pool	.\ListHashSet.h	/^            char pool[sizeof(Node) * m_poolSize];$/;"	m	union:WTF::ListHashSetNodeAllocator::__anon9	access:public
WTF::ListHashSetNodeAllocator::allocate	.\ListHashSet.h	/^        Node* allocate()$/;"	f	struct:WTF::ListHashSetNodeAllocator	access:public	signature:()
WTF::ListHashSetNodeAllocator::deallocate	.\ListHashSet.h	/^        void deallocate(Node* node) $/;"	f	struct:WTF::ListHashSetNodeAllocator	access:public	signature:(Node* node)
WTF::ListHashSetNodeAllocator::inPool	.\ListHashSet.h	/^        bool inPool(Node* node)$/;"	f	struct:WTF::ListHashSetNodeAllocator	access:private	signature:(Node* node)
WTF::ListHashSetNodeAllocator::m_freeList	.\ListHashSet.h	/^        Node* m_freeList;$/;"	m	struct:WTF::ListHashSetNodeAllocator	access:private
WTF::ListHashSetNodeAllocator::m_isDoneWithInitialFreeList	.\ListHashSet.h	/^        bool m_isDoneWithInitialFreeList;$/;"	m	struct:WTF::ListHashSetNodeAllocator	access:private
WTF::ListHashSetNodeAllocator::m_pool	.\ListHashSet.h	/^        } m_pool;$/;"	m	struct:WTF::ListHashSetNodeAllocator	typeref:union:WTF::ListHashSetNodeAllocator::__anon9	access:private
WTF::ListHashSetNodeAllocator::m_poolSize	.\ListHashSet.h	/^        static const size_t m_poolSize = inlineCapacity;$/;"	m	struct:WTF::ListHashSetNodeAllocator	access:private
WTF::ListHashSetNodeAllocator::pastPool	.\ListHashSet.h	/^        Node* pastPool() { return pool() + m_poolSize; }$/;"	f	struct:WTF::ListHashSetNodeAllocator	access:private	signature:()
WTF::ListHashSetNodeAllocator::pool	.\ListHashSet.h	/^        Node* pool() { return reinterpret_cast_ptr<Node*>(m_pool.pool); }$/;"	f	struct:WTF::ListHashSetNodeAllocator	access:private	signature:()
WTF::ListHashSetNodeHashFunctions	.\ListHashSet.h	/^    template<typename HashArg> struct ListHashSetNodeHashFunctions {$/;"	s	namespace:WTF
WTF::ListHashSetNodeHashFunctions::equal	.\ListHashSet.h	/^        template<typename T> static bool equal(const T& a, const T& b) { return HashArg::equal(a->m_value, b->m_value); }$/;"	f	struct:WTF::ListHashSetNodeHashFunctions	access:public	signature:(const T& a, const T& b)
WTF::ListHashSetNodeHashFunctions::hash	.\ListHashSet.h	/^        template<typename T> static unsigned hash(const T& key) { return HashArg::hash(key->m_value); }$/;"	f	struct:WTF::ListHashSetNodeHashFunctions	access:public	signature:(const T& key)
WTF::ListHashSetNodeHashFunctions::safeToCompareToEmptyOrDeleted	.\ListHashSet.h	/^        static const bool safeToCompareToEmptyOrDeleted = false;$/;"	m	struct:WTF::ListHashSetNodeHashFunctions	access:public
WTF::ListHashSetReverseIterator	.\ListHashSet.h	/^    template<typename ValueArg, size_t inlineCapacity, typename HashArg> class ListHashSetReverseIterator {$/;"	c	namespace:WTF
WTF::ListHashSetReverseIterator::ListHashSetReverseIterator	.\ListHashSet.h	/^        ListHashSetReverseIterator() { }$/;"	f	class:WTF::ListHashSetReverseIterator	access:public	signature:()
WTF::ListHashSetReverseIterator::ListHashSetReverseIterator	.\ListHashSet.h	/^        ListHashSetReverseIterator(const ListHashSetType* set, Node* position) : m_iterator(set, position) { }$/;"	f	class:WTF::ListHashSetReverseIterator	access:private	signature:(const ListHashSetType* set, Node* position)
WTF::ListHashSetReverseIterator::ListHashSetType	.\ListHashSet.h	/^        typedef ListHashSet<ValueArg, inlineCapacity, HashArg> ListHashSetType;$/;"	t	class:WTF::ListHashSetReverseIterator	access:private
WTF::ListHashSetReverseIterator::Node	.\ListHashSet.h	/^        typedef ListHashSetNode<ValueArg, inlineCapacity> Node;$/;"	t	class:WTF::ListHashSetReverseIterator	access:private
WTF::ListHashSetReverseIterator::PointerType	.\ListHashSet.h	/^        typedef ValueType* PointerType;$/;"	t	class:WTF::ListHashSetReverseIterator	access:private
WTF::ListHashSetReverseIterator::ReferenceType	.\ListHashSet.h	/^        typedef ValueType& ReferenceType;$/;"	t	class:WTF::ListHashSetReverseIterator	access:private
WTF::ListHashSetReverseIterator::ValueType	.\ListHashSet.h	/^        typedef ValueArg ValueType;$/;"	t	class:WTF::ListHashSetReverseIterator	access:private
WTF::ListHashSetReverseIterator::const_reverse_iterator	.\ListHashSet.h	/^        typedef ListHashSetConstReverseIterator<ValueArg, inlineCapacity, HashArg> const_reverse_iterator;$/;"	t	class:WTF::ListHashSetReverseIterator	access:private
WTF::ListHashSetReverseIterator::get	.\ListHashSet.h	/^        PointerType get() const { return const_cast<PointerType>(m_iterator.get()); }$/;"	f	class:WTF::ListHashSetReverseIterator	access:public	signature:() const
WTF::ListHashSetReverseIterator::m_iterator	.\ListHashSet.h	/^        const_reverse_iterator m_iterator;$/;"	m	class:WTF::ListHashSetReverseIterator	access:private
WTF::ListHashSetReverseIterator::node	.\ListHashSet.h	/^        Node* node() { return m_iterator.node(); }$/;"	f	class:WTF::ListHashSetReverseIterator	access:private	signature:()
WTF::ListHashSetReverseIterator::operator !=	.\ListHashSet.h	/^        bool operator!=(const reverse_iterator& other) const { return m_iterator != other.m_iterator; }$/;"	f	class:WTF::ListHashSetReverseIterator	access:public	signature:(const reverse_iterator& other) const
WTF::ListHashSetReverseIterator::operator *	.\ListHashSet.h	/^        ReferenceType operator*() const { return *get(); }$/;"	f	class:WTF::ListHashSetReverseIterator	access:public	signature:() const
WTF::ListHashSetReverseIterator::operator ++	.\ListHashSet.h	/^        reverse_iterator& operator++() { ++m_iterator; return *this; }$/;"	f	class:WTF::ListHashSetReverseIterator	access:public	signature:()
WTF::ListHashSetReverseIterator::operator --	.\ListHashSet.h	/^        reverse_iterator& operator--() { --m_iterator; return *this; }$/;"	f	class:WTF::ListHashSetReverseIterator	access:public	signature:()
WTF::ListHashSetReverseIterator::operator ->	.\ListHashSet.h	/^        PointerType operator->() const { return get(); }$/;"	f	class:WTF::ListHashSetReverseIterator	access:public	signature:() const
WTF::ListHashSetReverseIterator::operator ==	.\ListHashSet.h	/^        bool operator==(const reverse_iterator& other) const { return m_iterator == other.m_iterator; }$/;"	f	class:WTF::ListHashSetReverseIterator	access:public	signature:(const reverse_iterator& other) const
WTF::ListHashSetReverseIterator::operator const_reverse_iterator	.\ListHashSet.h	/^        operator const_reverse_iterator() const { return m_iterator; }$/;"	f	class:WTF::ListHashSetReverseIterator	access:public	signature:() const
WTF::ListHashSetReverseIterator::reverse_iterator	.\ListHashSet.h	/^        typedef ListHashSetReverseIterator<ValueArg, inlineCapacity, HashArg> reverse_iterator;$/;"	t	class:WTF::ListHashSetReverseIterator	access:private
WTF::ListHashSetTranslator	.\ListHashSet.h	/^    struct ListHashSetTranslator {$/;"	s	namespace:WTF
WTF::ListHashSetTranslator::equal	.\ListHashSet.h	/^        template<typename T, typename U> static bool equal(const T& a, const U& b) { return HashFunctions::equal(a->m_value, b); }$/;"	f	struct:WTF::ListHashSetTranslator	access:public	signature:(const T& a, const U& b)
WTF::ListHashSetTranslator::hash	.\ListHashSet.h	/^        template<typename T> static unsigned hash(const T& key) { return HashFunctions::hash(key); }$/;"	f	struct:WTF::ListHashSetTranslator	access:public	signature:(const T& key)
WTF::ListHashSetTranslator::translate	.\ListHashSet.h	/^        template<typename T, typename U, typename V> static void translate(T*& location, const U& key, const V& allocator)$/;"	f	struct:WTF::ListHashSetTranslator	access:public	signature:(T*& location, const U& key, const V& allocator)
WTF::ListHashSetTranslatorAdapter	.\ListHashSet.h	/^    struct ListHashSetTranslatorAdapter {$/;"	s	namespace:WTF
WTF::ListHashSetTranslatorAdapter::equal	.\ListHashSet.h	/^        template<typename T, typename U> static bool equal(const T& a, const U& b) { return Translator::equal(a->m_value, b); }$/;"	f	struct:WTF::ListHashSetTranslatorAdapter	access:public	signature:(const T& a, const U& b)
WTF::ListHashSetTranslatorAdapter::hash	.\ListHashSet.h	/^        template<typename T> static unsigned hash(const T& key) { return Translator::hash(key); }$/;"	f	struct:WTF::ListHashSetTranslatorAdapter	access:public	signature:(const T& key)
WTF::ListRefPtr	.\ListRefPtr.h	/^    template <typename T> class ListRefPtr : public RefPtr<T> {$/;"	c	namespace:WTF	inherits:RefPtr
WTF::ListRefPtr::ListRefPtr	.\ListRefPtr.h	/^        ListRefPtr() : RefPtr<T>() {}$/;"	f	class:WTF::ListRefPtr	access:public	signature:()
WTF::ListRefPtr::ListRefPtr	.\ListRefPtr.h	/^        ListRefPtr(T* ptr) : RefPtr<T>(ptr) {}$/;"	f	class:WTF::ListRefPtr	access:public	signature:(T* ptr)
WTF::ListRefPtr::ListRefPtr	.\ListRefPtr.h	/^        ListRefPtr(const RefPtr<T>& o) : RefPtr<T>(o) {}$/;"	f	class:WTF::ListRefPtr	access:public	signature:(const RefPtr<T>& o)
WTF::ListRefPtr::ListRefPtr	.\ListRefPtr.h	/^        template <typename U> ListRefPtr(const PassRefPtr<U>& o) : RefPtr<T>(o) {}$/;"	f	class:WTF::ListRefPtr	access:public	signature:(const PassRefPtr<U>& o)
WTF::ListRefPtr::operator =	.\ListRefPtr.h	/^        ListRefPtr& operator=(T* optr) { RefPtr<T>::operator=(optr); return *this; }$/;"	f	class:WTF::ListRefPtr	access:public	signature:(T* optr)
WTF::ListRefPtr::operator =	.\ListRefPtr.h	/^        ListRefPtr& operator=(const PassRefPtr<T>& o) { RefPtr<T>::operator=(o); return *this; }$/;"	f	class:WTF::ListRefPtr	access:public	signature:(const PassRefPtr<T>& o)
WTF::ListRefPtr::operator =	.\ListRefPtr.h	/^        ListRefPtr& operator=(const RefPtr<T>& o) { RefPtr<T>::operator=(o); return *this; }$/;"	f	class:WTF::ListRefPtr	access:public	signature:(const RefPtr<T>& o)
WTF::ListRefPtr::operator =	.\ListRefPtr.h	/^        template <typename U> ListRefPtr& operator=(const PassRefPtr<U>& o) { RefPtr<T>::operator=(o); return *this; }$/;"	f	class:WTF::ListRefPtr	access:public	signature:(const PassRefPtr<U>& o)
WTF::ListRefPtr::operator =	.\ListRefPtr.h	/^        template <typename U> ListRefPtr& operator=(const RefPtr<U>& o) { RefPtr<T>::operator=(o); return *this; }$/;"	f	class:WTF::ListRefPtr	access:public	signature:(const RefPtr<U>& o)
WTF::ListRefPtr::~ListRefPtr	.\ListRefPtr.h	/^        ~ListRefPtr()$/;"	f	class:WTF::ListRefPtr	access:public	signature:()
WTF::Locker	.\Locker.h	/^template <typename T> class Locker {$/;"	c	namespace:WTF
WTF::Locker::Locker	.\Locker.h	/^    Locker(T& lockable) : m_lockable(lockable) { m_lockable.lock(); }$/;"	f	class:WTF::Locker	access:public	signature:(T& lockable)
WTF::Locker::WTF_MAKE_NONCOPYABLE	.\Locker.h	/^    WTF_MAKE_NONCOPYABLE(Locker);$/;"	p	class:WTF::Locker	access:private	signature:(Locker)
WTF::Locker::m_lockable	.\Locker.h	/^    T& m_lockable;$/;"	m	class:WTF::Locker	access:private
WTF::Locker::~Locker	.\Locker.h	/^    ~Locker() { m_lockable.unlock(); }$/;"	f	class:WTF::Locker	access:public	signature:()
WTF::Lowercase	.\HexNumber.h	/^    Lowercase,$/;"	e	enum:WTF::HexConversionMode
WTF::MD5	.\MD5.h	/^class MD5 {$/;"	c	namespace:WTF
WTF::MD5::MD5	.\MD5.cpp	/^MD5::MD5()$/;"	f	class:WTF::MD5	signature:()
WTF::MD5::MD5	.\MD5.h	/^    WTF_EXPORT_PRIVATE MD5();$/;"	p	class:WTF::MD5	access:public	signature:()
WTF::MD5::addBytes	.\MD5.cpp	/^void MD5::addBytes(const uint8_t* input, size_t length)$/;"	f	class:WTF::MD5	signature:(const uint8_t* input, size_t length)
WTF::MD5::addBytes	.\MD5.h	/^    WTF_EXPORT_PRIVATE void addBytes(const uint8_t* input, size_t length);$/;"	p	class:WTF::MD5	access:public	signature:(const uint8_t* input, size_t length)
WTF::MD5::addBytes	.\MD5.h	/^    void addBytes(const Vector<uint8_t>& input)$/;"	f	class:WTF::MD5	access:public	signature:(const Vector<uint8_t>& input)
WTF::MD5::checksum	.\MD5.cpp	/^void MD5::checksum(Vector<uint8_t, 16>& digest)$/;"	f	class:WTF::MD5	signature:(Vector<uint8_t, 16>& digest)
WTF::MD5::checksum	.\MD5.h	/^    WTF_EXPORT_PRIVATE void checksum(Vector<uint8_t, 16>&);$/;"	p	class:WTF::MD5	access:public	signature:(Vector<uint8_t, 16>&)
WTF::MD5::m_bits	.\MD5.h	/^    uint32_t m_bits[2];$/;"	m	class:WTF::MD5	access:private
WTF::MD5::m_buf	.\MD5.h	/^    uint32_t m_buf[4];$/;"	m	class:WTF::MD5	access:private
WTF::MD5::m_in	.\MD5.h	/^    uint8_t m_in[64];$/;"	m	class:WTF::MD5	access:private
WTF::MD5Transform	.\MD5.cpp	/^static void MD5Transform(uint32_t buf[4], const uint32_t in[16])$/;"	f	namespace:WTF	file:	signature:(uint32_t buf[4], const uint32_t in[16])
WTF::MS_VC_EXCEPTION	.\ThreadingWin.cpp	/^static const DWORD MS_VC_EXCEPTION = 0x406D1388;$/;"	v	file:
WTF::MachineWord	.\text\ASCIIFastPath.h	/^typedef uintptr_t MachineWord;$/;"	t	namespace:WTF
WTF::MainThreadFunction	.\MainThread.h	/^typedef void MainThreadFunction(void*);$/;"	t	namespace:WTF
WTF::MainThreadInvoker	.\qt\MainThreadQt.cpp	/^class MainThreadInvoker : public QObject {$/;"	c	namespace:WTF	file:	inherits:QObject
WTF::MainThreadInvoker::MainThreadInvoker	.\qt\MainThreadQt.cpp	/^    MainThreadInvoker();$/;"	p	class:WTF::MainThreadInvoker	file:	access:public	signature:()
WTF::MainThreadInvoker::MainThreadInvoker	.\qt\MainThreadQt.cpp	/^MainThreadInvoker::MainThreadInvoker()$/;"	f	class:WTF::MainThreadInvoker	signature:()
WTF::MainThreadInvoker::event	.\qt\MainThreadQt.cpp	/^    virtual bool event(QEvent*);$/;"	p	class:WTF::MainThreadInvoker	file:	access:public	signature:(QEvent*)
WTF::MainThreadInvoker::event	.\qt\MainThreadQt.cpp	/^bool MainThreadInvoker::event(QEvent* e)$/;"	f	class:WTF::MainThreadInvoker	signature:(QEvent* e)
WTF::MapSelector	.\FastMalloc.cpp	/^template <> class MapSelector<32> {$/;"	c	namespace:WTF	file:
WTF::MapSelector	.\FastMalloc.cpp	/^template <> class MapSelector<64> {$/;"	c	namespace:WTF	file:
WTF::MapSelector	.\FastMalloc.cpp	/^template <int BITS> class MapSelector {$/;"	c	namespace:WTF	file:
WTF::MapSelector::CacheType	.\FastMalloc.cpp	/^  typedef PackedCache<32 - kPageShift, uint16_t> CacheType;$/;"	t	class:WTF::MapSelector	file:	access:public
WTF::MapSelector::CacheType	.\FastMalloc.cpp	/^  typedef PackedCache<64, uint64_t> CacheType;$/;"	t	class:WTF::MapSelector	file:	access:public
WTF::MapSelector::CacheType	.\FastMalloc.cpp	/^  typedef PackedCache<BITS, uint64_t> CacheType;$/;"	t	class:WTF::MapSelector	file:	access:public
WTF::MapSelector::Type	.\FastMalloc.cpp	/^  typedef TCMalloc_PageMap2<32 - kPageShift> Type;$/;"	t	class:WTF::MapSelector	file:	access:public
WTF::MapSelector::Type	.\FastMalloc.cpp	/^  typedef TCMalloc_PageMap3<64 - kPageShift - kBitsUnusedOn64Bit> Type;$/;"	t	class:WTF::MapSelector	file:	access:public
WTF::MapSelector::Type	.\FastMalloc.cpp	/^  typedef TCMalloc_PageMap3<BITS-kPageShift> Type;$/;"	t	class:WTF::MapSelector	file:	access:public
WTF::MaxSemaphoreCount	.\ThreadingWin.cpp	/^static const long MaxSemaphoreCount = static_cast<long>(~0UL >> 1);$/;"	v	file:
WTF::MemoryAllocationCanFail	.\wince\MemoryManager.h	/^    class MemoryAllocationCanFail {$/;"	c	namespace:WTF
WTF::MemoryAllocationCanFail::MemoryAllocationCanFail	.\wince\MemoryManager.h	/^        MemoryAllocationCanFail() : m_old(memoryManager()->allocationCanFail()) { memoryManager()->setAllocationCanFail(true); }$/;"	f	class:WTF::MemoryAllocationCanFail	access:public	signature:()
WTF::MemoryAllocationCanFail::m_old	.\wince\MemoryManager.h	/^        bool m_old;$/;"	m	class:WTF::MemoryAllocationCanFail	access:private
WTF::MemoryAllocationCanFail::~MemoryAllocationCanFail	.\wince\MemoryManager.h	/^        ~MemoryAllocationCanFail() { memoryManager()->setAllocationCanFail(m_old); }$/;"	f	class:WTF::MemoryAllocationCanFail	access:public	signature:()
WTF::MemoryAllocationCannotFail	.\wince\MemoryManager.h	/^    class MemoryAllocationCannotFail {$/;"	c	namespace:WTF
WTF::MemoryAllocationCannotFail::MemoryAllocationCannotFail	.\wince\MemoryManager.h	/^        MemoryAllocationCannotFail() : m_old(memoryManager()->allocationCanFail()) { memoryManager()->setAllocationCanFail(false); }$/;"	f	class:WTF::MemoryAllocationCannotFail	access:public	signature:()
WTF::MemoryAllocationCannotFail::m_old	.\wince\MemoryManager.h	/^        bool m_old;$/;"	m	class:WTF::MemoryAllocationCannotFail	access:private
WTF::MemoryAllocationCannotFail::~MemoryAllocationCannotFail	.\wince\MemoryManager.h	/^        ~MemoryAllocationCannotFail() { memoryManager()->setAllocationCanFail(m_old); }$/;"	f	class:WTF::MemoryAllocationCannotFail	access:public	signature:()
WTF::MemoryManager	.\wince\MemoryManager.h	/^    class MemoryManager {$/;"	c	namespace:WTF
WTF::MemoryManager::MemoryManager	.\wince\MemoryManager.cpp	/^MemoryManager::MemoryManager()$/;"	f	class:WTF::MemoryManager	signature:()
WTF::MemoryManager::MemoryManager	.\wince\MemoryManager.h	/^        MemoryManager();$/;"	p	class:WTF::MemoryManager	access:public	signature:()
WTF::MemoryManager::allocate64kBlock	.\wince\MemoryManager.cpp	/^void* MemoryManager::allocate64kBlock()$/;"	f	class:WTF::MemoryManager	signature:()
WTF::MemoryManager::allocate64kBlock	.\wince\MemoryManager.h	/^        static void* allocate64kBlock();$/;"	p	class:WTF::MemoryManager	access:public	signature:()
WTF::MemoryManager::allocationCanFail	.\wince\MemoryManager.h	/^        bool allocationCanFail() const { return m_allocationCanFail; }$/;"	f	class:WTF::MemoryManager	access:public	signature:() const
WTF::MemoryManager::createCompatibleBitmap	.\wince\MemoryManager.cpp	/^HBITMAP MemoryManager::createCompatibleBitmap(HDC hdc, int width, int height)$/;"	f	class:WTF::MemoryManager	signature:(HDC hdc, int width, int height)
WTF::MemoryManager::createCompatibleBitmap	.\wince\MemoryManager.h	/^        static HBITMAP createCompatibleBitmap(HDC hdc, int width, int height);$/;"	p	class:WTF::MemoryManager	access:public	signature:(HDC hdc, int width, int height)
WTF::MemoryManager::createDIBSection	.\wince\MemoryManager.cpp	/^HBITMAP MemoryManager::createDIBSection(const BITMAPINFO* pbmi, void** ppvBits)$/;"	f	class:WTF::MemoryManager	signature:(const BITMAPINFO* pbmi, void** ppvBits)
WTF::MemoryManager::createDIBSection	.\wince\MemoryManager.h	/^        static HBITMAP createDIBSection(const BITMAPINFO* pbmi, void** ppvBits);$/;"	p	class:WTF::MemoryManager	access:public	signature:(const BITMAPINFO* pbmi, void** ppvBits)
WTF::MemoryManager::free64kBlock	.\wince\MemoryManager.cpp	/^void MemoryManager::free64kBlock(void* p)$/;"	f	class:WTF::MemoryManager	signature:(void* p)
WTF::MemoryManager::free64kBlock	.\wince\MemoryManager.h	/^        static void free64kBlock(void*);$/;"	p	class:WTF::MemoryManager	access:public	signature:(void*)
WTF::MemoryManager::m_allocationCanFail	.\wince\MemoryManager.h	/^        bool m_allocationCanFail;$/;"	m	class:WTF::MemoryManager	access:private
WTF::MemoryManager::m_calloc	.\wince\MemoryManager.cpp	/^void* MemoryManager::m_calloc(size_t num, size_t size)$/;"	f	class:WTF::MemoryManager	signature:(size_t num, size_t size)
WTF::MemoryManager::m_calloc	.\wince\MemoryManager.h	/^        static void* m_calloc(size_t num, size_t size);$/;"	p	class:WTF::MemoryManager	access:public	signature:(size_t num, size_t size)
WTF::MemoryManager::m_free	.\wince\MemoryManager.cpp	/^void MemoryManager::m_free(void* p)$/;"	f	class:WTF::MemoryManager	signature:(void* p)
WTF::MemoryManager::m_free	.\wince\MemoryManager.h	/^        static void m_free(void*);$/;"	p	class:WTF::MemoryManager	access:public	signature:(void*)
WTF::MemoryManager::m_malloc	.\wince\MemoryManager.cpp	/^void* MemoryManager::m_malloc(size_t size)$/;"	f	class:WTF::MemoryManager	signature:(size_t size)
WTF::MemoryManager::m_malloc	.\wince\MemoryManager.h	/^        static void* m_malloc(size_t size);$/;"	p	class:WTF::MemoryManager	access:public	signature:(size_t size)
WTF::MemoryManager::m_realloc	.\wince\MemoryManager.cpp	/^void* MemoryManager::m_realloc(void* p, size_t size)$/;"	f	class:WTF::MemoryManager	signature:(void* p, size_t size)
WTF::MemoryManager::m_realloc	.\wince\MemoryManager.h	/^        static void* m_realloc(void* p, size_t size);$/;"	p	class:WTF::MemoryManager	access:public	signature:(void* p, size_t size)
WTF::MemoryManager::memoryManager	.\wince\MemoryManager.h	/^        friend MemoryManager* memoryManager();$/;"	p	class:WTF::MemoryManager	access:friend	signature:()
WTF::MemoryManager::onIdle	.\wince\MemoryManager.cpp	/^bool MemoryManager::onIdle(DWORD& timeLimitMs)$/;"	f	class:WTF::MemoryManager	signature:(DWORD& timeLimitMs)
WTF::MemoryManager::onIdle	.\wince\MemoryManager.h	/^        static bool onIdle(DWORD& timeLimitMs);$/;"	p	class:WTF::MemoryManager	access:public	signature:(DWORD& timeLimitMs)
WTF::MemoryManager::resizeMemory	.\wince\MemoryManager.cpp	/^bool MemoryManager::resizeMemory(void*, size_t)$/;"	f	class:WTF::MemoryManager	signature:(void*, size_t)
WTF::MemoryManager::resizeMemory	.\wince\MemoryManager.h	/^        static bool resizeMemory(void* p, size_t newSize);$/;"	p	class:WTF::MemoryManager	access:public	signature:(void* p, size_t newSize)
WTF::MemoryManager::setAllocationCanFail	.\wince\MemoryManager.h	/^        void setAllocationCanFail(bool c) { m_allocationCanFail = c; }$/;"	f	class:WTF::MemoryManager	access:public	signature:(bool c)
WTF::MemoryManager::virtualAlloc	.\wince\MemoryManager.cpp	/^LPVOID MemoryManager::virtualAlloc(LPVOID lpAddress, DWORD dwSize, DWORD flAllocationType, DWORD flProtect)$/;"	f	class:WTF::MemoryManager	signature:(LPVOID lpAddress, DWORD dwSize, DWORD flAllocationType, DWORD flProtect)
WTF::MemoryManager::virtualAlloc	.\wince\MemoryManager.h	/^        static LPVOID virtualAlloc(LPVOID lpAddress, DWORD dwSize, DWORD flAllocationType, DWORD flProtect);$/;"	p	class:WTF::MemoryManager	access:public	signature:(LPVOID lpAddress, DWORD dwSize, DWORD flAllocationType, DWORD flProtect)
WTF::MemoryManager::virtualFree	.\wince\MemoryManager.cpp	/^BOOL MemoryManager::virtualFree(LPVOID lpAddress, DWORD dwSize, DWORD dwFreeType)$/;"	f	class:WTF::MemoryManager	signature:(LPVOID lpAddress, DWORD dwSize, DWORD dwFreeType)
WTF::MemoryManager::virtualFree	.\wince\MemoryManager.h	/^        static BOOL virtualFree(LPVOID lpAddress, DWORD dwSize, DWORD dwFreeType);$/;"	p	class:WTF::MemoryManager	access:public	signature:(LPVOID lpAddress, DWORD dwSize, DWORD dwFreeType)
WTF::MemoryManager::~MemoryManager	.\wince\MemoryManager.cpp	/^MemoryManager::~MemoryManager()$/;"	f	class:WTF::MemoryManager	signature:()
WTF::MemoryManager::~MemoryManager	.\wince\MemoryManager.h	/^        ~MemoryManager();$/;"	p	class:WTF::MemoryManager	access:public	signature:()
WTF::MessageQueue	.\MessageQueue.h	/^    class MessageQueue {$/;"	c	namespace:WTF
WTF::MessageQueue::MessageQueue	.\MessageQueue.h	/^        MessageQueue() : m_killed(false) { }$/;"	f	class:WTF::MessageQueue	access:public	signature:()
WTF::MessageQueue::WTF_MAKE_NONCOPYABLE	.\MessageQueue.h	/^        WTF_MAKE_NONCOPYABLE(MessageQueue);$/;"	p	class:WTF::MessageQueue	access:private	signature:(MessageQueue)
WTF::MessageQueue::alwaysTruePredicate	.\MessageQueue.h	/^        static bool alwaysTruePredicate(DataType*) { return true; }$/;"	f	class:WTF::MessageQueue	access:private	signature:(DataType*)
WTF::MessageQueue::append	.\MessageQueue.h	/^        void append(PassOwnPtr<DataType>);$/;"	p	class:WTF::MessageQueue	access:public	signature:(PassOwnPtr<DataType>)
WTF::MessageQueue::append	.\MessageQueue.h	/^    inline void MessageQueue<DataType>::append(PassOwnPtr<DataType> message)$/;"	f	class:WTF::MessageQueue	signature:(PassOwnPtr<DataType> message)
WTF::MessageQueue::appendAndCheckEmpty	.\MessageQueue.h	/^        bool appendAndCheckEmpty(PassOwnPtr<DataType>);$/;"	p	class:WTF::MessageQueue	access:public	signature:(PassOwnPtr<DataType>)
WTF::MessageQueue::appendAndCheckEmpty	.\MessageQueue.h	/^    inline bool MessageQueue<DataType>::appendAndCheckEmpty(PassOwnPtr<DataType> message)$/;"	f	class:WTF::MessageQueue	signature:(PassOwnPtr<DataType> message)
WTF::MessageQueue::infiniteTime	.\MessageQueue.h	/^        static double infiniteTime() { return std::numeric_limits<double>::max(); }$/;"	f	class:WTF::MessageQueue	access:public	signature:()
WTF::MessageQueue::isEmpty	.\MessageQueue.h	/^        bool isEmpty();$/;"	p	class:WTF::MessageQueue	access:public	signature:()
WTF::MessageQueue::isEmpty	.\MessageQueue.h	/^    inline bool MessageQueue<DataType>::isEmpty()$/;"	f	class:WTF::MessageQueue	signature:()
WTF::MessageQueue::kill	.\MessageQueue.h	/^        void kill();$/;"	p	class:WTF::MessageQueue	access:public	signature:()
WTF::MessageQueue::kill	.\MessageQueue.h	/^    inline void MessageQueue<DataType>::kill()$/;"	f	class:WTF::MessageQueue	signature:()
WTF::MessageQueue::killed	.\MessageQueue.h	/^        bool killed() const;$/;"	p	class:WTF::MessageQueue	access:public	signature:() const
WTF::MessageQueue::killed	.\MessageQueue.h	/^    inline bool MessageQueue<DataType>::killed() const$/;"	f	class:WTF::MessageQueue	signature:() const
WTF::MessageQueue::m_condition	.\MessageQueue.h	/^        ThreadCondition m_condition;$/;"	m	class:WTF::MessageQueue	access:private
WTF::MessageQueue::m_killed	.\MessageQueue.h	/^        bool m_killed;$/;"	m	class:WTF::MessageQueue	access:private
WTF::MessageQueue::m_mutex	.\MessageQueue.h	/^        mutable Mutex m_mutex;$/;"	m	class:WTF::MessageQueue	access:private
WTF::MessageQueue::m_queue	.\MessageQueue.h	/^        Deque<DataType*> m_queue;$/;"	m	class:WTF::MessageQueue	access:private
WTF::MessageQueue::prepend	.\MessageQueue.h	/^        void prepend(PassOwnPtr<DataType>);$/;"	p	class:WTF::MessageQueue	access:public	signature:(PassOwnPtr<DataType>)
WTF::MessageQueue::prepend	.\MessageQueue.h	/^    inline void MessageQueue<DataType>::prepend(PassOwnPtr<DataType> message)$/;"	f	class:WTF::MessageQueue	signature:(PassOwnPtr<DataType> message)
WTF::MessageQueue::removeIf	.\MessageQueue.h	/^        void removeIf(Predicate&);$/;"	p	class:WTF::MessageQueue	access:public	signature:(Predicate&)
WTF::MessageQueue::removeIf	.\MessageQueue.h	/^    inline void MessageQueue<DataType>::removeIf(Predicate& predicate)$/;"	f	class:WTF::MessageQueue	signature:(Predicate& predicate)
WTF::MessageQueue::tryGetMessage	.\MessageQueue.h	/^        PassOwnPtr<DataType> tryGetMessage();$/;"	p	class:WTF::MessageQueue	access:public	signature:()
WTF::MessageQueue::tryGetMessage	.\MessageQueue.h	/^    inline PassOwnPtr<DataType> MessageQueue<DataType>::tryGetMessage()$/;"	f	class:WTF::MessageQueue	signature:()
WTF::MessageQueue::tryGetMessageIgnoringKilled	.\MessageQueue.h	/^        PassOwnPtr<DataType> tryGetMessageIgnoringKilled();$/;"	p	class:WTF::MessageQueue	access:public	signature:()
WTF::MessageQueue::tryGetMessageIgnoringKilled	.\MessageQueue.h	/^    inline PassOwnPtr<DataType> MessageQueue<DataType>::tryGetMessageIgnoringKilled()$/;"	f	class:WTF::MessageQueue	signature:()
WTF::MessageQueue::waitForMessage	.\MessageQueue.h	/^        PassOwnPtr<DataType> waitForMessage();$/;"	p	class:WTF::MessageQueue	access:public	signature:()
WTF::MessageQueue::waitForMessage	.\MessageQueue.h	/^    inline PassOwnPtr<DataType> MessageQueue<DataType>::waitForMessage()$/;"	f	class:WTF::MessageQueue	signature:()
WTF::MessageQueue::waitForMessageFilteredWithTimeout	.\MessageQueue.h	/^        PassOwnPtr<DataType> waitForMessageFilteredWithTimeout(MessageQueueWaitResult&, Predicate&, double absoluteTime);$/;"	p	class:WTF::MessageQueue	access:public	signature:(MessageQueueWaitResult&, Predicate&, double absoluteTime)
WTF::MessageQueue::waitForMessageFilteredWithTimeout	.\MessageQueue.h	/^    inline PassOwnPtr<DataType> MessageQueue<DataType>::waitForMessageFilteredWithTimeout(MessageQueueWaitResult& result, Predicate& predicate, double absoluteTime)$/;"	f	class:WTF::MessageQueue	signature:(MessageQueueWaitResult& result, Predicate& predicate, double absoluteTime)
WTF::MessageQueue::~MessageQueue	.\MessageQueue.h	/^        ~MessageQueue();$/;"	p	class:WTF::MessageQueue	access:public	signature:()
WTF::MessageQueue::~MessageQueue	.\MessageQueue.h	/^    MessageQueue<DataType>::~MessageQueue()$/;"	f	class:WTF::MessageQueue	signature:()
WTF::MessageQueueMessageReceived	.\MessageQueue.h	/^        MessageQueueMessageReceived   \/\/ A message was successfully received and returned.$/;"	e	enum:WTF::MessageQueueWaitResult
WTF::MessageQueueTerminated	.\MessageQueue.h	/^        MessageQueueTerminated,       \/\/ Queue was destroyed while waiting for message.$/;"	e	enum:WTF::MessageQueueWaitResult
WTF::MessageQueueTimeout	.\MessageQueue.h	/^        MessageQueueTimeout,          \/\/ Timeout was specified and it expired.$/;"	e	enum:WTF::MessageQueueWaitResult
WTF::MessageQueueWaitResult	.\MessageQueue.h	/^    enum MessageQueueWaitResult {$/;"	g	namespace:WTF
WTF::MetaAllocator	.\MetaAllocator.h	/^class MetaAllocator {$/;"	c	namespace:WTF
WTF::MetaAllocator::FreeSpaceNode	.\MetaAllocator.h	/^    class FreeSpaceNode : public RedBlackTree<FreeSpaceNode, size_t>::Node {$/;"	c	class:WTF::MetaAllocator	inherits:RedBlackTree::Node	access:private
WTF::MetaAllocator::FreeSpaceNode::FreeSpaceNode	.\MetaAllocator.h	/^        FreeSpaceNode(void* start, size_t sizeInBytes)$/;"	f	class:WTF::MetaAllocator::FreeSpaceNode	access:public	signature:(void* start, size_t sizeInBytes)
WTF::MetaAllocator::FreeSpaceNode::key	.\MetaAllocator.h	/^        size_t key()$/;"	f	class:WTF::MetaAllocator::FreeSpaceNode	access:public	signature:()
WTF::MetaAllocator::FreeSpaceNode::m_sizeInBytes	.\MetaAllocator.h	/^        size_t m_sizeInBytes;$/;"	m	class:WTF::MetaAllocator::FreeSpaceNode	access:public
WTF::MetaAllocator::FreeSpaceNode::m_start	.\MetaAllocator.h	/^        void* m_start;$/;"	m	class:WTF::MetaAllocator::FreeSpaceNode	access:public
WTF::MetaAllocator::MetaAllocator	.\MetaAllocator.cpp	/^MetaAllocator::MetaAllocator(size_t allocationGranule)$/;"	f	class:WTF::MetaAllocator	signature:(size_t allocationGranule)
WTF::MetaAllocator::MetaAllocator	.\MetaAllocator.h	/^    WTF_EXPORT_PRIVATE MetaAllocator(size_t allocationGranule);$/;"	p	class:WTF::MetaAllocator	access:public	signature:(size_t allocationGranule)
WTF::MetaAllocator::Statistics	.\MetaAllocator.h	/^    struct Statistics {$/;"	s	class:WTF::MetaAllocator	access:public
WTF::MetaAllocator::Statistics::bytesAllocated	.\MetaAllocator.h	/^        size_t bytesAllocated;$/;"	m	struct:WTF::MetaAllocator::Statistics	access:public
WTF::MetaAllocator::Statistics::bytesCommitted	.\MetaAllocator.h	/^        size_t bytesCommitted;$/;"	m	struct:WTF::MetaAllocator::Statistics	access:public
WTF::MetaAllocator::Statistics::bytesReserved	.\MetaAllocator.h	/^        size_t bytesReserved;$/;"	m	struct:WTF::MetaAllocator::Statistics	access:public
WTF::MetaAllocator::Tree	.\MetaAllocator.h	/^    typedef RedBlackTree<FreeSpaceNode, size_t> Tree;$/;"	t	class:WTF::MetaAllocator	access:private
WTF::MetaAllocator::WTF_MAKE_NONCOPYABLE	.\MetaAllocator.h	/^    WTF_MAKE_NONCOPYABLE(MetaAllocator);$/;"	p	class:WTF::MetaAllocator	access:private	signature:(MetaAllocator)
WTF::MetaAllocator::addFreeSpace	.\MetaAllocator.cpp	/^void MetaAllocator::addFreeSpace(void* start, size_t sizeInBytes)$/;"	f	class:WTF::MetaAllocator	signature:(void* start, size_t sizeInBytes)
WTF::MetaAllocator::addFreeSpace	.\MetaAllocator.h	/^    void addFreeSpace(void* start, size_t sizeInBytes);$/;"	p	class:WTF::MetaAllocator	access:private	signature:(void* start, size_t sizeInBytes)
WTF::MetaAllocator::addFreeSpaceFromReleasedHandle	.\MetaAllocator.cpp	/^void MetaAllocator::addFreeSpaceFromReleasedHandle(void* start, size_t sizeInBytes)$/;"	f	class:WTF::MetaAllocator	signature:(void* start, size_t sizeInBytes)
WTF::MetaAllocator::addFreeSpaceFromReleasedHandle	.\MetaAllocator.h	/^    void addFreeSpaceFromReleasedHandle(void* start, size_t sizeInBytes);$/;"	p	class:WTF::MetaAllocator	access:private	signature:(void* start, size_t sizeInBytes)
WTF::MetaAllocator::addFreshFreeSpace	.\MetaAllocator.cpp	/^void MetaAllocator::addFreshFreeSpace(void* start, size_t sizeInBytes)$/;"	f	class:WTF::MetaAllocator	signature:(void* start, size_t sizeInBytes)
WTF::MetaAllocator::addFreshFreeSpace	.\MetaAllocator.h	/^    WTF_EXPORT_PRIVATE void addFreshFreeSpace(void* start, size_t sizeInBytes);$/;"	p	class:WTF::MetaAllocator	access:public	signature:(void* start, size_t sizeInBytes)
WTF::MetaAllocator::allocFreeSpaceNode	.\MetaAllocator.cpp	/^MetaAllocator::FreeSpaceNode* MetaAllocator::allocFreeSpaceNode()$/;"	f	class:WTF::MetaAllocator	signature:()
WTF::MetaAllocator::allocFreeSpaceNode	.\MetaAllocator.h	/^    FreeSpaceNode* allocFreeSpaceNode();$/;"	p	class:WTF::MetaAllocator	access:private	signature:()
WTF::MetaAllocator::allocate	.\MetaAllocator.cpp	/^PassRefPtr<MetaAllocatorHandle> MetaAllocator::allocate(size_t sizeInBytes, void* ownerUID)$/;"	f	class:WTF::MetaAllocator	signature:(size_t sizeInBytes, void* ownerUID)
WTF::MetaAllocator::allocate	.\MetaAllocator.h	/^    WTF_EXPORT_PRIVATE PassRefPtr<MetaAllocatorHandle> allocate(size_t sizeInBytes, void* ownerUID);$/;"	p	class:WTF::MetaAllocator	access:public	signature:(size_t sizeInBytes, void* ownerUID)
WTF::MetaAllocator::allocateNewSpace	.\MetaAllocator.h	/^    virtual void* allocateNewSpace(size_t& numPages) = 0;$/;"	p	class:WTF::MetaAllocator	access:protected	signature:(size_t& numPages)
WTF::MetaAllocator::bytesAllocated	.\MetaAllocator.h	/^    size_t bytesAllocated() { return m_bytesAllocated; }$/;"	f	class:WTF::MetaAllocator	access:public	signature:()
WTF::MetaAllocator::bytesCommitted	.\MetaAllocator.h	/^    size_t bytesCommitted() { return m_bytesCommitted; }$/;"	f	class:WTF::MetaAllocator	access:public	signature:()
WTF::MetaAllocator::bytesReserved	.\MetaAllocator.h	/^    size_t bytesReserved() { return m_bytesReserved; }$/;"	f	class:WTF::MetaAllocator	access:public	signature:()
WTF::MetaAllocator::currentStatistics	.\MetaAllocator.cpp	/^MetaAllocator::Statistics MetaAllocator::currentStatistics()$/;"	f	class:WTF::MetaAllocator	signature:()
WTF::MetaAllocator::currentStatistics	.\MetaAllocator.h	/^    Statistics currentStatistics();$/;"	p	class:WTF::MetaAllocator	access:public	signature:()
WTF::MetaAllocator::debugFreeSpaceSize	.\MetaAllocator.cpp	/^size_t MetaAllocator::debugFreeSpaceSize()$/;"	f	class:WTF::MetaAllocator	signature:()
WTF::MetaAllocator::debugFreeSpaceSize	.\MetaAllocator.h	/^    WTF_EXPORT_PRIVATE size_t debugFreeSpaceSize();$/;"	p	class:WTF::MetaAllocator	access:public	signature:()
WTF::MetaAllocator::decrementPageOccupancy	.\MetaAllocator.cpp	/^void MetaAllocator::decrementPageOccupancy(void* address, size_t sizeInBytes)$/;"	f	class:WTF::MetaAllocator	signature:(void* address, size_t sizeInBytes)
WTF::MetaAllocator::decrementPageOccupancy	.\MetaAllocator.h	/^    void decrementPageOccupancy(void* address, size_t sizeInBytes);$/;"	p	class:WTF::MetaAllocator	access:private	signature:(void* address, size_t sizeInBytes)
WTF::MetaAllocator::dumpProfile	.\MetaAllocator.cpp	/^void MetaAllocator::dumpProfile()$/;"	f	class:WTF::MetaAllocator	signature:()
WTF::MetaAllocator::dumpProfile	.\MetaAllocator.h	/^    void dumpProfile() { }$/;"	f	class:WTF::MetaAllocator	access:public	signature:()
WTF::MetaAllocator::dumpProfile	.\MetaAllocator.h	/^    void dumpProfile();$/;"	p	class:WTF::MetaAllocator	access:public	signature:()
WTF::MetaAllocator::findAndRemoveFreeSpace	.\MetaAllocator.cpp	/^void* MetaAllocator::findAndRemoveFreeSpace(size_t sizeInBytes)$/;"	f	class:WTF::MetaAllocator	signature:(size_t sizeInBytes)
WTF::MetaAllocator::findAndRemoveFreeSpace	.\MetaAllocator.h	/^    void* findAndRemoveFreeSpace(size_t sizeInBytes);$/;"	p	class:WTF::MetaAllocator	access:private	signature:(size_t sizeInBytes)
WTF::MetaAllocator::freeFreeSpaceNode	.\MetaAllocator.cpp	/^void MetaAllocator::freeFreeSpaceNode(FreeSpaceNode* node)$/;"	f	class:WTF::MetaAllocator	signature:(FreeSpaceNode* node)
WTF::MetaAllocator::freeFreeSpaceNode	.\MetaAllocator.h	/^    WTF_EXPORT_PRIVATE void freeFreeSpaceNode(FreeSpaceNode*);$/;"	p	class:WTF::MetaAllocator	access:private	signature:(FreeSpaceNode*)
WTF::MetaAllocator::incrementPageOccupancy	.\MetaAllocator.cpp	/^void MetaAllocator::incrementPageOccupancy(void* address, size_t sizeInBytes)$/;"	f	class:WTF::MetaAllocator	signature:(void* address, size_t sizeInBytes)
WTF::MetaAllocator::incrementPageOccupancy	.\MetaAllocator.h	/^    void incrementPageOccupancy(void* address, size_t sizeInBytes);$/;"	p	class:WTF::MetaAllocator	access:private	signature:(void* address, size_t sizeInBytes)
WTF::MetaAllocator::m_allocationGranule	.\MetaAllocator.h	/^    size_t m_allocationGranule;$/;"	m	class:WTF::MetaAllocator	access:private
WTF::MetaAllocator::m_bytesAllocated	.\MetaAllocator.h	/^    size_t m_bytesAllocated;$/;"	m	class:WTF::MetaAllocator	access:private
WTF::MetaAllocator::m_bytesCommitted	.\MetaAllocator.h	/^    size_t m_bytesCommitted;$/;"	m	class:WTF::MetaAllocator	access:private
WTF::MetaAllocator::m_bytesReserved	.\MetaAllocator.h	/^    size_t m_bytesReserved;$/;"	m	class:WTF::MetaAllocator	access:private
WTF::MetaAllocator::m_freeSpaceEndAddressMap	.\MetaAllocator.h	/^    HashMap<void*, FreeSpaceNode*> m_freeSpaceEndAddressMap;$/;"	m	class:WTF::MetaAllocator	access:private
WTF::MetaAllocator::m_freeSpaceSizeMap	.\MetaAllocator.h	/^    Tree m_freeSpaceSizeMap;$/;"	m	class:WTF::MetaAllocator	access:private
WTF::MetaAllocator::m_freeSpaceStartAddressMap	.\MetaAllocator.h	/^    HashMap<void*, FreeSpaceNode*> m_freeSpaceStartAddressMap;$/;"	m	class:WTF::MetaAllocator	access:private
WTF::MetaAllocator::m_lock	.\MetaAllocator.h	/^    SpinLock m_lock;$/;"	m	class:WTF::MetaAllocator	access:private
WTF::MetaAllocator::m_logAllocationGranule	.\MetaAllocator.h	/^    unsigned m_logAllocationGranule;$/;"	m	class:WTF::MetaAllocator	access:private
WTF::MetaAllocator::m_logPageSize	.\MetaAllocator.h	/^    unsigned m_logPageSize;$/;"	m	class:WTF::MetaAllocator	access:private
WTF::MetaAllocator::m_mallocBalance	.\MetaAllocator.h	/^    size_t m_mallocBalance;$/;"	m	class:WTF::MetaAllocator	access:private
WTF::MetaAllocator::m_numAllocations	.\MetaAllocator.h	/^    unsigned m_numAllocations;$/;"	m	class:WTF::MetaAllocator	access:private
WTF::MetaAllocator::m_numFrees	.\MetaAllocator.h	/^    unsigned m_numFrees;$/;"	m	class:WTF::MetaAllocator	access:private
WTF::MetaAllocator::m_pageOccupancyMap	.\MetaAllocator.h	/^    HashMap<uintptr_t, size_t> m_pageOccupancyMap;$/;"	m	class:WTF::MetaAllocator	access:private
WTF::MetaAllocator::m_pageSize	.\MetaAllocator.h	/^    size_t m_pageSize;$/;"	m	class:WTF::MetaAllocator	access:private
WTF::MetaAllocator::m_tracker	.\MetaAllocator.h	/^    MetaAllocatorTracker* m_tracker;$/;"	m	class:WTF::MetaAllocator	access:private
WTF::MetaAllocator::notifyNeedPage	.\MetaAllocator.h	/^    virtual void notifyNeedPage(void* page) = 0;$/;"	p	class:WTF::MetaAllocator	access:protected	signature:(void* page)
WTF::MetaAllocator::notifyPageIsFree	.\MetaAllocator.h	/^    virtual void notifyPageIsFree(void* page) = 0;$/;"	p	class:WTF::MetaAllocator	access:protected	signature:(void* page)
WTF::MetaAllocator::release	.\MetaAllocator.cpp	/^ALWAYS_INLINE void MetaAllocator::release(MetaAllocatorHandle* handle)$/;"	f	class:WTF::MetaAllocator	signature:(MetaAllocatorHandle* handle)
WTF::MetaAllocator::release	.\MetaAllocator.h	/^    void release(MetaAllocatorHandle*);$/;"	p	class:WTF::MetaAllocator	access:private	signature:(MetaAllocatorHandle*)
WTF::MetaAllocator::roundUp	.\MetaAllocator.cpp	/^size_t MetaAllocator::roundUp(size_t sizeInBytes)$/;"	f	class:WTF::MetaAllocator	signature:(size_t sizeInBytes)
WTF::MetaAllocator::roundUp	.\MetaAllocator.h	/^    size_t roundUp(size_t sizeInBytes);$/;"	p	class:WTF::MetaAllocator	access:private	signature:(size_t sizeInBytes)
WTF::MetaAllocator::trackAllocations	.\MetaAllocator.h	/^    void trackAllocations(MetaAllocatorTracker* tracker)$/;"	f	class:WTF::MetaAllocator	access:public	signature:(MetaAllocatorTracker* tracker)
WTF::MetaAllocator::~MetaAllocator	.\MetaAllocator.h	/^    virtual ~MetaAllocator();$/;"	p	class:WTF::MetaAllocator	access:public	signature:()
WTF::MetaAllocator::~MetaAllocator	.\MetaAllocator.h	/^inline MetaAllocator::~MetaAllocator()$/;"	f	class:WTF::MetaAllocator	signature:()
WTF::MetaAllocatorHandle	.\MetaAllocatorHandle.h	/^class MetaAllocatorHandle : public RefCounted<MetaAllocatorHandle>, public RedBlackTree<MetaAllocatorHandle, void*>::Node {$/;"	c	namespace:WTF	inherits:RefCounted,RedBlackTree::Node
WTF::MetaAllocatorHandle::MetaAllocatorHandle	.\MetaAllocator.cpp	/^MetaAllocatorHandle::MetaAllocatorHandle(MetaAllocator* allocator, void* start, size_t sizeInBytes, void* ownerUID)$/;"	f	class:WTF::MetaAllocatorHandle	signature:(MetaAllocator* allocator, void* start, size_t sizeInBytes, void* ownerUID)
WTF::MetaAllocatorHandle::MetaAllocatorHandle	.\MetaAllocatorHandle.h	/^    MetaAllocatorHandle(MetaAllocator*, void* start, size_t sizeInBytes, void* ownerUID);$/;"	p	class:WTF::MetaAllocatorHandle	access:private	signature:(MetaAllocator*, void* start, size_t sizeInBytes, void* ownerUID)
WTF::MetaAllocatorHandle::allocator	.\MetaAllocatorHandle.h	/^    MetaAllocator* allocator()$/;"	f	class:WTF::MetaAllocatorHandle	access:public	signature:()
WTF::MetaAllocatorHandle::end	.\MetaAllocatorHandle.h	/^    void* end()$/;"	f	class:WTF::MetaAllocatorHandle	access:public	signature:()
WTF::MetaAllocatorHandle::isManaged	.\MetaAllocatorHandle.h	/^    bool isManaged()$/;"	f	class:WTF::MetaAllocatorHandle	access:public	signature:()
WTF::MetaAllocatorHandle::key	.\MetaAllocatorHandle.h	/^    void* key()$/;"	f	class:WTF::MetaAllocatorHandle	access:public	signature:()
WTF::MetaAllocatorHandle::m_allocator	.\MetaAllocatorHandle.h	/^    MetaAllocator* m_allocator;$/;"	m	class:WTF::MetaAllocatorHandle	access:private
WTF::MetaAllocatorHandle::m_ownerUID	.\MetaAllocatorHandle.h	/^    void* m_ownerUID;$/;"	m	class:WTF::MetaAllocatorHandle	access:private
WTF::MetaAllocatorHandle::m_sizeInBytes	.\MetaAllocatorHandle.h	/^    size_t m_sizeInBytes;$/;"	m	class:WTF::MetaAllocatorHandle	access:private
WTF::MetaAllocatorHandle::m_start	.\MetaAllocatorHandle.h	/^    void* m_start;$/;"	m	class:WTF::MetaAllocatorHandle	access:private
WTF::MetaAllocatorHandle::ownerUID	.\MetaAllocatorHandle.h	/^    void* ownerUID()$/;"	f	class:WTF::MetaAllocatorHandle	access:public	signature:()
WTF::MetaAllocatorHandle::shrink	.\MetaAllocator.cpp	/^void MetaAllocatorHandle::shrink(size_t newSizeInBytes)$/;"	f	class:WTF::MetaAllocatorHandle	signature:(size_t newSizeInBytes)
WTF::MetaAllocatorHandle::shrink	.\MetaAllocatorHandle.h	/^    WTF_EXPORT_PRIVATE void shrink(size_t newSizeInBytes);$/;"	p	class:WTF::MetaAllocatorHandle	access:public	signature:(size_t newSizeInBytes)
WTF::MetaAllocatorHandle::sizeInBytes	.\MetaAllocatorHandle.h	/^    size_t sizeInBytes()$/;"	f	class:WTF::MetaAllocatorHandle	access:public	signature:()
WTF::MetaAllocatorHandle::start	.\MetaAllocatorHandle.h	/^    void* start()$/;"	f	class:WTF::MetaAllocatorHandle	access:public	signature:()
WTF::MetaAllocatorHandle::~MetaAllocatorHandle	.\MetaAllocator.cpp	/^MetaAllocatorHandle::~MetaAllocatorHandle()$/;"	f	class:WTF::MetaAllocatorHandle	signature:()
WTF::MetaAllocatorHandle::~MetaAllocatorHandle	.\MetaAllocatorHandle.h	/^    WTF_EXPORT_PRIVATE ~MetaAllocatorHandle();$/;"	p	class:WTF::MetaAllocatorHandle	access:public	signature:()
WTF::MetaAllocatorTracker	.\MetaAllocator.h	/^class MetaAllocatorTracker {$/;"	c	namespace:WTF
WTF::MetaAllocatorTracker::find	.\MetaAllocator.h	/^    MetaAllocatorHandle* find(void* address)$/;"	f	class:WTF::MetaAllocatorTracker	access:public	signature:(void* address)
WTF::MetaAllocatorTracker::m_allocations	.\MetaAllocator.h	/^    RedBlackTree<MetaAllocatorHandle, void*> m_allocations;$/;"	m	class:WTF::MetaAllocatorTracker	access:public
WTF::MetaAllocatorTracker::notify	.\MetaAllocator.cpp	/^void MetaAllocatorTracker::notify(MetaAllocatorHandle* handle)$/;"	f	class:WTF::MetaAllocatorTracker	signature:(MetaAllocatorHandle* handle)
WTF::MetaAllocatorTracker::notify	.\MetaAllocator.h	/^    void notify(MetaAllocatorHandle*);$/;"	p	class:WTF::MetaAllocatorTracker	access:public	signature:(MetaAllocatorHandle*)
WTF::MetaAllocatorTracker::release	.\MetaAllocator.cpp	/^void MetaAllocatorTracker::release(MetaAllocatorHandle* handle)$/;"	f	class:WTF::MetaAllocatorTracker	signature:(MetaAllocatorHandle* handle)
WTF::MetaAllocatorTracker::release	.\MetaAllocator.h	/^    void release(MetaAllocatorHandle*);$/;"	p	class:WTF::MetaAllocatorTracker	access:public	signature:(MetaAllocatorHandle*)
WTF::MetaDataAlloc	.\FastMalloc.cpp	/^static void* MetaDataAlloc(size_t bytes) {$/;"	f	namespace:WTF	file:	signature:(size_t bytes)
WTF::Mover	.\HashTable.h	/^    template<typename T> struct Mover<T, false> { static void move(T& from, T& to) { to = from; } };$/;"	s	namespace:WTF
WTF::Mover	.\HashTable.h	/^    template<typename T> struct Mover<T, true> { static void move(T& from, T& to) { hashTableSwap(from, to); } };$/;"	s	namespace:WTF
WTF::Mover::move	.\HashTable.h	/^    template<typename T> struct Mover<T, false> { static void move(T& from, T& to) { to = from; } };$/;"	f	struct:WTF::Mover	access:public	signature:(T& from, T& to)
WTF::Mover::move	.\HashTable.h	/^    template<typename T> struct Mover<T, true> { static void move(T& from, T& to) { hashTableSwap(from, to); } };$/;"	f	struct:WTF::Mover	access:public	signature:(T& from, T& to)
WTF::Mutex	.\ThreadingPrimitives.h	/^class Mutex {$/;"	c	namespace:WTF
WTF::Mutex::Mutex	.\ThreadingPrimitives.h	/^    WTF_EXPORT_PRIVATE Mutex();$/;"	p	class:WTF::Mutex	access:public	signature:()
WTF::Mutex::Mutex	.\ThreadingPthreads.cpp	/^Mutex::Mutex()$/;"	f	class:WTF::Mutex	signature:()
WTF::Mutex::Mutex	.\ThreadingWin.cpp	/^Mutex::Mutex()$/;"	f	class:WTF::Mutex	signature:()
WTF::Mutex::WTF_MAKE_FAST_ALLOCATED	.\ThreadingPrimitives.h	/^    WTF_MAKE_NONCOPYABLE(Mutex); WTF_MAKE_FAST_ALLOCATED;$/;"	m	class:WTF::Mutex	access:private
WTF::Mutex::WTF_MAKE_NONCOPYABLE	.\ThreadingPrimitives.h	/^    WTF_MAKE_NONCOPYABLE(Mutex); WTF_MAKE_FAST_ALLOCATED;$/;"	p	class:WTF::Mutex	access:private	signature:(Mutex)
WTF::Mutex::impl	.\ThreadingPrimitives.h	/^    PlatformMutex& impl() { return m_mutex; }$/;"	f	class:WTF::Mutex	access:public	signature:()
WTF::Mutex::lock	.\ThreadingPrimitives.h	/^    WTF_EXPORT_PRIVATE void lock();$/;"	p	class:WTF::Mutex	access:public	signature:()
WTF::Mutex::lock	.\ThreadingPthreads.cpp	/^void Mutex::lock()$/;"	f	class:WTF::Mutex	signature:()
WTF::Mutex::lock	.\ThreadingWin.cpp	/^void Mutex::lock()$/;"	f	class:WTF::Mutex	signature:()
WTF::Mutex::m_mutex	.\ThreadingPrimitives.h	/^    PlatformMutex m_mutex;$/;"	m	class:WTF::Mutex	access:private
WTF::Mutex::tryLock	.\ThreadingPrimitives.h	/^    WTF_EXPORT_PRIVATE bool tryLock();$/;"	p	class:WTF::Mutex	access:public	signature:()
WTF::Mutex::tryLock	.\ThreadingPthreads.cpp	/^bool Mutex::tryLock()$/;"	f	class:WTF::Mutex	signature:()
WTF::Mutex::tryLock	.\ThreadingWin.cpp	/^bool Mutex::tryLock()$/;"	f	class:WTF::Mutex	signature:()
WTF::Mutex::unlock	.\ThreadingPrimitives.h	/^    WTF_EXPORT_PRIVATE void unlock();$/;"	p	class:WTF::Mutex	access:public	signature:()
WTF::Mutex::unlock	.\ThreadingPthreads.cpp	/^void Mutex::unlock()$/;"	f	class:WTF::Mutex	signature:()
WTF::Mutex::unlock	.\ThreadingWin.cpp	/^void Mutex::unlock()$/;"	f	class:WTF::Mutex	signature:()
WTF::Mutex::~Mutex	.\ThreadingPrimitives.h	/^    WTF_EXPORT_PRIVATE ~Mutex();$/;"	p	class:WTF::Mutex	access:public	signature:()
WTF::Mutex::~Mutex	.\ThreadingPthreads.cpp	/^Mutex::~Mutex()$/;"	f	class:WTF::Mutex	signature:()
WTF::Mutex::~Mutex	.\ThreadingWin.cpp	/^Mutex::~Mutex()$/;"	f	class:WTF::Mutex	signature:()
WTF::MutexLocker	.\ThreadingPrimitives.h	/^typedef Locker<Mutex> MutexLocker;$/;"	t	namespace:WTF
WTF::NewSpan	.\FastMalloc.cpp	/^static Span* NewSpan(PageID p, Length len) {$/;"	f	namespace:WTF	file:	signature:(PageID p, Length len)
WTF::NewThreadContext	.\Threading.cpp	/^struct NewThreadContext {$/;"	s	namespace:WTF	file:
WTF::NewThreadContext::NewThreadContext	.\Threading.cpp	/^    NewThreadContext(ThreadFunction entryPoint, void* data, const char* name)$/;"	f	struct:WTF::NewThreadContext	access:public	signature:(ThreadFunction entryPoint, void* data, const char* name)
WTF::NewThreadContext::WTF_MAKE_FAST_ALLOCATED	.\Threading.cpp	/^    WTF_MAKE_FAST_ALLOCATED;$/;"	m	struct:WTF::NewThreadContext	file:	access:public
WTF::NewThreadContext::creationMutex	.\Threading.cpp	/^    Mutex creationMutex;$/;"	m	struct:WTF::NewThreadContext	file:	access:public
WTF::NewThreadContext::data	.\Threading.cpp	/^    void* data;$/;"	m	struct:WTF::NewThreadContext	file:	access:public
WTF::NewThreadContext::entryPoint	.\Threading.cpp	/^    ThreadFunction entryPoint;$/;"	m	struct:WTF::NewThreadContext	file:	access:public
WTF::NewThreadContext::name	.\Threading.cpp	/^    const char* name;$/;"	m	struct:WTF::NewThreadContext	file:	access:public
WTF::NonASCIIMask	.\text\ASCIIFastPath.h	/^template<> struct NonASCIIMask<4, LChar> {$/;"	s	namespace:WTF
WTF::NonASCIIMask	.\text\ASCIIFastPath.h	/^template<> struct NonASCIIMask<4, UChar> {$/;"	s	namespace:WTF
WTF::NonASCIIMask	.\text\ASCIIFastPath.h	/^template<> struct NonASCIIMask<8, LChar> {$/;"	s	namespace:WTF
WTF::NonASCIIMask	.\text\ASCIIFastPath.h	/^template<> struct NonASCIIMask<8, UChar> {$/;"	s	namespace:WTF
WTF::NonASCIIMask::value	.\text\ASCIIFastPath.h	/^    static inline uint32_t value() { return 0x80808080U; }$/;"	f	struct:WTF::NonASCIIMask	access:public	signature:()
WTF::NonASCIIMask::value	.\text\ASCIIFastPath.h	/^    static inline uint32_t value() { return 0xFF80FF80U; }$/;"	f	struct:WTF::NonASCIIMask	access:public	signature:()
WTF::NonASCIIMask::value	.\text\ASCIIFastPath.h	/^    static inline uint64_t value() { return 0x8080808080808080ULL; }$/;"	f	struct:WTF::NonASCIIMask	access:public	signature:()
WTF::NonASCIIMask::value	.\text\ASCIIFastPath.h	/^    static inline uint64_t value() { return 0xFF80FF80FF80FF80ULL; }$/;"	f	struct:WTF::NonASCIIMask	access:public	signature:()
WTF::NonNullPassRefPtr	.\PassRefPtr.h	/^    template<typename T> class NonNullPassRefPtr {$/;"	c	namespace:WTF
WTF::NonNullPassRefPtr::NonNullPassRefPtr	.\PassRefPtr.h	/^        NonNullPassRefPtr(T* ptr)$/;"	f	class:WTF::NonNullPassRefPtr	access:public	signature:(T* ptr)
WTF::NonNullPassRefPtr::NonNullPassRefPtr	.\PassRefPtr.h	/^        NonNullPassRefPtr(const NonNullPassRefPtr& o)$/;"	f	class:WTF::NonNullPassRefPtr	access:public	signature:(const NonNullPassRefPtr& o)
WTF::NonNullPassRefPtr::NonNullPassRefPtr	.\PassRefPtr.h	/^        template<typename U> NonNullPassRefPtr(const NonNullPassRefPtr<U>& o)$/;"	f	class:WTF::NonNullPassRefPtr	access:public	signature:(const NonNullPassRefPtr<U>& o)
WTF::NonNullPassRefPtr::NonNullPassRefPtr	.\PassRefPtr.h	/^        template<typename U> NonNullPassRefPtr(const PassRefPtr<U>& o)$/;"	f	class:WTF::NonNullPassRefPtr	access:public	signature:(const PassRefPtr<U>& o)
WTF::NonNullPassRefPtr::NonNullPassRefPtr	.\PassRefPtr.h	/^        template<typename U> NonNullPassRefPtr(const RefPtr<U>& o)$/;"	f	class:WTF::NonNullPassRefPtr	access:public	signature:(const RefPtr<U>& o)
WTF::NonNullPassRefPtr::get	.\PassRefPtr.h	/^        T* get() const { return m_ptr; }$/;"	f	class:WTF::NonNullPassRefPtr	access:public	signature:() const
WTF::NonNullPassRefPtr::m_ptr	.\PassRefPtr.h	/^        mutable T* m_ptr;$/;"	m	class:WTF::NonNullPassRefPtr	access:private
WTF::NonNullPassRefPtr::operator *	.\PassRefPtr.h	/^        T& operator*() const { return *m_ptr; }$/;"	f	class:WTF::NonNullPassRefPtr	access:public	signature:() const
WTF::NonNullPassRefPtr::operator ->	.\PassRefPtr.h	/^        T* operator->() const { return m_ptr; }$/;"	f	class:WTF::NonNullPassRefPtr	access:public	signature:() const
WTF::NonNullPassRefPtr::operator =	.\PassRefPtr.h	/^        NonNullPassRefPtr& operator=(const NonNullPassRefPtr&) { COMPILE_ASSERT(!sizeof(T*), NonNullPassRefPtr_should_never_be_assigned_to); return *this; }$/;"	f	class:WTF::NonNullPassRefPtr	access:public	signature:(const NonNullPassRefPtr&)
WTF::NonNullPassRefPtr::~NonNullPassRefPtr	.\PassRefPtr.h	/^        ALWAYS_INLINE ~NonNullPassRefPtr() { derefIfNotNull(m_ptr); }$/;"	f	class:WTF::NonNullPassRefPtr	access:public	signature:()
WTF::NumMoveSize	.\FastMalloc.cpp	/^static int NumMoveSize(size_t size) {$/;"	f	namespace:WTF	file:	signature:(size_t size)
WTF::NumberToStringBuffer	.\dtoa.h	/^typedef char NumberToStringBuffer[NumberToStringBufferLength];$/;"	t	namespace:WTF
WTF::NumberToStringBufferLength	.\dtoa.h	/^const unsigned NumberToStringBufferLength = 96;$/;"	v
WTF::NumberToUStringBuffer	.\dtoa.h	/^typedef UChar NumberToUStringBuffer[NumberToStringBufferLength];$/;"	t	namespace:WTF
WTF::OSAllocator	.\OSAllocator.h	/^class OSAllocator {$/;"	c	namespace:WTF
WTF::OSAllocator::FastMallocPages	.\OSAllocator.h	/^        FastMallocPages = VM_TAG_FOR_TCMALLOC_MEMORY,$/;"	e	enum:WTF::OSAllocator::Usage
WTF::OSAllocator::JSGCHeapPages	.\OSAllocator.h	/^        JSGCHeapPages = VM_TAG_FOR_COLLECTOR_MEMORY,$/;"	e	enum:WTF::OSAllocator::Usage
WTF::OSAllocator::JSJITCodePages	.\OSAllocator.h	/^        JSJITCodePages = VM_TAG_FOR_EXECUTABLEALLOCATOR_MEMORY,$/;"	e	enum:WTF::OSAllocator::Usage
WTF::OSAllocator::JSVMStackPages	.\OSAllocator.h	/^        JSVMStackPages = VM_TAG_FOR_REGISTERFILE_MEMORY,$/;"	e	enum:WTF::OSAllocator::Usage
WTF::OSAllocator::UnknownUsage	.\OSAllocator.h	/^        UnknownUsage = -1,$/;"	e	enum:WTF::OSAllocator::Usage
WTF::OSAllocator::Usage	.\OSAllocator.h	/^    enum Usage {$/;"	g	class:WTF::OSAllocator	access:public
WTF::OSAllocator::commit	.\OSAllocator.h	/^    static void commit(void*, size_t, bool writable, bool executable);$/;"	p	class:WTF::OSAllocator	access:public	signature:(void*, size_t, bool writable, bool executable)
WTF::OSAllocator::commit	.\OSAllocatorPosix.cpp	/^void OSAllocator::commit(void* address, size_t bytes, bool writable, bool executable)$/;"	f	class:WTF::OSAllocator	signature:(void* address, size_t bytes, bool writable, bool executable)
WTF::OSAllocator::commit	.\OSAllocatorWin.cpp	/^void OSAllocator::commit(void* address, size_t bytes, bool writable, bool executable)$/;"	f	class:WTF::OSAllocator	signature:(void* address, size_t bytes, bool writable, bool executable)
WTF::OSAllocator::decommit	.\OSAllocator.h	/^    static void decommit(void*, size_t);$/;"	p	class:WTF::OSAllocator	access:public	signature:(void*, size_t)
WTF::OSAllocator::decommit	.\OSAllocatorPosix.cpp	/^void OSAllocator::decommit(void* address, size_t bytes)$/;"	f	class:WTF::OSAllocator	signature:(void* address, size_t bytes)
WTF::OSAllocator::decommit	.\OSAllocatorWin.cpp	/^void OSAllocator::decommit(void* address, size_t bytes)$/;"	f	class:WTF::OSAllocator	signature:(void* address, size_t bytes)
WTF::OSAllocator::decommitAndRelease	.\OSAllocator.h	/^    static void decommitAndRelease(void* base, size_t size);$/;"	p	class:WTF::OSAllocator	access:public	signature:(void* base, size_t size)
WTF::OSAllocator::decommitAndRelease	.\OSAllocator.h	/^    static void decommitAndRelease(void* releaseBase, size_t releaseSize, void* decommitBase, size_t decommitSize);$/;"	p	class:WTF::OSAllocator	access:public	signature:(void* releaseBase, size_t releaseSize, void* decommitBase, size_t decommitSize)
WTF::OSAllocator::decommitAndRelease	.\OSAllocator.h	/^inline void OSAllocator::decommitAndRelease(void* base, size_t size)$/;"	f	class:WTF::OSAllocator	signature:(void* base, size_t size)
WTF::OSAllocator::decommitAndRelease	.\OSAllocator.h	/^inline void OSAllocator::decommitAndRelease(void* releaseBase, size_t releaseSize, void* decommitBase, size_t decommitSize)$/;"	f	class:WTF::OSAllocator	signature:(void* releaseBase, size_t releaseSize, void* decommitBase, size_t decommitSize)
WTF::OSAllocator::reallocateCommitted	.\OSAllocator.h	/^    static T* reallocateCommitted(T*, size_t oldSize, size_t newSize, Usage = UnknownUsage, bool writable = true, bool executable = false);$/;"	p	class:WTF::OSAllocator	access:public	signature:(T*, size_t oldSize, size_t newSize, Usage = UnknownUsage, bool writable = true, bool executable = false)
WTF::OSAllocator::reallocateCommitted	.\OSAllocator.h	/^inline T* OSAllocator::reallocateCommitted(T* oldBase, size_t oldSize, size_t newSize, Usage usage, bool writable, bool executable)$/;"	f	class:WTF::OSAllocator	signature:(T* oldBase, size_t oldSize, size_t newSize, Usage usage, bool writable, bool executable)
WTF::OSAllocator::releaseDecommitted	.\OSAllocator.h	/^    WTF_EXPORT_PRIVATE static void releaseDecommitted(void*, size_t);$/;"	p	class:WTF::OSAllocator	access:public	signature:(void*, size_t)
WTF::OSAllocator::releaseDecommitted	.\OSAllocatorPosix.cpp	/^void OSAllocator::releaseDecommitted(void* address, size_t bytes)$/;"	f	class:WTF::OSAllocator	signature:(void* address, size_t bytes)
WTF::OSAllocator::releaseDecommitted	.\OSAllocatorWin.cpp	/^void OSAllocator::releaseDecommitted(void* address, size_t bytes)$/;"	f	class:WTF::OSAllocator	signature:(void* address, size_t bytes)
WTF::OSAllocator::reserveAndCommit	.\OSAllocator.h	/^    WTF_EXPORT_PRIVATE static void* reserveAndCommit(size_t, Usage = UnknownUsage, bool writable = true, bool executable = false, bool includesGuardPages = false);$/;"	p	class:WTF::OSAllocator	access:public	signature:(size_t, Usage = UnknownUsage, bool writable = true, bool executable = false, bool includesGuardPages = false)
WTF::OSAllocator::reserveAndCommit	.\OSAllocator.h	/^    static void* reserveAndCommit(size_t reserveSize, size_t commitSize, Usage = UnknownUsage, bool writable = true, bool executable = false);$/;"	p	class:WTF::OSAllocator	access:public	signature:(size_t reserveSize, size_t commitSize, Usage = UnknownUsage, bool writable = true, bool executable = false)
WTF::OSAllocator::reserveAndCommit	.\OSAllocator.h	/^inline void* OSAllocator::reserveAndCommit(size_t reserveSize, size_t commitSize, Usage usage, bool writable, bool executable)$/;"	f	class:WTF::OSAllocator	signature:(size_t reserveSize, size_t commitSize, Usage usage, bool writable, bool executable)
WTF::OSAllocator::reserveAndCommit	.\OSAllocatorPosix.cpp	/^void* OSAllocator::reserveAndCommit(size_t bytes, Usage usage, bool writable, bool executable, bool includesGuardPages)$/;"	f	class:WTF::OSAllocator	signature:(size_t bytes, Usage usage, bool writable, bool executable, bool includesGuardPages)
WTF::OSAllocator::reserveAndCommit	.\OSAllocatorWin.cpp	/^void* OSAllocator::reserveAndCommit(size_t bytes, Usage, bool writable, bool executable, bool)$/;"	f	class:WTF::OSAllocator	signature:(size_t bytes, Usage, bool writable, bool executable, bool)
WTF::OSAllocator::reserveUncommitted	.\OSAllocator.h	/^    static void* reserveUncommitted(size_t, Usage = UnknownUsage, bool writable = true, bool executable = false, bool includesGuardPages = false);$/;"	p	class:WTF::OSAllocator	access:public	signature:(size_t, Usage = UnknownUsage, bool writable = true, bool executable = false, bool includesGuardPages = false)
WTF::OSAllocator::reserveUncommitted	.\OSAllocatorPosix.cpp	/^void* OSAllocator::reserveUncommitted(size_t bytes, Usage usage, bool writable, bool executable, bool includesGuardPages)$/;"	f	class:WTF::OSAllocator	signature:(size_t bytes, Usage usage, bool writable, bool executable, bool includesGuardPages)
WTF::OSAllocator::reserveUncommitted	.\OSAllocatorWin.cpp	/^void* OSAllocator::reserveUncommitted(size_t bytes, Usage, bool writable, bool executable, bool)$/;"	f	class:WTF::OSAllocator	signature:(size_t bytes, Usage, bool writable, bool executable, bool)
WTF::OrdinalNumber	.\text\TextPosition.h	/^class OrdinalNumber {$/;"	c	namespace:WTF
WTF::OrdinalNumber::OrdinalNumber	.\text\TextPosition.h	/^    OrdinalNumber() : m_zeroBasedValue(0) { }$/;"	f	class:WTF::OrdinalNumber	access:public	signature:()
WTF::OrdinalNumber::OrdinalNumber	.\text\TextPosition.h	/^    OrdinalNumber(int zeroBasedInt) : m_zeroBasedValue(zeroBasedInt) { }$/;"	f	class:WTF::OrdinalNumber	access:private	signature:(int zeroBasedInt)
WTF::OrdinalNumber::beforeFirst	.\text\TextPosition.h	/^    static OrdinalNumber beforeFirst() { return OrdinalNumber(-1); }$/;"	f	class:WTF::OrdinalNumber	access:public	signature:()
WTF::OrdinalNumber::first	.\text\TextPosition.h	/^    static OrdinalNumber first() { return OrdinalNumber(0); }$/;"	f	class:WTF::OrdinalNumber	access:public	signature:()
WTF::OrdinalNumber::fromOneBasedInt	.\text\TextPosition.h	/^    static OrdinalNumber fromOneBasedInt(int oneBasedInt) { return OrdinalNumber(oneBasedInt - 1); }$/;"	f	class:WTF::OrdinalNumber	access:public	signature:(int oneBasedInt)
WTF::OrdinalNumber::fromZeroBasedInt	.\text\TextPosition.h	/^    static OrdinalNumber fromZeroBasedInt(int zeroBasedInt) { return OrdinalNumber(zeroBasedInt); }$/;"	f	class:WTF::OrdinalNumber	access:public	signature:(int zeroBasedInt)
WTF::OrdinalNumber::m_zeroBasedValue	.\text\TextPosition.h	/^    int m_zeroBasedValue;$/;"	m	class:WTF::OrdinalNumber	access:private
WTF::OrdinalNumber::oneBasedInt	.\text\TextPosition.h	/^    int oneBasedInt() const { return m_zeroBasedValue + 1; }$/;"	f	class:WTF::OrdinalNumber	access:public	signature:() const
WTF::OrdinalNumber::operator !=	.\text\TextPosition.h	/^    bool operator!=(OrdinalNumber other) { return !((*this) == other); }$/;"	f	class:WTF::OrdinalNumber	access:public	signature:(OrdinalNumber other)
WTF::OrdinalNumber::operator ==	.\text\TextPosition.h	/^    bool operator==(OrdinalNumber other) { return m_zeroBasedValue == other.m_zeroBasedValue; }$/;"	f	class:WTF::OrdinalNumber	access:public	signature:(OrdinalNumber other)
WTF::OrdinalNumber::zeroBasedInt	.\text\TextPosition.h	/^    int zeroBasedInt() const { return m_zeroBasedValue; }$/;"	f	class:WTF::OrdinalNumber	access:public	signature:() const
WTF::OwnArrayPtr	.\OwnArrayPtr.h	/^template <typename T> class OwnArrayPtr {$/;"	c	namespace:WTF
WTF::OwnArrayPtr::OwnArrayPtr	.\OwnArrayPtr.h	/^    OwnArrayPtr() : m_ptr(0) { }$/;"	f	class:WTF::OwnArrayPtr	access:public	signature:()
WTF::OwnArrayPtr::OwnArrayPtr	.\OwnArrayPtr.h	/^    OwnArrayPtr(const OwnArrayPtr<T>&);$/;"	p	class:WTF::OwnArrayPtr	access:public	signature:(const OwnArrayPtr<T>&)
WTF::OwnArrayPtr::OwnArrayPtr	.\OwnArrayPtr.h	/^    template<typename U> OwnArrayPtr(const PassOwnArrayPtr<U>& o);$/;"	p	class:WTF::OwnArrayPtr	access:public	signature:(const PassOwnArrayPtr<U>& o)
WTF::OwnArrayPtr::OwnArrayPtr	.\OwnArrayPtr.h	/^template<typename T> template<typename U> inline OwnArrayPtr<T>::OwnArrayPtr(const PassOwnArrayPtr<U>& o)$/;"	f	class:WTF::OwnArrayPtr	signature:(const PassOwnArrayPtr<U>& o)
WTF::OwnArrayPtr::OwnArrayPtr::UnspecifiedBoolType	.\OwnArrayPtr.h	/^    typedef T* OwnArrayPtr::*UnspecifiedBoolType;$/;"	t	class:WTF::OwnArrayPtr::OwnArrayPtr	access:public
WTF::OwnArrayPtr::PtrType	.\OwnArrayPtr.h	/^    typedef T* PtrType;$/;"	t	class:WTF::OwnArrayPtr	access:public
WTF::OwnArrayPtr::WARN_UNUSED_RETURN	.\OwnArrayPtr.h	/^    PtrType leakPtr() WARN_UNUSED_RETURN;$/;"	m	class:WTF::OwnArrayPtr	access:public
WTF::OwnArrayPtr::clear	.\OwnArrayPtr.h	/^    void clear();$/;"	p	class:WTF::OwnArrayPtr	access:public	signature:()
WTF::OwnArrayPtr::clear	.\OwnArrayPtr.h	/^template<typename T> inline void OwnArrayPtr<T>::clear()$/;"	f	class:WTF::OwnArrayPtr	signature:()
WTF::OwnArrayPtr::get	.\OwnArrayPtr.h	/^    PtrType get() const { return m_ptr; }$/;"	f	class:WTF::OwnArrayPtr	access:public	signature:() const
WTF::OwnArrayPtr::leakPtr	.\OwnArrayPtr.h	/^template<typename T> inline typename OwnArrayPtr<T>::PtrType OwnArrayPtr<T>::leakPtr()$/;"	f	class:WTF::OwnArrayPtr	signature:()
WTF::OwnArrayPtr::m_ptr	.\OwnArrayPtr.h	/^    PtrType m_ptr;$/;"	m	class:WTF::OwnArrayPtr	access:private
WTF::OwnArrayPtr::operator !	.\OwnArrayPtr.h	/^    bool operator!() const { return !m_ptr; }$/;"	f	class:WTF::OwnArrayPtr	access:public	signature:() const
WTF::OwnArrayPtr::operator *	.\OwnArrayPtr.h	/^    T& operator*() const { ASSERT(m_ptr); return *m_ptr; }$/;"	f	class:WTF::OwnArrayPtr	access:public	signature:() const
WTF::OwnArrayPtr::operator ->	.\OwnArrayPtr.h	/^    PtrType operator->() const { ASSERT(m_ptr); return m_ptr; }$/;"	f	class:WTF::OwnArrayPtr	access:public	signature:() const
WTF::OwnArrayPtr::operator =	.\OwnArrayPtr.h	/^    OwnArrayPtr& operator=(const PassOwnArrayPtr<T>&);$/;"	p	class:WTF::OwnArrayPtr	access:public	signature:(const PassOwnArrayPtr<T>&)
WTF::OwnArrayPtr::operator =	.\OwnArrayPtr.h	/^    OwnArrayPtr& operator=(std::nullptr_t) { clear(); return *this; }$/;"	f	class:WTF::OwnArrayPtr	access:public	signature:(std::nullptr_t)
WTF::OwnArrayPtr::operator =	.\OwnArrayPtr.h	/^    template<typename U> OwnArrayPtr& operator=(const PassOwnArrayPtr<U>&);$/;"	p	class:WTF::OwnArrayPtr	access:public	signature:(const PassOwnArrayPtr<U>&)
WTF::OwnArrayPtr::operator =	.\OwnArrayPtr.h	/^template<typename T> inline OwnArrayPtr<T>& OwnArrayPtr<T>::operator=(const PassOwnArrayPtr<T>& o)$/;"	f	class:WTF::OwnArrayPtr	signature:(const PassOwnArrayPtr<T>& o)
WTF::OwnArrayPtr::operator =	.\OwnArrayPtr.h	/^template<typename T> template<typename U> inline OwnArrayPtr<T>& OwnArrayPtr<T>::operator=(const PassOwnArrayPtr<U>& o)$/;"	f	class:WTF::OwnArrayPtr	signature:(const PassOwnArrayPtr<U>& o)
WTF::OwnArrayPtr::operator UnspecifiedBoolType	.\OwnArrayPtr.h	/^    operator UnspecifiedBoolType() const { return m_ptr ? &OwnArrayPtr::m_ptr : 0; }$/;"	f	class:WTF::OwnArrayPtr	access:public	signature:() const
WTF::OwnArrayPtr::operator []	.\OwnArrayPtr.h	/^    T& operator[](std::ptrdiff_t i) const { ASSERT(m_ptr); ASSERT(i >= 0); return m_ptr[i]; }$/;"	f	class:WTF::OwnArrayPtr	access:public	signature:(std::ptrdiff_t i) const
WTF::OwnArrayPtr::release	.\OwnArrayPtr.h	/^    PassOwnArrayPtr<T> release();$/;"	p	class:WTF::OwnArrayPtr	access:public	signature:()
WTF::OwnArrayPtr::release	.\OwnArrayPtr.h	/^template<typename T> inline PassOwnArrayPtr<T> OwnArrayPtr<T>::release()$/;"	f	class:WTF::OwnArrayPtr	signature:()
WTF::OwnArrayPtr::swap	.\OwnArrayPtr.h	/^    void swap(OwnArrayPtr& o) { std::swap(m_ptr, o.m_ptr); }$/;"	f	class:WTF::OwnArrayPtr	access:public	signature:(OwnArrayPtr& o)
WTF::OwnArrayPtr::~OwnArrayPtr	.\OwnArrayPtr.h	/^    ~OwnArrayPtr() { deleteOwnedArrayPtr(m_ptr); }$/;"	f	class:WTF::OwnArrayPtr	access:public	signature:()
WTF::OwnPtr	.\OwnPtr.h	/^    template<typename T> class OwnPtr {$/;"	c	namespace:WTF
WTF::OwnPtr::OwnPtr	.\OwnPtr.h	/^        OwnPtr() : m_ptr(0) { }$/;"	f	class:WTF::OwnPtr	access:public	signature:()
WTF::OwnPtr::OwnPtr	.\OwnPtr.h	/^        OwnPtr(const OwnPtr<ValueType>&);$/;"	p	class:WTF::OwnPtr	access:public	signature:(const OwnPtr<ValueType>&)
WTF::OwnPtr::OwnPtr	.\OwnPtr.h	/^        OwnPtr(std::nullptr_t) : m_ptr(0) { }$/;"	f	class:WTF::OwnPtr	access:public	signature:(std::nullptr_t)
WTF::OwnPtr::OwnPtr	.\OwnPtr.h	/^        template<typename U> OwnPtr(const PassOwnPtr<U>& o);$/;"	p	class:WTF::OwnPtr	access:public	signature:(const PassOwnPtr<U>& o)
WTF::OwnPtr::OwnPtr	.\OwnPtr.h	/^    template<typename T> template<typename U> inline OwnPtr<T>::OwnPtr(const PassOwnPtr<U>& o)$/;"	f	class:WTF::OwnPtr	signature:(const PassOwnPtr<U>& o)
WTF::OwnPtr::OwnPtr::UnspecifiedBoolType	.\OwnPtr.h	/^        typedef PtrType OwnPtr::*UnspecifiedBoolType;$/;"	t	class:WTF::OwnPtr::OwnPtr	access:public
WTF::OwnPtr::PtrType	.\OwnPtr.h	/^        typedef ValueType* PtrType;$/;"	t	class:WTF::OwnPtr	access:public
WTF::OwnPtr::ValueType	.\OwnPtr.h	/^        typedef typename RemovePointer<T>::Type ValueType;$/;"	t	class:WTF::OwnPtr	access:public
WTF::OwnPtr::WARN_UNUSED_RETURN	.\OwnPtr.h	/^        PtrType leakPtr() WARN_UNUSED_RETURN;$/;"	m	class:WTF::OwnPtr	access:public
WTF::OwnPtr::clear	.\OwnPtr.h	/^        void clear();$/;"	p	class:WTF::OwnPtr	access:public	signature:()
WTF::OwnPtr::clear	.\OwnPtr.h	/^    template<typename T> inline void OwnPtr<T>::clear()$/;"	f	class:WTF::OwnPtr	signature:()
WTF::OwnPtr::get	.\OwnPtr.h	/^        PtrType get() const { return m_ptr; }$/;"	f	class:WTF::OwnPtr	access:public	signature:() const
WTF::OwnPtr::leakPtr	.\OwnPtr.h	/^    template<typename T> inline typename OwnPtr<T>::PtrType OwnPtr<T>::leakPtr()$/;"	f	class:WTF::OwnPtr	signature:()
WTF::OwnPtr::m_ptr	.\OwnPtr.h	/^        PtrType m_ptr;$/;"	m	class:WTF::OwnPtr	access:private
WTF::OwnPtr::operator !	.\OwnPtr.h	/^        bool operator!() const { return !m_ptr; }$/;"	f	class:WTF::OwnPtr	access:public	signature:() const
WTF::OwnPtr::operator !=	.\OwnPtr.h	/^        template<typename U> bool operator!=(const OwnPtr<U>&) { COMPILE_ASSERT(!sizeof(U*), OwnPtrs_should_never_be_equal); return false; }$/;"	f	class:WTF::OwnPtr	access:private	signature:(const OwnPtr<U>&)
WTF::OwnPtr::operator !=	.\OwnPtr.h	/^        template<typename U> bool operator!=(const PassOwnPtr<U>&) { COMPILE_ASSERT(!sizeof(U*), OwnPtrs_should_never_be_equal); return false; }$/;"	f	class:WTF::OwnPtr	access:private	signature:(const PassOwnPtr<U>&)
WTF::OwnPtr::operator *	.\OwnPtr.h	/^        ValueType& operator*() const { ASSERT(m_ptr); return *m_ptr; }$/;"	f	class:WTF::OwnPtr	access:public	signature:() const
WTF::OwnPtr::operator ->	.\OwnPtr.h	/^        PtrType operator->() const { ASSERT(m_ptr); return m_ptr; }$/;"	f	class:WTF::OwnPtr	access:public	signature:() const
WTF::OwnPtr::operator =	.\OwnPtr.h	/^        OwnPtr& operator=(const OwnPtr<T>&);$/;"	p	class:WTF::OwnPtr	access:private	signature:(const OwnPtr<T>&)
WTF::OwnPtr::operator =	.\OwnPtr.h	/^        OwnPtr& operator=(const PassOwnPtr<T>&);$/;"	p	class:WTF::OwnPtr	access:public	signature:(const PassOwnPtr<T>&)
WTF::OwnPtr::operator =	.\OwnPtr.h	/^        OwnPtr& operator=(std::nullptr_t) { clear(); return *this; }$/;"	f	class:WTF::OwnPtr	access:public	signature:(std::nullptr_t)
WTF::OwnPtr::operator =	.\OwnPtr.h	/^        template<typename U> OwnPtr& operator=(const PassOwnPtr<U>&);$/;"	p	class:WTF::OwnPtr	access:public	signature:(const PassOwnPtr<U>&)
WTF::OwnPtr::operator =	.\OwnPtr.h	/^    template<typename T> inline OwnPtr<T>& OwnPtr<T>::operator=(const PassOwnPtr<T>& o)$/;"	f	class:WTF::OwnPtr	signature:(const PassOwnPtr<T>& o)
WTF::OwnPtr::operator =	.\OwnPtr.h	/^    template<typename T> template<typename U> inline OwnPtr<T>& OwnPtr<T>::operator=(const PassOwnPtr<U>& o)$/;"	f	class:WTF::OwnPtr	signature:(const PassOwnPtr<U>& o)
WTF::OwnPtr::operator ==	.\OwnPtr.h	/^        template<typename U> bool operator==(const OwnPtr<U>&) { COMPILE_ASSERT(!sizeof(U*), OwnPtrs_should_never_be_equal); return false; }$/;"	f	class:WTF::OwnPtr	access:private	signature:(const OwnPtr<U>&)
WTF::OwnPtr::operator ==	.\OwnPtr.h	/^        template<typename U> bool operator==(const PassOwnPtr<U>&) { COMPILE_ASSERT(!sizeof(U*), OwnPtrs_should_never_be_equal); return false; }$/;"	f	class:WTF::OwnPtr	access:private	signature:(const PassOwnPtr<U>&)
WTF::OwnPtr::operator UnspecifiedBoolType	.\OwnPtr.h	/^        operator UnspecifiedBoolType() const { return m_ptr ? &OwnPtr::m_ptr : 0; }$/;"	f	class:WTF::OwnPtr	access:public	signature:() const
WTF::OwnPtr::release	.\OwnPtr.h	/^        PassOwnPtr<T> release();$/;"	p	class:WTF::OwnPtr	access:public	signature:()
WTF::OwnPtr::release	.\OwnPtr.h	/^    template<typename T> inline PassOwnPtr<T> OwnPtr<T>::release()$/;"	f	class:WTF::OwnPtr	signature:()
WTF::OwnPtr::swap	.\OwnPtr.h	/^        void swap(OwnPtr& o) { std::swap(m_ptr, o.m_ptr); }$/;"	f	class:WTF::OwnPtr	access:public	signature:(OwnPtr& o)
WTF::OwnPtr::~OwnPtr	.\OwnPtr.h	/^        ~OwnPtr() { deleteOwnedPtr(m_ptr); }$/;"	f	class:WTF::OwnPtr	access:public	signature:()
WTF::OwnPtr_should_stay_small	.\SizeLimits.cpp	/^COMPILE_ASSERT(sizeof(OwnPtr<int>) == sizeof(int*), OwnPtr_should_stay_small);$/;"	v
WTF::P5Node	.\dtoa.cpp	/^struct P5Node {$/;"	s	namespace:WTF	file:
WTF::P5Node::P5Node	.\dtoa.cpp	/^    P5Node() { }$/;"	f	struct:WTF::P5Node	access:public	signature:()
WTF::P5Node::WTF_MAKE_FAST_ALLOCATED	.\dtoa.cpp	/^    WTF_MAKE_NONCOPYABLE(P5Node); WTF_MAKE_FAST_ALLOCATED;$/;"	m	struct:WTF::P5Node	file:	access:public
WTF::P5Node::WTF_MAKE_NONCOPYABLE	.\dtoa.cpp	/^    WTF_MAKE_NONCOPYABLE(P5Node); WTF_MAKE_FAST_ALLOCATED;$/;"	p	struct:WTF::P5Node	file:	access:public	signature:(P5Node)
WTF::P5Node::next	.\dtoa.cpp	/^    P5Node* next;$/;"	m	struct:WTF::P5Node	file:	access:public
WTF::P5Node::val	.\dtoa.cpp	/^    BigInt val;$/;"	m	struct:WTF::P5Node	file:	access:public
WTF::PackedIntVector	.\PackedIntVector.h	/^class PackedIntVector {$/;"	c	namespace:WTF
WTF::PackedIntVector::PackedIntVector	.\PackedIntVector.h	/^    PackedIntVector()$/;"	f	class:WTF::PackedIntVector	access:public	signature:()
WTF::PackedIntVector::PackedIntVector	.\PackedIntVector.h	/^    PackedIntVector(const PackedIntVector& other)$/;"	f	class:WTF::PackedIntVector	access:public	signature:(const PackedIntVector& other)
WTF::PackedIntVector::clearAll	.\PackedIntVector.h	/^    void clearAll()$/;"	f	class:WTF::PackedIntVector	access:public	signature:()
WTF::PackedIntVector::ensureSize	.\PackedIntVector.h	/^    void ensureSize(size_t numInts)$/;"	f	class:WTF::PackedIntVector	access:public	signature:(size_t numInts)
WTF::PackedIntVector::get	.\PackedIntVector.h	/^    T get(size_t index) const$/;"	f	class:WTF::PackedIntVector	access:public	signature:(size_t index) const
WTF::PackedIntVector::m_bits	.\PackedIntVector.h	/^    BitVector m_bits;$/;"	m	class:WTF::PackedIntVector	access:private
WTF::PackedIntVector::mask	.\PackedIntVector.h	/^    static uintptr_t mask() { return (static_cast<uintptr_t>(2) << (bitCount - 1)) - 1; }$/;"	f	class:WTF::PackedIntVector	access:private	signature:()
WTF::PackedIntVector::operator =	.\PackedIntVector.h	/^    PackedIntVector& operator=(const PackedIntVector& other)$/;"	f	class:WTF::PackedIntVector	access:public	signature:(const PackedIntVector& other)
WTF::PackedIntVector::resize	.\PackedIntVector.h	/^    void resize(size_t numInts)$/;"	f	class:WTF::PackedIntVector	access:public	signature:(size_t numInts)
WTF::PackedIntVector::set	.\PackedIntVector.h	/^    void set(size_t index, T value)$/;"	f	class:WTF::PackedIntVector	access:public	signature:(size_t index, T value)
WTF::PackedIntVector::size	.\PackedIntVector.h	/^    size_t size() const$/;"	f	class:WTF::PackedIntVector	access:public	signature:() const
WTF::PageAllocation	.\PageAllocation.h	/^class PageAllocation : private PageBlock {$/;"	c	namespace:WTF	inherits:PageBlock
WTF::PageAllocation::PageAllocation	.\PageAllocation.h	/^    PageAllocation()$/;"	f	class:WTF::PageAllocation	access:public	signature:()
WTF::PageAllocation::PageAllocation	.\PageAllocation.h	/^    PageAllocation(void* base, size_t size)$/;"	f	class:WTF::PageAllocation	access:private	signature:(void* base, size_t size)
WTF::PageAllocation::allocate	.\PageAllocation.h	/^    static PageAllocation allocate(size_t size, OSAllocator::Usage usage = OSAllocator::UnknownUsage, bool writable = true, bool executable = false)$/;"	f	class:WTF::PageAllocation	access:public	signature:(size_t size, OSAllocator::Usage usage = OSAllocator::UnknownUsage, bool writable = true, bool executable = false)
WTF::PageAllocation::deallocate	.\PageAllocation.h	/^    void deallocate()$/;"	f	class:WTF::PageAllocation	access:public	signature:()
WTF::PageAllocationAligned	.\PageAllocationAligned.h	/^class PageAllocationAligned : private PageBlock {$/;"	c	namespace:WTF	inherits:PageBlock
WTF::PageAllocationAligned::PageAllocationAligned	.\PageAllocationAligned.h	/^    PageAllocationAligned()$/;"	f	class:WTF::PageAllocationAligned	access:public	signature:()
WTF::PageAllocationAligned::PageAllocationAligned	.\PageAllocationAligned.h	/^    PageAllocationAligned(void* base, size_t size)$/;"	f	class:WTF::PageAllocationAligned	access:private	signature:(void* base, size_t size)
WTF::PageAllocationAligned::PageAllocationAligned	.\PageAllocationAligned.h	/^    PageAllocationAligned(void* base, size_t size, void* reservationBase, size_t reservationSize)$/;"	f	class:WTF::PageAllocationAligned	access:private	signature:(void* base, size_t size, void* reservationBase, size_t reservationSize)
WTF::PageAllocationAligned::allocate	.\PageAllocationAligned.cpp	/^PageAllocationAligned PageAllocationAligned::allocate(size_t size, size_t alignment, OSAllocator::Usage usage, bool writable, bool executable)$/;"	f	class:WTF::PageAllocationAligned	signature:(size_t size, size_t alignment, OSAllocator::Usage usage, bool writable, bool executable)
WTF::PageAllocationAligned::allocate	.\PageAllocationAligned.h	/^    static PageAllocationAligned allocate(size_t size, size_t alignment, OSAllocator::Usage usage = OSAllocator::UnknownUsage, bool writable = true, bool executable = false);$/;"	p	class:WTF::PageAllocationAligned	access:public	signature:(size_t size, size_t alignment, OSAllocator::Usage usage = OSAllocator::UnknownUsage, bool writable = true, bool executable = false)
WTF::PageAllocationAligned::deallocate	.\PageAllocationAligned.cpp	/^void PageAllocationAligned::deallocate()$/;"	f	class:WTF::PageAllocationAligned	signature:()
WTF::PageAllocationAligned::deallocate	.\PageAllocationAligned.h	/^    void deallocate();$/;"	p	class:WTF::PageAllocationAligned	access:public	signature:()
WTF::PageAllocationAligned::m_reservation	.\PageAllocationAligned.h	/^    PageBlock m_reservation;$/;"	m	class:WTF::PageAllocationAligned	access:private
WTF::PageBlock	.\PageBlock.h	/^class PageBlock {$/;"	c	namespace:WTF
WTF::PageBlock::PageBlock	.\PageBlock.h	/^    PageBlock();$/;"	p	class:WTF::PageBlock	access:public	signature:()
WTF::PageBlock::PageBlock	.\PageBlock.h	/^    PageBlock(const PageBlock&);$/;"	p	class:WTF::PageBlock	access:public	signature:(const PageBlock&)
WTF::PageBlock::PageBlock	.\PageBlock.h	/^    PageBlock(void*, size_t, bool hasGuardPages);$/;"	p	class:WTF::PageBlock	access:public	signature:(void*, size_t, bool hasGuardPages)
WTF::PageBlock::PageBlock	.\PageBlock.h	/^inline PageBlock::PageBlock()$/;"	f	class:WTF::PageBlock	signature:()
WTF::PageBlock::PageBlock	.\PageBlock.h	/^inline PageBlock::PageBlock(const PageBlock& other)$/;"	f	class:WTF::PageBlock	signature:(const PageBlock& other)
WTF::PageBlock::PageBlock	.\PageBlock.h	/^inline PageBlock::PageBlock(void* base, size_t size, bool hasGuardPages)$/;"	f	class:WTF::PageBlock	signature:(void* base, size_t size, bool hasGuardPages)
WTF::PageBlock::base	.\PageBlock.h	/^    void* base() const { return m_base; }$/;"	f	class:WTF::PageBlock	access:public	signature:() const
WTF::PageBlock::contains	.\PageBlock.h	/^    bool contains(void* containedBase, size_t containedSize)$/;"	f	class:WTF::PageBlock	access:public	signature:(void* containedBase, size_t containedSize)
WTF::PageBlock::m_base	.\PageBlock.h	/^    void* m_base;$/;"	m	class:WTF::PageBlock	access:private
WTF::PageBlock::m_realBase	.\PageBlock.h	/^    void* m_realBase;$/;"	m	class:WTF::PageBlock	access:private
WTF::PageBlock::m_size	.\PageBlock.h	/^    size_t m_size;$/;"	m	class:WTF::PageBlock	access:private
WTF::PageBlock::operator bool	.\PageBlock.h	/^    operator bool() const { return !!m_realBase; }$/;"	f	class:WTF::PageBlock	access:public	signature:() const
WTF::PageBlock::size	.\PageBlock.h	/^    size_t size() const { return m_size; }$/;"	f	class:WTF::PageBlock	access:public	signature:() const
WTF::PageHeapAllocator	.\FastMalloc.cpp	/^class PageHeapAllocator {$/;"	c	namespace:WTF	file:
WTF::PageHeapAllocator::Delete	.\FastMalloc.cpp	/^  void Delete(T* p) {$/;"	f	class:WTF::PageHeapAllocator	access:public	signature:(T* p)
WTF::PageHeapAllocator::Init	.\FastMalloc.cpp	/^  void Init() {$/;"	f	class:WTF::PageHeapAllocator	access:public	signature:()
WTF::PageHeapAllocator::New	.\FastMalloc.cpp	/^  T* New() {$/;"	f	class:WTF::PageHeapAllocator	access:public	signature:()
WTF::PageHeapAllocator::allocated_regions_	.\FastMalloc.cpp	/^  void* allocated_regions_;$/;"	m	class:WTF::PageHeapAllocator	file:	access:private
WTF::PageHeapAllocator::free_area_	.\FastMalloc.cpp	/^  char* free_area_;$/;"	m	class:WTF::PageHeapAllocator	file:	access:private
WTF::PageHeapAllocator::free_avail_	.\FastMalloc.cpp	/^  size_t free_avail_;$/;"	m	class:WTF::PageHeapAllocator	file:	access:private
WTF::PageHeapAllocator::free_list_	.\FastMalloc.cpp	/^  void* free_list_;$/;"	m	class:WTF::PageHeapAllocator	file:	access:private
WTF::PageHeapAllocator::inuse	.\FastMalloc.cpp	/^  int inuse() const { return inuse_; }$/;"	f	class:WTF::PageHeapAllocator	access:public	signature:() const
WTF::PageHeapAllocator::inuse_	.\FastMalloc.cpp	/^  int inuse_;$/;"	m	class:WTF::PageHeapAllocator	file:	access:private
WTF::PageHeapAllocator::kAlignedSize	.\FastMalloc.cpp	/^  static const size_t kAlignedSize$/;"	m	class:WTF::PageHeapAllocator	file:	access:private
WTF::PageHeapAllocator::kAllocIncrement	.\FastMalloc.cpp	/^  static const size_t kAllocIncrement = 32 << 10;$/;"	m	class:WTF::PageHeapAllocator	file:	access:private
WTF::PageHeapAllocator::recordAdministrativeRegions	.\FastMalloc.cpp	/^  void recordAdministrativeRegions(Recorder& recorder, const RemoteMemoryReader& reader)$/;"	f	class:WTF::PageHeapAllocator	access:public	signature:(Recorder& recorder, const RemoteMemoryReader& reader)
WTF::PageHeapUnion	.\FastMalloc.cpp	/^} PageHeapUnion;$/;"	t	namespace:WTF	typeref:union:WTF::__anon5	file:
WTF::PageID	.\FastMalloc.cpp	/^typedef uintptr_t PageID;$/;"	t	namespace:WTF	file:
WTF::PageMapFreeObjectFinder	.\FastMalloc.cpp	/^class PageMapFreeObjectFinder {$/;"	c	namespace:WTF	file:
WTF::PageMapFreeObjectFinder::PageMapFreeObjectFinder	.\FastMalloc.cpp	/^    PageMapFreeObjectFinder(const RemoteMemoryReader& reader, FreeObjectFinder& freeObjectFinder)$/;"	f	class:WTF::PageMapFreeObjectFinder	access:public	signature:(const RemoteMemoryReader& reader, FreeObjectFinder& freeObjectFinder)
WTF::PageMapFreeObjectFinder::m_freeObjectFinder	.\FastMalloc.cpp	/^    FreeObjectFinder& m_freeObjectFinder;$/;"	m	class:WTF::PageMapFreeObjectFinder	file:	access:private
WTF::PageMapFreeObjectFinder::m_reader	.\FastMalloc.cpp	/^    const RemoteMemoryReader& m_reader;$/;"	m	class:WTF::PageMapFreeObjectFinder	file:	access:private
WTF::PageMapFreeObjectFinder::visit	.\FastMalloc.cpp	/^    int visit(void* ptr) const$/;"	f	class:WTF::PageMapFreeObjectFinder	access:public	signature:(void* ptr) const
WTF::PageMapMemoryUsageRecorder	.\FastMalloc.cpp	/^class PageMapMemoryUsageRecorder {$/;"	c	namespace:WTF	file:
WTF::PageMapMemoryUsageRecorder::PageMapMemoryUsageRecorder	.\FastMalloc.cpp	/^    PageMapMemoryUsageRecorder(task_t task, void* context, unsigned typeMask, vm_range_recorder_t* recorder, const RemoteMemoryReader& reader, const FreeObjectFinder& freeObjectFinder)$/;"	f	class:WTF::PageMapMemoryUsageRecorder	access:public	signature:(task_t task, void* context, unsigned typeMask, vm_range_recorder_t* recorder, const RemoteMemoryReader& reader, const FreeObjectFinder& freeObjectFinder)
WTF::PageMapMemoryUsageRecorder::m_coalescedSpans	.\FastMalloc.cpp	/^    Vector<Span*> m_coalescedSpans;$/;"	m	class:WTF::PageMapMemoryUsageRecorder	file:	access:private
WTF::PageMapMemoryUsageRecorder::m_context	.\FastMalloc.cpp	/^    void* m_context;$/;"	m	class:WTF::PageMapMemoryUsageRecorder	file:	access:private
WTF::PageMapMemoryUsageRecorder::m_freeObjectFinder	.\FastMalloc.cpp	/^    const FreeObjectFinder& m_freeObjectFinder;$/;"	m	class:WTF::PageMapMemoryUsageRecorder	file:	access:private
WTF::PageMapMemoryUsageRecorder::m_reader	.\FastMalloc.cpp	/^    const RemoteMemoryReader& m_reader;$/;"	m	class:WTF::PageMapMemoryUsageRecorder	file:	access:private
WTF::PageMapMemoryUsageRecorder::m_recorder	.\FastMalloc.cpp	/^    vm_range_recorder_t* m_recorder;$/;"	m	class:WTF::PageMapMemoryUsageRecorder	file:	access:private
WTF::PageMapMemoryUsageRecorder::m_seenPointers	.\FastMalloc.cpp	/^    HashSet<void*> m_seenPointers;$/;"	m	class:WTF::PageMapMemoryUsageRecorder	file:	access:private
WTF::PageMapMemoryUsageRecorder::m_task	.\FastMalloc.cpp	/^    task_t m_task;$/;"	m	class:WTF::PageMapMemoryUsageRecorder	file:	access:private
WTF::PageMapMemoryUsageRecorder::m_typeMask	.\FastMalloc.cpp	/^    unsigned m_typeMask;$/;"	m	class:WTF::PageMapMemoryUsageRecorder	file:	access:private
WTF::PageMapMemoryUsageRecorder::recordPendingRegions	.\FastMalloc.cpp	/^    void recordPendingRegions()$/;"	f	class:WTF::PageMapMemoryUsageRecorder	access:public	signature:()
WTF::PageMapMemoryUsageRecorder::visit	.\FastMalloc.cpp	/^    int visit(void* ptr)$/;"	f	class:WTF::PageMapMemoryUsageRecorder	access:public	signature:(void* ptr)
WTF::PageMapMemoryUsageRecorder::~PageMapMemoryUsageRecorder	.\FastMalloc.cpp	/^    ~PageMapMemoryUsageRecorder()$/;"	f	class:WTF::PageMapMemoryUsageRecorder	access:public	signature:()
WTF::PageReservation	.\PageReservation.h	/^class PageReservation : private PageBlock {$/;"	c	namespace:WTF	inherits:PageBlock
WTF::PageReservation::PageReservation	.\PageReservation.h	/^    PageReservation()$/;"	f	class:WTF::PageReservation	access:public	signature:()
WTF::PageReservation::PageReservation	.\PageReservation.h	/^    PageReservation(void* base, size_t size, bool writable, bool executable, bool hasGuardPages)$/;"	f	class:WTF::PageReservation	access:private	signature:(void* base, size_t size, bool writable, bool executable, bool hasGuardPages)
WTF::PageReservation::commit	.\PageReservation.h	/^    void commit(void* start, size_t size)$/;"	f	class:WTF::PageReservation	access:public	signature:(void* start, size_t size)
WTF::PageReservation::committed	.\PageReservation.h	/^    size_t committed()$/;"	f	class:WTF::PageReservation	access:public	signature:()
WTF::PageReservation::deallocate	.\PageReservation.h	/^    void deallocate()$/;"	f	class:WTF::PageReservation	access:public	signature:()
WTF::PageReservation::decommit	.\PageReservation.h	/^    void decommit(void* start, size_t size)$/;"	f	class:WTF::PageReservation	access:public	signature:(void* start, size_t size)
WTF::PageReservation::m_committed	.\PageReservation.h	/^    size_t m_committed;$/;"	m	class:WTF::PageReservation	access:private
WTF::PageReservation::m_executable	.\PageReservation.h	/^    bool m_executable;$/;"	m	class:WTF::PageReservation	access:private
WTF::PageReservation::m_writable	.\PageReservation.h	/^    bool m_writable;$/;"	m	class:WTF::PageReservation	access:private
WTF::PageReservation::reserve	.\PageReservation.h	/^    static PageReservation reserve(size_t size, OSAllocator::Usage usage = OSAllocator::UnknownUsage, bool writable = true, bool executable = false)$/;"	f	class:WTF::PageReservation	access:public	signature:(size_t size, OSAllocator::Usage usage = OSAllocator::UnknownUsage, bool writable = true, bool executable = false)
WTF::PageReservation::reserveWithGuardPages	.\PageReservation.h	/^    static PageReservation reserveWithGuardPages(size_t size, OSAllocator::Usage usage = OSAllocator::UnknownUsage, bool writable = true, bool executable = false)$/;"	f	class:WTF::PageReservation	access:public	signature:(size_t size, OSAllocator::Usage usage = OSAllocator::UnknownUsage, bool writable = true, bool executable = false)
WTF::PagesToMB	.\FastMalloc.cpp	/^static double PagesToMB(uint64_t pages) {$/;"	f	namespace:WTF	file:	signature:(uint64_t pages)
WTF::PairFirstExtractor	.\HashMap.h	/^    template<typename PairType> struct PairFirstExtractor {$/;"	s	namespace:WTF
WTF::PairFirstExtractor::extract	.\HashMap.h	/^        static const typename PairType::first_type& extract(const PairType& p) { return p.first; }$/;"	f	struct:WTF::PairFirstExtractor	access:public	signature:(const PairType& p)
WTF::PairHash	.\HashFunctions.h	/^    template<typename T, typename U> struct PairHash {$/;"	s	namespace:WTF
WTF::PairHash::equal	.\HashFunctions.h	/^        static bool equal(const std::pair<T, U>& a, const std::pair<T, U>& b)$/;"	f	struct:WTF::PairHash	access:public	signature:(const std::pair<T, U>& a, const std::pair<T, U>& b)
WTF::PairHash::hash	.\HashFunctions.h	/^        static unsigned hash(const std::pair<T, U>& p)$/;"	f	struct:WTF::PairHash	access:public	signature:(const std::pair<T, U>& p)
WTF::PairHash::safeToCompareToEmptyOrDeleted	.\HashFunctions.h	/^        static const bool safeToCompareToEmptyOrDeleted = DefaultHash<T>::Hash::safeToCompareToEmptyOrDeleted $/;"	m	struct:WTF::PairHash	access:public
WTF::PairHashTraits	.\HashTraits.h	/^    struct PairHashTraits : GenericHashTraits<pair<typename FirstTraitsArg::TraitType, typename SecondTraitsArg::TraitType> > {$/;"	s	namespace:WTF	inherits:GenericHashTraits
WTF::PairHashTraits::EmptyValueType	.\HashTraits.h	/^        typedef pair<typename FirstTraits::EmptyValueType, typename SecondTraits::EmptyValueType> EmptyValueType;$/;"	t	struct:WTF::PairHashTraits	access:public
WTF::PairHashTraits::FirstTraits	.\HashTraits.h	/^        typedef FirstTraitsArg FirstTraits;$/;"	t	struct:WTF::PairHashTraits	access:public
WTF::PairHashTraits::SecondTraits	.\HashTraits.h	/^        typedef SecondTraitsArg SecondTraits;$/;"	t	struct:WTF::PairHashTraits	access:public
WTF::PairHashTraits::TraitType	.\HashTraits.h	/^        typedef pair<typename FirstTraits::TraitType, typename SecondTraits::TraitType> TraitType;$/;"	t	struct:WTF::PairHashTraits	access:public
WTF::PairHashTraits::constructDeletedValue	.\HashTraits.h	/^        static void constructDeletedValue(TraitType& slot) { FirstTraits::constructDeletedValue(slot.first); }$/;"	f	struct:WTF::PairHashTraits	access:public	signature:(TraitType& slot)
WTF::PairHashTraits::emptyValue	.\HashTraits.h	/^        static EmptyValueType emptyValue() { return make_pair(FirstTraits::emptyValue(), SecondTraits::emptyValue()); }$/;"	f	struct:WTF::PairHashTraits	access:public	signature:()
WTF::PairHashTraits::emptyValueIsZero	.\HashTraits.h	/^        static const bool emptyValueIsZero = FirstTraits::emptyValueIsZero && SecondTraits::emptyValueIsZero;$/;"	m	struct:WTF::PairHashTraits	access:public
WTF::PairHashTraits::isDeletedValue	.\HashTraits.h	/^        static bool isDeletedValue(const TraitType& value) { return FirstTraits::isDeletedValue(value.first); }$/;"	f	struct:WTF::PairHashTraits	access:public	signature:(const TraitType& value)
WTF::PairHashTraits::minimumTableSize	.\HashTraits.h	/^        static const int minimumTableSize = FirstTraits::minimumTableSize;$/;"	m	struct:WTF::PairHashTraits	access:public
WTF::PairHashTraits::needsDestruction	.\HashTraits.h	/^        static const bool needsDestruction = FirstTraits::needsDestruction || SecondTraits::needsDestruction;$/;"	m	struct:WTF::PairHashTraits	access:public
WTF::ParallelEnvironment	.\ParallelJobsGeneric.h	/^class ParallelEnvironment {$/;"	c	namespace:WTF
WTF::ParallelEnvironment	.\ParallelJobsLibdispatch.h	/^class ParallelEnvironment {$/;"	c	namespace:WTF
WTF::ParallelEnvironment	.\ParallelJobsOpenMP.h	/^class ParallelEnvironment {$/;"	c	namespace:WTF
WTF::ParallelEnvironment::ParallelEnvironment	.\ParallelJobsGeneric.cpp	/^ParallelEnvironment::ParallelEnvironment(ThreadFunction threadFunction, size_t sizeOfParameter, int requestedJobNumber) :$/;"	f	class:WTF::ParallelEnvironment	signature:(ThreadFunction threadFunction, size_t sizeOfParameter, int requestedJobNumber)
WTF::ParallelEnvironment::ParallelEnvironment	.\ParallelJobsGeneric.h	/^    ParallelEnvironment(ThreadFunction, size_t sizeOfParameter, int requestedJobNumber);$/;"	p	class:WTF::ParallelEnvironment	access:public	signature:(ThreadFunction, size_t sizeOfParameter, int requestedJobNumber)
WTF::ParallelEnvironment::ParallelEnvironment	.\ParallelJobsLibdispatch.h	/^    ParallelEnvironment(ThreadFunction threadFunction, size_t sizeOfParameter, int requestedJobNumber)$/;"	f	class:WTF::ParallelEnvironment	access:public	signature:(ThreadFunction threadFunction, size_t sizeOfParameter, int requestedJobNumber)
WTF::ParallelEnvironment::ParallelEnvironment	.\ParallelJobsOpenMP.h	/^    ParallelEnvironment(ThreadFunction threadFunction, size_t sizeOfParameter, int requestedJobNumber) :$/;"	f	class:WTF::ParallelEnvironment	access:public	signature:(ThreadFunction threadFunction, size_t sizeOfParameter, int requestedJobNumber)
WTF::ParallelEnvironment::ThreadFunction	.\ParallelJobsGeneric.h	/^    typedef void (*ThreadFunction)(void*);$/;"	t	class:WTF::ParallelEnvironment	access:public
WTF::ParallelEnvironment::ThreadFunction	.\ParallelJobsLibdispatch.h	/^    typedef void (*ThreadFunction)(void*);$/;"	t	class:WTF::ParallelEnvironment	access:public
WTF::ParallelEnvironment::ThreadFunction	.\ParallelJobsOpenMP.h	/^    typedef void (*ThreadFunction)(void*);$/;"	t	class:WTF::ParallelEnvironment	access:public
WTF::ParallelEnvironment::ThreadPrivate	.\ParallelJobsGeneric.h	/^    class ThreadPrivate : public RefCounted<ThreadPrivate> {$/;"	c	class:WTF::ParallelEnvironment	inherits:RefCounted	access:public
WTF::ParallelEnvironment::ThreadPrivate::ThreadPrivate	.\ParallelJobsGeneric.h	/^        ThreadPrivate()$/;"	f	class:WTF::ParallelEnvironment::ThreadPrivate	access:public	signature:()
WTF::ParallelEnvironment::ThreadPrivate::create	.\ParallelJobsGeneric.h	/^        static PassRefPtr<ThreadPrivate> create()$/;"	f	class:WTF::ParallelEnvironment::ThreadPrivate	access:public	signature:()
WTF::ParallelEnvironment::ThreadPrivate::execute	.\ParallelJobsGeneric.cpp	/^void ParallelEnvironment::ThreadPrivate::execute(ThreadFunction threadFunction, void* parameters)$/;"	f	class:WTF::ParallelEnvironment::ThreadPrivate	signature:(ThreadFunction threadFunction, void* parameters)
WTF::ParallelEnvironment::ThreadPrivate::execute	.\ParallelJobsGeneric.h	/^        void execute(ThreadFunction, void*);$/;"	p	class:WTF::ParallelEnvironment::ThreadPrivate	access:public	signature:(ThreadFunction, void*)
WTF::ParallelEnvironment::ThreadPrivate::m_mutex	.\ParallelJobsGeneric.h	/^        mutable Mutex m_mutex;$/;"	m	class:WTF::ParallelEnvironment::ThreadPrivate	access:private
WTF::ParallelEnvironment::ThreadPrivate::m_parameters	.\ParallelJobsGeneric.h	/^        void* m_parameters;$/;"	m	class:WTF::ParallelEnvironment::ThreadPrivate	access:private
WTF::ParallelEnvironment::ThreadPrivate::m_parent	.\ParallelJobsGeneric.h	/^        ParallelEnvironment* m_parent;$/;"	m	class:WTF::ParallelEnvironment::ThreadPrivate	access:private
WTF::ParallelEnvironment::ThreadPrivate::m_running	.\ParallelJobsGeneric.h	/^        bool m_running;$/;"	m	class:WTF::ParallelEnvironment::ThreadPrivate	access:private
WTF::ParallelEnvironment::ThreadPrivate::m_threadCondition	.\ParallelJobsGeneric.h	/^        ThreadCondition m_threadCondition;$/;"	m	class:WTF::ParallelEnvironment::ThreadPrivate	access:private
WTF::ParallelEnvironment::ThreadPrivate::m_threadFunction	.\ParallelJobsGeneric.h	/^        ThreadFunction m_threadFunction;$/;"	m	class:WTF::ParallelEnvironment::ThreadPrivate	access:private
WTF::ParallelEnvironment::ThreadPrivate::m_threadID	.\ParallelJobsGeneric.h	/^        ThreadIdentifier m_threadID;$/;"	m	class:WTF::ParallelEnvironment::ThreadPrivate	access:private
WTF::ParallelEnvironment::ThreadPrivate::tryLockFor	.\ParallelJobsGeneric.cpp	/^bool ParallelEnvironment::ThreadPrivate::tryLockFor(ParallelEnvironment* parent)$/;"	f	class:WTF::ParallelEnvironment::ThreadPrivate	signature:(ParallelEnvironment* parent)
WTF::ParallelEnvironment::ThreadPrivate::tryLockFor	.\ParallelJobsGeneric.h	/^        bool tryLockFor(ParallelEnvironment*);$/;"	p	class:WTF::ParallelEnvironment::ThreadPrivate	access:public	signature:(ParallelEnvironment*)
WTF::ParallelEnvironment::ThreadPrivate::waitForFinish	.\ParallelJobsGeneric.cpp	/^void ParallelEnvironment::ThreadPrivate::waitForFinish()$/;"	f	class:WTF::ParallelEnvironment::ThreadPrivate	signature:()
WTF::ParallelEnvironment::ThreadPrivate::waitForFinish	.\ParallelJobsGeneric.h	/^        void waitForFinish();$/;"	p	class:WTF::ParallelEnvironment::ThreadPrivate	access:public	signature:()
WTF::ParallelEnvironment::ThreadPrivate::workerThread	.\ParallelJobsGeneric.cpp	/^void ParallelEnvironment::ThreadPrivate::workerThread(void* threadData)$/;"	f	class:WTF::ParallelEnvironment::ThreadPrivate	signature:(void* threadData)
WTF::ParallelEnvironment::ThreadPrivate::workerThread	.\ParallelJobsGeneric.h	/^        static void workerThread(void*);$/;"	p	class:WTF::ParallelEnvironment::ThreadPrivate	access:public	signature:(void*)
WTF::ParallelEnvironment::WTF_MAKE_FAST_ALLOCATED	.\ParallelJobsGeneric.h	/^    WTF_MAKE_FAST_ALLOCATED;$/;"	m	class:WTF::ParallelEnvironment	access:private
WTF::ParallelEnvironment::WTF_MAKE_FAST_ALLOCATED	.\ParallelJobsLibdispatch.h	/^    WTF_MAKE_FAST_ALLOCATED;$/;"	m	class:WTF::ParallelEnvironment	access:private
WTF::ParallelEnvironment::WTF_MAKE_NONCOPYABLE	.\ParallelJobsOpenMP.h	/^    WTF_MAKE_NONCOPYABLE(ParallelEnvironment);$/;"	p	class:WTF::ParallelEnvironment	access:private	signature:(ParallelEnvironment)
WTF::ParallelEnvironment::execute	.\ParallelJobsGeneric.cpp	/^void ParallelEnvironment::execute(void* parameters)$/;"	f	class:WTF::ParallelEnvironment	signature:(void* parameters)
WTF::ParallelEnvironment::execute	.\ParallelJobsGeneric.h	/^    void execute(void* parameters);$/;"	p	class:WTF::ParallelEnvironment	access:public	signature:(void* parameters)
WTF::ParallelEnvironment::execute	.\ParallelJobsLibdispatch.h	/^    void execute(unsigned char* parameters)$/;"	f	class:WTF::ParallelEnvironment	access:public	signature:(unsigned char* parameters)
WTF::ParallelEnvironment::execute	.\ParallelJobsOpenMP.h	/^    void execute(unsigned char* parameters)$/;"	f	class:WTF::ParallelEnvironment	access:public	signature:(unsigned char* parameters)
WTF::ParallelEnvironment::m_numberOfJobs	.\ParallelJobsGeneric.h	/^    int m_numberOfJobs;$/;"	m	class:WTF::ParallelEnvironment	access:private
WTF::ParallelEnvironment::m_numberOfJobs	.\ParallelJobsLibdispatch.h	/^    int m_numberOfJobs;$/;"	m	class:WTF::ParallelEnvironment	access:private
WTF::ParallelEnvironment::m_numberOfJobs	.\ParallelJobsOpenMP.h	/^    int m_numberOfJobs;$/;"	m	class:WTF::ParallelEnvironment	access:private
WTF::ParallelEnvironment::m_sizeOfParameter	.\ParallelJobsGeneric.h	/^    size_t m_sizeOfParameter;$/;"	m	class:WTF::ParallelEnvironment	access:private
WTF::ParallelEnvironment::m_sizeOfParameter	.\ParallelJobsLibdispatch.h	/^    size_t m_sizeOfParameter;$/;"	m	class:WTF::ParallelEnvironment	access:private
WTF::ParallelEnvironment::m_sizeOfParameter	.\ParallelJobsOpenMP.h	/^    size_t m_sizeOfParameter;$/;"	m	class:WTF::ParallelEnvironment	access:private
WTF::ParallelEnvironment::m_threadFunction	.\ParallelJobsGeneric.h	/^    ThreadFunction m_threadFunction;$/;"	m	class:WTF::ParallelEnvironment	access:private
WTF::ParallelEnvironment::m_threadFunction	.\ParallelJobsLibdispatch.h	/^    ThreadFunction m_threadFunction;$/;"	m	class:WTF::ParallelEnvironment	access:private
WTF::ParallelEnvironment::m_threadFunction	.\ParallelJobsOpenMP.h	/^    ThreadFunction m_threadFunction;$/;"	m	class:WTF::ParallelEnvironment	access:private
WTF::ParallelEnvironment::m_threads	.\ParallelJobsGeneric.h	/^    Vector< RefPtr<ThreadPrivate> > m_threads;$/;"	m	class:WTF::ParallelEnvironment	access:private
WTF::ParallelEnvironment::numberOfJobs	.\ParallelJobsGeneric.h	/^    int numberOfJobs()$/;"	f	class:WTF::ParallelEnvironment	access:public	signature:()
WTF::ParallelEnvironment::numberOfJobs	.\ParallelJobsLibdispatch.h	/^    int numberOfJobs()$/;"	f	class:WTF::ParallelEnvironment	access:public	signature:()
WTF::ParallelEnvironment::numberOfJobs	.\ParallelJobsOpenMP.h	/^    int numberOfJobs()$/;"	f	class:WTF::ParallelEnvironment	access:public	signature:()
WTF::ParallelEnvironment::s_threadPool	.\ParallelJobsGeneric.cpp	/^Vector< RefPtr<ParallelEnvironment::ThreadPrivate> >* ParallelEnvironment::s_threadPool = 0;$/;"	m	class:WTF::ParallelEnvironment	file:
WTF::ParallelEnvironment::s_threadPool	.\ParallelJobsGeneric.h	/^    static Vector< RefPtr<ThreadPrivate> >* s_threadPool;$/;"	m	class:WTF::ParallelEnvironment	access:private
WTF::ParallelJobs	.\ParallelJobs.h	/^class ParallelJobs {$/;"	c	namespace:WTF
WTF::ParallelJobs::ParallelJobs	.\ParallelJobs.h	/^    ParallelJobs(WorkerFunction func, int requestedJobNumber) :$/;"	f	class:WTF::ParallelJobs	access:public	signature:(WorkerFunction func, int requestedJobNumber)
WTF::ParallelJobs::WTF_MAKE_FAST_ALLOCATED	.\ParallelJobs.h	/^    WTF_MAKE_FAST_ALLOCATED;$/;"	m	class:WTF::ParallelJobs	access:private
WTF::ParallelJobs::WorkerFunction	.\ParallelJobs.h	/^    typedef void (*WorkerFunction)(Type*);$/;"	t	class:WTF::ParallelJobs	access:public
WTF::ParallelJobs::execute	.\ParallelJobs.h	/^    void execute()$/;"	f	class:WTF::ParallelJobs	access:public	signature:()
WTF::ParallelJobs::m_parallelEnvironment	.\ParallelJobs.h	/^    ParallelEnvironment m_parallelEnvironment;$/;"	m	class:WTF::ParallelJobs	access:private
WTF::ParallelJobs::m_parameters	.\ParallelJobs.h	/^    Vector<Type> m_parameters;$/;"	m	class:WTF::ParallelJobs	access:private
WTF::ParallelJobs::numberOfJobs	.\ParallelJobs.h	/^    size_t numberOfJobs()$/;"	f	class:WTF::ParallelJobs	access:public	signature:()
WTF::ParallelJobs::parameter	.\ParallelJobs.h	/^    Type& parameter(size_t i)$/;"	f	class:WTF::ParallelJobs	access:public	signature:(size_t i)
WTF::ParamStorageTraits	.\Functional.h	/^template<typename T> struct ParamStorageTraits {$/;"	s	namespace:WTF
WTF::ParamStorageTraits	.\Functional.h	/^template<typename T> struct ParamStorageTraits<PassRefPtr<T> > {$/;"	s	namespace:WTF
WTF::ParamStorageTraits	.\Functional.h	/^template<typename T> struct ParamStorageTraits<RefPtr<T> > {$/;"	s	namespace:WTF
WTF::ParamStorageTraits	.\Functional.h	/^template<typename T> struct ParamStorageTraits<RetainPtr<T> > {$/;"	s	namespace:WTF
WTF::ParamStorageTraits::StorageType	.\Functional.h	/^    typedef RefPtr<T> StorageType;$/;"	t	struct:WTF::ParamStorageTraits	access:public
WTF::ParamStorageTraits::StorageType	.\Functional.h	/^    typedef RetainPtr<T> StorageType;$/;"	t	struct:WTF::ParamStorageTraits	access:public
WTF::ParamStorageTraits::StorageType	.\Functional.h	/^    typedef T StorageType;$/;"	t	struct:WTF::ParamStorageTraits	access:public
WTF::ParamStorageTraits::unwrap	.\Functional.h	/^    static T* unwrap(const StorageType& value) { return value.get(); }$/;"	f	struct:WTF::ParamStorageTraits	access:public	signature:(const StorageType& value)
WTF::ParamStorageTraits::unwrap	.\Functional.h	/^    static const T& unwrap(const StorageType& value) { return value; }$/;"	f	struct:WTF::ParamStorageTraits	access:public	signature:(const StorageType& value)
WTF::ParamStorageTraits::unwrap	.\Functional.h	/^    static typename RetainPtr<T>::PtrType unwrap(const StorageType& value) { return value.get(); }$/;"	f	struct:WTF::ParamStorageTraits	access:public	signature:(const StorageType& value)
WTF::ParamStorageTraits::wrap	.\Functional.h	/^    static StorageType wrap(PassRefPtr<T> value) { return value; }$/;"	f	struct:WTF::ParamStorageTraits	access:public	signature:(PassRefPtr<T> value)
WTF::ParamStorageTraits::wrap	.\Functional.h	/^    static StorageType wrap(RefPtr<T> value) { return value.release(); }$/;"	f	struct:WTF::ParamStorageTraits	access:public	signature:(RefPtr<T> value)
WTF::ParamStorageTraits::wrap	.\Functional.h	/^    static StorageType wrap(const RetainPtr<T>& value) { return value; }$/;"	f	struct:WTF::ParamStorageTraits	access:public	signature:(const RetainPtr<T>& value)
WTF::ParamStorageTraits::wrap	.\Functional.h	/^    static StorageType wrap(const T& value) { return value; }$/;"	f	struct:WTF::ParamStorageTraits	access:public	signature:(const T& value)
WTF::ParsedURL	.\url\api\ParsedURL.h	/^class ParsedURL {$/;"	c	namespace:WTF
WTF::ParsedURL::ParsedURL	.\url\api\ParsedURL.cpp	/^ParsedURL::ParsedURL(const String& urlString)$/;"	f	class:WTF::ParsedURL	signature:(const String& urlString)
WTF::ParsedURL::ParsedURL	.\url\api\ParsedURL.h	/^    ParsedURL() { };$/;"	f	class:WTF::ParsedURL	access:public	signature:()
WTF::ParsedURL::ParsedURL	.\url\api\ParsedURL.h	/^    WTF_EXPORT_PRIVATE explicit ParsedURL(const String&);$/;"	p	class:WTF::ParsedURL	access:public	signature:(const String&)
WTF::ParsedURL::baseAsString	.\url\api\ParsedURL.cpp	/^String ParsedURL::baseAsString() const$/;"	f	class:WTF::ParsedURL	signature:() const
WTF::ParsedURL::baseAsString	.\url\api\ParsedURL.h	/^    WTF_EXPORT_PRIVATE String baseAsString() const;$/;"	p	class:WTF::ParsedURL	access:public	signature:() const
WTF::ParsedURL::fragment	.\url\api\ParsedURL.cpp	/^String ParsedURL::fragment() const$/;"	f	class:WTF::ParsedURL	signature:() const
WTF::ParsedURL::fragment	.\url\api\ParsedURL.h	/^    WTF_EXPORT_PRIVATE String fragment() const;$/;"	p	class:WTF::ParsedURL	access:public	signature:() const
WTF::ParsedURL::host	.\url\api\ParsedURL.cpp	/^String ParsedURL::host() const$/;"	f	class:WTF::ParsedURL	signature:() const
WTF::ParsedURL::host	.\url\api\ParsedURL.h	/^    WTF_EXPORT_PRIVATE String host() const;$/;"	p	class:WTF::ParsedURL	access:public	signature:() const
WTF::ParsedURL::isValid	.\url\api\ParsedURL.h	/^    bool isValid() const { return !m_spec.string().isEmpty(); }$/;"	f	class:WTF::ParsedURL	access:public	signature:() const
WTF::ParsedURL::isolatedCopy	.\url\api\ParsedURL.cpp	/^ParsedURL ParsedURL::isolatedCopy() const$/;"	f	class:WTF::ParsedURL	signature:() const
WTF::ParsedURL::isolatedCopy	.\url\api\ParsedURL.h	/^    WTF_EXPORT_PRIVATE ParsedURL isolatedCopy() const;$/;"	p	class:WTF::ParsedURL	access:public	signature:() const
WTF::ParsedURL::m_segments	.\url\api\ParsedURL.h	/^    URLSegments m_segments;$/;"	m	class:WTF::ParsedURL	access:private
WTF::ParsedURL::m_spec	.\url\api\ParsedURL.h	/^    URLString m_spec;$/;"	m	class:WTF::ParsedURL	access:private
WTF::ParsedURL::password	.\url\api\ParsedURL.cpp	/^String ParsedURL::password() const$/;"	f	class:WTF::ParsedURL	signature:() const
WTF::ParsedURL::password	.\url\api\ParsedURL.h	/^    WTF_EXPORT_PRIVATE String password() const;$/;"	p	class:WTF::ParsedURL	access:public	signature:() const
WTF::ParsedURL::path	.\url\api\ParsedURL.cpp	/^String ParsedURL::path() const$/;"	f	class:WTF::ParsedURL	signature:() const
WTF::ParsedURL::path	.\url\api\ParsedURL.h	/^    WTF_EXPORT_PRIVATE String path() const;$/;"	p	class:WTF::ParsedURL	access:public	signature:() const
WTF::ParsedURL::port	.\url\api\ParsedURL.cpp	/^String ParsedURL::port() const$/;"	f	class:WTF::ParsedURL	signature:() const
WTF::ParsedURL::port	.\url\api\ParsedURL.h	/^    WTF_EXPORT_PRIVATE String port() const;$/;"	p	class:WTF::ParsedURL	access:public	signature:() const
WTF::ParsedURL::query	.\url\api\ParsedURL.cpp	/^String ParsedURL::query() const$/;"	f	class:WTF::ParsedURL	signature:() const
WTF::ParsedURL::query	.\url\api\ParsedURL.h	/^    WTF_EXPORT_PRIVATE String query() const;$/;"	p	class:WTF::ParsedURL	access:public	signature:() const
WTF::ParsedURL::scheme	.\url\api\ParsedURL.cpp	/^String ParsedURL::scheme() const$/;"	f	class:WTF::ParsedURL	signature:() const
WTF::ParsedURL::scheme	.\url\api\ParsedURL.h	/^    WTF_EXPORT_PRIVATE String scheme() const;$/;"	p	class:WTF::ParsedURL	access:public	signature:() const
WTF::ParsedURL::segment	.\url\api\ParsedURL.cpp	/^String ParsedURL::segment(const URLComponent& component) const$/;"	f	class:WTF::ParsedURL	signature:(const URLComponent& component) const
WTF::ParsedURL::segment	.\url\api\ParsedURL.h	/^    inline String segment(const URLComponent&) const;$/;"	p	class:WTF::ParsedURL	access:private	signature:(const URLComponent&) const
WTF::ParsedURL::spec	.\url\api\ParsedURL.h	/^    URLString spec() { return m_spec; }$/;"	f	class:WTF::ParsedURL	access:public	signature:()
WTF::ParsedURL::username	.\url\api\ParsedURL.cpp	/^String ParsedURL::username() const$/;"	f	class:WTF::ParsedURL	signature:() const
WTF::ParsedURL::username	.\url\api\ParsedURL.h	/^    WTF_EXPORT_PRIVATE String username() const;$/;"	p	class:WTF::ParsedURL	access:public	signature:() const
WTF::PassOwnArrayPtr	.\PassOwnArrayPtr.h	/^template<typename T> class PassOwnArrayPtr {$/;"	c	namespace:WTF
WTF::PassOwnArrayPtr::PassOwnArrayPtr	.\PassOwnArrayPtr.h	/^    PassOwnArrayPtr() : m_ptr(0) { }$/;"	f	class:WTF::PassOwnArrayPtr	access:public	signature:()
WTF::PassOwnArrayPtr::PassOwnArrayPtr	.\PassOwnArrayPtr.h	/^    PassOwnArrayPtr(const PassOwnArrayPtr& o) : m_ptr(o.leakPtr()) { }$/;"	f	class:WTF::PassOwnArrayPtr	access:public	signature:(const PassOwnArrayPtr& o)
WTF::PassOwnArrayPtr::PassOwnArrayPtr	.\PassOwnArrayPtr.h	/^    PassOwnArrayPtr(std::nullptr_t) : m_ptr(0) { }$/;"	f	class:WTF::PassOwnArrayPtr	access:public	signature:(std::nullptr_t)
WTF::PassOwnArrayPtr::PassOwnArrayPtr	.\PassOwnArrayPtr.h	/^    explicit PassOwnArrayPtr(PtrType ptr) : m_ptr(ptr) { }$/;"	f	class:WTF::PassOwnArrayPtr	access:private	signature:(PtrType ptr)
WTF::PassOwnArrayPtr::PassOwnArrayPtr	.\PassOwnArrayPtr.h	/^    template<typename U> PassOwnArrayPtr(const PassOwnArrayPtr<U>& o) : m_ptr(o.leakPtr()) { }$/;"	f	class:WTF::PassOwnArrayPtr	access:public	signature:(const PassOwnArrayPtr<U>& o)
WTF::PassOwnArrayPtr::PassOwnArrayPtr::UnspecifiedBoolType	.\PassOwnArrayPtr.h	/^    typedef PtrType PassOwnArrayPtr::*UnspecifiedBoolType;$/;"	t	class:WTF::PassOwnArrayPtr::PassOwnArrayPtr	access:public
WTF::PassOwnArrayPtr::PtrType	.\PassOwnArrayPtr.h	/^    typedef T* PtrType;$/;"	t	class:WTF::PassOwnArrayPtr	access:public
WTF::PassOwnArrayPtr::WARN_UNUSED_RETURN	.\PassOwnArrayPtr.h	/^    PtrType leakPtr() const WARN_UNUSED_RETURN;$/;"	m	class:WTF::PassOwnArrayPtr	access:public
WTF::PassOwnArrayPtr::adoptArrayPtr	.\PassOwnArrayPtr.h	/^    template<typename U> friend PassOwnArrayPtr<U> adoptArrayPtr(U*);$/;"	p	class:WTF::PassOwnArrayPtr	access:friend	signature:(U*)
WTF::PassOwnArrayPtr::get	.\PassOwnArrayPtr.h	/^    PtrType get() const { return m_ptr; }$/;"	f	class:WTF::PassOwnArrayPtr	access:public	signature:() const
WTF::PassOwnArrayPtr::leakPtr	.\PassOwnArrayPtr.h	/^template<typename T> inline typename PassOwnArrayPtr<T>::PtrType PassOwnArrayPtr<T>::leakPtr() const$/;"	f	class:WTF::PassOwnArrayPtr	signature:() const
WTF::PassOwnArrayPtr::m_ptr	.\PassOwnArrayPtr.h	/^    mutable PtrType m_ptr;$/;"	m	class:WTF::PassOwnArrayPtr	access:private
WTF::PassOwnArrayPtr::operator !	.\PassOwnArrayPtr.h	/^    bool operator!() const { return !m_ptr; }$/;"	f	class:WTF::PassOwnArrayPtr	access:public	signature:() const
WTF::PassOwnArrayPtr::operator *	.\PassOwnArrayPtr.h	/^    T& operator*() const { ASSERT(m_ptr); return *m_ptr; }$/;"	f	class:WTF::PassOwnArrayPtr	access:public	signature:() const
WTF::PassOwnArrayPtr::operator ->	.\PassOwnArrayPtr.h	/^    PtrType operator->() const { ASSERT(m_ptr); return m_ptr; }$/;"	f	class:WTF::PassOwnArrayPtr	access:public	signature:() const
WTF::PassOwnArrayPtr::operator =	.\PassOwnArrayPtr.h	/^    PassOwnArrayPtr& operator=(const PassOwnArrayPtr&) { COMPILE_ASSERT(!sizeof(T*), PassOwnArrayPtr_should_never_be_assigned_to); return *this; }$/;"	f	class:WTF::PassOwnArrayPtr	access:public	signature:(const PassOwnArrayPtr&)
WTF::PassOwnArrayPtr::operator UnspecifiedBoolType	.\PassOwnArrayPtr.h	/^    operator UnspecifiedBoolType() const { return m_ptr ? &PassOwnArrayPtr::m_ptr : 0; }$/;"	f	class:WTF::PassOwnArrayPtr	access:public	signature:() const
WTF::PassOwnArrayPtr::~PassOwnArrayPtr	.\PassOwnArrayPtr.h	/^    ~PassOwnArrayPtr() { deleteOwnedArrayPtr(m_ptr); }$/;"	f	class:WTF::PassOwnArrayPtr	access:public	signature:()
WTF::PassOwnPtr	.\PassOwnPtr.h	/^    template<typename T> class PassOwnPtr {$/;"	c	namespace:WTF
WTF::PassOwnPtr::PassOwnPtr	.\PassOwnPtr.h	/^        PassOwnPtr() : m_ptr(0) { }$/;"	f	class:WTF::PassOwnPtr	access:public	signature:()
WTF::PassOwnPtr::PassOwnPtr	.\PassOwnPtr.h	/^        PassOwnPtr(const PassOwnPtr& o) : m_ptr(o.leakPtr()) { }$/;"	f	class:WTF::PassOwnPtr	access:public	signature:(const PassOwnPtr& o)
WTF::PassOwnPtr::PassOwnPtr	.\PassOwnPtr.h	/^        PassOwnPtr(std::nullptr_t) : m_ptr(0) { }$/;"	f	class:WTF::PassOwnPtr	access:public	signature:(std::nullptr_t)
WTF::PassOwnPtr::PassOwnPtr	.\PassOwnPtr.h	/^        explicit PassOwnPtr(PtrType ptr) : m_ptr(ptr) { }$/;"	f	class:WTF::PassOwnPtr	access:private	signature:(PtrType ptr)
WTF::PassOwnPtr::PassOwnPtr	.\PassOwnPtr.h	/^        template<typename U> PassOwnPtr(const PassOwnPtr<U>& o) : m_ptr(o.leakPtr()) { }$/;"	f	class:WTF::PassOwnPtr	access:public	signature:(const PassOwnPtr<U>& o)
WTF::PassOwnPtr::PassOwnPtr::UnspecifiedBoolType	.\PassOwnPtr.h	/^        typedef PtrType PassOwnPtr::*UnspecifiedBoolType;$/;"	t	class:WTF::PassOwnPtr::PassOwnPtr	access:public
WTF::PassOwnPtr::PtrType	.\PassOwnPtr.h	/^        typedef ValueType* PtrType;$/;"	t	class:WTF::PassOwnPtr	access:public
WTF::PassOwnPtr::ValueType	.\PassOwnPtr.h	/^        typedef typename RemovePointer<T>::Type ValueType;$/;"	t	class:WTF::PassOwnPtr	access:public
WTF::PassOwnPtr::WARN_UNUSED_RETURN	.\PassOwnPtr.h	/^        PtrType leakPtr() const WARN_UNUSED_RETURN;$/;"	m	class:WTF::PassOwnPtr	access:public
WTF::PassOwnPtr::adoptPtr	.\PassOwnPtr.h	/^        template<typename U> friend PassOwnPtr<U> adoptPtr(U*);$/;"	p	class:WTF::PassOwnPtr	access:friend	signature:(U*)
WTF::PassOwnPtr::get	.\PassOwnPtr.h	/^        PtrType get() const { return m_ptr; }$/;"	f	class:WTF::PassOwnPtr	access:public	signature:() const
WTF::PassOwnPtr::leakPtr	.\PassOwnPtr.h	/^    template<typename T> inline typename PassOwnPtr<T>::PtrType PassOwnPtr<T>::leakPtr() const$/;"	f	class:WTF::PassOwnPtr	signature:() const
WTF::PassOwnPtr::m_ptr	.\PassOwnPtr.h	/^        mutable PtrType m_ptr;$/;"	m	class:WTF::PassOwnPtr	access:private
WTF::PassOwnPtr::operator !	.\PassOwnPtr.h	/^        bool operator!() const { return !m_ptr; }$/;"	f	class:WTF::PassOwnPtr	access:public	signature:() const
WTF::PassOwnPtr::operator !=	.\PassOwnPtr.h	/^        template<typename U> bool operator!=(const OwnPtr<U>&) { COMPILE_ASSERT(!sizeof(U*), OwnPtrs_should_never_be_equal); return false; }$/;"	f	class:WTF::PassOwnPtr	access:private	signature:(const OwnPtr<U>&)
WTF::PassOwnPtr::operator !=	.\PassOwnPtr.h	/^        template<typename U> bool operator!=(const PassOwnPtr<U>&) { COMPILE_ASSERT(!sizeof(U*), OwnPtrs_should_never_be_equal); return false; }$/;"	f	class:WTF::PassOwnPtr	access:private	signature:(const PassOwnPtr<U>&)
WTF::PassOwnPtr::operator *	.\PassOwnPtr.h	/^        ValueType& operator*() const { ASSERT(m_ptr); return *m_ptr; }$/;"	f	class:WTF::PassOwnPtr	access:public	signature:() const
WTF::PassOwnPtr::operator ->	.\PassOwnPtr.h	/^        PtrType operator->() const { ASSERT(m_ptr); return m_ptr; }$/;"	f	class:WTF::PassOwnPtr	access:public	signature:() const
WTF::PassOwnPtr::operator =	.\PassOwnPtr.h	/^        PassOwnPtr& operator=(const PassOwnPtr&) { COMPILE_ASSERT(!sizeof(T*), PassOwnPtr_should_never_be_assigned_to); return *this; }$/;"	f	class:WTF::PassOwnPtr	access:public	signature:(const PassOwnPtr&)
WTF::PassOwnPtr::operator ==	.\PassOwnPtr.h	/^        template<typename U> bool operator==(const OwnPtr<U>&) { COMPILE_ASSERT(!sizeof(U*), OwnPtrs_should_never_be_equal); return false; }$/;"	f	class:WTF::PassOwnPtr	access:private	signature:(const OwnPtr<U>&)
WTF::PassOwnPtr::operator ==	.\PassOwnPtr.h	/^        template<typename U> bool operator==(const PassOwnPtr<U>&) { COMPILE_ASSERT(!sizeof(U*), OwnPtrs_should_never_be_equal); return false; }$/;"	f	class:WTF::PassOwnPtr	access:private	signature:(const PassOwnPtr<U>&)
WTF::PassOwnPtr::operator UnspecifiedBoolType	.\PassOwnPtr.h	/^        operator UnspecifiedBoolType() const { return m_ptr ? &PassOwnPtr::m_ptr : 0; }$/;"	f	class:WTF::PassOwnPtr	access:public	signature:() const
WTF::PassOwnPtr::~PassOwnPtr	.\PassOwnPtr.h	/^        ~PassOwnPtr() { deleteOwnedPtr(m_ptr); }$/;"	f	class:WTF::PassOwnPtr	access:public	signature:()
WTF::PassRefPtr	.\PassRefPtr.h	/^    template<typename T> class PassRefPtr {$/;"	c	namespace:WTF
WTF::PassRefPtr::PassRefPtr	.\PassRefPtr.h	/^        PassRefPtr() : m_ptr(0) { }$/;"	f	class:WTF::PassRefPtr	access:public	signature:()
WTF::PassRefPtr::PassRefPtr	.\PassRefPtr.h	/^        PassRefPtr(T* ptr) : m_ptr(ptr) { refIfNotNull(ptr); }$/;"	f	class:WTF::PassRefPtr	access:public	signature:(T* ptr)
WTF::PassRefPtr::PassRefPtr	.\PassRefPtr.h	/^        PassRefPtr(T* ptr, bool) : m_ptr(ptr) { }$/;"	f	class:WTF::PassRefPtr	access:private	signature:(T* ptr, bool)
WTF::PassRefPtr::PassRefPtr	.\PassRefPtr.h	/^        PassRefPtr(const PassRefPtr& o) : m_ptr(o.leakRef()) { }$/;"	f	class:WTF::PassRefPtr	access:public	signature:(const PassRefPtr& o)
WTF::PassRefPtr::PassRefPtr	.\PassRefPtr.h	/^        template<typename U> PassRefPtr(const PassRefPtr<U>& o) : m_ptr(o.leakRef()) { }$/;"	f	class:WTF::PassRefPtr	access:public	signature:(const PassRefPtr<U>& o)
WTF::PassRefPtr::PassRefPtr	.\PassRefPtr.h	/^        template<typename U> PassRefPtr(const RefPtr<U>&);$/;"	p	class:WTF::PassRefPtr	access:public	signature:(const RefPtr<U>&)
WTF::PassRefPtr::PassRefPtr	.\PassRefPtr.h	/^    template<typename T> template<typename U> inline PassRefPtr<T>::PassRefPtr(const RefPtr<U>& o)$/;"	f	class:WTF::PassRefPtr	signature:(const RefPtr<U>& o)
WTF::PassRefPtr::UnspecifiedBoolType	.\PassRefPtr.h	/^        typedef T* (PassRefPtr::*UnspecifiedBoolType);$/;"	t	class:WTF::PassRefPtr	access:public
WTF::PassRefPtr::WARN_UNUSED_RETURN	.\PassRefPtr.h	/^        T* leakRef() const WARN_UNUSED_RETURN;$/;"	m	class:WTF::PassRefPtr	access:public
WTF::PassRefPtr::adoptRef	.\PassRefPtr.h	/^        friend PassRefPtr adoptRef<T>(T*);$/;"	p	class:WTF::PassRefPtr	access:friend	signature:(T*)
WTF::PassRefPtr::get	.\PassRefPtr.h	/^        T* get() const { return m_ptr; }$/;"	f	class:WTF::PassRefPtr	access:public	signature:() const
WTF::PassRefPtr::leakRef	.\PassRefPtr.h	/^    template<typename T> inline T* PassRefPtr<T>::leakRef() const$/;"	f	class:WTF::PassRefPtr	signature:() const
WTF::PassRefPtr::m_ptr	.\PassRefPtr.h	/^        mutable T* m_ptr;$/;"	m	class:WTF::PassRefPtr	access:private
WTF::PassRefPtr::operator !	.\PassRefPtr.h	/^        bool operator!() const { return !m_ptr; }$/;"	f	class:WTF::PassRefPtr	access:public	signature:() const
WTF::PassRefPtr::operator *	.\PassRefPtr.h	/^        T& operator*() const { return *m_ptr; }$/;"	f	class:WTF::PassRefPtr	access:public	signature:() const
WTF::PassRefPtr::operator ->	.\PassRefPtr.h	/^        T* operator->() const { return m_ptr; }$/;"	f	class:WTF::PassRefPtr	access:public	signature:() const
WTF::PassRefPtr::operator =	.\PassRefPtr.h	/^        PassRefPtr& operator=(const PassRefPtr&) { COMPILE_ASSERT(!sizeof(T*), PassRefPtr_should_never_be_assigned_to); return *this; }$/;"	f	class:WTF::PassRefPtr	access:public	signature:(const PassRefPtr&)
WTF::PassRefPtr::operator UnspecifiedBoolType	.\PassRefPtr.h	/^        operator UnspecifiedBoolType() const { return m_ptr ? &PassRefPtr::m_ptr : 0; }$/;"	f	class:WTF::PassRefPtr	access:public	signature:() const
WTF::PassRefPtr::~PassRefPtr	.\PassRefPtr.h	/^        ALWAYS_INLINE ~PassRefPtr() { derefIfNotNull(m_ptr); }$/;"	f	class:WTF::PassRefPtr	access:public	signature:()
WTF::PassRefPtr_should_stay_small	.\SizeLimits.cpp	/^COMPILE_ASSERT(sizeof(PassRefPtr<RefCounted<int> >) == sizeof(int*), PassRefPtr_should_stay_small);$/;"	v
WTF::PassTraits	.\PassTraits.h	/^template<typename T> struct PassTraits {$/;"	s	namespace:WTF
WTF::PassTraits	.\PassTraits.h	/^template<typename T> struct PassTraits<OwnPtr<T> > {$/;"	s	namespace:WTF
WTF::PassTraits	.\PassTraits.h	/^template<typename T> struct PassTraits<RefPtr<T> > {$/;"	s	namespace:WTF
WTF::PassTraits::PassType	.\PassTraits.h	/^    typedef PassOwnPtr<T> PassType;$/;"	t	struct:WTF::PassTraits	access:public
WTF::PassTraits::PassType	.\PassTraits.h	/^    typedef PassRefPtr<T> PassType;$/;"	t	struct:WTF::PassTraits	access:public
WTF::PassTraits::PassType	.\PassTraits.h	/^    typedef T PassType;$/;"	t	struct:WTF::PassTraits	access:public
WTF::PassTraits::Type	.\PassTraits.h	/^    typedef OwnPtr<T> Type;$/;"	t	struct:WTF::PassTraits	access:public
WTF::PassTraits::Type	.\PassTraits.h	/^    typedef RefPtr<T> Type;$/;"	t	struct:WTF::PassTraits	access:public
WTF::PassTraits::Type	.\PassTraits.h	/^    typedef T Type;$/;"	t	struct:WTF::PassTraits	access:public
WTF::PassTraits::transfer	.\PassTraits.h	/^    static PassType transfer(Type& value) { return value.release(); }$/;"	f	struct:WTF::PassTraits	access:public	signature:(Type& value)
WTF::PassTraits::transfer	.\PassTraits.h	/^    static PassType transfer(Type& value) { return value; }$/;"	f	struct:WTF::PassTraits	access:public	signature:(Type& value)
WTF::PlacementNewAdopt	.\RefPtr.h	/^    enum PlacementNewAdoptType { PlacementNewAdopt };$/;"	e	enum:WTF::PlacementNewAdoptType
WTF::PlacementNewAdoptType	.\RefPtr.h	/^    enum PlacementNewAdoptType { PlacementNewAdopt };$/;"	g	namespace:WTF
WTF::PlatformCondition	.\ThreadingPrimitives.h	/^typedef pthread_cond_t PlatformCondition;$/;"	t	namespace:WTF
WTF::PlatformCondition::signal	.\ThreadingWin.cpp	/^void PlatformCondition::signal(bool unblockAll)$/;"	f	class:WTF::PlatformCondition	signature:(bool unblockAll)
WTF::PlatformCondition::timedWait	.\ThreadingWin.cpp	/^bool PlatformCondition::timedWait(PlatformMutex& mutex, DWORD durationMilliseconds)$/;"	f	class:WTF::PlatformCondition	signature:(PlatformMutex& mutex, DWORD durationMilliseconds)
WTF::PlatformMutex	.\ThreadingPrimitives.h	/^typedef pthread_mutex_t PlatformMutex;$/;"	t	namespace:WTF
WTF::PlatformReadWriteLock	.\ThreadingPrimitives.h	/^typedef pthread_rwlock_t PlatformReadWriteLock;$/;"	t	namespace:WTF
WTF::PlatformReadWriteLock	.\ThreadingPrimitives.h	/^typedef void* PlatformReadWriteLock;$/;"	t	namespace:WTF
WTF::PossiblyNull	.\PossiblyNull.h	/^template <typename T> struct PossiblyNull {$/;"	s	namespace:WTF
WTF::PossiblyNull::PossiblyNull	.\PossiblyNull.h	/^    PossiblyNull(T data)$/;"	f	struct:WTF::PossiblyNull	access:public	signature:(T data)
WTF::PossiblyNull::PossiblyNull	.\PossiblyNull.h	/^    PossiblyNull(const PossiblyNull<T>& source)$/;"	f	struct:WTF::PossiblyNull	access:public	signature:(const PossiblyNull<T>& source)
WTF::PossiblyNull::WARN_UNUSED_RETURN	.\PossiblyNull.h	/^    bool getValue(T& out) WARN_UNUSED_RETURN;$/;"	m	struct:WTF::PossiblyNull	access:public
WTF::PossiblyNull::getValue	.\PossiblyNull.h	/^template <typename T> bool PossiblyNull<T>::getValue(T& out)$/;"	f	class:WTF::PossiblyNull	signature:(T& out)
WTF::PossiblyNull::m_data	.\PossiblyNull.h	/^    mutable T m_data;$/;"	m	struct:WTF::PossiblyNull	access:private
WTF::PossiblyNull::~PossiblyNull	.\PossiblyNull.h	/^    ~PossiblyNull() { ASSERT(!m_data); }$/;"	f	struct:WTF::PossiblyNull	access:public	signature:()
WTF::PrintStats	.\FastMalloc.cpp	/^static void PrintStats(int level) {$/;"	f	namespace:WTF	file:	signature:(int level)
WTF::PtrHash	.\HashFunctions.h	/^    template<typename P> struct PtrHash<RefPtr<P> > : PtrHash<P*> {$/;"	s	namespace:WTF	inherits:PtrHash
WTF::PtrHash	.\HashFunctions.h	/^    template<typename T> struct PtrHash {$/;"	s	namespace:WTF
WTF::PtrHash	.\RetainPtr.h	/^    template<typename P> struct PtrHash<RetainPtr<P> > : PtrHash<typename RetainPtr<P>::PtrType> {$/;"	s	namespace:WTF	inherits:PtrHash
WTF::PtrHash::equal	.\HashFunctions.h	/^        static bool equal(P* a, const RefPtr<P>& b) { return a == b; }$/;"	f	struct:WTF::PtrHash	access:public	signature:(P* a, const RefPtr<P>& b)
WTF::PtrHash::equal	.\HashFunctions.h	/^        static bool equal(T a, T b) { return a == b; }$/;"	f	struct:WTF::PtrHash	access:public	signature:(T a, T b)
WTF::PtrHash::equal	.\HashFunctions.h	/^        static bool equal(const RefPtr<P>& a, P* b) { return a == b; }$/;"	f	struct:WTF::PtrHash	access:public	signature:(const RefPtr<P>& a, P* b)
WTF::PtrHash::equal	.\HashFunctions.h	/^        static bool equal(const RefPtr<P>& a, const RefPtr<P>& b) { return a == b; }$/;"	f	struct:WTF::PtrHash	access:public	signature:(const RefPtr<P>& a, const RefPtr<P>& b)
WTF::PtrHash::equal	.\RetainPtr.h	/^        static bool equal(const RetainPtr<P>& a, const RetainPtr<P>& b) { return a == b; }$/;"	f	struct:WTF::PtrHash	access:public	signature:(const RetainPtr<P>& a, const RetainPtr<P>& b)
WTF::PtrHash::equal	.\RetainPtr.h	/^        static bool equal(const RetainPtr<P>& a, typename RetainPtr<P>::PtrType b) { return a == b; }$/;"	f	struct:WTF::PtrHash	access:public	signature:(const RetainPtr<P>& a, typename RetainPtr<P>::PtrType b)
WTF::PtrHash::equal	.\RetainPtr.h	/^        static bool equal(typename RetainPtr<P>::PtrType a, const RetainPtr<P>& b) { return a == b; }$/;"	f	struct:WTF::PtrHash	access:public	signature:(typename RetainPtr<P>::PtrType a, const RetainPtr<P>& b)
WTF::PtrHash::hash	.\HashFunctions.h	/^        static unsigned hash(T key)$/;"	f	struct:WTF::PtrHash	access:public	signature:(T key)
WTF::PtrHash::hash	.\HashFunctions.h	/^        static unsigned hash(const RefPtr<P>& key) { return hash(key.get()); }$/;"	f	struct:WTF::PtrHash	access:public	signature:(const RefPtr<P>& key)
WTF::PtrHash::hash	.\RetainPtr.h	/^        static unsigned hash(const RetainPtr<P>& key) { return hash(key.get()); }$/;"	f	struct:WTF::PtrHash	access:public	signature:(const RetainPtr<P>& key)
WTF::PtrHash::safeToCompareToEmptyOrDeleted	.\HashFunctions.h	/^        static const bool safeToCompareToEmptyOrDeleted = true;$/;"	m	struct:WTF::PtrHash	access:public
WTF::RawURLBuffer	.\url\src\RawURLBuffer.h	/^class RawURLBuffer : public URLBuffer<CharacterType> {$/;"	c	namespace:WTF	inherits:URLBuffer
WTF::RawURLBuffer::RawURLBuffer	.\url\src\RawURLBuffer.h	/^    RawURLBuffer() : URLBuffer<CharacterType>()$/;"	f	class:WTF::RawURLBuffer	access:public	signature:()
WTF::RawURLBuffer::m_inlineBuffer	.\url\src\RawURLBuffer.h	/^    CharacterType m_inlineBuffer[inlineCapacity];$/;"	m	class:WTF::RawURLBuffer	access:protected
WTF::RawURLBuffer::resize	.\url\src\RawURLBuffer.h	/^    virtual void resize(int size)$/;"	f	class:WTF::RawURLBuffer	access:public	signature:(int size)
WTF::RawURLBuffer::~RawURLBuffer	.\url\src\RawURLBuffer.h	/^    virtual ~RawURLBuffer()$/;"	f	class:WTF::RawURLBuffer	access:public	signature:()
WTF::ReadWriteLock	.\ThreadingPrimitives.h	/^class ReadWriteLock {$/;"	c	namespace:WTF
WTF::ReadWriteLock::ReadWriteLock	.\ThreadingPrimitives.h	/^    ReadWriteLock();$/;"	p	class:WTF::ReadWriteLock	access:public	signature:()
WTF::ReadWriteLock::ReadWriteLock	.\ThreadingPthreads.cpp	/^ReadWriteLock::ReadWriteLock()$/;"	f	class:WTF::ReadWriteLock	signature:()
WTF::ReadWriteLock::WTF_MAKE_NONCOPYABLE	.\ThreadingPrimitives.h	/^    WTF_MAKE_NONCOPYABLE(ReadWriteLock);$/;"	p	class:WTF::ReadWriteLock	access:private	signature:(ReadWriteLock)
WTF::ReadWriteLock::m_readWriteLock	.\ThreadingPrimitives.h	/^    PlatformReadWriteLock m_readWriteLock;$/;"	m	class:WTF::ReadWriteLock	access:private
WTF::ReadWriteLock::readLock	.\ThreadingPrimitives.h	/^    void readLock();$/;"	p	class:WTF::ReadWriteLock	access:public	signature:()
WTF::ReadWriteLock::readLock	.\ThreadingPthreads.cpp	/^void ReadWriteLock::readLock()$/;"	f	class:WTF::ReadWriteLock	signature:()
WTF::ReadWriteLock::tryReadLock	.\ThreadingPrimitives.h	/^    bool tryReadLock();$/;"	p	class:WTF::ReadWriteLock	access:public	signature:()
WTF::ReadWriteLock::tryReadLock	.\ThreadingPthreads.cpp	/^bool ReadWriteLock::tryReadLock()$/;"	f	class:WTF::ReadWriteLock	signature:()
WTF::ReadWriteLock::tryWriteLock	.\ThreadingPrimitives.h	/^    bool tryWriteLock();$/;"	p	class:WTF::ReadWriteLock	access:public	signature:()
WTF::ReadWriteLock::tryWriteLock	.\ThreadingPthreads.cpp	/^bool ReadWriteLock::tryWriteLock()$/;"	f	class:WTF::ReadWriteLock	signature:()
WTF::ReadWriteLock::unlock	.\ThreadingPrimitives.h	/^    void unlock();$/;"	p	class:WTF::ReadWriteLock	access:public	signature:()
WTF::ReadWriteLock::unlock	.\ThreadingPthreads.cpp	/^void ReadWriteLock::unlock()$/;"	f	class:WTF::ReadWriteLock	signature:()
WTF::ReadWriteLock::writeLock	.\ThreadingPrimitives.h	/^    void writeLock();$/;"	p	class:WTF::ReadWriteLock	access:public	signature:()
WTF::ReadWriteLock::writeLock	.\ThreadingPthreads.cpp	/^void ReadWriteLock::writeLock()$/;"	f	class:WTF::ReadWriteLock	signature:()
WTF::ReadWriteLock::~ReadWriteLock	.\ThreadingPrimitives.h	/^    ~ReadWriteLock();$/;"	p	class:WTF::ReadWriteLock	access:public	signature:()
WTF::ReadWriteLock::~ReadWriteLock	.\ThreadingPthreads.cpp	/^ReadWriteLock::~ReadWriteLock()$/;"	f	class:WTF::ReadWriteLock	signature:()
WTF::RecordOverflow	.\CheckedArithmetic.h	/^class RecordOverflow {$/;"	c	namespace:WTF
WTF::RecordOverflow::RecordOverflow	.\CheckedArithmetic.h	/^    RecordOverflow()$/;"	f	class:WTF::RecordOverflow	access:protected	signature:()
WTF::RecordOverflow::clearOverflow	.\CheckedArithmetic.h	/^    void clearOverflow()$/;"	f	class:WTF::RecordOverflow	access:protected	signature:()
WTF::RecordOverflow::hasOverflowed	.\CheckedArithmetic.h	/^    bool hasOverflowed() const { return m_overflowed; }$/;"	f	class:WTF::RecordOverflow	access:public	signature:() const
WTF::RecordOverflow::m_overflowed	.\CheckedArithmetic.h	/^    unsigned char m_overflowed;$/;"	m	class:WTF::RecordOverflow	access:private
WTF::RecordOverflow::overflowed	.\CheckedArithmetic.h	/^    void overflowed()$/;"	f	class:WTF::RecordOverflow	access:protected	signature:()
WTF::RedBlackTree	.\RedBlackTree.h	/^class RedBlackTree {$/;"	c	namespace:WTF
WTF::RedBlackTree::Black	.\RedBlackTree.h	/^        Black$/;"	e	enum:WTF::RedBlackTree::Color
WTF::RedBlackTree::Color	.\RedBlackTree.h	/^    enum Color {$/;"	g	class:WTF::RedBlackTree	access:private
WTF::RedBlackTree::Node	.\RedBlackTree.h	/^    class Node {$/;"	c	class:WTF::RedBlackTree	access:public
WTF::RedBlackTree::Node::color	.\RedBlackTree.h	/^        Color color() const$/;"	f	class:WTF::RedBlackTree::Node	access:private	signature:() const
WTF::RedBlackTree::Node::left	.\RedBlackTree.h	/^        NodeType* left() const$/;"	f	class:WTF::RedBlackTree::Node	access:private	signature:() const
WTF::RedBlackTree::Node::m_left	.\RedBlackTree.h	/^        NodeType* m_left;$/;"	m	class:WTF::RedBlackTree::Node	access:private
WTF::RedBlackTree::Node::m_parentAndRed	.\RedBlackTree.h	/^        uintptr_t m_parentAndRed;$/;"	m	class:WTF::RedBlackTree::Node	access:private
WTF::RedBlackTree::Node::m_right	.\RedBlackTree.h	/^        NodeType* m_right;$/;"	m	class:WTF::RedBlackTree::Node	access:private
WTF::RedBlackTree::Node::parent	.\RedBlackTree.h	/^        NodeType* parent() const$/;"	f	class:WTF::RedBlackTree::Node	access:private	signature:() const
WTF::RedBlackTree::Node::predecessor	.\RedBlackTree.h	/^        NodeType* predecessor()$/;"	f	class:WTF::RedBlackTree::Node	access:public	signature:()
WTF::RedBlackTree::Node::predecessor	.\RedBlackTree.h	/^        const NodeType* predecessor() const$/;"	f	class:WTF::RedBlackTree::Node	access:public	signature:() const
WTF::RedBlackTree::Node::reset	.\RedBlackTree.h	/^        void reset()$/;"	f	class:WTF::RedBlackTree::Node	access:private	signature:()
WTF::RedBlackTree::Node::right	.\RedBlackTree.h	/^        NodeType* right() const$/;"	f	class:WTF::RedBlackTree::Node	access:private	signature:() const
WTF::RedBlackTree::Node::setColor	.\RedBlackTree.h	/^        void setColor(Color value)$/;"	f	class:WTF::RedBlackTree::Node	access:private	signature:(Color value)
WTF::RedBlackTree::Node::setLeft	.\RedBlackTree.h	/^        void setLeft(NodeType* node)$/;"	f	class:WTF::RedBlackTree::Node	access:private	signature:(NodeType* node)
WTF::RedBlackTree::Node::setParent	.\RedBlackTree.h	/^        void setParent(NodeType* newParent)$/;"	f	class:WTF::RedBlackTree::Node	access:private	signature:(NodeType* newParent)
WTF::RedBlackTree::Node::setRight	.\RedBlackTree.h	/^        void setRight(NodeType* node)$/;"	f	class:WTF::RedBlackTree::Node	access:private	signature:(NodeType* node)
WTF::RedBlackTree::Node::successor	.\RedBlackTree.h	/^        NodeType* successor()$/;"	f	class:WTF::RedBlackTree::Node	access:public	signature:()
WTF::RedBlackTree::Node::successor	.\RedBlackTree.h	/^        const NodeType* successor() const$/;"	f	class:WTF::RedBlackTree::Node	access:public	signature:() const
WTF::RedBlackTree::Red	.\RedBlackTree.h	/^        Red = 1,$/;"	e	enum:WTF::RedBlackTree::Color
WTF::RedBlackTree::RedBlackTree	.\RedBlackTree.h	/^    RedBlackTree()$/;"	f	class:WTF::RedBlackTree	access:public	signature:()
WTF::RedBlackTree::WTF_MAKE_NONCOPYABLE	.\RedBlackTree.h	/^    WTF_MAKE_NONCOPYABLE(RedBlackTree);$/;"	p	class:WTF::RedBlackTree	access:private	signature:(RedBlackTree)
WTF::RedBlackTree::findExact	.\RedBlackTree.h	/^    NodeType* findExact(const KeyType& key) const$/;"	f	class:WTF::RedBlackTree	access:public	signature:(const KeyType& key) const
WTF::RedBlackTree::findGreatestLessThanOrEqual	.\RedBlackTree.h	/^    NodeType* findGreatestLessThanOrEqual(const KeyType& key) const$/;"	f	class:WTF::RedBlackTree	access:public	signature:(const KeyType& key) const
WTF::RedBlackTree::findLeastGreaterThanOrEqual	.\RedBlackTree.h	/^    NodeType* findLeastGreaterThanOrEqual(const KeyType& key) const$/;"	f	class:WTF::RedBlackTree	access:public	signature:(const KeyType& key) const
WTF::RedBlackTree::first	.\RedBlackTree.h	/^    NodeType* first() const$/;"	f	class:WTF::RedBlackTree	access:public	signature:() const
WTF::RedBlackTree::insert	.\RedBlackTree.h	/^    void insert(NodeType* x)$/;"	f	class:WTF::RedBlackTree	access:public	signature:(NodeType* x)
WTF::RedBlackTree::isEmpty	.\RedBlackTree.h	/^    bool isEmpty()$/;"	f	class:WTF::RedBlackTree	access:public	signature:()
WTF::RedBlackTree::last	.\RedBlackTree.h	/^    NodeType* last() const$/;"	f	class:WTF::RedBlackTree	access:public	signature:() const
WTF::RedBlackTree::leftRotate	.\RedBlackTree.h	/^    NodeType* leftRotate(NodeType* x)$/;"	f	class:WTF::RedBlackTree	access:private	signature:(NodeType* x)
WTF::RedBlackTree::m_root	.\RedBlackTree.h	/^    NodeType* m_root;$/;"	m	class:WTF::RedBlackTree	access:private
WTF::RedBlackTree::remove	.\RedBlackTree.h	/^    NodeType* remove(NodeType* z)$/;"	f	class:WTF::RedBlackTree	access:public	signature:(NodeType* z)
WTF::RedBlackTree::remove	.\RedBlackTree.h	/^    NodeType* remove(const KeyType& key)$/;"	f	class:WTF::RedBlackTree	access:public	signature:(const KeyType& key)
WTF::RedBlackTree::removeFixup	.\RedBlackTree.h	/^    void removeFixup(NodeType* x, NodeType* xParent)$/;"	f	class:WTF::RedBlackTree	access:private	signature:(NodeType* x, NodeType* xParent)
WTF::RedBlackTree::rightRotate	.\RedBlackTree.h	/^    NodeType* rightRotate(NodeType* y)$/;"	f	class:WTF::RedBlackTree	access:private	signature:(NodeType* y)
WTF::RedBlackTree::size	.\RedBlackTree.h	/^    size_t size()$/;"	f	class:WTF::RedBlackTree	access:public	signature:()
WTF::RedBlackTree::treeInsert	.\RedBlackTree.h	/^    void treeInsert(NodeType* z)$/;"	f	class:WTF::RedBlackTree	access:private	signature:(NodeType* z)
WTF::RedBlackTree::treeMaximum	.\RedBlackTree.h	/^    static NodeType* treeMaximum(NodeType* x)$/;"	f	class:WTF::RedBlackTree	access:private	signature:(NodeType* x)
WTF::RedBlackTree::treeMaximum	.\RedBlackTree.h	/^    static const NodeType* treeMaximum(const NodeType* x)$/;"	f	class:WTF::RedBlackTree	access:private	signature:(const NodeType* x)
WTF::RedBlackTree::treeMinimum	.\RedBlackTree.h	/^    static NodeType* treeMinimum(NodeType* x)$/;"	f	class:WTF::RedBlackTree	access:private	signature:(NodeType* x)
WTF::RedBlackTree::treeMinimum	.\RedBlackTree.h	/^    static const NodeType* treeMinimum(const NodeType* x)$/;"	f	class:WTF::RedBlackTree	access:private	signature:(const NodeType* x)
WTF::RefAndDeref	.\Functional.h	/^template<typename T, bool shouldRefAndDeref> struct RefAndDeref {$/;"	s	namespace:WTF
WTF::RefAndDeref	.\Functional.h	/^template<typename T> struct RefAndDeref<T*, true> {$/;"	s	namespace:WTF
WTF::RefAndDeref::deref	.\Functional.h	/^    static void deref(T) { }$/;"	f	struct:WTF::RefAndDeref	access:public	signature:(T)
WTF::RefAndDeref::deref	.\Functional.h	/^    static void deref(T* t) { t->deref(); }$/;"	f	struct:WTF::RefAndDeref	access:public	signature:(T* t)
WTF::RefAndDeref::ref	.\Functional.h	/^    static void ref(T) { }$/;"	f	struct:WTF::RefAndDeref	access:public	signature:(T)
WTF::RefAndDeref::ref	.\Functional.h	/^    static void ref(T* t) { t->ref(); }$/;"	f	struct:WTF::RefAndDeref	access:public	signature:(T* t)
WTF::RefCounted	.\RefCounted.h	/^template<typename T> class RefCounted : public RefCountedBase {$/;"	c	namespace:WTF	inherits:RefCountedBase
WTF::RefCounted::RefCounted	.\RefCounted.h	/^    RefCounted() { }$/;"	f	class:WTF::RefCounted	access:protected	signature:()
WTF::RefCounted::WTF_MAKE_FAST_ALLOCATED	.\RefCounted.h	/^    WTF_MAKE_NONCOPYABLE(RefCounted); WTF_MAKE_FAST_ALLOCATED;$/;"	m	class:WTF::RefCounted	access:private
WTF::RefCounted::WTF_MAKE_NONCOPYABLE	.\RefCounted.h	/^    WTF_MAKE_NONCOPYABLE(RefCounted); WTF_MAKE_FAST_ALLOCATED;$/;"	p	class:WTF::RefCounted	access:private	signature:(RefCounted)
WTF::RefCounted::deref	.\RefCounted.h	/^    void deref()$/;"	f	class:WTF::RefCounted	access:public	signature:()
WTF::RefCounted::~RefCounted	.\RefCounted.h	/^    ~RefCounted()$/;"	f	class:WTF::RefCounted	access:protected	signature:()
WTF::RefCountedArray	.\RefCountedArray.h	/^class RefCountedArray {$/;"	c	namespace:WTF
WTF::RefCountedArray::Header	.\RefCountedArray.h	/^    struct Header {$/;"	s	class:WTF::RefCountedArray	access:private
WTF::RefCountedArray::Header::fromPayload	.\RefCountedArray.h	/^        static Header* fromPayload(T* payload)$/;"	f	struct:WTF::RefCountedArray::Header	access:public	signature:(T* payload)
WTF::RefCountedArray::Header::length	.\RefCountedArray.h	/^        unsigned length;$/;"	m	struct:WTF::RefCountedArray::Header	access:public
WTF::RefCountedArray::Header::payload	.\RefCountedArray.h	/^        T* payload()$/;"	f	struct:WTF::RefCountedArray::Header	access:public	signature:()
WTF::RefCountedArray::Header::refCount	.\RefCountedArray.h	/^        unsigned refCount;$/;"	m	struct:WTF::RefCountedArray::Header	access:public
WTF::RefCountedArray::Header::size	.\RefCountedArray.h	/^        static size_t size()$/;"	f	struct:WTF::RefCountedArray::Header	access:public	signature:()
WTF::RefCountedArray::RefCountedArray	.\RefCountedArray.h	/^    RefCountedArray()$/;"	f	class:WTF::RefCountedArray	access:public	signature:()
WTF::RefCountedArray::RefCountedArray	.\RefCountedArray.h	/^    RefCountedArray(const RefCountedArray& other)$/;"	f	class:WTF::RefCountedArray	access:public	signature:(const RefCountedArray& other)
WTF::RefCountedArray::RefCountedArray	.\RefCountedArray.h	/^    explicit RefCountedArray(const Vector<T>& other)$/;"	f	class:WTF::RefCountedArray	access:public	signature:(const Vector<T>& other)
WTF::RefCountedArray::at	.\RefCountedArray.h	/^    T& at(size_t i)$/;"	f	class:WTF::RefCountedArray	access:public	signature:(size_t i)
WTF::RefCountedArray::at	.\RefCountedArray.h	/^    const T& at(size_t i) const$/;"	f	class:WTF::RefCountedArray	access:public	signature:(size_t i) const
WTF::RefCountedArray::begin	.\RefCountedArray.h	/^    T* begin() { return m_data; }$/;"	f	class:WTF::RefCountedArray	access:public	signature:()
WTF::RefCountedArray::begin	.\RefCountedArray.h	/^    const T* begin() const { return m_data; }$/;"	f	class:WTF::RefCountedArray	access:public	signature:() const
WTF::RefCountedArray::data	.\RefCountedArray.h	/^    T* data() { return m_data; }$/;"	f	class:WTF::RefCountedArray	access:public	signature:()
WTF::RefCountedArray::data	.\RefCountedArray.h	/^    const T* data() const { return m_data; }$/;"	f	class:WTF::RefCountedArray	access:public	signature:() const
WTF::RefCountedArray::end	.\RefCountedArray.h	/^    T* end()$/;"	f	class:WTF::RefCountedArray	access:public	signature:()
WTF::RefCountedArray::end	.\RefCountedArray.h	/^    const T* end() const { return const_cast<RefCountedArray*>(this)->end(); }$/;"	f	class:WTF::RefCountedArray	access:public	signature:() const
WTF::RefCountedArray::m_data	.\RefCountedArray.h	/^    T* m_data;$/;"	m	class:WTF::RefCountedArray	access:private
WTF::RefCountedArray::operator =	.\RefCountedArray.h	/^    RefCountedArray& operator=(const RefCountedArray& other)$/;"	f	class:WTF::RefCountedArray	access:public	signature:(const RefCountedArray& other)
WTF::RefCountedArray::operator []	.\RefCountedArray.h	/^    T& operator[](size_t i) { return at(i); }$/;"	f	class:WTF::RefCountedArray	access:public	signature:(size_t i)
WTF::RefCountedArray::operator []	.\RefCountedArray.h	/^    const T& operator[](size_t i) const { return at(i); }$/;"	f	class:WTF::RefCountedArray	access:public	signature:(size_t i) const
WTF::RefCountedArray::size	.\RefCountedArray.h	/^    size_t size() const$/;"	f	class:WTF::RefCountedArray	access:public	signature:() const
WTF::RefCountedArray::~RefCountedArray	.\RefCountedArray.h	/^    ~RefCountedArray()$/;"	f	class:WTF::RefCountedArray	access:public	signature:()
WTF::RefCountedBase	.\RefCounted.h	/^class RefCountedBase {$/;"	c	namespace:WTF
WTF::RefCountedBase::RefCountedBase	.\RefCounted.h	/^    RefCountedBase()$/;"	f	class:WTF::RefCountedBase	access:protected	signature:()
WTF::RefCountedBase::addressOfCount	.\RefCounted.h	/^    const int* addressOfCount() const$/;"	f	class:WTF::RefCountedBase	access:public	signature:() const
WTF::RefCountedBase::adopted	.\RefCounted.h	/^    friend void adopted(RefCountedBase*);$/;"	p	class:WTF::RefCountedBase	access:friend	signature:(RefCountedBase*)
WTF::RefCountedBase::deletionHasBegun	.\RefCounted.h	/^    bool deletionHasBegun() const$/;"	f	class:WTF::RefCountedBase	access:protected	signature:() const
WTF::RefCountedBase::derefBase	.\RefCounted.h	/^    bool derefBase()$/;"	f	class:WTF::RefCountedBase	access:protected	signature:()
WTF::RefCountedBase::hasOneRef	.\RefCounted.h	/^    bool hasOneRef() const$/;"	f	class:WTF::RefCountedBase	access:public	signature:() const
WTF::RefCountedBase::m_adoptionIsRequired	.\RefCounted.h	/^    bool m_adoptionIsRequired;$/;"	m	class:WTF::RefCountedBase	access:private
WTF::RefCountedBase::m_deletionHasBegun	.\RefCounted.h	/^    bool m_deletionHasBegun;$/;"	m	class:WTF::RefCountedBase	access:private
WTF::RefCountedBase::m_refCount	.\RefCounted.h	/^    int m_refCount;$/;"	m	class:WTF::RefCountedBase	access:private
WTF::RefCountedBase::m_verifier	.\RefCounted.h	/^    ThreadRestrictionVerifier m_verifier;$/;"	m	class:WTF::RefCountedBase	access:private
WTF::RefCountedBase::ref	.\RefCounted.h	/^    void ref()$/;"	f	class:WTF::RefCountedBase	access:public	signature:()
WTF::RefCountedBase::refCount	.\RefCounted.h	/^    int refCount() const$/;"	f	class:WTF::RefCountedBase	access:public	signature:() const
WTF::RefCountedBase::relaxAdoptionRequirement	.\RefCounted.h	/^    void relaxAdoptionRequirement()$/;"	f	class:WTF::RefCountedBase	access:public	signature:()
WTF::RefCountedBase::setDispatchQueueForVerifier	.\RefCounted.h	/^    void setDispatchQueueForVerifier(dispatch_queue_t);$/;"	p	class:WTF::RefCountedBase	access:public	signature:(dispatch_queue_t)
WTF::RefCountedBase::setDispatchQueueForVerifier	.\RefCounted.h	/^inline void RefCountedBase::setDispatchQueueForVerifier(dispatch_queue_t queue)$/;"	f	class:WTF::RefCountedBase	signature:(dispatch_queue_t queue)
WTF::RefCountedBase::setDispatchQueueForVerifier	.\RefCounted.h	/^inline void RefCountedBase::setDispatchQueueForVerifier(dispatch_queue_t) { }$/;"	f	class:WTF::RefCountedBase	signature:(dispatch_queue_t)
WTF::RefCountedBase::setMutexForVerifier	.\RefCounted.h	/^    void setMutexForVerifier(Mutex&);$/;"	p	class:WTF::RefCountedBase	access:public	signature:(Mutex&)
WTF::RefCountedBase::setMutexForVerifier	.\RefCounted.h	/^inline void RefCountedBase::setMutexForVerifier(Mutex& mutex)$/;"	f	class:WTF::RefCountedBase	signature:(Mutex& mutex)
WTF::RefCountedBase::setMutexForVerifier	.\RefCounted.h	/^inline void RefCountedBase::setMutexForVerifier(Mutex&) { }$/;"	f	class:WTF::RefCountedBase	signature:(Mutex&)
WTF::RefCountedBase::turnOffVerifier	.\RefCounted.h	/^    void turnOffVerifier()$/;"	f	class:WTF::RefCountedBase	access:public	signature:()
WTF::RefCountedBase::~RefCountedBase	.\RefCounted.h	/^    ~RefCountedBase()$/;"	f	class:WTF::RefCountedBase	access:protected	signature:()
WTF::RefCountedCustomAllocated	.\RefCounted.h	/^template<typename T> class RefCountedCustomAllocated : public RefCountedBase {$/;"	c	namespace:WTF	inherits:RefCountedBase
WTF::RefCountedCustomAllocated::WTF_MAKE_NONCOPYABLE	.\RefCounted.h	/^    WTF_MAKE_NONCOPYABLE(RefCountedCustomAllocated);$/;"	p	class:WTF::RefCountedCustomAllocated	access:private	signature:(RefCountedCustomAllocated)
WTF::RefCountedCustomAllocated::deref	.\RefCounted.h	/^    void deref()$/;"	f	class:WTF::RefCountedCustomAllocated	access:public	signature:()
WTF::RefCountedCustomAllocated::~RefCountedCustomAllocated	.\RefCounted.h	/^    ~RefCountedCustomAllocated()$/;"	f	class:WTF::RefCountedCustomAllocated	access:protected	signature:()
WTF::RefCountedCustomAllocated_should_stay_small	.\SizeLimits.cpp	/^COMPILE_ASSERT(sizeof(RefCountedCustomAllocated<int>) == sizeof(SameSizeAsRefCounted), RefCountedCustomAllocated_should_stay_small);$/;"	v
WTF::RefCountedLeakCounter	.\RefCountedLeakCounter.h	/^    struct RefCountedLeakCounter {$/;"	s	namespace:WTF
WTF::RefCountedLeakCounter::RefCountedLeakCounter	.\RefCountedLeakCounter.cpp	/^RefCountedLeakCounter::RefCountedLeakCounter(const char*) { }$/;"	f	class:WTF::RefCountedLeakCounter	signature:(const char*)
WTF::RefCountedLeakCounter::RefCountedLeakCounter	.\RefCountedLeakCounter.h	/^        WTF_EXPORT_PRIVATE explicit RefCountedLeakCounter(const char* description);$/;"	p	struct:WTF::RefCountedLeakCounter	access:public	signature:(const char* description)
WTF::RefCountedLeakCounter::cancelMessageSuppression	.\RefCountedLeakCounter.cpp	/^void RefCountedLeakCounter::cancelMessageSuppression(const char*) { }$/;"	f	class:WTF::RefCountedLeakCounter	signature:(const char*)
WTF::RefCountedLeakCounter::cancelMessageSuppression	.\RefCountedLeakCounter.h	/^        WTF_EXPORT_PRIVATE static void cancelMessageSuppression(const char*);$/;"	p	struct:WTF::RefCountedLeakCounter	access:public	signature:(const char*)
WTF::RefCountedLeakCounter::decrement	.\RefCountedLeakCounter.cpp	/^void RefCountedLeakCounter::decrement() { }$/;"	f	class:WTF::RefCountedLeakCounter	signature:()
WTF::RefCountedLeakCounter::decrement	.\RefCountedLeakCounter.h	/^        WTF_EXPORT_PRIVATE void decrement();$/;"	p	struct:WTF::RefCountedLeakCounter	access:public	signature:()
WTF::RefCountedLeakCounter::increment	.\RefCountedLeakCounter.cpp	/^void RefCountedLeakCounter::increment() { }$/;"	f	class:WTF::RefCountedLeakCounter	signature:()
WTF::RefCountedLeakCounter::increment	.\RefCountedLeakCounter.h	/^        WTF_EXPORT_PRIVATE void increment();$/;"	p	struct:WTF::RefCountedLeakCounter	access:public	signature:()
WTF::RefCountedLeakCounter::m_count	.\RefCountedLeakCounter.h	/^        int m_count;$/;"	m	struct:WTF::RefCountedLeakCounter	access:private
WTF::RefCountedLeakCounter::m_count	.\RefCountedLeakCounter.h	/^        volatile int m_count;$/;"	m	struct:WTF::RefCountedLeakCounter	access:private
WTF::RefCountedLeakCounter::m_description	.\RefCountedLeakCounter.h	/^        const char* m_description;$/;"	m	struct:WTF::RefCountedLeakCounter	access:private
WTF::RefCountedLeakCounter::suppressMessages	.\RefCountedLeakCounter.cpp	/^void RefCountedLeakCounter::suppressMessages(const char*) { }$/;"	f	class:WTF::RefCountedLeakCounter	signature:(const char*)
WTF::RefCountedLeakCounter::suppressMessages	.\RefCountedLeakCounter.h	/^        WTF_EXPORT_PRIVATE static void suppressMessages(const char*);$/;"	p	struct:WTF::RefCountedLeakCounter	access:public	signature:(const char*)
WTF::RefCountedLeakCounter::~RefCountedLeakCounter	.\RefCountedLeakCounter.cpp	/^RefCountedLeakCounter::~RefCountedLeakCounter() { }$/;"	f	class:WTF::RefCountedLeakCounter	signature:()
WTF::RefCountedLeakCounter::~RefCountedLeakCounter	.\RefCountedLeakCounter.h	/^        WTF_EXPORT_PRIVATE ~RefCountedLeakCounter();$/;"	p	struct:WTF::RefCountedLeakCounter	access:public	signature:()
WTF::RefCounted_should_stay_small	.\SizeLimits.cpp	/^COMPILE_ASSERT(sizeof(RefCounted<int>) == sizeof(SameSizeAsRefCounted), RefCounted_should_stay_small);$/;"	v
WTF::RefPtr	.\RefPtr.h	/^    template<typename T> class RefPtr {$/;"	c	namespace:WTF
WTF::RefPtr::RefPtr	.\RefPtr.h	/^        ALWAYS_INLINE RefPtr() : m_ptr(0) { }$/;"	f	class:WTF::RefPtr	access:public	signature:()
WTF::RefPtr::RefPtr	.\RefPtr.h	/^        ALWAYS_INLINE RefPtr(PlacementNewAdoptType) { }$/;"	f	class:WTF::RefPtr	access:public	signature:(PlacementNewAdoptType)
WTF::RefPtr::RefPtr	.\RefPtr.h	/^        ALWAYS_INLINE RefPtr(T* ptr) : m_ptr(ptr) { refIfNotNull(ptr); }$/;"	f	class:WTF::RefPtr	access:public	signature:(T* ptr)
WTF::RefPtr::RefPtr	.\RefPtr.h	/^        ALWAYS_INLINE RefPtr(const RefPtr& o) : m_ptr(o.m_ptr) { refIfNotNull(m_ptr); }$/;"	f	class:WTF::RefPtr	access:public	signature:(const RefPtr& o)
WTF::RefPtr::RefPtr	.\RefPtr.h	/^        RefPtr(HashTableDeletedValueType) : m_ptr(hashTableDeletedValue()) { }$/;"	f	class:WTF::RefPtr	access:public	signature:(HashTableDeletedValueType)
WTF::RefPtr::RefPtr	.\RefPtr.h	/^        template<typename U> RefPtr(const NonNullPassRefPtr<U>&);$/;"	p	class:WTF::RefPtr	access:public	signature:(const NonNullPassRefPtr<U>&)
WTF::RefPtr::RefPtr	.\RefPtr.h	/^        template<typename U> RefPtr(const PassRefPtr<U>&);$/;"	p	class:WTF::RefPtr	access:public	signature:(const PassRefPtr<U>&)
WTF::RefPtr::RefPtr	.\RefPtr.h	/^        template<typename U> RefPtr(const RefPtr<U>& o) : m_ptr(o.get()) { refIfNotNull(m_ptr); }$/;"	f	class:WTF::RefPtr	access:public	signature:(const RefPtr<U>& o)
WTF::RefPtr::RefPtr	.\RefPtr.h	/^    template<typename T> template<typename U> inline RefPtr<T>::RefPtr(const NonNullPassRefPtr<U>& o)$/;"	f	class:WTF::RefPtr	signature:(const NonNullPassRefPtr<U>& o)
WTF::RefPtr::RefPtr	.\RefPtr.h	/^    template<typename T> template<typename U> inline RefPtr<T>::RefPtr(const PassRefPtr<U>& o)$/;"	f	class:WTF::RefPtr	signature:(const PassRefPtr<U>& o)
WTF::RefPtr::UnspecifiedBoolType	.\RefPtr.h	/^        typedef T* (RefPtr::*UnspecifiedBoolType);$/;"	t	class:WTF::RefPtr	access:public
WTF::RefPtr::WTF_MAKE_FAST_ALLOCATED	.\RefPtr.h	/^        WTF_MAKE_FAST_ALLOCATED;$/;"	m	class:WTF::RefPtr	access:private
WTF::RefPtr::clear	.\RefPtr.h	/^        void clear();$/;"	p	class:WTF::RefPtr	access:public	signature:()
WTF::RefPtr::clear	.\RefPtr.h	/^    template<typename T> inline void RefPtr<T>::clear()$/;"	f	class:WTF::RefPtr	signature:()
WTF::RefPtr::get	.\RefPtr.h	/^        T* get() const { return m_ptr; }$/;"	f	class:WTF::RefPtr	access:public	signature:() const
WTF::RefPtr::hashTableDeletedValue	.\RefPtr.h	/^        static T* hashTableDeletedValue() { return reinterpret_cast<T*>(-1); }$/;"	f	class:WTF::RefPtr	access:public	signature:()
WTF::RefPtr::isHashTableDeletedValue	.\RefPtr.h	/^        bool isHashTableDeletedValue() const { return m_ptr == hashTableDeletedValue(); }$/;"	f	class:WTF::RefPtr	access:public	signature:() const
WTF::RefPtr::m_ptr	.\RefPtr.h	/^        T* m_ptr;$/;"	m	class:WTF::RefPtr	access:private
WTF::RefPtr::operator !	.\RefPtr.h	/^        bool operator!() const { return !m_ptr; }$/;"	f	class:WTF::RefPtr	access:public	signature:() const
WTF::RefPtr::operator *	.\RefPtr.h	/^        T& operator*() const { return *m_ptr; }$/;"	f	class:WTF::RefPtr	access:public	signature:() const
WTF::RefPtr::operator ->	.\RefPtr.h	/^        ALWAYS_INLINE T* operator->() const { return m_ptr; }$/;"	f	class:WTF::RefPtr	access:public	signature:() const
WTF::RefPtr::operator =	.\RefPtr.h	/^        RefPtr& operator=(T*);$/;"	p	class:WTF::RefPtr	access:public	signature:(T*)
WTF::RefPtr::operator =	.\RefPtr.h	/^        RefPtr& operator=(const NonNullPassRefPtr<T>&);$/;"	p	class:WTF::RefPtr	access:public	signature:(const NonNullPassRefPtr<T>&)
WTF::RefPtr::operator =	.\RefPtr.h	/^        RefPtr& operator=(const PassRefPtr<T>&);$/;"	p	class:WTF::RefPtr	access:public	signature:(const PassRefPtr<T>&)
WTF::RefPtr::operator =	.\RefPtr.h	/^        RefPtr& operator=(const RefPtr&);$/;"	p	class:WTF::RefPtr	access:public	signature:(const RefPtr&)
WTF::RefPtr::operator =	.\RefPtr.h	/^        RefPtr& operator=(std::nullptr_t) { clear(); return *this; }$/;"	f	class:WTF::RefPtr	access:public	signature:(std::nullptr_t)
WTF::RefPtr::operator =	.\RefPtr.h	/^        template<typename U> RefPtr& operator=(const NonNullPassRefPtr<U>&);$/;"	p	class:WTF::RefPtr	access:public	signature:(const NonNullPassRefPtr<U>&)
WTF::RefPtr::operator =	.\RefPtr.h	/^        template<typename U> RefPtr& operator=(const PassRefPtr<U>&);$/;"	p	class:WTF::RefPtr	access:public	signature:(const PassRefPtr<U>&)
WTF::RefPtr::operator =	.\RefPtr.h	/^        template<typename U> RefPtr& operator=(const RefPtr<U>&);$/;"	p	class:WTF::RefPtr	access:public	signature:(const RefPtr<U>&)
WTF::RefPtr::operator =	.\RefPtr.h	/^    template<typename T> inline RefPtr<T>& RefPtr<T>::operator=(T* optr)$/;"	f	class:WTF::RefPtr	signature:(T* optr)
WTF::RefPtr::operator =	.\RefPtr.h	/^    template<typename T> inline RefPtr<T>& RefPtr<T>::operator=(const NonNullPassRefPtr<T>& o)$/;"	f	class:WTF::RefPtr	signature:(const NonNullPassRefPtr<T>& o)
WTF::RefPtr::operator =	.\RefPtr.h	/^    template<typename T> inline RefPtr<T>& RefPtr<T>::operator=(const PassRefPtr<T>& o)$/;"	f	class:WTF::RefPtr	signature:(const PassRefPtr<T>& o)
WTF::RefPtr::operator =	.\RefPtr.h	/^    template<typename T> inline RefPtr<T>& RefPtr<T>::operator=(const RefPtr<T>& o)$/;"	f	class:WTF::RefPtr	signature:(const RefPtr<T>& o)
WTF::RefPtr::operator =	.\RefPtr.h	/^    template<typename T> template<typename U> inline RefPtr<T>& RefPtr<T>::operator=(const NonNullPassRefPtr<U>& o)$/;"	f	class:WTF::RefPtr	signature:(const NonNullPassRefPtr<U>& o)
WTF::RefPtr::operator =	.\RefPtr.h	/^    template<typename T> template<typename U> inline RefPtr<T>& RefPtr<T>::operator=(const PassRefPtr<U>& o)$/;"	f	class:WTF::RefPtr	signature:(const PassRefPtr<U>& o)
WTF::RefPtr::operator =	.\RefPtr.h	/^    template<typename T> template<typename U> inline RefPtr<T>& RefPtr<T>::operator=(const RefPtr<U>& o)$/;"	f	class:WTF::RefPtr	signature:(const RefPtr<U>& o)
WTF::RefPtr::operator UnspecifiedBoolType	.\RefPtr.h	/^        operator UnspecifiedBoolType() const { return m_ptr ? &RefPtr::m_ptr : 0; }$/;"	f	class:WTF::RefPtr	access:public	signature:() const
WTF::RefPtr::release	.\RefPtr.h	/^        PassRefPtr<T> release() { PassRefPtr<T> tmp = adoptRef(m_ptr); m_ptr = 0; return tmp; }$/;"	f	class:WTF::RefPtr	access:public	signature:()
WTF::RefPtr::swap	.\RefPtr.h	/^        void swap(RefPtr&);$/;"	p	class:WTF::RefPtr	access:public	signature:(RefPtr&)
WTF::RefPtr::swap	.\RefPtr.h	/^    template<class T> inline void RefPtr<T>::swap(RefPtr<T>& o)$/;"	f	class:WTF::RefPtr	signature:(RefPtr<T>& o)
WTF::RefPtr::~RefPtr	.\RefPtr.h	/^        ALWAYS_INLINE ~RefPtr() { derefIfNotNull(m_ptr); }$/;"	f	class:WTF::RefPtr	access:public	signature:()
WTF::RefPtr_should_stay_small	.\SizeLimits.cpp	/^COMPILE_ASSERT(sizeof(RefPtr<RefCounted<int> >) == sizeof(int*), RefPtr_should_stay_small);$/;"	v
WTF::ReferenceTypeMaker	.\HashMap.h	/^    template<typename T> struct ReferenceTypeMaker {$/;"	s	namespace:WTF
WTF::ReferenceTypeMaker	.\HashMap.h	/^    template<typename T> struct ReferenceTypeMaker<T&> {$/;"	s	namespace:WTF
WTF::ReferenceTypeMaker::ReferenceType	.\HashMap.h	/^        typedef T& ReferenceType;$/;"	t	struct:WTF::ReferenceTypeMaker	access:public
WTF::RemoteMemoryReader	.\MallocZoneSupport.h	/^class RemoteMemoryReader {$/;"	c	namespace:WTF
WTF::RemoteMemoryReader::RemoteMemoryReader	.\MallocZoneSupport.h	/^    RemoteMemoryReader(task_t task, memory_reader_t* reader)$/;"	f	class:WTF::RemoteMemoryReader	access:public	signature:(task_t task, memory_reader_t* reader)
WTF::RemoteMemoryReader::m_reader	.\MallocZoneSupport.h	/^    memory_reader_t* m_reader;$/;"	m	class:WTF::RemoteMemoryReader	access:private
WTF::RemoteMemoryReader::m_task	.\MallocZoneSupport.h	/^    task_t m_task;$/;"	m	class:WTF::RemoteMemoryReader	access:private
WTF::RemoteMemoryReader::nextEntryInLinkedList	.\MallocZoneSupport.h	/^    T* nextEntryInLinkedList(T** address) const$/;"	f	class:WTF::RemoteMemoryReader	access:public	signature:(T** address) const
WTF::RemoteMemoryReader::operator ()	.\MallocZoneSupport.h	/^    T* operator()(T* address, size_t size=sizeof(T)) const$/;"	f	class:WTF::RemoteMemoryReader	access:public	signature:(T* address, size_t size=sizeof(T)) const
WTF::RemoteMemoryReader::operator ()	.\MallocZoneSupport.h	/^    void* operator()(vm_address_t address, size_t size) const$/;"	f	class:WTF::RemoteMemoryReader	access:public	signature:(vm_address_t address, size_t size) const
WTF::RemoveChecked	.\CheckedArithmetic.h	/^template <typename T> struct RemoveChecked {$/;"	s	namespace:WTF
WTF::RemoveChecked	.\CheckedArithmetic.h	/^template <typename T> struct RemoveChecked<Checked<T, CrashOnOverflow> > {$/;"	s	namespace:WTF
WTF::RemoveChecked	.\CheckedArithmetic.h	/^template <typename T> struct RemoveChecked<Checked<T, RecordOverflow> > {$/;"	s	namespace:WTF
WTF::RemoveChecked::CleanType	.\CheckedArithmetic.h	/^    typedef T CleanType;$/;"	t	struct:WTF::RemoveChecked	access:public
WTF::RemoveChecked::CleanType	.\CheckedArithmetic.h	/^    typedef typename RemoveChecked<T>::CleanType CleanType;$/;"	t	struct:WTF::RemoveChecked	access:public
WTF::RemoveChecked::DefaultValue	.\CheckedArithmetic.h	/^    static const CleanType DefaultValue = 0;    $/;"	m	struct:WTF::RemoveChecked	access:public
WTF::RemoveChecked::DefaultValue	.\CheckedArithmetic.h	/^    static const CleanType DefaultValue = 0;$/;"	m	struct:WTF::RemoveChecked	access:public
WTF::RemoveConst	.\TypeTraits.h	/^    template <typename T> struct RemoveConst {$/;"	s	namespace:WTF
WTF::RemoveConst	.\TypeTraits.h	/^    template <typename T> struct RemoveConst<const T> {$/;"	s	namespace:WTF
WTF::RemoveConst::Type	.\TypeTraits.h	/^        typedef T Type;$/;"	t	struct:WTF::RemoveConst	access:public
WTF::RemoveConstVolatile	.\TypeTraits.h	/^    template <typename T> struct RemoveConstVolatile {$/;"	s	namespace:WTF
WTF::RemoveConstVolatile::Type	.\TypeTraits.h	/^        typedef typename RemoveVolatile<typename RemoveConst<T>::Type>::Type Type;$/;"	t	struct:WTF::RemoveConstVolatile	access:public
WTF::RemoveExtent	.\TypeTraits.h	/^    template <typename T, size_t N> struct RemoveExtent<T[N]> {$/;"	s	namespace:WTF
WTF::RemoveExtent	.\TypeTraits.h	/^    template <typename T> struct RemoveExtent {$/;"	s	namespace:WTF
WTF::RemoveExtent	.\TypeTraits.h	/^    template <typename T> struct RemoveExtent<T[]> {$/;"	s	namespace:WTF
WTF::RemoveExtent::Type	.\TypeTraits.h	/^        typedef T Type;$/;"	t	struct:WTF::RemoveExtent	access:public
WTF::RemovePointer	.\TypeTraits.h	/^    template <typename T> struct RemovePointer {$/;"	s	namespace:WTF
WTF::RemovePointer	.\TypeTraits.h	/^    template <typename T> struct RemovePointer<T*> {$/;"	s	namespace:WTF
WTF::RemovePointer::Type	.\TypeTraits.h	/^        typedef T Type;$/;"	t	struct:WTF::RemovePointer	access:public
WTF::RemoveReference	.\TypeTraits.h	/^    template <typename T> struct RemoveReference {$/;"	s	namespace:WTF
WTF::RemoveReference	.\TypeTraits.h	/^    template <typename T> struct RemoveReference<T&> {$/;"	s	namespace:WTF
WTF::RemoveReference::Type	.\TypeTraits.h	/^        typedef T Type;$/;"	t	struct:WTF::RemoveReference	access:public
WTF::RemoveTemplate	.\TypeTraits.h	/^    template <typename T, template <class V> class OuterTemplate> struct RemoveTemplate {$/;"	s	namespace:WTF
WTF::RemoveTemplate	.\TypeTraits.h	/^    template <typename T, template <class V> class OuterTemplate> struct RemoveTemplate<OuterTemplate<T>, OuterTemplate> {$/;"	s	namespace:WTF
WTF::RemoveTemplate::Type	.\TypeTraits.h	/^        typedef T Type;$/;"	t	struct:WTF::RemoveTemplate	access:public
WTF::RemoveVolatile	.\TypeTraits.h	/^    template <typename T> struct RemoveVolatile {$/;"	s	namespace:WTF
WTF::RemoveVolatile	.\TypeTraits.h	/^    template <typename T> struct RemoveVolatile<volatile T> {$/;"	s	namespace:WTF
WTF::RemoveVolatile::Type	.\TypeTraits.h	/^        typedef T Type;$/;"	t	struct:WTF::RemoveVolatile	access:public
WTF::Result	.\CheckedArithmetic.h	/^template <typename U, typename V> struct Result : ResultBase<typename RemoveChecked<U>::CleanType, typename RemoveChecked<V>::CleanType> {$/;"	s	namespace:WTF	inherits:ResultBase
WTF::ResultBase	.\CheckedArithmetic.h	/^template <typename U, typename V> struct ResultBase<U, V, false, false> {$/;"	s	namespace:WTF
WTF::ResultBase	.\CheckedArithmetic.h	/^template <typename U, typename V> struct ResultBase<U, V, false, true> {$/;"	s	namespace:WTF
WTF::ResultBase	.\CheckedArithmetic.h	/^template <typename U, typename V> struct ResultBase<U, V, true, false> {$/;"	s	namespace:WTF
WTF::ResultBase	.\CheckedArithmetic.h	/^template <typename U> struct ResultBase<U, U, false, true> {$/;"	s	namespace:WTF
WTF::ResultBase::ResultType	.\CheckedArithmetic.h	/^    typedef U ResultType;$/;"	t	struct:WTF::ResultBase	access:public
WTF::ResultBase::ResultType	.\CheckedArithmetic.h	/^    typedef V ResultType;$/;"	t	struct:WTF::ResultBase	access:public
WTF::ResultBase::ResultType	.\CheckedArithmetic.h	/^    typedef typename SignednessSelector<U, V>::ResultType ResultType;$/;"	t	struct:WTF::ResultBase	access:public
WTF::ResultOverflowed	.\CheckedArithmetic.h	/^enum ResultOverflowedTag { ResultOverflowed };$/;"	e	enum:WTF::ResultOverflowedTag
WTF::ResultOverflowedTag	.\CheckedArithmetic.h	/^enum ResultOverflowedTag { ResultOverflowed };$/;"	g	namespace:WTF
WTF::RetainPtr	.\RetainPtr.h	/^    template<typename T> class RetainPtr {$/;"	c	namespace:WTF
WTF::RetainPtr::PtrType	.\RetainPtr.h	/^        typedef ValueType* PtrType;$/;"	t	class:WTF::RetainPtr	access:public
WTF::RetainPtr::RetainPtr	.\RetainPtr.h	/^        RetainPtr() : m_ptr(0) {}$/;"	f	class:WTF::RetainPtr	access:public	signature:()
WTF::RetainPtr::RetainPtr	.\RetainPtr.h	/^        RetainPtr(AdoptCFTag, PtrType ptr) : m_ptr(ptr) { }$/;"	f	class:WTF::RetainPtr	access:public	signature:(AdoptCFTag, PtrType ptr)
WTF::RetainPtr::RetainPtr	.\RetainPtr.h	/^        RetainPtr(AdoptNSTag, PtrType ptr) : m_ptr(ptr) { adoptNSReference(ptr); }$/;"	f	class:WTF::RetainPtr	access:public	signature:(AdoptNSTag, PtrType ptr)
WTF::RetainPtr::RetainPtr	.\RetainPtr.h	/^        RetainPtr(HashTableDeletedValueType) : m_ptr(hashTableDeletedValue()) { }$/;"	f	class:WTF::RetainPtr	access:public	signature:(HashTableDeletedValueType)
WTF::RetainPtr::RetainPtr	.\RetainPtr.h	/^        RetainPtr(PtrType ptr) : m_ptr(ptr) { if (ptr) CFRetain(ptr); }$/;"	f	class:WTF::RetainPtr	access:public	signature:(PtrType ptr)
WTF::RetainPtr::RetainPtr	.\RetainPtr.h	/^        RetainPtr(RetainPtr&& o) : m_ptr(o.leakRef()) { }$/;"	f	class:WTF::RetainPtr	access:public	signature:(RetainPtr&& o)
WTF::RetainPtr::RetainPtr	.\RetainPtr.h	/^        RetainPtr(const RetainPtr& o) : m_ptr(o.m_ptr) { if (PtrType ptr = m_ptr) CFRetain(ptr); }$/;"	f	class:WTF::RetainPtr	access:public	signature:(const RetainPtr& o)
WTF::RetainPtr::RetainPtr	.\RetainPtr.h	/^        template<typename U> RetainPtr(const RetainPtr<U>&);$/;"	p	class:WTF::RetainPtr	access:public	signature:(const RetainPtr<U>&)
WTF::RetainPtr::RetainPtr	.\RetainPtr.h	/^    template<typename T> template<typename U> inline RetainPtr<T>::RetainPtr(const RetainPtr<U>& o)$/;"	f	class:WTF::RetainPtr	signature:(const RetainPtr<U>& o)
WTF::RetainPtr::RetainPtr::UnspecifiedBoolType	.\RetainPtr.h	/^        typedef PtrType RetainPtr::*UnspecifiedBoolType;$/;"	t	class:WTF::RetainPtr::RetainPtr	access:public
WTF::RetainPtr::ValueType	.\RetainPtr.h	/^        typedef typename RemovePointer<T>::Type ValueType;$/;"	t	class:WTF::RetainPtr	access:public
WTF::RetainPtr::WARN_UNUSED_RETURN	.\RetainPtr.h	/^        PtrType leakRef() WARN_UNUSED_RETURN;$/;"	m	class:WTF::RetainPtr	access:public
WTF::RetainPtr::adoptCF	.\RetainPtr.h	/^        void adoptCF(PtrType);$/;"	p	class:WTF::RetainPtr	access:public	signature:(PtrType)
WTF::RetainPtr::adoptCF	.\RetainPtr.h	/^    template<typename T> inline void RetainPtr<T>::adoptCF(PtrType optr)$/;"	f	class:WTF::RetainPtr	signature:(PtrType optr)
WTF::RetainPtr::adoptNS	.\RetainPtr.h	/^        void adoptNS(PtrType);$/;"	p	class:WTF::RetainPtr	access:public	signature:(PtrType)
WTF::RetainPtr::adoptNS	.\RetainPtr.h	/^    template<typename T> inline void RetainPtr<T>::adoptNS(PtrType optr)$/;"	f	class:WTF::RetainPtr	signature:(PtrType optr)
WTF::RetainPtr::clear	.\RetainPtr.h	/^        void clear();$/;"	p	class:WTF::RetainPtr	access:public	signature:()
WTF::RetainPtr::clear	.\RetainPtr.h	/^    template<typename T> inline void RetainPtr<T>::clear()$/;"	f	class:WTF::RetainPtr	signature:()
WTF::RetainPtr::get	.\RetainPtr.h	/^        PtrType get() const { return m_ptr; }$/;"	f	class:WTF::RetainPtr	access:public	signature:() const
WTF::RetainPtr::hashTableDeletedValue	.\RetainPtr.h	/^        static PtrType hashTableDeletedValue() { return reinterpret_cast<PtrType>(-1); }$/;"	f	class:WTF::RetainPtr	access:private	signature:()
WTF::RetainPtr::isHashTableDeletedValue	.\RetainPtr.h	/^        bool isHashTableDeletedValue() const { return m_ptr == hashTableDeletedValue(); }$/;"	f	class:WTF::RetainPtr	access:public	signature:() const
WTF::RetainPtr::leakRef	.\RetainPtr.h	/^    template<typename T> inline typename RetainPtr<T>::PtrType RetainPtr<T>::leakRef()$/;"	f	class:WTF::RetainPtr	signature:()
WTF::RetainPtr::m_ptr	.\RetainPtr.h	/^        PtrType m_ptr;$/;"	m	class:WTF::RetainPtr	access:private
WTF::RetainPtr::operator !	.\RetainPtr.h	/^        bool operator!() const { return !m_ptr; }$/;"	f	class:WTF::RetainPtr	access:public	signature:() const
WTF::RetainPtr::operator ->	.\RetainPtr.h	/^        PtrType operator->() const { return m_ptr; }$/;"	f	class:WTF::RetainPtr	access:public	signature:() const
WTF::RetainPtr::operator =	.\RetainPtr.h	/^        RetainPtr& operator=(PtrType);$/;"	p	class:WTF::RetainPtr	access:public	signature:(PtrType)
WTF::RetainPtr::operator =	.\RetainPtr.h	/^        RetainPtr& operator=(RetainPtr&&);$/;"	p	class:WTF::RetainPtr	access:public	signature:(RetainPtr&&)
WTF::RetainPtr::operator =	.\RetainPtr.h	/^        RetainPtr& operator=(const RetainPtr&);$/;"	p	class:WTF::RetainPtr	access:public	signature:(const RetainPtr&)
WTF::RetainPtr::operator =	.\RetainPtr.h	/^        RetainPtr& operator=(std::nullptr_t) { clear(); return *this; }$/;"	f	class:WTF::RetainPtr	access:public	signature:(std::nullptr_t)
WTF::RetainPtr::operator =	.\RetainPtr.h	/^        template<typename U> RetainPtr& operator=(RetainPtr<U>&&);$/;"	p	class:WTF::RetainPtr	access:public	signature:(RetainPtr<U>&&)
WTF::RetainPtr::operator =	.\RetainPtr.h	/^        template<typename U> RetainPtr& operator=(U*);$/;"	p	class:WTF::RetainPtr	access:public	signature:(U*)
WTF::RetainPtr::operator =	.\RetainPtr.h	/^        template<typename U> RetainPtr& operator=(const RetainPtr<U>&);$/;"	p	class:WTF::RetainPtr	access:public	signature:(const RetainPtr<U>&)
WTF::RetainPtr::operator =	.\RetainPtr.h	/^    template<typename T> inline RetainPtr<T>& RetainPtr<T>::operator=(PtrType optr)$/;"	f	class:WTF::RetainPtr	signature:(PtrType optr)
WTF::RetainPtr::operator =	.\RetainPtr.h	/^    template<typename T> inline RetainPtr<T>& RetainPtr<T>::operator=(RetainPtr<T>&& o)$/;"	f	class:WTF::RetainPtr	signature:(RetainPtr<T>&& o)
WTF::RetainPtr::operator =	.\RetainPtr.h	/^    template<typename T> inline RetainPtr<T>& RetainPtr<T>::operator=(const RetainPtr<T>& o)$/;"	f	class:WTF::RetainPtr	signature:(const RetainPtr<T>& o)
WTF::RetainPtr::operator =	.\RetainPtr.h	/^    template<typename T> template<typename U> inline RetainPtr<T>& RetainPtr<T>::operator=(RetainPtr<U>&& o)$/;"	f	class:WTF::RetainPtr	signature:(RetainPtr<U>&& o)
WTF::RetainPtr::operator =	.\RetainPtr.h	/^    template<typename T> template<typename U> inline RetainPtr<T>& RetainPtr<T>::operator=(U* optr)$/;"	f	class:WTF::RetainPtr	signature:(U* optr)
WTF::RetainPtr::operator =	.\RetainPtr.h	/^    template<typename T> template<typename U> inline RetainPtr<T>& RetainPtr<T>::operator=(const RetainPtr<U>& o)$/;"	f	class:WTF::RetainPtr	signature:(const RetainPtr<U>& o)
WTF::RetainPtr::operator UnspecifiedBoolType	.\RetainPtr.h	/^        operator UnspecifiedBoolType() const { return m_ptr ? &RetainPtr::m_ptr : 0; }$/;"	f	class:WTF::RetainPtr	access:public	signature:() const
WTF::RetainPtr::swap	.\RetainPtr.h	/^        void swap(RetainPtr&);$/;"	p	class:WTF::RetainPtr	access:public	signature:(RetainPtr&)
WTF::RetainPtr::swap	.\RetainPtr.h	/^    template<typename T> inline void RetainPtr<T>::swap(RetainPtr<T>& o)$/;"	f	class:WTF::RetainPtr	signature:(RetainPtr<T>& o)
WTF::RetainPtr::~RetainPtr	.\RetainPtr.h	/^        ~RetainPtr() { if (PtrType ptr = m_ptr) CFRelease(ptr); }$/;"	f	class:WTF::RetainPtr	access:public	signature:()
WTF::RoundingDecimalPlaces	.\DecimalNumber.h	/^enum RoundingDecimalPlacesType { RoundingDecimalPlaces };$/;"	e	enum:WTF::RoundingDecimalPlacesType
WTF::RoundingDecimalPlacesType	.\DecimalNumber.h	/^enum RoundingDecimalPlacesType { RoundingDecimalPlaces };$/;"	g	namespace:WTF
WTF::RoundingSignificantFigures	.\DecimalNumber.h	/^enum RoundingSignificantFiguresType { RoundingSignificantFigures };$/;"	e	enum:WTF::RoundingSignificantFiguresType
WTF::RoundingSignificantFiguresType	.\DecimalNumber.h	/^enum RoundingSignificantFiguresType { RoundingSignificantFigures };$/;"	g	namespace:WTF
WTF::SHA1	.\SHA1.h	/^class SHA1 {$/;"	c	namespace:WTF
WTF::SHA1::SHA1	.\SHA1.cpp	/^SHA1::SHA1()$/;"	f	class:WTF::SHA1	signature:()
WTF::SHA1::SHA1	.\SHA1.h	/^    WTF_EXPORT_PRIVATE SHA1();$/;"	p	class:WTF::SHA1	access:public	signature:()
WTF::SHA1::addBytes	.\SHA1.cpp	/^void SHA1::addBytes(const uint8_t* input, size_t length)$/;"	f	class:WTF::SHA1	signature:(const uint8_t* input, size_t length)
WTF::SHA1::addBytes	.\SHA1.h	/^    WTF_EXPORT_PRIVATE void addBytes(const uint8_t* input, size_t length);$/;"	p	class:WTF::SHA1	access:public	signature:(const uint8_t* input, size_t length)
WTF::SHA1::addBytes	.\SHA1.h	/^    void addBytes(const Vector<uint8_t>& input)$/;"	f	class:WTF::SHA1	access:public	signature:(const Vector<uint8_t>& input)
WTF::SHA1::computeHash	.\SHA1.cpp	/^void SHA1::computeHash(Vector<uint8_t, 20>& digest)$/;"	f	class:WTF::SHA1	signature:(Vector<uint8_t, 20>& digest)
WTF::SHA1::computeHash	.\SHA1.h	/^    WTF_EXPORT_PRIVATE void computeHash(Vector<uint8_t, 20>&);$/;"	p	class:WTF::SHA1	access:public	signature:(Vector<uint8_t, 20>&)
WTF::SHA1::finalize	.\SHA1.cpp	/^void SHA1::finalize()$/;"	f	class:WTF::SHA1	signature:()
WTF::SHA1::finalize	.\SHA1.h	/^    void finalize();$/;"	p	class:WTF::SHA1	access:private	signature:()
WTF::SHA1::m_buffer	.\SHA1.h	/^    uint8_t m_buffer[64];$/;"	m	class:WTF::SHA1	access:private
WTF::SHA1::m_cursor	.\SHA1.h	/^    size_t m_cursor; \/\/ Number of bytes filled in m_buffer (0-64).$/;"	m	class:WTF::SHA1	access:private
WTF::SHA1::m_hash	.\SHA1.h	/^    uint32_t m_hash[5];$/;"	m	class:WTF::SHA1	access:private
WTF::SHA1::m_totalBytes	.\SHA1.h	/^    uint64_t m_totalBytes; \/\/ Number of bytes added so far.$/;"	m	class:WTF::SHA1	access:private
WTF::SHA1::processBlock	.\SHA1.cpp	/^void SHA1::processBlock()$/;"	f	class:WTF::SHA1	signature:()
WTF::SHA1::processBlock	.\SHA1.h	/^    void processBlock();$/;"	p	class:WTF::SHA1	access:private	signature:()
WTF::SHA1::reset	.\SHA1.cpp	/^void SHA1::reset()$/;"	f	class:WTF::SHA1	signature:()
WTF::SHA1::reset	.\SHA1.h	/^    void reset();$/;"	p	class:WTF::SHA1	access:private	signature:()
WTF::SLL_Next	.\FastMalloc.cpp	/^static inline void *SLL_Next(void *t) {$/;"	f	namespace:WTF	file:	signature:(void *t)
WTF::SLL_Pop	.\FastMalloc.cpp	/^static inline void *SLL_Pop(void **list) {$/;"	f	namespace:WTF	file:	signature:(void **list)
WTF::SLL_PopRange	.\FastMalloc.cpp	/^static inline void SLL_PopRange(void **head, int N, void **start, void **end) {$/;"	f	namespace:WTF	file:	signature:(void **head, int N, void **start, void **end)
WTF::SLL_Push	.\FastMalloc.cpp	/^static inline void SLL_Push(void **list, void *element) {$/;"	f	namespace:WTF	file:	signature:(void **list, void *element)
WTF::SLL_PushRange	.\FastMalloc.cpp	/^static inline void SLL_PushRange(void **head, void *start, void *end) {$/;"	f	namespace:WTF	file:	signature:(void **head, void *start, void *end)
WTF::SLL_SetNext	.\FastMalloc.cpp	/^static inline void SLL_SetNext(void *t, void *n) {$/;"	f	namespace:WTF	file:	signature:(void *t, void *n)
WTF::SLL_Size	.\FastMalloc.cpp	/^static inline size_t SLL_Size(void *head) {$/;"	f	namespace:WTF	file:	signature:(void *head)
WTF::SameSizeAsRefCounted	.\SizeLimits.cpp	/^struct SameSizeAsRefCounted {$/;"	s	namespace:WTF	file:
WTF::SameSizeAsRefCounted::a	.\SizeLimits.cpp	/^    int a;$/;"	m	struct:WTF::SameSizeAsRefCounted	file:	access:public
WTF::SameSizeAsRefCounted::b	.\SizeLimits.cpp	/^    bool b;$/;"	m	struct:WTF::SameSizeAsRefCounted	file:	access:public
WTF::SameSizeAsRefCounted::c	.\SizeLimits.cpp	/^    bool c;$/;"	m	struct:WTF::SameSizeAsRefCounted	file:	access:public
WTF::SameSizeAsRefCounted::d	.\SizeLimits.cpp	/^    ThreadRestrictionVerifier d;$/;"	m	struct:WTF::SameSizeAsRefCounted	file:	access:public
WTF::SegmentedVector	.\SegmentedVector.h	/^    template <typename T, size_t SegmentSize> class SegmentedVector {$/;"	c	namespace:WTF
WTF::SegmentedVector::Iterator	.\SegmentedVector.h	/^        typedef SegmentedVectorIterator<T, SegmentSize> Iterator;$/;"	t	class:WTF::SegmentedVector	access:public
WTF::SegmentedVector::Segment	.\SegmentedVector.h	/^        typedef Vector<T, SegmentSize> Segment;$/;"	t	class:WTF::SegmentedVector	access:private
WTF::SegmentedVector::SegmentedVector	.\SegmentedVector.h	/^        SegmentedVector()$/;"	f	class:WTF::SegmentedVector	access:public	signature:()
WTF::SegmentedVector::alloc	.\SegmentedVector.h	/^        T& alloc()$/;"	f	class:WTF::SegmentedVector	access:public	signature:()
WTF::SegmentedVector::append	.\SegmentedVector.h	/^        template <typename U> void append(const U& value)$/;"	f	class:WTF::SegmentedVector	access:public	signature:(const U& value)
WTF::SegmentedVector::at	.\SegmentedVector.h	/^        T& at(size_t index)$/;"	f	class:WTF::SegmentedVector	access:public	signature:(size_t index)
WTF::SegmentedVector::begin	.\SegmentedVector.h	/^        Iterator begin()$/;"	f	class:WTF::SegmentedVector	access:public	signature:()
WTF::SegmentedVector::clear	.\SegmentedVector.h	/^        void clear()$/;"	f	class:WTF::SegmentedVector	access:public	signature:()
WTF::SegmentedVector::deleteAllSegments	.\SegmentedVector.h	/^        void deleteAllSegments()$/;"	f	class:WTF::SegmentedVector	access:private	signature:()
WTF::SegmentedVector::end	.\SegmentedVector.h	/^        Iterator end()$/;"	f	class:WTF::SegmentedVector	access:public	signature:()
WTF::SegmentedVector::ensureSegment	.\SegmentedVector.h	/^        void ensureSegment(size_t segmentIndex, size_t size)$/;"	f	class:WTF::SegmentedVector	access:private	signature:(size_t segmentIndex, size_t size)
WTF::SegmentedVector::ensureSegmentsFor	.\SegmentedVector.h	/^        void ensureSegmentsFor(size_t size)$/;"	f	class:WTF::SegmentedVector	access:private	signature:(size_t size)
WTF::SegmentedVector::grow	.\SegmentedVector.h	/^        void grow(size_t size)$/;"	f	class:WTF::SegmentedVector	access:public	signature:(size_t size)
WTF::SegmentedVector::isEmpty	.\SegmentedVector.h	/^        bool isEmpty() const { return !size(); }$/;"	f	class:WTF::SegmentedVector	access:public	signature:() const
WTF::SegmentedVector::last	.\SegmentedVector.h	/^        T& last()$/;"	f	class:WTF::SegmentedVector	access:public	signature:()
WTF::SegmentedVector::m_inlineSegment	.\SegmentedVector.h	/^        Segment m_inlineSegment;$/;"	m	class:WTF::SegmentedVector	access:private
WTF::SegmentedVector::m_segments	.\SegmentedVector.h	/^        Vector<Segment*, 32> m_segments;$/;"	m	class:WTF::SegmentedVector	access:private
WTF::SegmentedVector::m_size	.\SegmentedVector.h	/^        size_t m_size;$/;"	m	class:WTF::SegmentedVector	access:private
WTF::SegmentedVector::operator []	.\SegmentedVector.h	/^        T& operator[](size_t index)$/;"	f	class:WTF::SegmentedVector	access:public	signature:(size_t index)
WTF::SegmentedVector::removeLast	.\SegmentedVector.h	/^        void removeLast()$/;"	f	class:WTF::SegmentedVector	access:public	signature:()
WTF::SegmentedVector::segmentExistsFor	.\SegmentedVector.h	/^        bool segmentExistsFor(size_t index)$/;"	f	class:WTF::SegmentedVector	access:private	signature:(size_t index)
WTF::SegmentedVector::segmentFor	.\SegmentedVector.h	/^        Segment* segmentFor(size_t index)$/;"	f	class:WTF::SegmentedVector	access:private	signature:(size_t index)
WTF::SegmentedVector::size	.\SegmentedVector.h	/^        size_t size() const { return m_size; }$/;"	f	class:WTF::SegmentedVector	access:public	signature:() const
WTF::SegmentedVector::subscriptFor	.\SegmentedVector.h	/^        size_t subscriptFor(size_t index)$/;"	f	class:WTF::SegmentedVector	access:private	signature:(size_t index)
WTF::SegmentedVector::~SegmentedVector	.\SegmentedVector.h	/^        ~SegmentedVector()$/;"	f	class:WTF::SegmentedVector	access:public	signature:()
WTF::SegmentedVectorIterator	.\SegmentedVector.h	/^    template <typename T, size_t SegmentSize> class SegmentedVectorIterator {$/;"	c	namespace:WTF
WTF::SegmentedVectorIterator::Iterator	.\SegmentedVector.h	/^        typedef SegmentedVectorIterator<T, SegmentSize> Iterator;$/;"	t	class:WTF::SegmentedVectorIterator	access:public
WTF::SegmentedVectorIterator::SegmentedVectorIterator	.\SegmentedVector.h	/^        SegmentedVectorIterator(SegmentedVector<T, SegmentSize>& vector, size_t segment, size_t index)$/;"	f	class:WTF::SegmentedVectorIterator	access:private	signature:(SegmentedVector<T, SegmentSize>& vector, size_t segment, size_t index)
WTF::SegmentedVectorIterator::m_index	.\SegmentedVector.h	/^        size_t m_index;$/;"	m	class:WTF::SegmentedVectorIterator	access:private
WTF::SegmentedVectorIterator::m_segment	.\SegmentedVector.h	/^        size_t m_segment;$/;"	m	class:WTF::SegmentedVectorIterator	access:private
WTF::SegmentedVectorIterator::m_vector	.\SegmentedVector.h	/^        SegmentedVector<T, SegmentSize>& m_vector;$/;"	m	class:WTF::SegmentedVectorIterator	access:private
WTF::SegmentedVectorIterator::operator !=	.\SegmentedVector.h	/^        bool operator!=(const Iterator& other) const$/;"	f	class:WTF::SegmentedVectorIterator	access:public	signature:(const Iterator& other) const
WTF::SegmentedVectorIterator::operator *	.\SegmentedVector.h	/^        T& operator*() const { return m_vector.m_segments.at(m_segment)->at(m_index); }$/;"	f	class:WTF::SegmentedVectorIterator	access:public	signature:() const
WTF::SegmentedVectorIterator::operator ++	.\SegmentedVector.h	/^        Iterator& operator++()$/;"	f	class:WTF::SegmentedVectorIterator	access:public	signature:()
WTF::SegmentedVectorIterator::operator ->	.\SegmentedVector.h	/^        T* operator->() const { return &m_vector.m_segments.at(m_segment)->at(m_index); }$/;"	f	class:WTF::SegmentedVectorIterator	access:public	signature:() const
WTF::SegmentedVectorIterator::operator =	.\SegmentedVector.h	/^        SegmentedVectorIterator& operator=(const SegmentedVectorIterator<T, SegmentSize>& other)$/;"	f	class:WTF::SegmentedVectorIterator	access:public	signature:(const SegmentedVectorIterator<T, SegmentSize>& other)
WTF::SegmentedVectorIterator::operator ==	.\SegmentedVector.h	/^        bool operator==(const Iterator& other) const$/;"	f	class:WTF::SegmentedVectorIterator	access:public	signature:(const Iterator& other) const
WTF::SegmentedVectorIterator::~SegmentedVectorIterator	.\SegmentedVector.h	/^        ~SegmentedVectorIterator() { }$/;"	f	class:WTF::SegmentedVectorIterator	access:public	signature:()
WTF::Sentinel	.\SentinelLinkedList.h	/^enum SentinelTag { Sentinel };$/;"	e	enum:WTF::SentinelTag
WTF::SentinelLinkedList	.\SentinelLinkedList.h	/^template <typename T, typename RawNode = T> class SentinelLinkedList {$/;"	c	namespace:WTF
WTF::SentinelLinkedList::SentinelLinkedList	.\SentinelLinkedList.h	/^    SentinelLinkedList();$/;"	p	class:WTF::SentinelLinkedList	access:public	signature:()
WTF::SentinelLinkedList::SentinelLinkedList	.\SentinelLinkedList.h	/^template <typename T, typename RawNode> inline SentinelLinkedList<T, RawNode>::SentinelLinkedList()$/;"	f	class:WTF::SentinelLinkedList	signature:()
WTF::SentinelLinkedList::begin	.\SentinelLinkedList.h	/^    iterator begin();$/;"	p	class:WTF::SentinelLinkedList	access:public	signature:()
WTF::SentinelLinkedList::begin	.\SentinelLinkedList.h	/^template <typename T, typename RawNode> inline typename SentinelLinkedList<T, RawNode>::iterator SentinelLinkedList<T, RawNode>::begin()$/;"	f	class:WTF::SentinelLinkedList	signature:()
WTF::SentinelLinkedList::end	.\SentinelLinkedList.h	/^    iterator end();$/;"	p	class:WTF::SentinelLinkedList	access:public	signature:()
WTF::SentinelLinkedList::end	.\SentinelLinkedList.h	/^template <typename T, typename RawNode> inline typename SentinelLinkedList<T, RawNode>::iterator SentinelLinkedList<T, RawNode>::end()$/;"	f	class:WTF::SentinelLinkedList	signature:()
WTF::SentinelLinkedList::isEmpty	.\SentinelLinkedList.h	/^    bool isEmpty() { return begin() == end(); }$/;"	f	class:WTF::SentinelLinkedList	access:public	signature:()
WTF::SentinelLinkedList::iterator	.\SentinelLinkedList.h	/^    typedef T* iterator;$/;"	t	class:WTF::SentinelLinkedList	access:public
WTF::SentinelLinkedList::m_headSentinel	.\SentinelLinkedList.h	/^    RawNode m_headSentinel;$/;"	m	class:WTF::SentinelLinkedList	access:private
WTF::SentinelLinkedList::m_tailSentinel	.\SentinelLinkedList.h	/^    RawNode m_tailSentinel;$/;"	m	class:WTF::SentinelLinkedList	access:private
WTF::SentinelLinkedList::push	.\SentinelLinkedList.h	/^    void push(T*);$/;"	p	class:WTF::SentinelLinkedList	access:public	signature:(T*)
WTF::SentinelLinkedList::push	.\SentinelLinkedList.h	/^template <typename T, typename RawNode> inline void SentinelLinkedList<T, RawNode>::push(T* node)$/;"	f	class:WTF::SentinelLinkedList	signature:(T* node)
WTF::SentinelLinkedList::remove	.\SentinelLinkedList.h	/^    static void remove(T*);$/;"	p	class:WTF::SentinelLinkedList	access:public	signature:(T*)
WTF::SentinelLinkedList::remove	.\SentinelLinkedList.h	/^template <typename T, typename RawNode> inline void SentinelLinkedList<T, RawNode>::remove(T* node)$/;"	f	class:WTF::SentinelLinkedList	signature:(T* node)
WTF::SentinelTag	.\SentinelLinkedList.h	/^enum SentinelTag { Sentinel };$/;"	g	namespace:WTF
WTF::ShouldRoundDecimalPlaces	.\text\WTFString.h	/^    ShouldRoundDecimalPlaces = 1 << 1,$/;"	e	enum:WTF::FloatConversionFlags
WTF::ShouldRoundSignificantFigures	.\text\WTFString.h	/^    ShouldRoundSignificantFigures = 1 << 0,$/;"	e	enum:WTF::FloatConversionFlags
WTF::ShouldTruncateTrailingZeros	.\text\WTFString.h	/^    ShouldTruncateTrailingZeros = 1 << 2$/;"	e	enum:WTF::FloatConversionFlags
WTF::SignednessSelector	.\CheckedArithmetic.h	/^template <typename U, typename V> struct SignednessSelector<U, V, false, false> {$/;"	s	namespace:WTF
WTF::SignednessSelector	.\CheckedArithmetic.h	/^template <typename U, typename V> struct SignednessSelector<U, V, false, true> {$/;"	s	namespace:WTF
WTF::SignednessSelector	.\CheckedArithmetic.h	/^template <typename U, typename V> struct SignednessSelector<U, V, true, false> {$/;"	s	namespace:WTF
WTF::SignednessSelector	.\CheckedArithmetic.h	/^template <typename U, typename V> struct SignednessSelector<U, V, true, true> {$/;"	s	namespace:WTF
WTF::SignednessSelector::ResultType	.\CheckedArithmetic.h	/^    typedef U ResultType;$/;"	t	struct:WTF::SignednessSelector	access:public
WTF::SignednessSelector::ResultType	.\CheckedArithmetic.h	/^    typedef V ResultType;$/;"	t	struct:WTF::SignednessSelector	access:public
WTF::SimpleClassHashTraits	.\HashTraits.h	/^    template<typename T> struct SimpleClassHashTraits : GenericHashTraits<T> {$/;"	s	namespace:WTF	inherits:GenericHashTraits
WTF::SimpleClassHashTraits::constructDeletedValue	.\HashTraits.h	/^        static void constructDeletedValue(T& slot) { new (NotNull, &slot) T(HashTableDeletedValue); }$/;"	f	struct:WTF::SimpleClassHashTraits	access:public	signature:(T& slot)
WTF::SimpleClassHashTraits::emptyValueIsZero	.\HashTraits.h	/^        static const bool emptyValueIsZero = true;$/;"	m	struct:WTF::SimpleClassHashTraits	access:public
WTF::SimpleClassHashTraits::isDeletedValue	.\HashTraits.h	/^        static bool isDeletedValue(const T& value) { return value.isHashTableDeletedValue(); }$/;"	f	struct:WTF::SimpleClassHashTraits	access:public	signature:(const T& value)
WTF::SimpleClassVectorTraits	.\VectorTraits.h	/^    struct SimpleClassVectorTraits : VectorTraitsBase<false, void>$/;"	s	namespace:WTF	inherits:VectorTraitsBase
WTF::SimpleClassVectorTraits::canCompareWithMemcmp	.\VectorTraits.h	/^        static const bool canCompareWithMemcmp = true;$/;"	m	struct:WTF::SimpleClassVectorTraits	access:public
WTF::SimpleClassVectorTraits::canInitializeWithMemset	.\VectorTraits.h	/^        static const bool canInitializeWithMemset = true;$/;"	m	struct:WTF::SimpleClassVectorTraits	access:public
WTF::SimpleClassVectorTraits::canMoveWithMemcpy	.\VectorTraits.h	/^        static const bool canMoveWithMemcpy = true;$/;"	m	struct:WTF::SimpleClassVectorTraits	access:public
WTF::SimpleStats	.\SimpleStats.h	/^class SimpleStats {$/;"	c	namespace:WTF
WTF::SimpleStats::SimpleStats	.\SimpleStats.h	/^    SimpleStats()$/;"	f	class:WTF::SimpleStats	access:public	signature:()
WTF::SimpleStats::add	.\SimpleStats.h	/^    void add(double value)$/;"	f	class:WTF::SimpleStats	access:public	signature:(double value)
WTF::SimpleStats::count	.\SimpleStats.h	/^    double count() const$/;"	f	class:WTF::SimpleStats	access:public	signature:() const
WTF::SimpleStats::m_count	.\SimpleStats.h	/^    double m_count;$/;"	m	class:WTF::SimpleStats	access:private
WTF::SimpleStats::m_sum	.\SimpleStats.h	/^    double m_sum;$/;"	m	class:WTF::SimpleStats	access:private
WTF::SimpleStats::m_sumOfSquares	.\SimpleStats.h	/^    double m_sumOfSquares;$/;"	m	class:WTF::SimpleStats	access:private
WTF::SimpleStats::mean	.\SimpleStats.h	/^    double mean() const$/;"	f	class:WTF::SimpleStats	access:public	signature:() const
WTF::SimpleStats::operator !	.\SimpleStats.h	/^    bool operator!() const$/;"	f	class:WTF::SimpleStats	access:public	signature:() const
WTF::SimpleStats::standardDeviation	.\SimpleStats.h	/^    double standardDeviation() const$/;"	f	class:WTF::SimpleStats	access:public	signature:() const
WTF::SimpleStats::sum	.\SimpleStats.h	/^    double sum() const$/;"	f	class:WTF::SimpleStats	access:public	signature:() const
WTF::SimpleStats::sumOfSquares	.\SimpleStats.h	/^    double sumOfSquares() const$/;"	f	class:WTF::SimpleStats	access:public	signature:() const
WTF::SimpleStats::variance	.\SimpleStats.h	/^    double variance() const$/;"	f	class:WTF::SimpleStats	access:public	signature:() const
WTF::SinglyLinkedList	.\SinglyLinkedList.h	/^template <typename Node> class SinglyLinkedList {$/;"	c	namespace:WTF
WTF::SinglyLinkedList::SinglyLinkedList	.\SinglyLinkedList.h	/^    SinglyLinkedList();$/;"	p	class:WTF::SinglyLinkedList	access:public	signature:()
WTF::SinglyLinkedList::SinglyLinkedList	.\SinglyLinkedList.h	/^template <typename Node> inline SinglyLinkedList<Node>::SinglyLinkedList()$/;"	f	class:WTF::SinglyLinkedList	signature:()
WTF::SinglyLinkedList::isEmpty	.\SinglyLinkedList.h	/^    bool isEmpty();$/;"	p	class:WTF::SinglyLinkedList	access:public	signature:()
WTF::SinglyLinkedList::isEmpty	.\SinglyLinkedList.h	/^template <typename Node> inline bool SinglyLinkedList<Node>::isEmpty()$/;"	f	class:WTF::SinglyLinkedList	signature:()
WTF::SinglyLinkedList::m_head	.\SinglyLinkedList.h	/^    Node* m_head;$/;"	m	class:WTF::SinglyLinkedList	access:private
WTF::SinglyLinkedList::pop	.\SinglyLinkedList.h	/^    Node* pop();$/;"	p	class:WTF::SinglyLinkedList	access:public	signature:()
WTF::SinglyLinkedList::pop	.\SinglyLinkedList.h	/^template <typename Node> inline Node* SinglyLinkedList<Node>::pop()$/;"	f	class:WTF::SinglyLinkedList	signature:()
WTF::SinglyLinkedList::push	.\SinglyLinkedList.h	/^    void push(Node*);$/;"	p	class:WTF::SinglyLinkedList	access:public	signature:(Node*)
WTF::SinglyLinkedList::push	.\SinglyLinkedList.h	/^template <typename Node> inline void SinglyLinkedList<Node>::push(Node* node)$/;"	f	class:WTF::SinglyLinkedList	signature:(Node* node)
WTF::SizeClass	.\FastMalloc.cpp	/^static ALWAYS_INLINE size_t SizeClass(size_t size) {$/;"	f	namespace:WTF	file:	signature:(size_t size)
WTF::SpaceOrNewlinePredicate	.\text\StringImpl.cpp	/^class SpaceOrNewlinePredicate {$/;"	c	namespace:WTF	file:
WTF::SpaceOrNewlinePredicate::operator ()	.\text\StringImpl.cpp	/^    inline bool operator()(UChar ch) const$/;"	f	class:WTF::SpaceOrNewlinePredicate	access:public	signature:(UChar ch) const
WTF::Span	.\FastMalloc.cpp	/^struct Span {$/;"	s	namespace:WTF	file:
WTF::Span::decommitted	.\FastMalloc.cpp	/^  bool decommitted : 1;$/;"	m	struct:WTF::Span	file:	access:public
WTF::Span::free	.\FastMalloc.cpp	/^  unsigned int  free : 1;       \/\/ Is the span free$/;"	m	struct:WTF::Span	file:	access:public
WTF::Span::history	.\FastMalloc.cpp	/^  char history[64];$/;"	m	struct:WTF::Span	file:	access:public
WTF::Span::length	.\FastMalloc.cpp	/^  Length        length;         \/\/ Number of pages in span$/;"	m	struct:WTF::Span	file:	access:public
WTF::Span::next	.\FastMalloc.cpp	/^  Span*         next;           \/\/ Used when in link list$/;"	m	struct:WTF::Span	file:	access:public
WTF::Span::nexthistory	.\FastMalloc.cpp	/^  int nexthistory;$/;"	m	struct:WTF::Span	file:	access:public
WTF::Span::objects	.\FastMalloc.cpp	/^  void*         objects;        \/\/ Linked list of free objects$/;"	m	struct:WTF::Span	file:	access:public
WTF::Span::prev	.\FastMalloc.cpp	/^  Span*         prev;           \/\/ Used when in link list$/;"	m	struct:WTF::Span	file:	access:public
WTF::Span::refcount	.\FastMalloc.cpp	/^  unsigned int  refcount : 11;  \/\/ Number of non-free objects$/;"	m	struct:WTF::Span	file:	access:public
WTF::Span::sample	.\FastMalloc.cpp	/^  unsigned int  sample : 1;     \/\/ Sampled object?$/;"	m	struct:WTF::Span	file:	access:public
WTF::Span::sizeclass	.\FastMalloc.cpp	/^  unsigned int  sizeclass : 8;  \/\/ Size-class for small objects (or 0)$/;"	m	struct:WTF::Span	file:	access:public
WTF::Span::start	.\FastMalloc.cpp	/^  PageID        start;          \/\/ Starting page number$/;"	m	struct:WTF::Span	file:	access:public
WTF::Span::value	.\FastMalloc.cpp	/^  int value[64];$/;"	m	struct:WTF::Span	file:	access:public
WTF::SpanToMallocResult	.\FastMalloc.cpp	/^static inline void* SpanToMallocResult(Span *span) {$/;"	f	namespace:WTF	file:	signature:(Span *span)
WTF::Spectrum	.\Spectrum.h	/^class Spectrum {$/;"	c	namespace:WTF
WTF::Spectrum::KeyAndCount	.\Spectrum.h	/^    struct KeyAndCount {$/;"	s	class:WTF::Spectrum	access:public
WTF::Spectrum::KeyAndCount::KeyAndCount	.\Spectrum.h	/^        KeyAndCount() { }$/;"	f	struct:WTF::Spectrum::KeyAndCount	access:public	signature:()
WTF::Spectrum::KeyAndCount::KeyAndCount	.\Spectrum.h	/^        KeyAndCount(const T& key, unsigned long count)$/;"	f	struct:WTF::Spectrum::KeyAndCount	access:public	signature:(const T& key, unsigned long count)
WTF::Spectrum::KeyAndCount::count	.\Spectrum.h	/^        unsigned long count;$/;"	m	struct:WTF::Spectrum::KeyAndCount	access:public
WTF::Spectrum::KeyAndCount::key	.\Spectrum.h	/^        T key;$/;"	m	struct:WTF::Spectrum::KeyAndCount	access:public
WTF::Spectrum::KeyAndCount::operator <	.\Spectrum.h	/^        bool operator<(const KeyAndCount& other) const$/;"	f	struct:WTF::Spectrum::KeyAndCount	access:public	signature:(const KeyAndCount& other) const
WTF::Spectrum::Spectrum	.\Spectrum.h	/^    Spectrum() { }$/;"	f	class:WTF::Spectrum	access:public	signature:()
WTF::Spectrum::add	.\Spectrum.h	/^    void add(const T& key, unsigned long count = 1)$/;"	f	class:WTF::Spectrum	access:public	signature:(const T& key, unsigned long count = 1)
WTF::Spectrum::begin	.\Spectrum.h	/^    const_iterator begin() const { return m_map.begin(); }$/;"	f	class:WTF::Spectrum	access:public	signature:() const
WTF::Spectrum::begin	.\Spectrum.h	/^    iterator begin() { return m_map.begin(); }$/;"	f	class:WTF::Spectrum	access:public	signature:()
WTF::Spectrum::buildList	.\Spectrum.h	/^    Vector<KeyAndCount> buildList() const$/;"	f	class:WTF::Spectrum	access:public	signature:() const
WTF::Spectrum::const_iterator	.\Spectrum.h	/^    typedef typename HashMap<T, unsigned long>::const_iterator const_iterator;$/;"	t	class:WTF::Spectrum	access:public
WTF::Spectrum::end	.\Spectrum.h	/^    const_iterator end() const { return m_map.end(); }$/;"	f	class:WTF::Spectrum	access:public	signature:() const
WTF::Spectrum::end	.\Spectrum.h	/^    iterator end() { return m_map.end(); }$/;"	f	class:WTF::Spectrum	access:public	signature:()
WTF::Spectrum::get	.\Spectrum.h	/^    unsigned long get(const T& key) const$/;"	f	class:WTF::Spectrum	access:public	signature:(const T& key) const
WTF::Spectrum::iterator	.\Spectrum.h	/^    typedef typename HashMap<T, unsigned long>::iterator iterator;$/;"	t	class:WTF::Spectrum	access:public
WTF::Spectrum::m_map	.\Spectrum.h	/^    HashMap<T, unsigned long> m_map;$/;"	m	class:WTF::Spectrum	access:private
WTF::StackBounds	.\StackBounds.h	/^class StackBounds {$/;"	c	namespace:WTF
WTF::StackBounds::StackBounds	.\StackBounds.h	/^    StackBounds()$/;"	f	class:WTF::StackBounds	access:public	signature:()
WTF::StackBounds::checkConsistency	.\StackBounds.h	/^    void checkConsistency() const$/;"	f	class:WTF::StackBounds	access:private	signature:() const
WTF::StackBounds::current	.\StackBounds.h	/^    void* current() const$/;"	f	class:WTF::StackBounds	access:public	signature:() const
WTF::StackBounds::currentThreadStackBounds	.\StackBounds.h	/^    static StackBounds currentThreadStackBounds()$/;"	f	class:WTF::StackBounds	access:public	signature:()
WTF::StackBounds::initialize	.\StackBounds.cpp	/^void StackBounds::initialize()$/;"	f	class:WTF::StackBounds	signature:()
WTF::StackBounds::initialize	.\StackBounds.h	/^    void initialize();$/;"	p	class:WTF::StackBounds	access:private	signature:()
WTF::StackBounds::isGrowingDownward	.\StackBounds.h	/^    bool isGrowingDownward() const$/;"	f	class:WTF::StackBounds	access:private	signature:() const
WTF::StackBounds::m_bound	.\StackBounds.h	/^    void* m_bound;$/;"	m	class:WTF::StackBounds	access:private
WTF::StackBounds::m_origin	.\StackBounds.h	/^    void* m_origin;$/;"	m	class:WTF::StackBounds	access:private
WTF::StackBounds::origin	.\StackBounds.h	/^    void* origin() const$/;"	f	class:WTF::StackBounds	access:public	signature:() const
WTF::StackBounds::recursionCheck	.\StackBounds.h	/^    bool recursionCheck(size_t minAvailableDelta = s_defaultAvailabilityDelta) const$/;"	f	class:WTF::StackBounds	access:public	signature:(size_t minAvailableDelta = s_defaultAvailabilityDelta) const
WTF::StackBounds::recursionLimit	.\StackBounds.h	/^    void* recursionLimit(size_t minAvailableDelta = s_defaultAvailabilityDelta) const$/;"	f	class:WTF::StackBounds	access:public	signature:(size_t minAvailableDelta = s_defaultAvailabilityDelta) const
WTF::StackBounds::s_defaultAvailabilityDelta	.\StackBounds.h	/^    const static size_t s_defaultAvailabilityDelta = 4096;$/;"	m	class:WTF::StackBounds	access:private
WTF::StackTrace	.\FastMalloc.cpp	/^struct StackTrace {$/;"	s	namespace:WTF	file:
WTF::StackTrace::depth	.\FastMalloc.cpp	/^  uintptr_t depth;         \/\/ Number of PC values stored in array below$/;"	m	struct:WTF::StackTrace	file:	access:public
WTF::StackTrace::size	.\FastMalloc.cpp	/^  uintptr_t size;          \/\/ Size of object$/;"	m	struct:WTF::StackTrace	file:	access:public
WTF::StackTrace::stack	.\FastMalloc.cpp	/^  void*     stack[kMaxStackDepth];$/;"	m	struct:WTF::StackTrace	file:	access:public
WTF::String	.\text\WTFString.h	/^class String {$/;"	c	namespace:WTF
WTF::String::String	.\qt\StringQt.cpp	/^String::String(const QString& qstr)$/;"	f	class:WTF::String	signature:(const QString& qstr)
WTF::String::String	.\qt\StringQt.cpp	/^String::String(const QStringRef& ref)$/;"	f	class:WTF::String	signature:(const QStringRef& ref)
WTF::String::String	.\text\WTFString.cpp	/^String::String(const LChar* characters)$/;"	f	class:WTF::String	signature:(const LChar* characters)
WTF::String::String	.\text\WTFString.cpp	/^String::String(const LChar* characters, unsigned length)$/;"	f	class:WTF::String	signature:(const LChar* characters, unsigned length)
WTF::String::String	.\text\WTFString.cpp	/^String::String(const UChar* characters, unsigned length)$/;"	f	class:WTF::String	signature:(const UChar* characters, unsigned length)
WTF::String::String	.\text\WTFString.cpp	/^String::String(const UChar* str)$/;"	f	class:WTF::String	signature:(const UChar* str)
WTF::String::String	.\text\WTFString.cpp	/^String::String(const char* characters)$/;"	f	class:WTF::String	signature:(const char* characters)
WTF::String::String	.\text\WTFString.cpp	/^String::String(const char* characters, unsigned length)$/;"	f	class:WTF::String	signature:(const char* characters, unsigned length)
WTF::String::String	.\text\WTFString.h	/^    String() { }$/;"	f	class:WTF::String	access:public	signature:()
WTF::String::String	.\text\WTFString.h	/^    String(CFStringRef);$/;"	p	class:WTF::String	access:public	signature:(CFStringRef)
WTF::String::String	.\text\WTFString.h	/^    String(NSString*);$/;"	p	class:WTF::String	access:public	signature:(NSString*)
WTF::String::String	.\text\WTFString.h	/^    String(PassRefPtr<StringImpl> impl) : m_impl(impl) { }$/;"	f	class:WTF::String	access:public	signature:(PassRefPtr<StringImpl> impl)
WTF::String::String	.\text\WTFString.h	/^    String(RefPtr<StringImpl> impl) : m_impl(impl) { }$/;"	f	class:WTF::String	access:public	signature:(RefPtr<StringImpl> impl)
WTF::String::String	.\text\WTFString.h	/^    String(StringImpl* impl) : m_impl(impl) { }$/;"	f	class:WTF::String	access:public	signature:(StringImpl* impl)
WTF::String::String	.\text\WTFString.h	/^    String(WTF::HashTableDeletedValueType) : m_impl(WTF::HashTableDeletedValue) { }$/;"	f	class:WTF::String	access:public	signature:(WTF::HashTableDeletedValueType)
WTF::String::String	.\text\WTFString.h	/^    String(const BlackBerry::WebKit::WebString&);$/;"	p	class:WTF::String	access:public	signature:(const BlackBerry::WebKit::WebString&)
WTF::String::String	.\text\WTFString.h	/^    String(const QString&);$/;"	p	class:WTF::String	access:public	signature:(const QString&)
WTF::String::String	.\text\WTFString.h	/^    String(const QStringRef&);$/;"	p	class:WTF::String	access:public	signature:(const QStringRef&)
WTF::String::String	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE String(const LChar* characters);$/;"	p	class:WTF::String	access:public	signature:(const LChar* characters)
WTF::String::String	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE String(const LChar* characters, unsigned length);$/;"	p	class:WTF::String	access:public	signature:(const LChar* characters, unsigned length)
WTF::String::String	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE String(const UChar* characters, unsigned length);$/;"	p	class:WTF::String	access:public	signature:(const UChar* characters, unsigned length)
WTF::String::String	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE String(const UChar*);$/;"	p	class:WTF::String	access:public	signature:(const UChar*)
WTF::String::String	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE String(const char* characters);$/;"	p	class:WTF::String	access:public	signature:(const char* characters)
WTF::String::String	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE String(const char* characters, unsigned length);$/;"	p	class:WTF::String	access:public	signature:(const char* characters, unsigned length)
WTF::String::String	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE String(const wxString&);$/;"	p	class:WTF::String	access:public	signature:(const wxString&)
WTF::String::String	.\text\WTFString.h	/^    explicit String(const Vector<UChar, inlineCapacity>&);$/;"	p	class:WTF::String	access:public	signature:(const Vector<UChar, inlineCapacity>&)
WTF::String::String	.\text\WTFString.h	/^String::String(const Vector<UChar, inlineCapacity>& vector)$/;"	f	class:WTF::String	signature:(const Vector<UChar, inlineCapacity>& vector)
WTF::String::String	.\wx\StringWx.cpp	/^String::String(const wxString& wxstr)$/;"	f	class:WTF::String	signature:(const wxString& wxstr)
WTF::String::UnspecifiedBoolTypeA	.\text\WTFString.h	/^    typedef struct ImplicitConversionFromWTFStringToBoolDisallowedA* (String::*UnspecifiedBoolTypeA);$/;"	t	class:WTF::String	typeref:struct:WTF::String::ImplicitConversionFromWTFStringToBoolDisallowedA	access:public
WTF::String::UnspecifiedBoolTypeB	.\text\WTFString.h	/^    typedef struct ImplicitConversionFromWTFStringToBoolDisallowedB* (String::*UnspecifiedBoolTypeB);$/;"	t	class:WTF::String	typeref:struct:WTF::String::ImplicitConversionFromWTFStringToBoolDisallowedB	access:public
WTF::String::adopt	.\text\WTFString.h	/^    static String adopt(StringBuffer<LChar>& buffer) { return StringImpl::adopt(buffer); }$/;"	f	class:WTF::String	access:public	signature:(StringBuffer<LChar>& buffer)
WTF::String::adopt	.\text\WTFString.h	/^    static String adopt(StringBuffer<UChar>& buffer) { return StringImpl::adopt(buffer); }$/;"	f	class:WTF::String	access:public	signature:(StringBuffer<UChar>& buffer)
WTF::String::adopt	.\text\WTFString.h	/^    static String adopt(Vector<UChar, inlineCapacity>& vector) { return StringImpl::adopt(vector); }$/;"	f	class:WTF::String	access:public	signature:(Vector<UChar, inlineCapacity>& vector)
WTF::String::append	.\text\WTFString.cpp	/^void String::append(LChar c)$/;"	f	class:WTF::String	signature:(LChar c)
WTF::String::append	.\text\WTFString.cpp	/^void String::append(UChar c)$/;"	f	class:WTF::String	signature:(UChar c)
WTF::String::append	.\text\WTFString.cpp	/^void String::append(const String& str)$/;"	f	class:WTF::String	signature:(const String& str)
WTF::String::append	.\text\WTFString.cpp	/^void String::append(const UChar* charactersToAppend, unsigned lengthToAppend)$/;"	f	class:WTF::String	signature:(const UChar* charactersToAppend, unsigned lengthToAppend)
WTF::String::append	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE void append(LChar);$/;"	p	class:WTF::String	access:public	signature:(LChar)
WTF::String::append	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE void append(UChar);$/;"	p	class:WTF::String	access:public	signature:(UChar)
WTF::String::append	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE void append(const String&);$/;"	p	class:WTF::String	access:public	signature:(const String&)
WTF::String::append	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE void append(const UChar*, unsigned length);$/;"	p	class:WTF::String	access:public	signature:(const UChar*, unsigned length)
WTF::String::append	.\text\WTFString.h	/^    void append(char c) { append(static_cast<LChar>(c)); };$/;"	f	class:WTF::String	access:public	signature:(char c)
WTF::String::ascii	.\text\WTFString.cpp	/^CString String::ascii() const$/;"	f	class:WTF::String	signature:() const
WTF::String::ascii	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE CString ascii() const;$/;"	p	class:WTF::String	access:public	signature:() const
WTF::String::characterStartingAt	.\text\WTFString.cpp	/^UChar32 String::characterStartingAt(unsigned i) const$/;"	f	class:WTF::String	signature:(unsigned i) const
WTF::String::characterStartingAt	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE UChar32 characterStartingAt(unsigned) const; \/\/ Ditto.$/;"	p	class:WTF::String	access:public	signature:(unsigned) const
WTF::String::characters	.\text\WTFString.h	/^    const UChar* characters() const$/;"	f	class:WTF::String	access:public	signature:() const
WTF::String::characters16	.\text\WTFString.h	/^    const UChar* characters16() const$/;"	f	class:WTF::String	access:public	signature:() const
WTF::String::characters8	.\text\WTFString.h	/^    const LChar* characters8() const$/;"	f	class:WTF::String	access:public	signature:() const
WTF::String::charactersWithNullTermination	.\text\WTFString.cpp	/^const UChar* String::charactersWithNullTermination()$/;"	f	class:WTF::String	signature:()
WTF::String::charactersWithNullTermination	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE const UChar* charactersWithNullTermination();$/;"	p	class:WTF::String	access:public	signature:()
WTF::String::contains	.\text\WTFString.h	/^    bool contains(UChar c) const { return find(c) != notFound; }$/;"	f	class:WTF::String	access:public	signature:(UChar c) const
WTF::String::contains	.\text\WTFString.h	/^    bool contains(const LChar* str, bool caseSensitive = true) const { return find(str, 0, caseSensitive) != notFound; }$/;"	f	class:WTF::String	access:public	signature:(const LChar* str, bool caseSensitive = true) const
WTF::String::contains	.\text\WTFString.h	/^    bool contains(const String& str, bool caseSensitive = true) const { return find(str, 0, caseSensitive) != notFound; }$/;"	f	class:WTF::String	access:public	signature:(const String& str, bool caseSensitive = true) const
WTF::String::containsOnlyASCII	.\text\WTFString.h	/^    bool containsOnlyASCII() const;$/;"	p	class:WTF::String	access:public	signature:() const
WTF::String::containsOnlyASCII	.\text\WTFString.h	/^inline bool String::containsOnlyASCII() const$/;"	f	class:WTF::String	signature:() const
WTF::String::containsOnlyLatin1	.\text\WTFString.h	/^    bool containsOnlyLatin1() const;$/;"	p	class:WTF::String	access:public	signature:() const
WTF::String::containsOnlyLatin1	.\text\WTFString.h	/^inline bool String::containsOnlyLatin1() const$/;"	f	class:WTF::String	signature:() const
WTF::String::containsOnlyWhitespace	.\text\WTFString.h	/^    bool containsOnlyWhitespace() const { return !m_impl || m_impl->containsOnlyWhitespace(); }$/;"	f	class:WTF::String	access:public	signature:() const
WTF::String::createCFString	.\text\WTFString.h	/^    CFStringRef createCFString() const;$/;"	p	class:WTF::String	access:public	signature:() const
WTF::String::createUninitialized	.\text\WTFString.h	/^    static String createUninitialized(unsigned length, UChar*& data) { return StringImpl::createUninitialized(length, data); }$/;"	f	class:WTF::String	access:public	signature:(unsigned length, UChar*& data)
WTF::String::defaultWritingDirection	.\text\WTFString.h	/^    WTF::Unicode::Direction defaultWritingDirection(bool* hasStrongDirectionality = 0) const$/;"	f	class:WTF::String	access:public	signature:(bool* hasStrongDirectionality = 0) const
WTF::String::endsWith	.\text\WTFString.h	/^    bool endsWith(const String& s, bool caseSensitive = true) const$/;"	f	class:WTF::String	access:public	signature:(const String& s, bool caseSensitive = true) const
WTF::String::fill	.\text\WTFString.h	/^    void fill(UChar c) { if (m_impl) m_impl = m_impl->fill(c); }$/;"	f	class:WTF::String	access:public	signature:(UChar c)
WTF::String::find	.\text\WTFString.h	/^    size_t find(CharacterMatchFunctionPtr matchFunction, unsigned start = 0) const$/;"	f	class:WTF::String	access:public	signature:(CharacterMatchFunctionPtr matchFunction, unsigned start = 0) const
WTF::String::find	.\text\WTFString.h	/^    size_t find(UChar c, unsigned start = 0) const$/;"	f	class:WTF::String	access:public	signature:(UChar c, unsigned start = 0) const
WTF::String::find	.\text\WTFString.h	/^    size_t find(const LChar* str, unsigned start = 0) const$/;"	f	class:WTF::String	access:public	signature:(const LChar* str, unsigned start = 0) const
WTF::String::find	.\text\WTFString.h	/^    size_t find(const LChar* str, unsigned start, bool caseSensitive) const$/;"	f	class:WTF::String	access:public	signature:(const LChar* str, unsigned start, bool caseSensitive) const
WTF::String::find	.\text\WTFString.h	/^    size_t find(const String& str, unsigned start = 0) const$/;"	f	class:WTF::String	access:public	signature:(const String& str, unsigned start = 0) const
WTF::String::find	.\text\WTFString.h	/^    size_t find(const String& str, unsigned start, bool caseSensitive) const$/;"	f	class:WTF::String	access:public	signature:(const String& str, unsigned start, bool caseSensitive) const
WTF::String::findIgnoringCase	.\text\WTFString.h	/^    size_t findIgnoringCase(const LChar* str, unsigned start = 0) const$/;"	f	class:WTF::String	access:public	signature:(const LChar* str, unsigned start = 0) const
WTF::String::findIgnoringCase	.\text\WTFString.h	/^    size_t findIgnoringCase(const String& str, unsigned start = 0) const$/;"	f	class:WTF::String	access:public	signature:(const String& str, unsigned start = 0) const
WTF::String::foldCase	.\text\WTFString.cpp	/^String String::foldCase() const$/;"	f	class:WTF::String	signature:() const
WTF::String::foldCase	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE String foldCase() const;$/;"	p	class:WTF::String	access:public	signature:() const
WTF::String::format	.\text\WTFString.cpp	/^String String::format(const char *format, ...)$/;"	f	class:WTF::String	signature:(const char *format, ...)
WTF::String::format	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE static String format(const char *, ...);$/;"	p	class:WTF::String	access:public	signature:(const char *, ...)
WTF::String::fromUTF8	.\text\WTFString.cpp	/^String String::fromUTF8(const LChar* string)$/;"	f	class:WTF::String	signature:(const LChar* string)
WTF::String::fromUTF8	.\text\WTFString.cpp	/^String String::fromUTF8(const LChar* stringStart, size_t length)$/;"	f	class:WTF::String	signature:(const LChar* stringStart, size_t length)
WTF::String::fromUTF8	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE static String fromUTF8(const LChar*);$/;"	p	class:WTF::String	access:public	signature:(const LChar*)
WTF::String::fromUTF8	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE static String fromUTF8(const LChar*, size_t);$/;"	p	class:WTF::String	access:public	signature:(const LChar*, size_t)
WTF::String::fromUTF8	.\text\WTFString.h	/^    static String fromUTF8(const char* s) { return fromUTF8(reinterpret_cast<const LChar*>(s)); };$/;"	f	class:WTF::String	access:public	signature:(const char* s)
WTF::String::fromUTF8	.\text\WTFString.h	/^    static String fromUTF8(const char* s, size_t length) { return fromUTF8(reinterpret_cast<const LChar*>(s), length); };$/;"	f	class:WTF::String	access:public	signature:(const char* s, size_t length)
WTF::String::fromUTF8WithLatin1Fallback	.\text\WTFString.cpp	/^String String::fromUTF8WithLatin1Fallback(const LChar* string, size_t size)$/;"	f	class:WTF::String	signature:(const LChar* string, size_t size)
WTF::String::fromUTF8WithLatin1Fallback	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE static String fromUTF8WithLatin1Fallback(const LChar*, size_t);$/;"	p	class:WTF::String	access:public	signature:(const LChar*, size_t)
WTF::String::fromUTF8WithLatin1Fallback	.\text\WTFString.h	/^    static String fromUTF8WithLatin1Fallback(const char* s, size_t length) { return fromUTF8WithLatin1Fallback(reinterpret_cast<const LChar*>(s), length); };$/;"	f	class:WTF::String	access:public	signature:(const char* s, size_t length)
WTF::String::getCharacters	.\text\WTFString.h	/^    inline const CharType* getCharacters() const;$/;"	p	class:WTF::String	access:public	signature:() const
WTF::String::getCharacters	.\text\WTFString.h	/^inline const LChar* String::getCharacters<LChar>() const$/;"	f	class:WTF::String	signature:() const
WTF::String::getCharacters	.\text\WTFString.h	/^inline const UChar* String::getCharacters<UChar>() const$/;"	f	class:WTF::String	signature:() const
WTF::String::impl	.\text\WTFString.h	/^    StringImpl* impl() const { return m_impl.get(); }$/;"	f	class:WTF::String	access:public	signature:() const
WTF::String::insert	.\text\WTFString.cpp	/^void String::insert(const String& str, unsigned pos)$/;"	f	class:WTF::String	signature:(const String& str, unsigned pos)
WTF::String::insert	.\text\WTFString.cpp	/^void String::insert(const UChar* charactersToInsert, unsigned lengthToInsert, unsigned position)$/;"	f	class:WTF::String	signature:(const UChar* charactersToInsert, unsigned lengthToInsert, unsigned position)
WTF::String::insert	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE void insert(const String&, unsigned pos);$/;"	p	class:WTF::String	access:public	signature:(const String&, unsigned pos)
WTF::String::insert	.\text\WTFString.h	/^    void insert(const UChar*, unsigned length, unsigned pos);$/;"	p	class:WTF::String	access:public	signature:(const UChar*, unsigned length, unsigned pos)
WTF::String::is8Bit	.\text\WTFString.h	/^    bool is8Bit() const { return m_impl->is8Bit(); }$/;"	f	class:WTF::String	access:public	signature:() const
WTF::String::isAllSpecialCharacters	.\text\WTFString.h	/^    template<bool isSpecialCharacter(UChar)> bool isAllSpecialCharacters() const;$/;"	p	class:WTF::String	access:public	signature:() const
WTF::String::isAllSpecialCharacters	.\text\WTFString.h	/^template<bool isSpecialCharacter(UChar)> inline bool String::isAllSpecialCharacters() const$/;"	f	class:WTF::String	signature:() const
WTF::String::isEmpty	.\text\WTFString.h	/^    bool isEmpty() const { return !m_impl || !m_impl->length(); }$/;"	f	class:WTF::String	access:public	signature:() const
WTF::String::isHashTableDeletedValue	.\text\WTFString.h	/^    bool isHashTableDeletedValue() const { return m_impl.isHashTableDeletedValue(); }$/;"	f	class:WTF::String	access:public	signature:() const
WTF::String::isNull	.\text\WTFString.h	/^    bool isNull() const { return !m_impl; }$/;"	f	class:WTF::String	access:public	signature:() const
WTF::String::isolatedCopy	.\text\WTFString.cpp	/^String String::isolatedCopy() const$/;"	f	class:WTF::String	signature:() const
WTF::String::isolatedCopy	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE String isolatedCopy() const;$/;"	p	class:WTF::String	access:public	signature:() const
WTF::String::latin1	.\text\WTFString.cpp	/^CString String::latin1() const$/;"	f	class:WTF::String	signature:() const
WTF::String::latin1	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE CString latin1() const;$/;"	p	class:WTF::String	access:public	signature:() const
WTF::String::left	.\text\WTFString.h	/^    String left(unsigned len) const { return substring(0, len); }$/;"	f	class:WTF::String	access:public	signature:(unsigned len) const
WTF::String::length	.\text\WTFString.h	/^    unsigned length() const$/;"	f	class:WTF::String	access:public	signature:() const
WTF::String::lower	.\text\WTFString.cpp	/^String String::lower() const$/;"	f	class:WTF::String	signature:() const
WTF::String::lower	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE String lower() const;$/;"	p	class:WTF::String	access:public	signature:() const
WTF::String::m_impl	.\text\WTFString.h	/^    RefPtr<StringImpl> m_impl;$/;"	m	class:WTF::String	access:private
WTF::String::makeLower	.\text\WTFString.h	/^    void makeLower() { if (m_impl) m_impl = m_impl->lower(); }$/;"	f	class:WTF::String	access:public	signature:()
WTF::String::makeUpper	.\text\WTFString.h	/^    void makeUpper() { if (m_impl) m_impl = m_impl->upper(); }$/;"	f	class:WTF::String	access:public	signature:()
WTF::String::number	.\text\WTFString.cpp	/^String String::number(double number, unsigned flags, unsigned precision)$/;"	f	class:WTF::String	signature:(double number, unsigned flags, unsigned precision)
WTF::String::number	.\text\WTFString.cpp	/^String String::number(int n)$/;"	f	class:WTF::String	signature:(int n)
WTF::String::number	.\text\WTFString.cpp	/^String String::number(long long n)$/;"	f	class:WTF::String	signature:(long long n)
WTF::String::number	.\text\WTFString.cpp	/^String String::number(long n)$/;"	f	class:WTF::String	signature:(long n)
WTF::String::number	.\text\WTFString.cpp	/^String String::number(short n)$/;"	f	class:WTF::String	signature:(short n)
WTF::String::number	.\text\WTFString.cpp	/^String String::number(unsigned long long n)$/;"	f	class:WTF::String	signature:(unsigned long long n)
WTF::String::number	.\text\WTFString.cpp	/^String String::number(unsigned long n)$/;"	f	class:WTF::String	signature:(unsigned long n)
WTF::String::number	.\text\WTFString.cpp	/^String String::number(unsigned n)$/;"	f	class:WTF::String	signature:(unsigned n)
WTF::String::number	.\text\WTFString.cpp	/^String String::number(unsigned short n)$/;"	f	class:WTF::String	signature:(unsigned short n)
WTF::String::number	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE static String number(double, unsigned = ShouldRoundSignificantFigures | ShouldTruncateTrailingZeros, unsigned precision = 6);$/;"	p	class:WTF::String	access:public	signature:(double, unsigned = ShouldRoundSignificantFigures | ShouldTruncateTrailingZeros, unsigned precision = 6)
WTF::String::number	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE static String number(int);$/;"	p	class:WTF::String	access:public	signature:(int)
WTF::String::number	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE static String number(long long);$/;"	p	class:WTF::String	access:public	signature:(long long)
WTF::String::number	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE static String number(long);$/;"	p	class:WTF::String	access:public	signature:(long)
WTF::String::number	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE static String number(unsigned long long);$/;"	p	class:WTF::String	access:public	signature:(unsigned long long)
WTF::String::number	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE static String number(unsigned long);$/;"	p	class:WTF::String	access:public	signature:(unsigned long)
WTF::String::number	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE static String number(unsigned short);$/;"	p	class:WTF::String	access:public	signature:(unsigned short)
WTF::String::number	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE static String number(unsigned);$/;"	p	class:WTF::String	access:public	signature:(unsigned)
WTF::String::number	.\text\WTFString.h	/^    static String number(short);$/;"	p	class:WTF::String	access:public	signature:(short)
WTF::String::operator BlackBerry::WebKit::WebString	.\text\WTFString.h	/^    operator BlackBerry::WebKit::WebString() const;$/;"	p	class:WTF::String	access:public	signature:() const
WTF::String::operator NSString*	.\text\WTFString.h	/^    operator NSString*() const { if (!m_impl) return @""; return *m_impl; }$/;"	f	class:WTF::String	access:public	signature:() const
WTF::String::operator QString	.\qt\StringQt.cpp	/^String::operator QString() const$/;"	f	class:WTF::String	signature:() const
WTF::String::operator QString	.\text\WTFString.h	/^    operator QString() const;$/;"	p	class:WTF::String	access:public	signature:() const
WTF::String::operator UnspecifiedBoolTypeA	.\text\WTFString.h	/^    operator UnspecifiedBoolTypeA() const;$/;"	p	class:WTF::String	access:public	signature:() const
WTF::String::operator UnspecifiedBoolTypeB	.\text\WTFString.h	/^    operator UnspecifiedBoolTypeB() const;$/;"	p	class:WTF::String	access:public	signature:() const
WTF::String::operator []	.\text\WTFString.h	/^    UChar operator[](unsigned index) const$/;"	f	class:WTF::String	access:public	signature:(unsigned index) const
WTF::String::operator wxString	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE operator wxString() const;$/;"	p	class:WTF::String	access:public	signature:() const
WTF::String::operator wxString	.\wx\StringWx.cpp	/^String::operator wxString() const$/;"	f	class:WTF::String	signature:() const
WTF::String::percentage	.\text\WTFString.cpp	/^bool String::percentage(int& result) const$/;"	f	class:WTF::String	signature:(int& result) const
WTF::String::percentage	.\text\WTFString.h	/^    bool percentage(int& percentage) const;$/;"	p	class:WTF::String	access:public	signature:(int& percentage) const
WTF::String::remove	.\text\WTFString.cpp	/^void String::remove(unsigned position, int lengthToRemove)$/;"	f	class:WTF::String	signature:(unsigned position, int lengthToRemove)
WTF::String::remove	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE void remove(unsigned pos, int len = 1);$/;"	p	class:WTF::String	access:public	signature:(unsigned pos, int len = 1)
WTF::String::removeCharacters	.\text\WTFString.cpp	/^String String::removeCharacters(CharacterMatchFunctionPtr findMatch) const$/;"	f	class:WTF::String	signature:(CharacterMatchFunctionPtr findMatch) const
WTF::String::removeCharacters	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE String removeCharacters(CharacterMatchFunctionPtr) const;$/;"	p	class:WTF::String	access:public	signature:(CharacterMatchFunctionPtr) const
WTF::String::replace	.\text\WTFString.h	/^    String& replace(UChar a, UChar b) { if (m_impl) m_impl = m_impl->replace(a, b); return *this; }$/;"	f	class:WTF::String	access:public	signature:(UChar a, UChar b)
WTF::String::replace	.\text\WTFString.h	/^    String& replace(UChar a, const String& b) { if (m_impl) m_impl = m_impl->replace(a, b.impl()); return *this; }$/;"	f	class:WTF::String	access:public	signature:(UChar a, const String& b)
WTF::String::replace	.\text\WTFString.h	/^    String& replace(const String& a, const String& b) { if (m_impl) m_impl = m_impl->replace(a.impl(), b.impl()); return *this; }$/;"	f	class:WTF::String	access:public	signature:(const String& a, const String& b)
WTF::String::replace	.\text\WTFString.h	/^    String& replace(unsigned index, unsigned len, const String& b) { if (m_impl) m_impl = m_impl->replace(index, len, b.impl()); return *this; }$/;"	f	class:WTF::String	access:public	signature:(unsigned index, unsigned len, const String& b)
WTF::String::reverseFind	.\text\WTFString.h	/^    size_t reverseFind(UChar c, unsigned start = UINT_MAX) const$/;"	f	class:WTF::String	access:public	signature:(UChar c, unsigned start = UINT_MAX) const
WTF::String::reverseFind	.\text\WTFString.h	/^    size_t reverseFind(const String& str, unsigned start = UINT_MAX) const$/;"	f	class:WTF::String	access:public	signature:(const String& str, unsigned start = UINT_MAX) const
WTF::String::reverseFind	.\text\WTFString.h	/^    size_t reverseFind(const String& str, unsigned start, bool caseSensitive) const$/;"	f	class:WTF::String	access:public	signature:(const String& str, unsigned start, bool caseSensitive) const
WTF::String::reverseFindIgnoringCase	.\text\WTFString.h	/^    size_t reverseFindIgnoringCase(const String& str, unsigned start = UINT_MAX) const$/;"	f	class:WTF::String	access:public	signature:(const String& str, unsigned start = UINT_MAX) const
WTF::String::right	.\text\WTFString.h	/^    String right(unsigned len) const { return substring(length() - len, len); }$/;"	f	class:WTF::String	access:public	signature:(unsigned len) const
WTF::String::show	.\text\WTFString.h	/^    void show() const;$/;"	p	class:WTF::String	access:public	signature:() const
WTF::String::simplifyWhiteSpace	.\text\WTFString.cpp	/^String String::simplifyWhiteSpace() const$/;"	f	class:WTF::String	signature:() const
WTF::String::simplifyWhiteSpace	.\text\WTFString.cpp	/^String String::simplifyWhiteSpace(IsWhiteSpaceFunctionPtr isWhiteSpace) const$/;"	f	class:WTF::String	signature:(IsWhiteSpaceFunctionPtr isWhiteSpace) const
WTF::String::simplifyWhiteSpace	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE String simplifyWhiteSpace() const;$/;"	p	class:WTF::String	access:public	signature:() const
WTF::String::simplifyWhiteSpace	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE String simplifyWhiteSpace(IsWhiteSpaceFunctionPtr) const;$/;"	p	class:WTF::String	access:public	signature:(IsWhiteSpaceFunctionPtr) const
WTF::String::split	.\text\WTFString.cpp	/^void String::split(UChar separator, Vector<String>& result) const$/;"	f	class:WTF::String	signature:(UChar separator, Vector<String>& result) const
WTF::String::split	.\text\WTFString.cpp	/^void String::split(UChar separator, bool allowEmptyEntries, Vector<String>& result) const$/;"	f	class:WTF::String	signature:(UChar separator, bool allowEmptyEntries, Vector<String>& result) const
WTF::String::split	.\text\WTFString.cpp	/^void String::split(const String& separator, Vector<String>& result) const$/;"	f	class:WTF::String	signature:(const String& separator, Vector<String>& result) const
WTF::String::split	.\text\WTFString.cpp	/^void String::split(const String& separator, bool allowEmptyEntries, Vector<String>& result) const$/;"	f	class:WTF::String	signature:(const String& separator, bool allowEmptyEntries, Vector<String>& result) const
WTF::String::split	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE void split(UChar separator, Vector<String>& result) const;$/;"	p	class:WTF::String	access:public	signature:(UChar separator, Vector<String>& result) const
WTF::String::split	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE void split(UChar separator, bool allowEmptyEntries, Vector<String>& result) const;$/;"	p	class:WTF::String	access:public	signature:(UChar separator, bool allowEmptyEntries, Vector<String>& result) const
WTF::String::split	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE void split(const String& separator, Vector<String>& result) const;$/;"	p	class:WTF::String	access:public	signature:(const String& separator, Vector<String>& result) const
WTF::String::split	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE void split(const String& separator, bool allowEmptyEntries, Vector<String>& result) const;$/;"	p	class:WTF::String	access:public	signature:(const String& separator, bool allowEmptyEntries, Vector<String>& result) const
WTF::String::startsWith	.\text\WTFString.h	/^    bool startsWith(const String& s, bool caseSensitive = true) const$/;"	f	class:WTF::String	access:public	signature:(const String& s, bool caseSensitive = true) const
WTF::String::stripWhiteSpace	.\text\WTFString.cpp	/^String String::stripWhiteSpace() const$/;"	f	class:WTF::String	signature:() const
WTF::String::stripWhiteSpace	.\text\WTFString.cpp	/^String String::stripWhiteSpace(IsWhiteSpaceFunctionPtr isWhiteSpace) const$/;"	f	class:WTF::String	signature:(IsWhiteSpaceFunctionPtr isWhiteSpace) const
WTF::String::stripWhiteSpace	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE String stripWhiteSpace() const;$/;"	p	class:WTF::String	access:public	signature:() const
WTF::String::stripWhiteSpace	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE String stripWhiteSpace(IsWhiteSpaceFunctionPtr) const;$/;"	p	class:WTF::String	access:public	signature:(IsWhiteSpaceFunctionPtr) const
WTF::String::substring	.\text\WTFString.cpp	/^String String::substring(unsigned pos, unsigned len) const$/;"	f	class:WTF::String	signature:(unsigned pos, unsigned len) const
WTF::String::substring	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE String substring(unsigned pos, unsigned len = UINT_MAX) const;$/;"	p	class:WTF::String	access:public	signature:(unsigned pos, unsigned len = UINT_MAX) const
WTF::String::substringSharingImpl	.\text\WTFString.cpp	/^String String::substringSharingImpl(unsigned offset, unsigned length) const$/;"	f	class:WTF::String	signature:(unsigned offset, unsigned length) const
WTF::String::substringSharingImpl	.\text\WTFString.h	/^    String substringSharingImpl(unsigned pos, unsigned len = UINT_MAX) const;$/;"	p	class:WTF::String	access:public	signature:(unsigned pos, unsigned len = UINT_MAX) const
WTF::String::swap	.\text\WTFString.h	/^    void swap(String& o) { m_impl.swap(o.m_impl); }$/;"	f	class:WTF::String	access:public	signature:(String& o)
WTF::String::toDouble	.\text\WTFString.cpp	/^double String::toDouble(bool* ok, bool* didReadNumber) const$/;"	f	class:WTF::String	signature:(bool* ok, bool* didReadNumber) const
WTF::String::toDouble	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE double toDouble(bool* ok = 0, bool* didReadNumber = 0) const;$/;"	p	class:WTF::String	access:public	signature:(bool* ok = 0, bool* didReadNumber = 0) const
WTF::String::toFloat	.\text\WTFString.cpp	/^float String::toFloat(bool* ok, bool* didReadNumber) const$/;"	f	class:WTF::String	signature:(bool* ok, bool* didReadNumber) const
WTF::String::toFloat	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE float toFloat(bool* ok = 0, bool* didReadNumber = 0) const;$/;"	p	class:WTF::String	access:public	signature:(bool* ok = 0, bool* didReadNumber = 0) const
WTF::String::toInt	.\text\WTFString.cpp	/^int String::toInt(bool* ok) const$/;"	f	class:WTF::String	signature:(bool* ok) const
WTF::String::toInt	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE int toInt(bool* ok = 0) const;$/;"	p	class:WTF::String	access:public	signature:(bool* ok = 0) const
WTF::String::toInt64	.\text\WTFString.cpp	/^int64_t String::toInt64(bool* ok) const$/;"	f	class:WTF::String	signature:(bool* ok) const
WTF::String::toInt64	.\text\WTFString.h	/^    int64_t toInt64(bool* ok = 0) const;$/;"	p	class:WTF::String	access:public	signature:(bool* ok = 0) const
WTF::String::toInt64Strict	.\text\WTFString.cpp	/^int64_t String::toInt64Strict(bool* ok, int base) const$/;"	f	class:WTF::String	signature:(bool* ok, int base) const
WTF::String::toInt64Strict	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE int64_t toInt64Strict(bool* ok = 0, int base = 10) const;$/;"	p	class:WTF::String	access:public	signature:(bool* ok = 0, int base = 10) const
WTF::String::toIntPtr	.\text\WTFString.cpp	/^intptr_t String::toIntPtr(bool* ok) const$/;"	f	class:WTF::String	signature:(bool* ok) const
WTF::String::toIntPtr	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE intptr_t toIntPtr(bool* ok = 0) const;$/;"	p	class:WTF::String	access:public	signature:(bool* ok = 0) const
WTF::String::toIntPtrStrict	.\text\WTFString.cpp	/^intptr_t String::toIntPtrStrict(bool* ok, int base) const$/;"	f	class:WTF::String	signature:(bool* ok, int base) const
WTF::String::toIntPtrStrict	.\text\WTFString.h	/^    intptr_t toIntPtrStrict(bool* ok = 0, int base = 10) const;$/;"	p	class:WTF::String	access:public	signature:(bool* ok = 0, int base = 10) const
WTF::String::toIntStrict	.\text\WTFString.cpp	/^int String::toIntStrict(bool* ok, int base) const$/;"	f	class:WTF::String	signature:(bool* ok, int base) const
WTF::String::toIntStrict	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE int toIntStrict(bool* ok = 0, int base = 10) const;$/;"	p	class:WTF::String	access:public	signature:(bool* ok = 0, int base = 10) const
WTF::String::toUInt	.\text\WTFString.cpp	/^unsigned String::toUInt(bool* ok) const$/;"	f	class:WTF::String	signature:(bool* ok) const
WTF::String::toUInt	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE unsigned toUInt(bool* ok = 0) const;$/;"	p	class:WTF::String	access:public	signature:(bool* ok = 0) const
WTF::String::toUInt64	.\text\WTFString.cpp	/^uint64_t String::toUInt64(bool* ok) const$/;"	f	class:WTF::String	signature:(bool* ok) const
WTF::String::toUInt64	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE uint64_t toUInt64(bool* ok = 0) const;$/;"	p	class:WTF::String	access:public	signature:(bool* ok = 0) const
WTF::String::toUInt64Strict	.\text\WTFString.cpp	/^uint64_t String::toUInt64Strict(bool* ok, int base) const$/;"	f	class:WTF::String	signature:(bool* ok, int base) const
WTF::String::toUInt64Strict	.\text\WTFString.h	/^    uint64_t toUInt64Strict(bool* ok = 0, int base = 10) const;$/;"	p	class:WTF::String	access:public	signature:(bool* ok = 0, int base = 10) const
WTF::String::toUIntStrict	.\text\WTFString.cpp	/^unsigned String::toUIntStrict(bool* ok, int base) const$/;"	f	class:WTF::String	signature:(bool* ok, int base) const
WTF::String::toUIntStrict	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE unsigned toUIntStrict(bool* ok = 0, int base = 10) const;$/;"	p	class:WTF::String	access:public	signature:(bool* ok = 0, int base = 10) const
WTF::String::truncate	.\text\WTFString.cpp	/^void String::truncate(unsigned position)$/;"	f	class:WTF::String	signature:(unsigned position)
WTF::String::truncate	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE void truncate(unsigned len);$/;"	p	class:WTF::String	access:public	signature:(unsigned len)
WTF::String::upper	.\text\WTFString.cpp	/^String String::upper() const$/;"	f	class:WTF::String	signature:() const
WTF::String::upper	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE String upper() const;$/;"	p	class:WTF::String	access:public	signature:() const
WTF::String::utf8	.\text\WTFString.cpp	/^CString String::utf8(bool strict) const$/;"	f	class:WTF::String	signature:(bool strict) const
WTF::String::utf8	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE CString utf8(bool strict = false) const;$/;"	p	class:WTF::String	access:public	signature:(bool strict = false) const
WTF::String::~String	.\text\WTFString.h	/^    ALWAYS_INLINE ~String() { }$/;"	f	class:WTF::String	access:public	signature:()
WTF::StringAppend	.\text\StringOperators.h	/^class StringAppend {$/;"	c	namespace:WTF
WTF::StringAppend::StringAppend	.\text\StringOperators.h	/^    StringAppend(StringType1 string1, StringType2 string2)$/;"	f	class:WTF::StringAppend	access:public	signature:(StringType1 string1, StringType2 string2)
WTF::StringAppend::is8Bit	.\text\StringOperators.h	/^    bool is8Bit()$/;"	f	class:WTF::StringAppend	access:public	signature:()
WTF::StringAppend::length	.\text\StringOperators.h	/^    unsigned length()$/;"	f	class:WTF::StringAppend	access:public	signature:()
WTF::StringAppend::m_string1	.\text\StringOperators.h	/^    StringType1 m_string1;$/;"	m	class:WTF::StringAppend	access:private
WTF::StringAppend::m_string2	.\text\StringOperators.h	/^    StringType2 m_string2;$/;"	m	class:WTF::StringAppend	access:private
WTF::StringAppend::operator AtomicString	.\text\StringOperators.h	/^    operator AtomicString() const$/;"	f	class:WTF::StringAppend	access:public	signature:() const
WTF::StringAppend::operator String	.\text\StringOperators.h	/^    operator String() const$/;"	f	class:WTF::StringAppend	access:public	signature:() const
WTF::StringAppend::writeTo	.\text\StringOperators.h	/^    void writeTo(LChar* destination)$/;"	f	class:WTF::StringAppend	access:public	signature:(LChar* destination)
WTF::StringAppend::writeTo	.\text\StringOperators.h	/^    void writeTo(UChar* destination)$/;"	f	class:WTF::StringAppend	access:public	signature:(UChar* destination)
WTF::StringBuffer	.\text\StringBuffer.h	/^class StringBuffer {$/;"	c	namespace:WTF
WTF::StringBuffer::StringBuffer	.\text\StringBuffer.h	/^    explicit StringBuffer(unsigned length)$/;"	f	class:WTF::StringBuffer	access:public	signature:(unsigned length)
WTF::StringBuffer::WTF_MAKE_NONCOPYABLE	.\text\StringBuffer.h	/^    WTF_MAKE_NONCOPYABLE(StringBuffer);$/;"	p	class:WTF::StringBuffer	access:private	signature:(StringBuffer)
WTF::StringBuffer::characters	.\text\StringBuffer.h	/^    CharType* characters() { return m_data; }$/;"	f	class:WTF::StringBuffer	access:public	signature:()
WTF::StringBuffer::length	.\text\StringBuffer.h	/^    unsigned length() const { return m_length; }$/;"	f	class:WTF::StringBuffer	access:public	signature:() const
WTF::StringBuffer::m_data	.\text\StringBuffer.h	/^    CharType* m_data;$/;"	m	class:WTF::StringBuffer	access:private
WTF::StringBuffer::m_length	.\text\StringBuffer.h	/^    unsigned m_length;$/;"	m	class:WTF::StringBuffer	access:private
WTF::StringBuffer::operator []	.\text\StringBuffer.h	/^    UChar& operator[](unsigned i) { ASSERT(i < m_length); return m_data[i]; }$/;"	f	class:WTF::StringBuffer	access:public	signature:(unsigned i)
WTF::StringBuffer::release	.\text\StringBuffer.h	/^    CharType* release() { CharType* data = m_data; m_data = 0; return data; }$/;"	f	class:WTF::StringBuffer	access:public	signature:()
WTF::StringBuffer::resize	.\text\StringBuffer.h	/^    void resize(unsigned newLength)$/;"	f	class:WTF::StringBuffer	access:public	signature:(unsigned newLength)
WTF::StringBuffer::shrink	.\text\StringBuffer.h	/^    void shrink(unsigned newLength)$/;"	f	class:WTF::StringBuffer	access:public	signature:(unsigned newLength)
WTF::StringBuffer::~StringBuffer	.\text\StringBuffer.h	/^    ~StringBuffer()$/;"	f	class:WTF::StringBuffer	access:public	signature:()
WTF::StringBuilder	.\text\StringBuilder.h	/^class StringBuilder {$/;"	c	namespace:WTF
WTF::StringBuilder::StringBuilder	.\text\StringBuilder.h	/^    StringBuilder()$/;"	f	class:WTF::StringBuilder	access:public	signature:()
WTF::StringBuilder::WTF_MAKE_NONCOPYABLE	.\text\StringBuilder.h	/^    WTF_MAKE_NONCOPYABLE(StringBuilder);$/;"	p	class:WTF::StringBuilder	access:private	signature:(StringBuilder)
WTF::StringBuilder::__anon10::m_bufferCharacters16	.\text\StringBuilder.h	/^        UChar* m_bufferCharacters16;$/;"	m	union:WTF::StringBuilder::__anon10	access:public
WTF::StringBuilder::__anon10::m_bufferCharacters8	.\text\StringBuilder.h	/^        LChar* m_bufferCharacters8;$/;"	m	union:WTF::StringBuilder::__anon10	access:public
WTF::StringBuilder::allocateBuffer	.\text\StringBuilder.cpp	/^void StringBuilder::allocateBuffer(const LChar* currentCharacters, unsigned requiredLength)$/;"	f	class:WTF::StringBuilder	signature:(const LChar* currentCharacters, unsigned requiredLength)
WTF::StringBuilder::allocateBuffer	.\text\StringBuilder.cpp	/^void StringBuilder::allocateBuffer(const UChar* currentCharacters, unsigned requiredLength)$/;"	f	class:WTF::StringBuilder	signature:(const UChar* currentCharacters, unsigned requiredLength)
WTF::StringBuilder::allocateBuffer	.\text\StringBuilder.h	/^    void allocateBuffer(const LChar* currentCharacters, unsigned requiredLength);$/;"	p	class:WTF::StringBuilder	access:private	signature:(const LChar* currentCharacters, unsigned requiredLength)
WTF::StringBuilder::allocateBuffer	.\text\StringBuilder.h	/^    void allocateBuffer(const UChar* currentCharacters, unsigned requiredLength);$/;"	p	class:WTF::StringBuilder	access:private	signature:(const UChar* currentCharacters, unsigned requiredLength)
WTF::StringBuilder::allocateBufferUpConvert	.\text\StringBuilder.cpp	/^void StringBuilder::allocateBufferUpConvert(const LChar* currentCharacters, unsigned requiredLength)$/;"	f	class:WTF::StringBuilder	signature:(const LChar* currentCharacters, unsigned requiredLength)
WTF::StringBuilder::allocateBufferUpConvert	.\text\StringBuilder.h	/^    void allocateBufferUpConvert(const LChar* currentCharacters, unsigned requiredLength);$/;"	p	class:WTF::StringBuilder	access:private	signature:(const LChar* currentCharacters, unsigned requiredLength)
WTF::StringBuilder::append	.\text\StringBuilder.cpp	/^void StringBuilder::append(const LChar* characters, unsigned length)$/;"	f	class:WTF::StringBuilder	signature:(const LChar* characters, unsigned length)
WTF::StringBuilder::append	.\text\StringBuilder.cpp	/^void StringBuilder::append(const UChar* characters, unsigned length)$/;"	f	class:WTF::StringBuilder	signature:(const UChar* characters, unsigned length)
WTF::StringBuilder::append	.\text\StringBuilder.h	/^    ALWAYS_INLINE void append(const char* characters, unsigned length) { append(reinterpret_cast<const LChar*>(characters), length); }$/;"	f	class:WTF::StringBuilder	access:public	signature:(const char* characters, unsigned length)
WTF::StringBuilder::append	.\text\StringBuilder.h	/^    WTF_EXPORT_PRIVATE void append(const LChar*, unsigned);$/;"	p	class:WTF::StringBuilder	access:public	signature:(const LChar*, unsigned)
WTF::StringBuilder::append	.\text\StringBuilder.h	/^    WTF_EXPORT_PRIVATE void append(const UChar*, unsigned);$/;"	p	class:WTF::StringBuilder	access:public	signature:(const UChar*, unsigned)
WTF::StringBuilder::append	.\text\StringBuilder.h	/^    void append(LChar c)$/;"	f	class:WTF::StringBuilder	access:public	signature:(LChar c)
WTF::StringBuilder::append	.\text\StringBuilder.h	/^    void append(UChar c)$/;"	f	class:WTF::StringBuilder	access:public	signature:(UChar c)
WTF::StringBuilder::append	.\text\StringBuilder.h	/^    void append(char c)$/;"	f	class:WTF::StringBuilder	access:public	signature:(char c)
WTF::StringBuilder::append	.\text\StringBuilder.h	/^    void append(const String& string)$/;"	f	class:WTF::StringBuilder	access:public	signature:(const String& string)
WTF::StringBuilder::append	.\text\StringBuilder.h	/^    void append(const String& string, unsigned offset, unsigned length)$/;"	f	class:WTF::StringBuilder	access:public	signature:(const String& string, unsigned offset, unsigned length)
WTF::StringBuilder::append	.\text\StringBuilder.h	/^    void append(const StringBuilder& other)$/;"	f	class:WTF::StringBuilder	access:public	signature:(const StringBuilder& other)
WTF::StringBuilder::append	.\text\StringBuilder.h	/^    void append(const char* characters)$/;"	f	class:WTF::StringBuilder	access:public	signature:(const char* characters)
WTF::StringBuilder::appendUninitialized	.\text\StringBuilder.cpp	/^ALWAYS_INLINE CharType* StringBuilder::appendUninitialized(unsigned length)$/;"	f	class:WTF::StringBuilder	signature:(unsigned length)
WTF::StringBuilder::appendUninitialized	.\text\StringBuilder.h	/^    ALWAYS_INLINE CharType* appendUninitialized(unsigned length);$/;"	p	class:WTF::StringBuilder	access:private	signature:(unsigned length)
WTF::StringBuilder::appendUninitializedSlow	.\text\StringBuilder.cpp	/^CharType* StringBuilder::appendUninitializedSlow(unsigned requiredLength)$/;"	f	class:WTF::StringBuilder	signature:(unsigned requiredLength)
WTF::StringBuilder::appendUninitializedSlow	.\text\StringBuilder.h	/^    CharType* appendUninitializedSlow(unsigned length);$/;"	p	class:WTF::StringBuilder	access:private	signature:(unsigned length)
WTF::StringBuilder::canShrink	.\text\StringBuilder.cpp	/^bool StringBuilder::canShrink() const$/;"	f	class:WTF::StringBuilder	signature:() const
WTF::StringBuilder::canShrink	.\text\StringBuilder.h	/^    WTF_EXPORT_PRIVATE bool canShrink() const;$/;"	p	class:WTF::StringBuilder	access:public	signature:() const
WTF::StringBuilder::capacity	.\text\StringBuilder.h	/^    unsigned capacity() const$/;"	f	class:WTF::StringBuilder	access:public	signature:() const
WTF::StringBuilder::characters	.\text\StringBuilder.h	/^    const UChar* characters() const$/;"	f	class:WTF::StringBuilder	access:public	signature:() const
WTF::StringBuilder::characters16	.\text\StringBuilder.h	/^    const UChar* characters16() const$/;"	f	class:WTF::StringBuilder	access:public	signature:() const
WTF::StringBuilder::characters8	.\text\StringBuilder.h	/^    const LChar* characters8() const$/;"	f	class:WTF::StringBuilder	access:public	signature:() const
WTF::StringBuilder::clear	.\text\StringBuilder.h	/^    void clear()$/;"	f	class:WTF::StringBuilder	access:public	signature:()
WTF::StringBuilder::getBufferCharacters	.\text\StringBuilder.h	/^    ALWAYS_INLINE CharType * getBufferCharacters();$/;"	p	class:WTF::StringBuilder	access:private	signature:()
WTF::StringBuilder::getBufferCharacters	.\text\StringBuilder.h	/^ALWAYS_INLINE LChar* StringBuilder::getBufferCharacters<LChar>()$/;"	f	class:WTF::StringBuilder	signature:()
WTF::StringBuilder::getBufferCharacters	.\text\StringBuilder.h	/^ALWAYS_INLINE UChar* StringBuilder::getBufferCharacters<UChar>()$/;"	f	class:WTF::StringBuilder	signature:()
WTF::StringBuilder::is8Bit	.\text\StringBuilder.h	/^    bool is8Bit() const { return m_is8Bit; }$/;"	f	class:WTF::StringBuilder	access:public	signature:() const
WTF::StringBuilder::isEmpty	.\text\StringBuilder.h	/^    bool isEmpty() const { return !m_length; }$/;"	f	class:WTF::StringBuilder	access:public	signature:() const
WTF::StringBuilder::length	.\text\StringBuilder.h	/^    unsigned length() const$/;"	f	class:WTF::StringBuilder	access:public	signature:() const
WTF::StringBuilder::m_buffer	.\text\StringBuilder.h	/^    RefPtr<StringImpl> m_buffer;$/;"	m	class:WTF::StringBuilder	access:private
WTF::StringBuilder::m_is8Bit	.\text\StringBuilder.h	/^    bool m_is8Bit;$/;"	m	class:WTF::StringBuilder	access:private
WTF::StringBuilder::m_length	.\text\StringBuilder.h	/^    unsigned m_length;$/;"	m	class:WTF::StringBuilder	access:private
WTF::StringBuilder::m_string	.\text\StringBuilder.h	/^    mutable String m_string;$/;"	m	class:WTF::StringBuilder	access:private
WTF::StringBuilder::m_valid16BitShadowLength	.\text\StringBuilder.h	/^    mutable unsigned m_valid16BitShadowLength;$/;"	m	class:WTF::StringBuilder	access:private
WTF::StringBuilder::operator []	.\text\StringBuilder.h	/^    UChar operator[](unsigned i) const$/;"	f	class:WTF::StringBuilder	access:public	signature:(unsigned i) const
WTF::StringBuilder::reallocateBuffer	.\text\StringBuilder.cpp	/^void StringBuilder::reallocateBuffer<LChar>(unsigned requiredLength)$/;"	f	class:WTF::StringBuilder	signature:(unsigned requiredLength)
WTF::StringBuilder::reallocateBuffer	.\text\StringBuilder.cpp	/^void StringBuilder::reallocateBuffer<UChar>(unsigned requiredLength)$/;"	f	class:WTF::StringBuilder	signature:(unsigned requiredLength)
WTF::StringBuilder::reallocateBuffer	.\text\StringBuilder.h	/^    void reallocateBuffer(unsigned requiredLength);$/;"	p	class:WTF::StringBuilder	access:private	signature:(unsigned requiredLength)
WTF::StringBuilder::reifyString	.\text\StringBuilder.cpp	/^void StringBuilder::reifyString() const$/;"	f	class:WTF::StringBuilder	signature:() const
WTF::StringBuilder::reifyString	.\text\StringBuilder.h	/^    WTF_EXPORT_PRIVATE void reifyString() const;$/;"	p	class:WTF::StringBuilder	access:private	signature:() const
WTF::StringBuilder::reserveCapacity	.\text\StringBuilder.cpp	/^void StringBuilder::reserveCapacity(unsigned newCapacity)$/;"	f	class:WTF::StringBuilder	signature:(unsigned newCapacity)
WTF::StringBuilder::reserveCapacity	.\text\StringBuilder.h	/^    WTF_EXPORT_PRIVATE void reserveCapacity(unsigned newCapacity);$/;"	p	class:WTF::StringBuilder	access:public	signature:(unsigned newCapacity)
WTF::StringBuilder::resize	.\text\StringBuilder.cpp	/^void StringBuilder::resize(unsigned newSize)$/;"	f	class:WTF::StringBuilder	signature:(unsigned newSize)
WTF::StringBuilder::resize	.\text\StringBuilder.h	/^    WTF_EXPORT_PRIVATE void resize(unsigned newSize);$/;"	p	class:WTF::StringBuilder	access:public	signature:(unsigned newSize)
WTF::StringBuilder::shrinkToFit	.\text\StringBuilder.cpp	/^void StringBuilder::shrinkToFit()$/;"	f	class:WTF::StringBuilder	signature:()
WTF::StringBuilder::shrinkToFit	.\text\StringBuilder.h	/^    WTF_EXPORT_PRIVATE void shrinkToFit();$/;"	p	class:WTF::StringBuilder	access:public	signature:()
WTF::StringBuilder::swap	.\text\StringBuilder.h	/^    void swap(StringBuilder& stringBuilder)$/;"	f	class:WTF::StringBuilder	access:public	signature:(StringBuilder& stringBuilder)
WTF::StringBuilder::toAtomicString	.\text\StringBuilder.h	/^    AtomicString toAtomicString() const$/;"	f	class:WTF::StringBuilder	access:public	signature:() const
WTF::StringBuilder::toString	.\text\StringBuilder.h	/^    String toString()$/;"	f	class:WTF::StringBuilder	access:public	signature:()
WTF::StringBuilder::toStringPreserveCapacity	.\text\StringBuilder.h	/^    const String& toStringPreserveCapacity() const$/;"	f	class:WTF::StringBuilder	access:public	signature:() const
WTF::StringHash	.\text\StringHash.h	/^    struct StringHash {$/;"	s	namespace:WTF
WTF::StringHash::equal	.\text\StringHash.h	/^        static bool equal(const RefPtr<StringImpl>& a, const RefPtr<StringImpl>& b)$/;"	f	struct:WTF::StringHash	access:public	signature:(const RefPtr<StringImpl>& a, const RefPtr<StringImpl>& b)
WTF::StringHash::equal	.\text\StringHash.h	/^        static bool equal(const String& a, const String& b)$/;"	f	struct:WTF::StringHash	access:public	signature:(const String& a, const String& b)
WTF::StringHash::equal	.\text\StringHash.h	/^        static bool equal(const StringImpl* a, const StringImpl* b)$/;"	f	struct:WTF::StringHash	access:public	signature:(const StringImpl* a, const StringImpl* b)
WTF::StringHash::hash	.\text\StringHash.h	/^        static unsigned hash(StringImpl* key) { return key->hash(); }$/;"	f	struct:WTF::StringHash	access:public	signature:(StringImpl* key)
WTF::StringHash::hash	.\text\StringHash.h	/^        static unsigned hash(const RefPtr<StringImpl>& key) { return key->hash(); }$/;"	f	struct:WTF::StringHash	access:public	signature:(const RefPtr<StringImpl>& key)
WTF::StringHash::hash	.\text\StringHash.h	/^        static unsigned hash(const String& key) { return key.impl()->hash(); }$/;"	f	struct:WTF::StringHash	access:public	signature:(const String& key)
WTF::StringHash::safeToCompareToEmptyOrDeleted	.\text\StringHash.h	/^        static const bool safeToCompareToEmptyOrDeleted = false;$/;"	m	struct:WTF::StringHash	access:public
WTF::StringHasher	.\StringHasher.h	/^class StringHasher {$/;"	c	namespace:WTF
WTF::StringHasher::StringHasher	.\StringHasher.h	/^    inline StringHasher()$/;"	f	class:WTF::StringHasher	access:public	signature:()
WTF::StringHasher::addCharacter	.\StringHasher.h	/^    inline void addCharacter(UChar ch)$/;"	f	class:WTF::StringHasher	access:public	signature:(UChar ch)
WTF::StringHasher::addCharacters	.\StringHasher.h	/^    inline void addCharacters(UChar a, UChar b)$/;"	f	class:WTF::StringHasher	access:public	signature:(UChar a, UChar b)
WTF::StringHasher::addCharactersToHash	.\StringHasher.h	/^    inline void addCharactersToHash(UChar a, UChar b)$/;"	f	class:WTF::StringHasher	access:private	signature:(UChar a, UChar b)
WTF::StringHasher::computeHash	.\StringHasher.h	/^    template<typename T, UChar Converter(T)> static inline unsigned computeHash(const T* data)$/;"	f	class:WTF::StringHasher	access:public	signature:(const T* data)
WTF::StringHasher::computeHash	.\StringHasher.h	/^    template<typename T, UChar Converter(T)> static inline unsigned computeHash(const T* data, unsigned length)$/;"	f	class:WTF::StringHasher	access:public	signature:(const T* data, unsigned length)
WTF::StringHasher::computeHash	.\StringHasher.h	/^    template<typename T> static inline unsigned computeHash(const T* data)$/;"	f	class:WTF::StringHasher	access:public	signature:(const T* data)
WTF::StringHasher::computeHash	.\StringHasher.h	/^    template<typename T> static inline unsigned computeHash(const T* data, unsigned length)$/;"	f	class:WTF::StringHasher	access:public	signature:(const T* data, unsigned length)
WTF::StringHasher::defaultConverter	.\StringHasher.h	/^    static inline UChar defaultConverter(LChar ch)$/;"	f	class:WTF::StringHasher	access:private	signature:(LChar ch)
WTF::StringHasher::defaultConverter	.\StringHasher.h	/^    static inline UChar defaultConverter(UChar ch)$/;"	f	class:WTF::StringHasher	access:private	signature:(UChar ch)
WTF::StringHasher::flagCount	.\StringHasher.h	/^    static const unsigned flagCount = 8; \/\/ Save 8 bits for StringImpl to use as flags.$/;"	m	class:WTF::StringHasher	access:public
WTF::StringHasher::hash	.\StringHasher.h	/^    inline unsigned hash() const$/;"	f	class:WTF::StringHasher	access:public	signature:() const
WTF::StringHasher::hashMemory	.\StringHasher.h	/^    static inline unsigned hashMemory(const void* data, unsigned size)$/;"	f	class:WTF::StringHasher	access:public	signature:(const void* data, unsigned size)
WTF::StringHasher::hashMemory	.\StringHasher.h	/^    template<size_t length> static inline unsigned hashMemory(const void* data)$/;"	f	class:WTF::StringHasher	access:public	signature:(const void* data)
WTF::StringHasher::m_hasPendingCharacter	.\StringHasher.h	/^    bool m_hasPendingCharacter;$/;"	m	class:WTF::StringHasher	access:private
WTF::StringHasher::m_hash	.\StringHasher.h	/^    unsigned m_hash;$/;"	m	class:WTF::StringHasher	access:private
WTF::StringHasher::m_pendingCharacter	.\StringHasher.h	/^    UChar m_pendingCharacter;$/;"	m	class:WTF::StringHasher	access:private
WTF::StringImpl	.\text\StringImpl.h	/^class StringImpl {$/;"	c	namespace:WTF
WTF::StringImpl::BufferInternal	.\text\StringImpl.h	/^        BufferInternal,$/;"	e	enum:WTF::StringImpl::BufferOwnership
WTF::StringImpl::BufferOwned	.\text\StringImpl.h	/^        BufferOwned,$/;"	e	enum:WTF::StringImpl::BufferOwnership
WTF::StringImpl::BufferOwnership	.\text\StringImpl.h	/^    enum BufferOwnership {$/;"	g	class:WTF::StringImpl	access:private
WTF::StringImpl::BufferSubstring	.\text\StringImpl.h	/^        BufferSubstring,$/;"	e	enum:WTF::StringImpl::BufferOwnership
WTF::StringImpl::COMPILE_ASSERT	.\text\StringImpl.h	/^    COMPILE_ASSERT(s_flagCount == StringHasher::flagCount, StringHasher_reserves_enough_bits_for_StringImpl_flags);$/;"	p	class:WTF::StringImpl	access:private	signature:(s_flagCount == StringHasher::flagCount, StringHasher_reserves_enough_bits_for_StringImpl_flags)
WTF::StringImpl::ConstructStaticString	.\text\StringImpl.h	/^    enum ConstructStaticStringTag { ConstructStaticString };$/;"	e	enum:WTF::StringImpl::ConstructStaticStringTag
WTF::StringImpl::ConstructStaticStringTag	.\text\StringImpl.h	/^    enum ConstructStaticStringTag { ConstructStaticString };$/;"	g	class:WTF::StringImpl	access:private
WTF::StringImpl::Force8Bit	.\text\StringImpl.h	/^    enum Force8Bit { Force8BitConstructor };$/;"	g	class:WTF::StringImpl	access:private
WTF::StringImpl::Force8BitConstructor	.\text\StringImpl.h	/^    enum Force8Bit { Force8BitConstructor };$/;"	e	enum:WTF::StringImpl::Force8Bit
WTF::StringImpl::StringImpl	.\text\StringImpl.h	/^    StringImpl(const LChar* characters, unsigned length)$/;"	f	class:WTF::StringImpl	access:private	signature:(const LChar* characters, unsigned length)
WTF::StringImpl::StringImpl	.\text\StringImpl.h	/^    StringImpl(const LChar* characters, unsigned length, ConstructStaticStringTag)$/;"	f	class:WTF::StringImpl	access:private	signature:(const LChar* characters, unsigned length, ConstructStaticStringTag)
WTF::StringImpl::StringImpl	.\text\StringImpl.h	/^    StringImpl(const LChar* characters, unsigned length, PassRefPtr<StringImpl> base)$/;"	f	class:WTF::StringImpl	access:private	signature:(const LChar* characters, unsigned length, PassRefPtr<StringImpl> base)
WTF::StringImpl::StringImpl	.\text\StringImpl.h	/^    StringImpl(const UChar* characters, unsigned length)$/;"	f	class:WTF::StringImpl	access:private	signature:(const UChar* characters, unsigned length)
WTF::StringImpl::StringImpl	.\text\StringImpl.h	/^    StringImpl(const UChar* characters, unsigned length, ConstructStaticStringTag)$/;"	f	class:WTF::StringImpl	access:private	signature:(const UChar* characters, unsigned length, ConstructStaticStringTag)
WTF::StringImpl::StringImpl	.\text\StringImpl.h	/^    StringImpl(const UChar* characters, unsigned length, PassRefPtr<StringImpl> base)$/;"	f	class:WTF::StringImpl	access:private	signature:(const UChar* characters, unsigned length, PassRefPtr<StringImpl> base)
WTF::StringImpl::StringImpl	.\text\StringImpl.h	/^    StringImpl(unsigned length)$/;"	f	class:WTF::StringImpl	access:private	signature:(unsigned length)
WTF::StringImpl::StringImpl	.\text\StringImpl.h	/^    StringImpl(unsigned length, Force8Bit)$/;"	f	class:WTF::StringImpl	access:private	signature:(unsigned length, Force8Bit)
WTF::StringImpl::WTF_MAKE_FAST_ALLOCATED	.\text\StringImpl.h	/^    WTF_MAKE_NONCOPYABLE(StringImpl); WTF_MAKE_FAST_ALLOCATED;$/;"	m	class:WTF::StringImpl	access:private
WTF::StringImpl::WTF_MAKE_NONCOPYABLE	.\text\StringImpl.h	/^    WTF_MAKE_NONCOPYABLE(StringImpl); WTF_MAKE_FAST_ALLOCATED;$/;"	p	class:WTF::StringImpl	access:private	signature:(StringImpl)
WTF::StringImpl::__anon11::m_data16	.\text\StringImpl.h	/^        const UChar* m_data16;$/;"	m	union:WTF::StringImpl::__anon11	access:public
WTF::StringImpl::__anon11::m_data8	.\text\StringImpl.h	/^        const LChar* m_data8;$/;"	m	union:WTF::StringImpl::__anon11	access:public
WTF::StringImpl::__anon12::m_buffer	.\text\StringImpl.h	/^        void* m_buffer;$/;"	m	union:WTF::StringImpl::__anon12	access:public
WTF::StringImpl::__anon12::m_copyData16	.\text\StringImpl.h	/^        mutable UChar* m_copyData16;$/;"	m	union:WTF::StringImpl::__anon12	access:public
WTF::StringImpl::__anon12::m_substringBuffer	.\text\StringImpl.h	/^        StringImpl* m_substringBuffer;$/;"	m	union:WTF::StringImpl::__anon12	access:public
WTF::StringImpl::adopt	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::adopt(StringBuffer<LChar>& buffer)$/;"	f	class:WTF::StringImpl	signature:(StringBuffer<LChar>& buffer)
WTF::StringImpl::adopt	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::adopt(StringBuffer<UChar>& buffer)$/;"	f	class:WTF::StringImpl	signature:(StringBuffer<UChar>& buffer)
WTF::StringImpl::adopt	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE static PassRefPtr<StringImpl> adopt(StringBuffer<UChar>& buffer);$/;"	p	class:WTF::StringImpl	access:public	signature:(StringBuffer<UChar>& buffer)
WTF::StringImpl::adopt	.\text\StringImpl.h	/^    static PassRefPtr<StringImpl> adopt(StringBuffer<LChar>& buffer);$/;"	p	class:WTF::StringImpl	access:public	signature:(StringBuffer<LChar>& buffer)
WTF::StringImpl::adopt	.\text\StringImpl.h	/^    static PassRefPtr<StringImpl> adopt(Vector<CharType, inlineCapacity>& vector)$/;"	f	class:WTF::StringImpl	access:public	signature:(Vector<CharType, inlineCapacity>& vector)
WTF::StringImpl::bufferOwnership	.\text\StringImpl.h	/^    BufferOwnership bufferOwnership() const { return static_cast<BufferOwnership>(m_hashAndFlags & s_hashMaskBufferOwnership); }$/;"	f	class:WTF::StringImpl	access:private	signature:() const
WTF::StringImpl::characterStartingAt	.\text\StringImpl.cpp	/^UChar32 StringImpl::characterStartingAt(unsigned i)$/;"	f	class:WTF::StringImpl	signature:(unsigned i)
WTF::StringImpl::characterStartingAt	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE UChar32 characterStartingAt(unsigned);$/;"	p	class:WTF::StringImpl	access:public	signature:(unsigned)
WTF::StringImpl::characters	.\text\StringImpl.h	/^    ALWAYS_INLINE const UChar* characters() const$/;"	f	class:WTF::StringImpl	access:public	signature:() const
WTF::StringImpl::characters16	.\text\StringImpl.h	/^    ALWAYS_INLINE const UChar* characters16() const { ASSERT(!is8Bit()); return m_data16; }$/;"	f	class:WTF::StringImpl	access:public	signature:() const
WTF::StringImpl::characters8	.\text\StringImpl.h	/^    ALWAYS_INLINE const LChar* characters8() const { ASSERT(is8Bit()); return m_data8; }$/;"	f	class:WTF::StringImpl	access:public	signature:() const
WTF::StringImpl::containsOnlyWhitespace	.\text\StringImpl.cpp	/^bool StringImpl::containsOnlyWhitespace()$/;"	f	class:WTF::StringImpl	signature:()
WTF::StringImpl::containsOnlyWhitespace	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE bool containsOnlyWhitespace();$/;"	p	class:WTF::StringImpl	access:public	signature:()
WTF::StringImpl::copyChars	.\text\StringImpl.h	/^    template <typename T> static void copyChars(T* destination, const T* source, unsigned numCharacters)$/;"	f	class:WTF::StringImpl	access:public	signature:(T* destination, const T* source, unsigned numCharacters)
WTF::StringImpl::cost	.\text\StringImpl.h	/^    size_t cost()$/;"	f	class:WTF::StringImpl	access:public	signature:()
WTF::StringImpl::create	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::create(const LChar* characters, unsigned length)$/;"	f	class:WTF::StringImpl	signature:(const LChar* characters, unsigned length)
WTF::StringImpl::create	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::create(const LChar* string)$/;"	f	class:WTF::StringImpl	signature:(const LChar* string)
WTF::StringImpl::create	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::create(const UChar* characters, unsigned length)$/;"	f	class:WTF::StringImpl	signature:(const UChar* characters, unsigned length)
WTF::StringImpl::create	.\text\StringImpl.h	/^    ALWAYS_INLINE static PassRefPtr<StringImpl> create(const char* s) { return create(reinterpret_cast<const LChar*>(s)); }$/;"	f	class:WTF::StringImpl	access:public	signature:(const char* s)
WTF::StringImpl::create	.\text\StringImpl.h	/^    ALWAYS_INLINE static PassRefPtr<StringImpl> create(const char* s, unsigned length) { return create(reinterpret_cast<const LChar*>(s), length); }$/;"	f	class:WTF::StringImpl	access:public	signature:(const char* s, unsigned length)
WTF::StringImpl::create	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE static PassRefPtr<StringImpl> create(const LChar*);$/;"	p	class:WTF::StringImpl	access:public	signature:(const LChar*)
WTF::StringImpl::create	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE static PassRefPtr<StringImpl> create(const UChar*, unsigned length);$/;"	p	class:WTF::StringImpl	access:public	signature:(const UChar*, unsigned length)
WTF::StringImpl::create	.\text\StringImpl.h	/^    static ALWAYS_INLINE PassRefPtr<StringImpl> create(PassRefPtr<StringImpl> rep, unsigned offset, unsigned length)$/;"	f	class:WTF::StringImpl	access:public	signature:(PassRefPtr<StringImpl> rep, unsigned offset, unsigned length)
WTF::StringImpl::create	.\text\StringImpl.h	/^    static PassRefPtr<StringImpl> create(const LChar*, unsigned length);$/;"	p	class:WTF::StringImpl	access:public	signature:(const LChar*, unsigned length)
WTF::StringImpl::create8	.\text\StringImpl.h	/^    static ALWAYS_INLINE PassRefPtr<StringImpl> create8(PassRefPtr<StringImpl> rep, unsigned offset, unsigned length)$/;"	f	class:WTF::StringImpl	access:public	signature:(PassRefPtr<StringImpl> rep, unsigned offset, unsigned length)
WTF::StringImpl::createCFString	.\text\StringImpl.h	/^    CFStringRef createCFString();$/;"	p	class:WTF::StringImpl	access:public	signature:()
WTF::StringImpl::createUninitialized	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::createUninitialized(unsigned length, LChar*& data)$/;"	f	class:WTF::StringImpl	signature:(unsigned length, LChar*& data)
WTF::StringImpl::createUninitialized	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::createUninitialized(unsigned length, UChar*& data)$/;"	f	class:WTF::StringImpl	signature:(unsigned length, UChar*& data)
WTF::StringImpl::createUninitialized	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE static PassRefPtr<StringImpl> createUninitialized(unsigned length, UChar*& data);$/;"	p	class:WTF::StringImpl	access:public	signature:(unsigned length, UChar*& data)
WTF::StringImpl::createUninitialized	.\text\StringImpl.h	/^    static PassRefPtr<StringImpl> createUninitialized(unsigned length, LChar*& data);$/;"	p	class:WTF::StringImpl	access:public	signature:(unsigned length, LChar*& data)
WTF::StringImpl::createWithTerminatingNullCharacter	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::createWithTerminatingNullCharacter(const StringImpl& string)$/;"	f	class:WTF::StringImpl	signature:(const StringImpl& string)
WTF::StringImpl::createWithTerminatingNullCharacter	.\text\StringImpl.h	/^    static PassRefPtr<StringImpl> createWithTerminatingNullCharacter(const StringImpl&);$/;"	p	class:WTF::StringImpl	access:public	signature:(const StringImpl&)
WTF::StringImpl::dataOffset	.\text\StringImpl.h	/^    static unsigned dataOffset() { return OBJECT_OFFSETOF(StringImpl, m_data8); }$/;"	f	class:WTF::StringImpl	access:public	signature:()
WTF::StringImpl::defaultWritingDirection	.\text\StringImpl.cpp	/^WTF::Unicode::Direction StringImpl::defaultWritingDirection(bool* hasStrongDirectionality)$/;"	f	class:WTF::StringImpl	signature:(bool* hasStrongDirectionality)
WTF::StringImpl::defaultWritingDirection	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE WTF::Unicode::Direction defaultWritingDirection(bool* hasStrongDirectionality = 0);$/;"	p	class:WTF::StringImpl	access:public	signature:(bool* hasStrongDirectionality = 0)
WTF::StringImpl::deref	.\text\StringImpl.h	/^    inline void deref()$/;"	f	class:WTF::StringImpl	access:public	signature:()
WTF::StringImpl::empty	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE static StringImpl* empty();$/;"	p	class:WTF::StringImpl	access:public	signature:()
WTF::StringImpl::empty	.\text\StringStatics.cpp	/^StringImpl* StringImpl::empty()$/;"	f	class:WTF::StringImpl	signature:()
WTF::StringImpl::endsWith	.\text\StringImpl.cpp	/^bool StringImpl::endsWith(StringImpl* matchString, bool caseSensitive)$/;"	f	class:WTF::StringImpl	signature:(StringImpl* matchString, bool caseSensitive)
WTF::StringImpl::endsWith	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE bool endsWith(StringImpl*, bool caseSensitive = true);$/;"	p	class:WTF::StringImpl	access:public	signature:(StringImpl*, bool caseSensitive = true)
WTF::StringImpl::existingHash	.\text\StringImpl.h	/^    unsigned existingHash() const$/;"	f	class:WTF::StringImpl	access:public	signature:() const
WTF::StringImpl::fill	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::fill(UChar character)$/;"	f	class:WTF::StringImpl	signature:(UChar character)
WTF::StringImpl::fill	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE PassRefPtr<StringImpl> fill(UChar);$/;"	p	class:WTF::StringImpl	access:public	signature:(UChar)
WTF::StringImpl::find	.\text\StringImpl.cpp	/^size_t StringImpl::find(CharacterMatchFunctionPtr matchFunction, unsigned start)$/;"	f	class:WTF::StringImpl	signature:(CharacterMatchFunctionPtr matchFunction, unsigned start)
WTF::StringImpl::find	.\text\StringImpl.cpp	/^size_t StringImpl::find(StringImpl* matchString, unsigned index)$/;"	f	class:WTF::StringImpl	signature:(StringImpl* matchString, unsigned index)
WTF::StringImpl::find	.\text\StringImpl.cpp	/^size_t StringImpl::find(UChar c, unsigned start)$/;"	f	class:WTF::StringImpl	signature:(UChar c, unsigned start)
WTF::StringImpl::find	.\text\StringImpl.cpp	/^size_t StringImpl::find(const LChar* matchString, unsigned index)$/;"	f	class:WTF::StringImpl	signature:(const LChar* matchString, unsigned index)
WTF::StringImpl::find	.\text\StringImpl.h	/^    ALWAYS_INLINE size_t find(const char* s, unsigned index = 0) { return find(reinterpret_cast<const LChar*>(s), index); };$/;"	f	class:WTF::StringImpl	access:public	signature:(const char* s, unsigned index = 0)
WTF::StringImpl::find	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE size_t find(CharacterMatchFunctionPtr, unsigned index = 0);$/;"	p	class:WTF::StringImpl	access:public	signature:(CharacterMatchFunctionPtr, unsigned index = 0)
WTF::StringImpl::find	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE size_t find(StringImpl*, unsigned index = 0);$/;"	p	class:WTF::StringImpl	access:public	signature:(StringImpl*, unsigned index = 0)
WTF::StringImpl::find	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE size_t find(UChar, unsigned index = 0);$/;"	p	class:WTF::StringImpl	access:public	signature:(UChar, unsigned index = 0)
WTF::StringImpl::find	.\text\StringImpl.h	/^    size_t find(const LChar*, unsigned index = 0);$/;"	p	class:WTF::StringImpl	access:public	signature:(const LChar*, unsigned index = 0)
WTF::StringImpl::findIgnoringCase	.\text\StringImpl.cpp	/^size_t StringImpl::findIgnoringCase(StringImpl* matchString, unsigned index)$/;"	f	class:WTF::StringImpl	signature:(StringImpl* matchString, unsigned index)
WTF::StringImpl::findIgnoringCase	.\text\StringImpl.cpp	/^size_t StringImpl::findIgnoringCase(const LChar* matchString, unsigned index)$/;"	f	class:WTF::StringImpl	signature:(const LChar* matchString, unsigned index)
WTF::StringImpl::findIgnoringCase	.\text\StringImpl.h	/^    ALWAYS_INLINE size_t findIgnoringCase(const char* s, unsigned index = 0) { return findIgnoringCase(reinterpret_cast<const LChar*>(s), index); };$/;"	f	class:WTF::StringImpl	access:public	signature:(const char* s, unsigned index = 0)
WTF::StringImpl::findIgnoringCase	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE size_t findIgnoringCase(StringImpl*, unsigned index = 0);$/;"	p	class:WTF::StringImpl	access:public	signature:(StringImpl*, unsigned index = 0)
WTF::StringImpl::findIgnoringCase	.\text\StringImpl.h	/^    size_t findIgnoringCase(const LChar*, unsigned index = 0);$/;"	p	class:WTF::StringImpl	access:public	signature:(const LChar*, unsigned index = 0)
WTF::StringImpl::flagIs8Bit	.\text\StringImpl.h	/^    static unsigned flagIs8Bit() { return s_hashFlag8BitBuffer; }$/;"	f	class:WTF::StringImpl	access:public	signature:()
WTF::StringImpl::flagsOffset	.\text\StringImpl.h	/^    static unsigned flagsOffset() { return OBJECT_OFFSETOF(StringImpl, m_hashAndFlags); }$/;"	f	class:WTF::StringImpl	access:public	signature:()
WTF::StringImpl::foldCase	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::foldCase()$/;"	f	class:WTF::StringImpl	signature:()
WTF::StringImpl::foldCase	.\text\StringImpl.h	/^    PassRefPtr<StringImpl> foldCase();$/;"	p	class:WTF::StringImpl	access:public	signature:()
WTF::StringImpl::getCharacters	.\text\StringImpl.h	/^    ALWAYS_INLINE const CharType * getCharacters() const;$/;"	p	class:WTF::StringImpl	access:public	signature:() const
WTF::StringImpl::getCharacters	.\text\StringImpl.h	/^ALWAYS_INLINE const LChar* StringImpl::getCharacters<LChar>() const { return characters8(); }$/;"	f	class:WTF::StringImpl	signature:() const
WTF::StringImpl::getCharacters	.\text\StringImpl.h	/^ALWAYS_INLINE const UChar* StringImpl::getCharacters<UChar>() const { return characters(); }$/;"	f	class:WTF::StringImpl	signature:() const
WTF::StringImpl::getData16SlowCase	.\text\StringImpl.cpp	/^const UChar* StringImpl::getData16SlowCase() const$/;"	f	class:WTF::StringImpl	signature:() const
WTF::StringImpl::getData16SlowCase	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE NEVER_INLINE const UChar* getData16SlowCase() const;$/;"	p	class:WTF::StringImpl	access:private	signature:() const
WTF::StringImpl::has16BitShadow	.\text\StringImpl.h	/^    bool has16BitShadow() const { return m_hashAndFlags & s_hashFlagHas16BitShadow; }$/;"	f	class:WTF::StringImpl	access:public	signature:() const
WTF::StringImpl::hasHash	.\text\StringImpl.h	/^    bool hasHash() const$/;"	f	class:WTF::StringImpl	access:public	signature:() const
WTF::StringImpl::hasOneRef	.\text\StringImpl.h	/^    inline bool hasOneRef() const$/;"	f	class:WTF::StringImpl	access:public	signature:() const
WTF::StringImpl::hasTerminatingNullCharacter	.\text\StringImpl.h	/^    bool hasTerminatingNullCharacter() const { return m_hashAndFlags & s_hashFlagHasTerminatingNullCharacter; }$/;"	f	class:WTF::StringImpl	access:public	signature:() const
WTF::StringImpl::hash	.\text\StringImpl.h	/^    unsigned hash() const$/;"	f	class:WTF::StringImpl	access:public	signature:() const
WTF::StringImpl::hashSlowCase	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE NEVER_INLINE unsigned hashSlowCase() const;$/;"	p	class:WTF::StringImpl	access:private	signature:() const
WTF::StringImpl::hashSlowCase	.\text\StringStatics.cpp	/^NEVER_INLINE unsigned StringImpl::hashSlowCase() const$/;"	f	class:WTF::StringImpl	signature:() const
WTF::StringImpl::is8Bit	.\text\StringImpl.h	/^    bool is8Bit() const { return m_hashAndFlags & s_hashFlag8BitBuffer; }$/;"	f	class:WTF::StringImpl	access:public	signature:() const
WTF::StringImpl::isAtomic	.\text\StringImpl.h	/^    bool isAtomic() const { return m_hashAndFlags & s_hashFlagIsAtomic; }$/;"	f	class:WTF::StringImpl	access:public	signature:() const
WTF::StringImpl::isIdentifier	.\text\StringImpl.h	/^    bool isIdentifier() const { return m_hashAndFlags & s_hashFlagIsIdentifier; }$/;"	f	class:WTF::StringImpl	access:public	signature:() const
WTF::StringImpl::isStatic	.\text\StringImpl.h	/^    bool isStatic() const { return m_refCount & s_refCountFlagIsStaticString; }$/;"	f	class:WTF::StringImpl	access:private	signature:() const
WTF::StringImpl::isolatedCopy	.\text\StringImpl.h	/^    PassRefPtr<StringImpl> isolatedCopy() const;$/;"	p	class:WTF::StringImpl	access:public	signature:() const
WTF::StringImpl::isolatedCopy	.\text\StringImpl.h	/^inline PassRefPtr<StringImpl> StringImpl::isolatedCopy() const$/;"	f	class:WTF::StringImpl	signature:() const
WTF::StringImpl::length	.\text\StringImpl.h	/^    unsigned length() const { return m_length; }$/;"	f	class:WTF::StringImpl	access:public	signature:() const
WTF::StringImpl::lower	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::lower()$/;"	f	class:WTF::StringImpl	signature:()
WTF::StringImpl::lower	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE PassRefPtr<StringImpl> lower();$/;"	p	class:WTF::StringImpl	access:public	signature:()
WTF::StringImpl::m_hashAndFlags	.\text\StringImpl.h	/^    mutable unsigned m_hashAndFlags;$/;"	m	class:WTF::StringImpl	access:private
WTF::StringImpl::m_length	.\text\StringImpl.h	/^    unsigned m_length;$/;"	m	class:WTF::StringImpl	access:private
WTF::StringImpl::m_refCount	.\text\StringImpl.h	/^    unsigned m_refCount;$/;"	m	class:WTF::StringImpl	access:private
WTF::StringImpl::operator NSString*	.\text\StringImpl.h	/^    operator NSString*();$/;"	p	class:WTF::StringImpl	access:public	signature:()
WTF::StringImpl::operator []	.\text\StringImpl.h	/^    UChar operator[](unsigned i) const$/;"	f	class:WTF::StringImpl	access:public	signature:(unsigned i) const
WTF::StringImpl::rawHash	.\text\StringImpl.h	/^    unsigned rawHash() const$/;"	f	class:WTF::StringImpl	access:private	signature:() const
WTF::StringImpl::reallocate	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::reallocate(PassRefPtr<StringImpl> originalString, unsigned length, LChar*& data)$/;"	f	class:WTF::StringImpl	signature:(PassRefPtr<StringImpl> originalString, unsigned length, LChar*& data)
WTF::StringImpl::reallocate	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::reallocate(PassRefPtr<StringImpl> originalString, unsigned length, UChar*& data)$/;"	f	class:WTF::StringImpl	signature:(PassRefPtr<StringImpl> originalString, unsigned length, UChar*& data)
WTF::StringImpl::reallocate	.\text\StringImpl.h	/^    static PassRefPtr<StringImpl> reallocate(PassRefPtr<StringImpl> originalString, unsigned length, LChar*& data);$/;"	p	class:WTF::StringImpl	access:public	signature:(PassRefPtr<StringImpl> originalString, unsigned length, LChar*& data)
WTF::StringImpl::reallocate	.\text\StringImpl.h	/^    static PassRefPtr<StringImpl> reallocate(PassRefPtr<StringImpl> originalString, unsigned length, UChar*& data);$/;"	p	class:WTF::StringImpl	access:public	signature:(PassRefPtr<StringImpl> originalString, unsigned length, UChar*& data)
WTF::StringImpl::ref	.\text\StringImpl.h	/^    inline void ref()$/;"	f	class:WTF::StringImpl	access:public	signature:()
WTF::StringImpl::removeCharacters	.\text\StringImpl.cpp	/^ALWAYS_INLINE PassRefPtr<StringImpl> StringImpl::removeCharacters(const CharType* characters, CharacterMatchFunctionPtr findMatch)$/;"	f	class:WTF::StringImpl	signature:(const CharType* characters, CharacterMatchFunctionPtr findMatch)
WTF::StringImpl::removeCharacters	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::removeCharacters(CharacterMatchFunctionPtr findMatch)$/;"	f	class:WTF::StringImpl	signature:(CharacterMatchFunctionPtr findMatch)
WTF::StringImpl::removeCharacters	.\text\StringImpl.h	/^    ALWAYS_INLINE PassRefPtr<StringImpl> removeCharacters(const CharType* characters, CharacterMatchFunctionPtr);$/;"	p	class:WTF::StringImpl	access:public	signature:(const CharType* characters, CharacterMatchFunctionPtr)
WTF::StringImpl::removeCharacters	.\text\StringImpl.h	/^    PassRefPtr<StringImpl> removeCharacters(CharacterMatchFunctionPtr);$/;"	p	class:WTF::StringImpl	access:public	signature:(CharacterMatchFunctionPtr)
WTF::StringImpl::replace	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::replace(StringImpl* pattern, StringImpl* replacement)$/;"	f	class:WTF::StringImpl	signature:(StringImpl* pattern, StringImpl* replacement)
WTF::StringImpl::replace	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::replace(UChar oldC, UChar newC)$/;"	f	class:WTF::StringImpl	signature:(UChar oldC, UChar newC)
WTF::StringImpl::replace	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::replace(UChar pattern, StringImpl* replacement)$/;"	f	class:WTF::StringImpl	signature:(UChar pattern, StringImpl* replacement)
WTF::StringImpl::replace	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::replace(unsigned position, unsigned lengthToReplace, StringImpl* str)$/;"	f	class:WTF::StringImpl	signature:(unsigned position, unsigned lengthToReplace, StringImpl* str)
WTF::StringImpl::replace	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE PassRefPtr<StringImpl> replace(StringImpl*, StringImpl*);$/;"	p	class:WTF::StringImpl	access:public	signature:(StringImpl*, StringImpl*)
WTF::StringImpl::replace	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE PassRefPtr<StringImpl> replace(UChar, StringImpl*);$/;"	p	class:WTF::StringImpl	access:public	signature:(UChar, StringImpl*)
WTF::StringImpl::replace	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE PassRefPtr<StringImpl> replace(UChar, UChar);$/;"	p	class:WTF::StringImpl	access:public	signature:(UChar, UChar)
WTF::StringImpl::replace	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE PassRefPtr<StringImpl> replace(unsigned index, unsigned len, StringImpl*);$/;"	p	class:WTF::StringImpl	access:public	signature:(unsigned index, unsigned len, StringImpl*)
WTF::StringImpl::reverseFind	.\text\StringImpl.cpp	/^size_t StringImpl::reverseFind(StringImpl* matchString, unsigned index)$/;"	f	class:WTF::StringImpl	signature:(StringImpl* matchString, unsigned index)
WTF::StringImpl::reverseFind	.\text\StringImpl.cpp	/^size_t StringImpl::reverseFind(UChar c, unsigned index)$/;"	f	class:WTF::StringImpl	signature:(UChar c, unsigned index)
WTF::StringImpl::reverseFind	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE size_t reverseFind(StringImpl*, unsigned index = UINT_MAX);$/;"	p	class:WTF::StringImpl	access:public	signature:(StringImpl*, unsigned index = UINT_MAX)
WTF::StringImpl::reverseFind	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE size_t reverseFind(UChar, unsigned index = UINT_MAX);$/;"	p	class:WTF::StringImpl	access:public	signature:(UChar, unsigned index = UINT_MAX)
WTF::StringImpl::reverseFindIgnoringCase	.\text\StringImpl.cpp	/^size_t StringImpl::reverseFindIgnoringCase(StringImpl* matchString, unsigned index)$/;"	f	class:WTF::StringImpl	signature:(StringImpl* matchString, unsigned index)
WTF::StringImpl::reverseFindIgnoringCase	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE size_t reverseFindIgnoringCase(StringImpl*, unsigned index = UINT_MAX);$/;"	p	class:WTF::StringImpl	access:public	signature:(StringImpl*, unsigned index = UINT_MAX)
WTF::StringImpl::s_copyCharsInlineCutOff	.\text\StringImpl.h	/^    static const unsigned s_copyCharsInlineCutOff = 20;$/;"	m	class:WTF::StringImpl	access:private
WTF::StringImpl::s_flagCount	.\text\StringImpl.h	/^    static const unsigned s_flagCount = 8;$/;"	m	class:WTF::StringImpl	access:private
WTF::StringImpl::s_flagMask	.\text\StringImpl.h	/^    static const unsigned s_flagMask = (1u << s_flagCount) - 1;$/;"	m	class:WTF::StringImpl	access:private
WTF::StringImpl::s_hashFlag8BitBuffer	.\text\StringImpl.h	/^    static const unsigned s_hashFlag8BitBuffer = 1u << 6;$/;"	m	class:WTF::StringImpl	access:private
WTF::StringImpl::s_hashFlagDidReportCost	.\text\StringImpl.h	/^    static const unsigned s_hashFlagDidReportCost = 1u << 3;$/;"	m	class:WTF::StringImpl	access:private
WTF::StringImpl::s_hashFlagHas16BitShadow	.\text\StringImpl.h	/^    static const unsigned s_hashFlagHas16BitShadow = 1u << 7;$/;"	m	class:WTF::StringImpl	access:private
WTF::StringImpl::s_hashFlagHasTerminatingNullCharacter	.\text\StringImpl.h	/^    static const unsigned s_hashFlagHasTerminatingNullCharacter = 1u << 5;$/;"	m	class:WTF::StringImpl	access:private
WTF::StringImpl::s_hashFlagIsAtomic	.\text\StringImpl.h	/^    static const unsigned s_hashFlagIsAtomic = 1u << 4;$/;"	m	class:WTF::StringImpl	access:private
WTF::StringImpl::s_hashFlagIsIdentifier	.\text\StringImpl.h	/^    static const unsigned s_hashFlagIsIdentifier = 1u << 2;$/;"	m	class:WTF::StringImpl	access:private
WTF::StringImpl::s_hashMaskBufferOwnership	.\text\StringImpl.h	/^    static const unsigned s_hashMaskBufferOwnership = 1u | (1u << 1);$/;"	m	class:WTF::StringImpl	access:private
WTF::StringImpl::s_refCountFlagIsStaticString	.\text\StringImpl.h	/^    static const unsigned s_refCountFlagIsStaticString = 0x1;$/;"	m	class:WTF::StringImpl	access:private
WTF::StringImpl::s_refCountIncrement	.\text\StringImpl.h	/^    static const unsigned s_refCountIncrement = 0x2; \/\/ This allows us to ref \/ deref without disturbing the static string flag.$/;"	m	class:WTF::StringImpl	access:private
WTF::StringImpl::setHash	.\text\StringImpl.h	/^    void setHash(unsigned hash) const$/;"	f	class:WTF::StringImpl	access:private	signature:(unsigned hash) const
WTF::StringImpl::setIsAtomic	.\text\StringImpl.h	/^    void setIsAtomic(bool isIdentifier)$/;"	f	class:WTF::StringImpl	access:public	signature:(bool isIdentifier)
WTF::StringImpl::setIsIdentifier	.\text\StringImpl.h	/^    void setIsIdentifier(bool isIdentifier)$/;"	f	class:WTF::StringImpl	access:public	signature:(bool isIdentifier)
WTF::StringImpl::simplifyMatchedCharactersToSpace	.\text\StringImpl.cpp	/^inline PassRefPtr<StringImpl> StringImpl::simplifyMatchedCharactersToSpace(UCharPredicate predicate)$/;"	f	class:WTF::StringImpl	signature:(UCharPredicate predicate)
WTF::StringImpl::simplifyMatchedCharactersToSpace	.\text\StringImpl.h	/^    template <typename CharType, class UCharPredicate> PassRefPtr<StringImpl> simplifyMatchedCharactersToSpace(UCharPredicate);$/;"	p	class:WTF::StringImpl	access:private	signature:(UCharPredicate)
WTF::StringImpl::simplifyWhiteSpace	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::simplifyWhiteSpace()$/;"	f	class:WTF::StringImpl	signature:()
WTF::StringImpl::simplifyWhiteSpace	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::simplifyWhiteSpace(IsWhiteSpaceFunctionPtr isWhiteSpace)$/;"	f	class:WTF::StringImpl	signature:(IsWhiteSpaceFunctionPtr isWhiteSpace)
WTF::StringImpl::simplifyWhiteSpace	.\text\StringImpl.h	/^    PassRefPtr<StringImpl> simplifyWhiteSpace(IsWhiteSpaceFunctionPtr);$/;"	p	class:WTF::StringImpl	access:public	signature:(IsWhiteSpaceFunctionPtr)
WTF::StringImpl::simplifyWhiteSpace	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE PassRefPtr<StringImpl> simplifyWhiteSpace();$/;"	p	class:WTF::StringImpl	access:public	signature:()
WTF::StringImpl::startsWith	.\text\StringImpl.h	/^    bool startsWith(StringImpl* str, bool caseSensitive = true) { return (caseSensitive ? reverseFind(str, 0) : reverseFindIgnoringCase(str, 0)) == 0; }$/;"	f	class:WTF::StringImpl	access:public	signature:(StringImpl* str, bool caseSensitive = true)
WTF::StringImpl::stripMatchedCharacters	.\text\StringImpl.cpp	/^inline PassRefPtr<StringImpl> StringImpl::stripMatchedCharacters(UCharPredicate predicate)$/;"	f	class:WTF::StringImpl	signature:(UCharPredicate predicate)
WTF::StringImpl::stripMatchedCharacters	.\text\StringImpl.h	/^    template <class UCharPredicate> PassRefPtr<StringImpl> stripMatchedCharacters(UCharPredicate);$/;"	p	class:WTF::StringImpl	access:private	signature:(UCharPredicate)
WTF::StringImpl::stripWhiteSpace	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::stripWhiteSpace()$/;"	f	class:WTF::StringImpl	signature:()
WTF::StringImpl::stripWhiteSpace	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::stripWhiteSpace(IsWhiteSpaceFunctionPtr isWhiteSpace)$/;"	f	class:WTF::StringImpl	signature:(IsWhiteSpaceFunctionPtr isWhiteSpace)
WTF::StringImpl::stripWhiteSpace	.\text\StringImpl.h	/^    PassRefPtr<StringImpl> stripWhiteSpace();$/;"	p	class:WTF::StringImpl	access:public	signature:()
WTF::StringImpl::stripWhiteSpace	.\text\StringImpl.h	/^    PassRefPtr<StringImpl> stripWhiteSpace(IsWhiteSpaceFunctionPtr);$/;"	p	class:WTF::StringImpl	access:public	signature:(IsWhiteSpaceFunctionPtr)
WTF::StringImpl::substring	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::substring(unsigned start, unsigned length)$/;"	f	class:WTF::StringImpl	signature:(unsigned start, unsigned length)
WTF::StringImpl::substring	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE PassRefPtr<StringImpl> substring(unsigned pos, unsigned len = UINT_MAX);$/;"	p	class:WTF::StringImpl	access:public	signature:(unsigned pos, unsigned len = UINT_MAX)
WTF::StringImpl::toDouble	.\text\StringImpl.cpp	/^double StringImpl::toDouble(bool* ok, bool* didReadNumber)$/;"	f	class:WTF::StringImpl	signature:(bool* ok, bool* didReadNumber)
WTF::StringImpl::toDouble	.\text\StringImpl.h	/^    double toDouble(bool* ok = 0, bool* didReadNumber = 0);$/;"	p	class:WTF::StringImpl	access:public	signature:(bool* ok = 0, bool* didReadNumber = 0)
WTF::StringImpl::toFloat	.\text\StringImpl.cpp	/^float StringImpl::toFloat(bool* ok, bool* didReadNumber)$/;"	f	class:WTF::StringImpl	signature:(bool* ok, bool* didReadNumber)
WTF::StringImpl::toFloat	.\text\StringImpl.h	/^    float toFloat(bool* ok = 0, bool* didReadNumber = 0);$/;"	p	class:WTF::StringImpl	access:public	signature:(bool* ok = 0, bool* didReadNumber = 0)
WTF::StringImpl::toInt	.\text\StringImpl.cpp	/^int StringImpl::toInt(bool* ok)$/;"	f	class:WTF::StringImpl	signature:(bool* ok)
WTF::StringImpl::toInt	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE int toInt(bool* ok = 0); \/\/ ignores trailing garbage$/;"	p	class:WTF::StringImpl	access:public	signature:(bool* ok = 0)
WTF::StringImpl::toInt64	.\text\StringImpl.cpp	/^int64_t StringImpl::toInt64(bool* ok)$/;"	f	class:WTF::StringImpl	signature:(bool* ok)
WTF::StringImpl::toInt64	.\text\StringImpl.h	/^    int64_t toInt64(bool* ok = 0); \/\/ ignores trailing garbage$/;"	p	class:WTF::StringImpl	access:public	signature:(bool* ok = 0)
WTF::StringImpl::toInt64Strict	.\text\StringImpl.cpp	/^int64_t StringImpl::toInt64Strict(bool* ok, int base)$/;"	f	class:WTF::StringImpl	signature:(bool* ok, int base)
WTF::StringImpl::toInt64Strict	.\text\StringImpl.h	/^    int64_t toInt64Strict(bool* ok = 0, int base = 10);$/;"	p	class:WTF::StringImpl	access:public	signature:(bool* ok = 0, int base = 10)
WTF::StringImpl::toIntPtr	.\text\StringImpl.cpp	/^intptr_t StringImpl::toIntPtr(bool* ok)$/;"	f	class:WTF::StringImpl	signature:(bool* ok)
WTF::StringImpl::toIntPtr	.\text\StringImpl.h	/^    intptr_t toIntPtr(bool* ok = 0); \/\/ ignores trailing garbage$/;"	p	class:WTF::StringImpl	access:public	signature:(bool* ok = 0)
WTF::StringImpl::toIntPtrStrict	.\text\StringImpl.cpp	/^intptr_t StringImpl::toIntPtrStrict(bool* ok, int base)$/;"	f	class:WTF::StringImpl	signature:(bool* ok, int base)
WTF::StringImpl::toIntPtrStrict	.\text\StringImpl.h	/^    intptr_t toIntPtrStrict(bool* ok = 0, int base = 10);$/;"	p	class:WTF::StringImpl	access:public	signature:(bool* ok = 0, int base = 10)
WTF::StringImpl::toIntStrict	.\text\StringImpl.cpp	/^int StringImpl::toIntStrict(bool* ok, int base)$/;"	f	class:WTF::StringImpl	signature:(bool* ok, int base)
WTF::StringImpl::toIntStrict	.\text\StringImpl.h	/^    int toIntStrict(bool* ok = 0, int base = 10);$/;"	p	class:WTF::StringImpl	access:public	signature:(bool* ok = 0, int base = 10)
WTF::StringImpl::toUInt	.\text\StringImpl.cpp	/^unsigned StringImpl::toUInt(bool* ok)$/;"	f	class:WTF::StringImpl	signature:(bool* ok)
WTF::StringImpl::toUInt	.\text\StringImpl.h	/^    unsigned toUInt(bool* ok = 0); \/\/ ignores trailing garbage$/;"	p	class:WTF::StringImpl	access:public	signature:(bool* ok = 0)
WTF::StringImpl::toUInt64	.\text\StringImpl.cpp	/^uint64_t StringImpl::toUInt64(bool* ok)$/;"	f	class:WTF::StringImpl	signature:(bool* ok)
WTF::StringImpl::toUInt64	.\text\StringImpl.h	/^    uint64_t toUInt64(bool* ok = 0); \/\/ ignores trailing garbage$/;"	p	class:WTF::StringImpl	access:public	signature:(bool* ok = 0)
WTF::StringImpl::toUInt64Strict	.\text\StringImpl.cpp	/^uint64_t StringImpl::toUInt64Strict(bool* ok, int base)$/;"	f	class:WTF::StringImpl	signature:(bool* ok, int base)
WTF::StringImpl::toUInt64Strict	.\text\StringImpl.h	/^    uint64_t toUInt64Strict(bool* ok = 0, int base = 10);$/;"	p	class:WTF::StringImpl	access:public	signature:(bool* ok = 0, int base = 10)
WTF::StringImpl::toUIntStrict	.\text\StringImpl.cpp	/^unsigned StringImpl::toUIntStrict(bool* ok, int base)$/;"	f	class:WTF::StringImpl	signature:(bool* ok, int base)
WTF::StringImpl::toUIntStrict	.\text\StringImpl.h	/^    unsigned toUIntStrict(bool* ok = 0, int base = 10);$/;"	p	class:WTF::StringImpl	access:public	signature:(bool* ok = 0, int base = 10)
WTF::StringImpl::tryCreateUninitialized	.\text\StringImpl.h	/^    template <typename T> static ALWAYS_INLINE PassRefPtr<StringImpl> tryCreateUninitialized(unsigned length, T*& output)$/;"	f	class:WTF::StringImpl	access:public	signature:(unsigned length, T*& output)
WTF::StringImpl::upconvertCharacters	.\text\StringImpl.cpp	/^void StringImpl::upconvertCharacters(unsigned start, unsigned end) const$/;"	f	class:WTF::StringImpl	signature:(unsigned start, unsigned end) const
WTF::StringImpl::upconvertCharacters	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE void upconvertCharacters(unsigned, unsigned) const;$/;"	p	class:WTF::StringImpl	access:public	signature:(unsigned, unsigned) const
WTF::StringImpl::upper	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::upper()$/;"	f	class:WTF::StringImpl	signature:()
WTF::StringImpl::upper	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE PassRefPtr<StringImpl> upper();$/;"	p	class:WTF::StringImpl	access:public	signature:()
WTF::StringImpl::~StringImpl	.\text\StringImpl.cpp	/^StringImpl::~StringImpl()$/;"	f	class:WTF::StringImpl	signature:()
WTF::StringImpl::~StringImpl	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE ~StringImpl();$/;"	p	class:WTF::StringImpl	access:public	signature:()
WTF::StringTypeAdapter	.\text\StringConcatenate.h	/^class StringTypeAdapter {$/;"	c	namespace:WTF
WTF::StringTypeAdapter	.\text\StringConcatenate.h	/^class StringTypeAdapter<AtomicString> {$/;"	c	namespace:WTF
WTF::StringTypeAdapter	.\text\StringConcatenate.h	/^class StringTypeAdapter<LChar*> {$/;"	c	namespace:WTF
WTF::StringTypeAdapter	.\text\StringConcatenate.h	/^class StringTypeAdapter<LChar> {$/;"	c	namespace:WTF
WTF::StringTypeAdapter	.\text\StringConcatenate.h	/^class StringTypeAdapter<String> {$/;"	c	namespace:WTF
WTF::StringTypeAdapter	.\text\StringConcatenate.h	/^class StringTypeAdapter<UChar> {$/;"	c	namespace:WTF
WTF::StringTypeAdapter	.\text\StringConcatenate.h	/^class StringTypeAdapter<Vector<LChar> > {$/;"	c	namespace:WTF
WTF::StringTypeAdapter	.\text\StringConcatenate.h	/^class StringTypeAdapter<Vector<char> > {$/;"	c	namespace:WTF
WTF::StringTypeAdapter	.\text\StringConcatenate.h	/^class StringTypeAdapter<char*> {$/;"	c	namespace:WTF
WTF::StringTypeAdapter	.\text\StringConcatenate.h	/^class StringTypeAdapter<char> {$/;"	c	namespace:WTF
WTF::StringTypeAdapter	.\text\StringConcatenate.h	/^class StringTypeAdapter<const LChar*> {$/;"	c	namespace:WTF
WTF::StringTypeAdapter	.\text\StringConcatenate.h	/^class StringTypeAdapter<const UChar*> {$/;"	c	namespace:WTF
WTF::StringTypeAdapter	.\text\StringConcatenate.h	/^class StringTypeAdapter<const char*> {$/;"	c	namespace:WTF
WTF::StringTypeAdapter	.\text\StringOperators.h	/^class StringTypeAdapter<StringAppend<StringType1, StringType2> > {$/;"	c	namespace:WTF
WTF::StringTypeAdapter::StringTypeAdapter	.\text\StringConcatenate.h	/^    StringTypeAdapter<AtomicString>(const AtomicString& string)$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(const AtomicString& string)
WTF::StringTypeAdapter::StringTypeAdapter	.\text\StringConcatenate.h	/^    StringTypeAdapter<LChar*>(LChar* buffer)$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(LChar* buffer)
WTF::StringTypeAdapter::StringTypeAdapter	.\text\StringConcatenate.h	/^    StringTypeAdapter<LChar>(LChar buffer)$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(LChar buffer)
WTF::StringTypeAdapter::StringTypeAdapter	.\text\StringConcatenate.h	/^    StringTypeAdapter<String>(const String& string)$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(const String& string)
WTF::StringTypeAdapter::StringTypeAdapter	.\text\StringConcatenate.h	/^    StringTypeAdapter<UChar>(UChar buffer)$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(UChar buffer)
WTF::StringTypeAdapter::StringTypeAdapter	.\text\StringConcatenate.h	/^    StringTypeAdapter<Vector<LChar> >(const Vector<LChar>& buffer)$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(const Vector<LChar>& buffer)
WTF::StringTypeAdapter::StringTypeAdapter	.\text\StringConcatenate.h	/^    StringTypeAdapter<Vector<char> >(const Vector<char>& buffer)$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(const Vector<char>& buffer)
WTF::StringTypeAdapter::StringTypeAdapter	.\text\StringConcatenate.h	/^    StringTypeAdapter<char*>(char* buffer)$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(char* buffer)
WTF::StringTypeAdapter::StringTypeAdapter	.\text\StringConcatenate.h	/^    StringTypeAdapter<char>(char buffer)$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(char buffer)
WTF::StringTypeAdapter::StringTypeAdapter	.\text\StringConcatenate.h	/^    StringTypeAdapter<const LChar*>(const LChar* buffer)$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(const LChar* buffer)
WTF::StringTypeAdapter::StringTypeAdapter	.\text\StringConcatenate.h	/^    StringTypeAdapter<const UChar*>(const UChar* buffer)$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(const UChar* buffer)
WTF::StringTypeAdapter::StringTypeAdapter	.\text\StringConcatenate.h	/^    StringTypeAdapter<const char*>(const char* buffer)$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(const char* buffer)
WTF::StringTypeAdapter::StringTypeAdapter	.\text\StringOperators.h	/^    StringTypeAdapter<StringAppend<StringType1, StringType2> >(StringAppend<StringType1, StringType2>& buffer)$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(StringAppend<StringType1, StringType2>& buffer)
WTF::StringTypeAdapter::is8Bit	.\text\StringConcatenate.h	/^    bool is8Bit() { return false; }$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:()
WTF::StringTypeAdapter::is8Bit	.\text\StringConcatenate.h	/^    bool is8Bit() { return m_adapter.is8Bit(); }$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:()
WTF::StringTypeAdapter::is8Bit	.\text\StringConcatenate.h	/^    bool is8Bit() { return m_buffer <= 0xff; }$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:()
WTF::StringTypeAdapter::is8Bit	.\text\StringConcatenate.h	/^    bool is8Bit() { return m_buffer.isNull() || m_buffer.is8Bit(); }$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:()
WTF::StringTypeAdapter::is8Bit	.\text\StringConcatenate.h	/^    bool is8Bit() { return true; }$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:()
WTF::StringTypeAdapter::is8Bit	.\text\StringOperators.h	/^    bool is8Bit() { return m_buffer.is8Bit(); }$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:()
WTF::StringTypeAdapter::length	.\text\StringConcatenate.h	/^    size_t length() { return m_buffer.size(); }$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:()
WTF::StringTypeAdapter::length	.\text\StringConcatenate.h	/^    unsigned length() { return 1; }$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:()
WTF::StringTypeAdapter::length	.\text\StringConcatenate.h	/^    unsigned length() { return m_adapter.length(); }$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:()
WTF::StringTypeAdapter::length	.\text\StringConcatenate.h	/^    unsigned length() { return m_buffer.length(); }$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:()
WTF::StringTypeAdapter::length	.\text\StringConcatenate.h	/^    unsigned length() { return m_length; }$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:()
WTF::StringTypeAdapter::length	.\text\StringOperators.h	/^    unsigned length() { return m_buffer.length(); }$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:()
WTF::StringTypeAdapter::m_adapter	.\text\StringConcatenate.h	/^    StringTypeAdapter<String> m_adapter;$/;"	m	class:WTF::StringTypeAdapter	access:private
WTF::StringTypeAdapter::m_buffer	.\text\StringConcatenate.h	/^    LChar m_buffer;$/;"	m	class:WTF::StringTypeAdapter	access:private
WTF::StringTypeAdapter::m_buffer	.\text\StringConcatenate.h	/^    UChar m_buffer;$/;"	m	class:WTF::StringTypeAdapter	access:private
WTF::StringTypeAdapter::m_buffer	.\text\StringConcatenate.h	/^    const LChar* m_buffer;$/;"	m	class:WTF::StringTypeAdapter	access:private
WTF::StringTypeAdapter::m_buffer	.\text\StringConcatenate.h	/^    const String& m_buffer;$/;"	m	class:WTF::StringTypeAdapter	access:private
WTF::StringTypeAdapter::m_buffer	.\text\StringConcatenate.h	/^    const UChar* m_buffer;$/;"	m	class:WTF::StringTypeAdapter	access:private
WTF::StringTypeAdapter::m_buffer	.\text\StringConcatenate.h	/^    const Vector<LChar>& m_buffer;$/;"	m	class:WTF::StringTypeAdapter	access:private
WTF::StringTypeAdapter::m_buffer	.\text\StringConcatenate.h	/^    const Vector<char>& m_buffer;$/;"	m	class:WTF::StringTypeAdapter	access:private
WTF::StringTypeAdapter::m_buffer	.\text\StringConcatenate.h	/^    const char* m_buffer;$/;"	m	class:WTF::StringTypeAdapter	access:private
WTF::StringTypeAdapter::m_buffer	.\text\StringConcatenate.h	/^    unsigned char m_buffer;$/;"	m	class:WTF::StringTypeAdapter	access:private
WTF::StringTypeAdapter::m_buffer	.\text\StringOperators.h	/^    StringAppend<StringType1, StringType2>& m_buffer;$/;"	m	class:WTF::StringTypeAdapter	access:private
WTF::StringTypeAdapter::m_length	.\text\StringConcatenate.h	/^    unsigned m_length;$/;"	m	class:WTF::StringTypeAdapter	access:private
WTF::StringTypeAdapter::writeTo	.\text\StringConcatenate.h	/^    NO_RETURN_DUE_TO_CRASH void writeTo(LChar*)$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(LChar*)
WTF::StringTypeAdapter::writeTo	.\text\StringConcatenate.h	/^    void writeTo(LChar* destination) { m_adapter.writeTo(destination); }$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(LChar* destination)
WTF::StringTypeAdapter::writeTo	.\text\StringConcatenate.h	/^    void writeTo(LChar* destination)$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(LChar* destination)
WTF::StringTypeAdapter::writeTo	.\text\StringConcatenate.h	/^    void writeTo(UChar* destination) { *destination = m_buffer; }$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(UChar* destination)
WTF::StringTypeAdapter::writeTo	.\text\StringConcatenate.h	/^    void writeTo(UChar* destination) { m_adapter.writeTo(destination); }$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(UChar* destination)
WTF::StringTypeAdapter::writeTo	.\text\StringConcatenate.h	/^    void writeTo(UChar* destination)$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(UChar* destination)
WTF::StringTypeAdapter::writeTo	.\text\StringOperators.h	/^    void writeTo(LChar* destination) { m_buffer.writeTo(destination); }$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(LChar* destination)
WTF::StringTypeAdapter::writeTo	.\text\StringOperators.h	/^    void writeTo(UChar* destination) { m_buffer.writeTo(destination); }$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(UChar* destination)
WTF::SubstringLocation	.\text\AtomicString.cpp	/^struct SubstringLocation {$/;"	s	namespace:WTF	file:
WTF::SubstringLocation::baseString	.\text\AtomicString.cpp	/^    StringImpl* baseString;$/;"	m	struct:WTF::SubstringLocation	file:	access:public
WTF::SubstringLocation::length	.\text\AtomicString.cpp	/^    unsigned length;$/;"	m	struct:WTF::SubstringLocation	file:	access:public
WTF::SubstringLocation::start	.\text\AtomicString.cpp	/^    unsigned start;$/;"	m	struct:WTF::SubstringLocation	file:	access:public
WTF::SubstringTranslator	.\text\AtomicString.cpp	/^struct SubstringTranslator {$/;"	s	namespace:WTF	file:
WTF::SubstringTranslator::equal	.\text\AtomicString.cpp	/^    static bool equal(StringImpl* const& string, const SubstringLocation& buffer)$/;"	f	struct:WTF::SubstringTranslator	access:public	signature:(StringImpl* const& string, const SubstringLocation& buffer)
WTF::SubstringTranslator::hash	.\text\AtomicString.cpp	/^    static unsigned hash(const SubstringLocation& buffer)$/;"	f	struct:WTF::SubstringTranslator	access:public	signature:(const SubstringLocation& buffer)
WTF::SubstringTranslator::translate	.\text\AtomicString.cpp	/^    static void translate(StringImpl*& location, const SubstringLocation& buffer, unsigned hash)$/;"	f	struct:WTF::SubstringTranslator	access:public	signature:(StringImpl*& location, const SubstringLocation& buffer, unsigned hash)
WTF::TCEntry	.\FastMalloc.cpp	/^struct TCEntry {$/;"	s	namespace:WTF	file:
WTF::TCEntry::head	.\FastMalloc.cpp	/^  void *head;  \/\/ Head of chain of objects.$/;"	m	struct:WTF::TCEntry	file:	access:public
WTF::TCEntry::tail	.\FastMalloc.cpp	/^  void *tail;  \/\/ Tail of chain of objects.$/;"	m	struct:WTF::TCEntry	file:	access:public
WTF::TCMallocGuard	.\FastMalloc.cpp	/^class TCMallocGuard {$/;"	c	namespace:WTF	file:
WTF::TCMallocGuard::TCMallocGuard	.\FastMalloc.cpp	/^  TCMallocGuard() {$/;"	f	class:WTF::TCMallocGuard	access:public	signature:()
WTF::TCMallocGuard::~TCMallocGuard	.\FastMalloc.cpp	/^  ~TCMallocGuard() {$/;"	f	class:WTF::TCMallocGuard	access:public	signature:()
WTF::TCMallocImplementation	.\FastMalloc.cpp	/^class TCMallocImplementation : public MallocExtension {$/;"	c	namespace:WTF	file:	inherits:MallocExtension
WTF::TCMallocImplementation::GetNumericProperty	.\FastMalloc.cpp	/^  virtual bool GetNumericProperty(const char* name, size_t* value) {$/;"	f	class:WTF::TCMallocImplementation	access:public	signature:(const char* name, size_t* value)
WTF::TCMallocImplementation::GetStats	.\FastMalloc.cpp	/^  virtual void GetStats(char* buffer, int buffer_length) {$/;"	f	class:WTF::TCMallocImplementation	access:public	signature:(char* buffer, int buffer_length)
WTF::TCMallocImplementation::MarkThreadIdle	.\FastMalloc.cpp	/^  virtual void MarkThreadIdle() {$/;"	f	class:WTF::TCMallocImplementation	access:public	signature:()
WTF::TCMallocImplementation::ReadStackTraces	.\FastMalloc.cpp	/^  virtual void** ReadStackTraces() {$/;"	f	class:WTF::TCMallocImplementation	access:public	signature:()
WTF::TCMallocImplementation::ReleaseFreeMemory	.\FastMalloc.cpp	/^  virtual void ReleaseFreeMemory() {$/;"	f	class:WTF::TCMallocImplementation	access:public	signature:()
WTF::TCMallocImplementation::SetNumericProperty	.\FastMalloc.cpp	/^  virtual bool SetNumericProperty(const char* name, size_t value) {$/;"	f	class:WTF::TCMallocImplementation	access:public	signature:(const char* name, size_t value)
WTF::TCMallocStats	.\FastMalloc.cpp	/^struct TCMallocStats {$/;"	s	namespace:WTF	file:
WTF::TCMallocStats::central_bytes	.\FastMalloc.cpp	/^  uint64_t central_bytes;       \/\/ Bytes in central cache$/;"	m	struct:WTF::TCMallocStats	file:	access:public
WTF::TCMallocStats::metadata_bytes	.\FastMalloc.cpp	/^  uint64_t metadata_bytes;      \/\/ Bytes alloced for metadata$/;"	m	struct:WTF::TCMallocStats	file:	access:public
WTF::TCMallocStats::pageheap_bytes	.\FastMalloc.cpp	/^  uint64_t pageheap_bytes;      \/\/ Bytes in page heap$/;"	m	struct:WTF::TCMallocStats	file:	access:public
WTF::TCMallocStats::system_bytes	.\FastMalloc.cpp	/^  uint64_t system_bytes;        \/\/ Bytes alloced from system$/;"	m	struct:WTF::TCMallocStats	file:	access:public
WTF::TCMallocStats::thread_bytes	.\FastMalloc.cpp	/^  uint64_t thread_bytes;        \/\/ Bytes in thread caches$/;"	m	struct:WTF::TCMallocStats	file:	access:public
WTF::TCMallocStats::transfer_bytes	.\FastMalloc.cpp	/^  uint64_t transfer_bytes;      \/\/ Bytes in central transfer cache$/;"	m	struct:WTF::TCMallocStats	file:	access:public
WTF::TCMalloc_Central_FreeList	.\FastMalloc.cpp	/^class TCMalloc_Central_FreeList {$/;"	c	namespace:WTF	file:
WTF::TCMalloc_Central_FreeList::EvictRandomSizeClass	.\FastMalloc.cpp	/^  static ALWAYS_INLINE bool EvictRandomSizeClass(size_t locked_size_class, bool force);$/;"	p	class:WTF::TCMalloc_Central_FreeList	file:	access:private	signature:(size_t locked_size_class, bool force)
WTF::TCMalloc_Central_FreeList::EvictRandomSizeClass	.\FastMalloc.cpp	/^ALWAYS_INLINE bool TCMalloc_Central_FreeList::EvictRandomSizeClass($/;"	f	class:WTF::TCMalloc_Central_FreeList	signature:( size_t locked_size_class, bool force)
WTF::TCMalloc_Central_FreeList::FetchFromSpans	.\FastMalloc.cpp	/^  void* FetchFromSpans();$/;"	p	class:WTF::TCMalloc_Central_FreeList	file:	access:private	signature:()
WTF::TCMalloc_Central_FreeList::FetchFromSpans	.\FastMalloc.cpp	/^void* TCMalloc_Central_FreeList::FetchFromSpans() {$/;"	f	class:WTF::TCMalloc_Central_FreeList	signature:()
WTF::TCMalloc_Central_FreeList::FetchFromSpansSafe	.\FastMalloc.cpp	/^  void* FetchFromSpansSafe();$/;"	p	class:WTF::TCMalloc_Central_FreeList	file:	access:private	signature:()
WTF::TCMalloc_Central_FreeList::FetchFromSpansSafe	.\FastMalloc.cpp	/^void* TCMalloc_Central_FreeList::FetchFromSpansSafe() {$/;"	f	class:WTF::TCMalloc_Central_FreeList	signature:()
WTF::TCMalloc_Central_FreeList::Init	.\FastMalloc.cpp	/^  void Init(size_t cl);$/;"	p	class:WTF::TCMalloc_Central_FreeList	file:	access:public	signature:(size_t cl)
WTF::TCMalloc_Central_FreeList::Init	.\FastMalloc.cpp	/^void TCMalloc_Central_FreeList::Init(size_t cl) {$/;"	f	class:WTF::TCMalloc_Central_FreeList	signature:(size_t cl)
WTF::TCMalloc_Central_FreeList::InsertRange	.\FastMalloc.cpp	/^  void InsertRange(void *start, void *end, int N);$/;"	p	class:WTF::TCMalloc_Central_FreeList	file:	access:public	signature:(void *start, void *end, int N)
WTF::TCMalloc_Central_FreeList::InsertRange	.\FastMalloc.cpp	/^void TCMalloc_Central_FreeList::InsertRange(void *start, void *end, int N) {$/;"	f	class:WTF::TCMalloc_Central_FreeList	signature:(void *start, void *end, int N)
WTF::TCMalloc_Central_FreeList::MakeCacheSpace	.\FastMalloc.cpp	/^  bool MakeCacheSpace();$/;"	p	class:WTF::TCMalloc_Central_FreeList	file:	access:private	signature:()
WTF::TCMalloc_Central_FreeList::MakeCacheSpace	.\FastMalloc.cpp	/^bool TCMalloc_Central_FreeList::MakeCacheSpace() {$/;"	f	class:WTF::TCMalloc_Central_FreeList	signature:()
WTF::TCMalloc_Central_FreeList::Populate	.\FastMalloc.cpp	/^  ALWAYS_INLINE void Populate();$/;"	p	class:WTF::TCMalloc_Central_FreeList	file:	access:private	signature:()
WTF::TCMalloc_Central_FreeList::Populate	.\FastMalloc.cpp	/^ALWAYS_INLINE void TCMalloc_Central_FreeList::Populate() {$/;"	f	class:WTF::TCMalloc_Central_FreeList	signature:()
WTF::TCMalloc_Central_FreeList::ReleaseListToSpans	.\FastMalloc.cpp	/^  void ReleaseListToSpans(void *start);$/;"	p	class:WTF::TCMalloc_Central_FreeList	file:	access:private	signature:(void *start)
WTF::TCMalloc_Central_FreeList::ReleaseListToSpans	.\FastMalloc.cpp	/^void TCMalloc_Central_FreeList::ReleaseListToSpans(void* start) {$/;"	f	class:WTF::TCMalloc_Central_FreeList	signature:(void* start)
WTF::TCMalloc_Central_FreeList::ReleaseToSpans	.\FastMalloc.cpp	/^  ALWAYS_INLINE void ReleaseToSpans(void* object);$/;"	p	class:WTF::TCMalloc_Central_FreeList	file:	access:private	signature:(void* object)
WTF::TCMalloc_Central_FreeList::ReleaseToSpans	.\FastMalloc.cpp	/^ALWAYS_INLINE void TCMalloc_Central_FreeList::ReleaseToSpans(void* object) {$/;"	f	class:WTF::TCMalloc_Central_FreeList	signature:(void* object)
WTF::TCMalloc_Central_FreeList::RemoveRange	.\FastMalloc.cpp	/^  void RemoveRange(void **start, void **end, int *N);$/;"	p	class:WTF::TCMalloc_Central_FreeList	file:	access:public	signature:(void **start, void **end, int *N)
WTF::TCMalloc_Central_FreeList::RemoveRange	.\FastMalloc.cpp	/^void TCMalloc_Central_FreeList::RemoveRange(void **start, void **end, int *N) {$/;"	f	class:WTF::TCMalloc_Central_FreeList	signature:(void **start, void **end, int *N)
WTF::TCMalloc_Central_FreeList::ShrinkCache	.\FastMalloc.cpp	/^  bool ShrinkCache(int locked_size_class, bool force);$/;"	p	class:WTF::TCMalloc_Central_FreeList	file:	access:private	signature:(int locked_size_class, bool force)
WTF::TCMalloc_Central_FreeList::ShrinkCache	.\FastMalloc.cpp	/^bool TCMalloc_Central_FreeList::ShrinkCache(int locked_size_class, bool force) {$/;"	f	class:WTF::TCMalloc_Central_FreeList	signature:(int locked_size_class, bool force)
WTF::TCMalloc_Central_FreeList::cache_size_	.\FastMalloc.cpp	/^  int32_t cache_size_;$/;"	m	class:WTF::TCMalloc_Central_FreeList	file:	access:private
WTF::TCMalloc_Central_FreeList::counter_	.\FastMalloc.cpp	/^  size_t   counter_;        \/\/ Number of free objects in cache entry$/;"	m	class:WTF::TCMalloc_Central_FreeList	file:	access:private
WTF::TCMalloc_Central_FreeList::empty_	.\FastMalloc.cpp	/^  Span     empty_;          \/\/ Dummy header for list of empty spans$/;"	m	class:WTF::TCMalloc_Central_FreeList	file:	access:private
WTF::TCMalloc_Central_FreeList::enumerateFreeObjects	.\FastMalloc.cpp	/^  void enumerateFreeObjects(Finder& finder, const Reader& reader, TCMalloc_Central_FreeList* remoteCentralFreeList)$/;"	f	class:WTF::TCMalloc_Central_FreeList	access:public	signature:(Finder& finder, const Reader& reader, TCMalloc_Central_FreeList* remoteCentralFreeList)
WTF::TCMalloc_Central_FreeList::length	.\FastMalloc.cpp	/^  size_t length() {$/;"	f	class:WTF::TCMalloc_Central_FreeList	access:public	signature:()
WTF::TCMalloc_Central_FreeList::lock_	.\FastMalloc.cpp	/^  SpinLock lock_;$/;"	m	class:WTF::TCMalloc_Central_FreeList	file:	access:private
WTF::TCMalloc_Central_FreeList::nonempty_	.\FastMalloc.cpp	/^  Span     nonempty_;       \/\/ Dummy header for list of non-empty spans$/;"	m	class:WTF::TCMalloc_Central_FreeList	file:	access:private
WTF::TCMalloc_Central_FreeList::size_class_	.\FastMalloc.cpp	/^  size_t   size_class_;     \/\/ My size class$/;"	m	class:WTF::TCMalloc_Central_FreeList	file:	access:private
WTF::TCMalloc_Central_FreeList::tc_length	.\FastMalloc.cpp	/^  int tc_length() {$/;"	f	class:WTF::TCMalloc_Central_FreeList	access:public	signature:()
WTF::TCMalloc_Central_FreeList::tc_slots_	.\FastMalloc.cpp	/^  TCEntry tc_slots_[kNumTransferEntries];$/;"	m	class:WTF::TCMalloc_Central_FreeList	file:	access:private
WTF::TCMalloc_Central_FreeList::used_slots_	.\FastMalloc.cpp	/^  int32_t used_slots_;$/;"	m	class:WTF::TCMalloc_Central_FreeList	file:	access:private
WTF::TCMalloc_Central_FreeListPadded	.\FastMalloc.cpp	/^class TCMalloc_Central_FreeListPadded : public TCMalloc_Central_FreeList {$/;"	c	namespace:WTF	file:	inherits:TCMalloc_Central_FreeList
WTF::TCMalloc_Central_FreeListPadded::pad_	.\FastMalloc.cpp	/^  char pad_[(64 - (sizeof(TCMalloc_Central_FreeList) % 64)) % 64];$/;"	m	class:WTF::TCMalloc_Central_FreeListPadded	file:	access:private
WTF::TCMalloc_PageHeap	.\FastMalloc.cpp	/^class TCMalloc_PageHeap {$/;"	c	namespace:WTF	file:
WTF::TCMalloc_PageHeap::AllocLarge	.\FastMalloc.cpp	/^  Span* AllocLarge(Length n);$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:private	signature:(Length n)
WTF::TCMalloc_PageHeap::AllocLarge	.\FastMalloc.cpp	/^Span* TCMalloc_PageHeap::AllocLarge(Length n) {$/;"	f	class:WTF::TCMalloc_PageHeap	signature:(Length n)
WTF::TCMalloc_PageHeap::CacheSizeClass	.\FastMalloc.cpp	/^  void CacheSizeClass(PageID p, size_t cl) const { pagemap_cache_.Put(p, cl); }$/;"	f	class:WTF::TCMalloc_PageHeap	access:public	signature:(PageID p, size_t cl) const
WTF::TCMalloc_PageHeap::Carve	.\FastMalloc.cpp	/^  void Carve(Span* span, Length n, bool released);$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:private	signature:(Span* span, Length n, bool released)
WTF::TCMalloc_PageHeap::Carve	.\FastMalloc.cpp	/^inline void TCMalloc_PageHeap::Carve(Span* span, Length n, bool released) {$/;"	f	class:WTF::TCMalloc_PageHeap	signature:(Span* span, Length n, bool released)
WTF::TCMalloc_PageHeap::Check	.\FastMalloc.cpp	/^  bool Check();$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:public	signature:()
WTF::TCMalloc_PageHeap::Check	.\FastMalloc.cpp	/^bool TCMalloc_PageHeap::Check() {$/;"	f	class:WTF::TCMalloc_PageHeap	signature:()
WTF::TCMalloc_PageHeap::CheckList	.\FastMalloc.cpp	/^  size_t CheckList(Span* list, Length min_pages, Length max_pages, bool decommitted);$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:public	signature:(Span* list, Length min_pages, Length max_pages, bool decommitted)
WTF::TCMalloc_PageHeap::CheckList	.\FastMalloc.cpp	/^size_t TCMalloc_PageHeap::CheckList(Span* list, Length min_pages, Length max_pages, bool decommitted) {$/;"	f	class:WTF::TCMalloc_PageHeap	signature:(Span* list, Length min_pages, Length max_pages, bool decommitted)
WTF::TCMalloc_PageHeap::CheckList	.\FastMalloc.cpp	/^size_t TCMalloc_PageHeap::CheckList(Span*, Length, Length, bool) {$/;"	f	class:WTF::TCMalloc_PageHeap	signature:(Span*, Length, Length, bool)
WTF::TCMalloc_PageHeap::Delete	.\FastMalloc.cpp	/^  void Delete(Span* span);$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:public	signature:(Span* span)
WTF::TCMalloc_PageHeap::Delete	.\FastMalloc.cpp	/^inline void TCMalloc_PageHeap::Delete(Span* span) {$/;"	f	class:WTF::TCMalloc_PageHeap	signature:(Span* span)
WTF::TCMalloc_PageHeap::Dump	.\FastMalloc.cpp	/^  void Dump(TCMalloc_Printer* out);$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:public	signature:(TCMalloc_Printer* out)
WTF::TCMalloc_PageHeap::Dump	.\FastMalloc.cpp	/^void TCMalloc_PageHeap::Dump(TCMalloc_Printer* out) {$/;"	f	class:WTF::TCMalloc_PageHeap	signature:(TCMalloc_Printer* out)
WTF::TCMalloc_PageHeap::FreeBytes	.\FastMalloc.cpp	/^  uint64_t FreeBytes() const {$/;"	f	class:WTF::TCMalloc_PageHeap	access:public	signature:() const
WTF::TCMalloc_PageHeap::GetDescriptor	.\FastMalloc.cpp	/^  inline Span* GetDescriptor(PageID p) const {$/;"	f	class:WTF::TCMalloc_PageHeap	access:public	signature:(PageID p) const
WTF::TCMalloc_PageHeap::GetDescriptorEnsureSafe	.\FastMalloc.cpp	/^  inline Span* GetDescriptorEnsureSafe(PageID p)$/;"	f	class:WTF::TCMalloc_PageHeap	access:public	signature:(PageID p)
WTF::TCMalloc_PageHeap::GetSizeClassIfCached	.\FastMalloc.cpp	/^  size_t GetSizeClassIfCached(PageID p) const {$/;"	f	class:WTF::TCMalloc_PageHeap	access:public	signature:(PageID p) const
WTF::TCMalloc_PageHeap::GrowHeap	.\FastMalloc.cpp	/^  bool GrowHeap(Length n);$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:private	signature:(Length n)
WTF::TCMalloc_PageHeap::GrowHeap	.\FastMalloc.cpp	/^bool TCMalloc_PageHeap::GrowHeap(Length n) {$/;"	f	class:WTF::TCMalloc_PageHeap	signature:(Length n)
WTF::TCMalloc_PageHeap::IncrementalScavenge	.\FastMalloc.cpp	/^  void IncrementalScavenge(Length n);$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:private	signature:(Length n)
WTF::TCMalloc_PageHeap::IncrementalScavenge	.\FastMalloc.cpp	/^void TCMalloc_PageHeap::IncrementalScavenge(Length n) {$/;"	f	class:WTF::TCMalloc_PageHeap	signature:(Length n)
WTF::TCMalloc_PageHeap::New	.\FastMalloc.cpp	/^  Span* New(Length n);$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:public	signature:(Length n)
WTF::TCMalloc_PageHeap::New	.\FastMalloc.cpp	/^inline Span* TCMalloc_PageHeap::New(Length n) {$/;"	f	class:WTF::TCMalloc_PageHeap	signature:(Length n)
WTF::TCMalloc_PageHeap::PageMap	.\FastMalloc.cpp	/^  typedef MapSelector<8*sizeof(uintptr_t)>::Type PageMap;$/;"	t	class:WTF::TCMalloc_PageHeap	file:	access:private
WTF::TCMalloc_PageHeap::PageMapCache	.\FastMalloc.cpp	/^  typedef MapSelector<8*sizeof(uintptr_t)>::CacheType PageMapCache;$/;"	t	class:WTF::TCMalloc_PageHeap	file:	access:private
WTF::TCMalloc_PageHeap::RecordSpan	.\FastMalloc.cpp	/^  void RecordSpan(Span* span) {$/;"	f	class:WTF::TCMalloc_PageHeap	file:	access:private	signature:(Span* span)
WTF::TCMalloc_PageHeap::RegisterSizeClass	.\FastMalloc.cpp	/^  void RegisterSizeClass(Span* span, size_t sc);$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:public	signature:(Span* span, size_t sc)
WTF::TCMalloc_PageHeap::RegisterSizeClass	.\FastMalloc.cpp	/^void TCMalloc_PageHeap::RegisterSizeClass(Span* span, size_t sc) {$/;"	f	class:WTF::TCMalloc_PageHeap	signature:(Span* span, size_t sc)
WTF::TCMalloc_PageHeap::ReleaseFreeList	.\FastMalloc.cpp	/^  void ReleaseFreeList(Span*, Span*);$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:public	signature:(Span*, Span*)
WTF::TCMalloc_PageHeap::ReleaseFreeList	.\FastMalloc.cpp	/^void TCMalloc_PageHeap::ReleaseFreeList(Span* list, Span* returned) {$/;"	f	class:WTF::TCMalloc_PageHeap	signature:(Span* list, Span* returned)
WTF::TCMalloc_PageHeap::ReleaseFreePages	.\FastMalloc.cpp	/^  void ReleaseFreePages();$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:public	signature:()
WTF::TCMalloc_PageHeap::ReleaseFreePages	.\FastMalloc.cpp	/^void TCMalloc_PageHeap::ReleaseFreePages() {$/;"	f	class:WTF::TCMalloc_PageHeap	signature:()
WTF::TCMalloc_PageHeap::ReturnedBytes	.\FastMalloc.cpp	/^  size_t ReturnedBytes() const;$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:public	signature:() const
WTF::TCMalloc_PageHeap::ReturnedBytes	.\FastMalloc.cpp	/^size_t TCMalloc_PageHeap::ReturnedBytes() const {$/;"	f	class:WTF::TCMalloc_PageHeap	signature:() const
WTF::TCMalloc_PageHeap::SpanList	.\FastMalloc.cpp	/^  struct SpanList {$/;"	s	class:WTF::TCMalloc_PageHeap	file:	access:private
WTF::TCMalloc_PageHeap::SpanList::normal	.\FastMalloc.cpp	/^    Span        normal;$/;"	m	struct:WTF::TCMalloc_PageHeap::SpanList	file:	access:public
WTF::TCMalloc_PageHeap::SpanList::returned	.\FastMalloc.cpp	/^    Span        returned;$/;"	m	struct:WTF::TCMalloc_PageHeap::SpanList	file:	access:public
WTF::TCMalloc_PageHeap::Split	.\FastMalloc.cpp	/^  Span* Split(Span* span, Length n);$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:public	signature:(Span* span, Length n)
WTF::TCMalloc_PageHeap::Split	.\FastMalloc.cpp	/^Span* TCMalloc_PageHeap::Split(Span* span, Length n) {$/;"	f	class:WTF::TCMalloc_PageHeap	signature:(Span* span, Length n)
WTF::TCMalloc_PageHeap::SystemBytes	.\FastMalloc.cpp	/^  inline uint64_t SystemBytes() const { return system_bytes_; }$/;"	f	class:WTF::TCMalloc_PageHeap	access:public	signature:() const
WTF::TCMalloc_PageHeap::free_	.\FastMalloc.cpp	/^  SpanList free_[kMaxPages];$/;"	m	class:WTF::TCMalloc_PageHeap	file:	access:private
WTF::TCMalloc_PageHeap::free_committed_pages_	.\FastMalloc.cpp	/^  Length free_committed_pages_;$/;"	m	class:WTF::TCMalloc_PageHeap	file:	access:private
WTF::TCMalloc_PageHeap::free_pages_	.\FastMalloc.cpp	/^  uintptr_t free_pages_;$/;"	m	class:WTF::TCMalloc_PageHeap	file:	access:private
WTF::TCMalloc_PageHeap::init	.\FastMalloc.cpp	/^  void init();$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:public	signature:()
WTF::TCMalloc_PageHeap::init	.\FastMalloc.cpp	/^void TCMalloc_PageHeap::init()$/;"	f	class:WTF::TCMalloc_PageHeap	signature:()
WTF::TCMalloc_PageHeap::initializeScavenger	.\FastMalloc.cpp	/^  void initializeScavenger();$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:private	signature:()
WTF::TCMalloc_PageHeap::initializeScavenger	.\FastMalloc.cpp	/^void TCMalloc_PageHeap::initializeScavenger()$/;"	f	class:WTF::TCMalloc_PageHeap	signature:()
WTF::TCMalloc_PageHeap::isScavengerSuspended	.\FastMalloc.cpp	/^  ALWAYS_INLINE bool isScavengerSuspended();$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:private	signature:()
WTF::TCMalloc_PageHeap::isScavengerSuspended	.\FastMalloc.cpp	/^ALWAYS_INLINE bool TCMalloc_PageHeap::isScavengerSuspended()$/;"	f	class:WTF::TCMalloc_PageHeap	signature:()
WTF::TCMalloc_PageHeap::large_	.\FastMalloc.cpp	/^  SpanList large_;$/;"	m	class:WTF::TCMalloc_PageHeap	file:	access:private
WTF::TCMalloc_PageHeap::m_scavengeCondition	.\FastMalloc.cpp	/^  pthread_cond_t m_scavengeCondition;$/;"	m	class:WTF::TCMalloc_PageHeap	file:	access:private
WTF::TCMalloc_PageHeap::m_scavengeMutex	.\FastMalloc.cpp	/^  pthread_mutex_t m_scavengeMutex;$/;"	m	class:WTF::TCMalloc_PageHeap	file:	access:private
WTF::TCMalloc_PageHeap::m_scavengeQueue	.\FastMalloc.cpp	/^  dispatch_queue_t m_scavengeQueue;$/;"	m	class:WTF::TCMalloc_PageHeap	file:	access:private
WTF::TCMalloc_PageHeap::m_scavengeQueueTimer	.\FastMalloc.cpp	/^  HANDLE m_scavengeQueueTimer;$/;"	m	class:WTF::TCMalloc_PageHeap	file:	access:private
WTF::TCMalloc_PageHeap::m_scavengeThreadActive	.\FastMalloc.cpp	/^  bool m_scavengeThreadActive;$/;"	m	class:WTF::TCMalloc_PageHeap	file:	access:private
WTF::TCMalloc_PageHeap::m_scavengeTimer	.\FastMalloc.cpp	/^  dispatch_source_t m_scavengeTimer;$/;"	m	class:WTF::TCMalloc_PageHeap	file:	access:private
WTF::TCMalloc_PageHeap::m_scavengingSuspended	.\FastMalloc.cpp	/^  bool m_scavengingSuspended;$/;"	m	class:WTF::TCMalloc_PageHeap	file:	access:private
WTF::TCMalloc_PageHeap::min_free_committed_pages_since_last_scavenge_	.\FastMalloc.cpp	/^  Length min_free_committed_pages_since_last_scavenge_;$/;"	m	class:WTF::TCMalloc_PageHeap	file:	access:private
WTF::TCMalloc_PageHeap::pagemap_	.\FastMalloc.cpp	/^  PageMap pagemap_;$/;"	m	class:WTF::TCMalloc_PageHeap	file:	access:private
WTF::TCMalloc_PageHeap::pagemap_cache_	.\FastMalloc.cpp	/^  mutable PageMapCache pagemap_cache_;$/;"	m	class:WTF::TCMalloc_PageHeap	file:	access:private
WTF::TCMalloc_PageHeap::periodicScavenge	.\FastMalloc.cpp	/^  void periodicScavenge();$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:private	signature:()
WTF::TCMalloc_PageHeap::periodicScavenge	.\FastMalloc.cpp	/^void TCMalloc_PageHeap::periodicScavenge()$/;"	f	class:WTF::TCMalloc_PageHeap	signature:()
WTF::TCMalloc_PageHeap::rescheduleScavenger	.\FastMalloc.cpp	/^  ALWAYS_INLINE void rescheduleScavenger();$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:private	signature:()
WTF::TCMalloc_PageHeap::rescheduleScavenger	.\FastMalloc.cpp	/^ALWAYS_INLINE void TCMalloc_PageHeap::rescheduleScavenger()$/;"	f	class:WTF::TCMalloc_PageHeap	signature:()
WTF::TCMalloc_PageHeap::runScavengerThread	.\FastMalloc.cpp	/^  static NO_RETURN_WITH_VALUE void* runScavengerThread(void*);$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:private	signature:(void*)
WTF::TCMalloc_PageHeap::runScavengerThread	.\FastMalloc.cpp	/^void* TCMalloc_PageHeap::runScavengerThread(void* context)$/;"	f	class:WTF::TCMalloc_PageHeap	signature:(void* context)
WTF::TCMalloc_PageHeap::scavenge	.\FastMalloc.cpp	/^  void scavenge();$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:private	signature:()
WTF::TCMalloc_PageHeap::scavenge	.\FastMalloc.cpp	/^void TCMalloc_PageHeap::scavenge()$/;"	f	class:WTF::TCMalloc_PageHeap	signature:()
WTF::TCMalloc_PageHeap::scavenge_counter_	.\FastMalloc.cpp	/^  int64_t scavenge_counter_;$/;"	m	class:WTF::TCMalloc_PageHeap	file:	access:private
WTF::TCMalloc_PageHeap::scavenge_index_	.\FastMalloc.cpp	/^  size_t scavenge_index_;$/;"	m	class:WTF::TCMalloc_PageHeap	file:	access:private
WTF::TCMalloc_PageHeap::scavengerThread	.\FastMalloc.cpp	/^  NO_RETURN void scavengerThread();$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:private	signature:()
WTF::TCMalloc_PageHeap::scavengerThread	.\FastMalloc.cpp	/^void TCMalloc_PageHeap::scavengerThread()$/;"	f	class:WTF::TCMalloc_PageHeap	signature:()
WTF::TCMalloc_PageHeap::scavengerTimerFired	.\FastMalloc.cpp	/^  static void CALLBACK scavengerTimerFired(void*, BOOLEAN);$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:private	signature:(void*, BOOLEAN)
WTF::TCMalloc_PageHeap::scavengerTimerFired	.\FastMalloc.cpp	/^void TCMalloc_PageHeap::scavengerTimerFired(void* context, BOOLEAN)$/;"	f	class:WTF::TCMalloc_PageHeap	signature:(void* context, BOOLEAN)
WTF::TCMalloc_PageHeap::scheduleScavenger	.\FastMalloc.cpp	/^  ALWAYS_INLINE void scheduleScavenger();$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:private	signature:()
WTF::TCMalloc_PageHeap::scheduleScavenger	.\FastMalloc.cpp	/^ALWAYS_INLINE void TCMalloc_PageHeap::scheduleScavenger()$/;"	f	class:WTF::TCMalloc_PageHeap	signature:()
WTF::TCMalloc_PageHeap::shouldScavenge	.\FastMalloc.cpp	/^  ALWAYS_INLINE bool shouldScavenge() const;$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:private	signature:() const
WTF::TCMalloc_PageHeap::shouldScavenge	.\FastMalloc.cpp	/^ALWAYS_INLINE bool TCMalloc_PageHeap::shouldScavenge() const $/;"	f	class:WTF::TCMalloc_PageHeap	signature:() const
WTF::TCMalloc_PageHeap::signalScavenger	.\FastMalloc.cpp	/^  ALWAYS_INLINE void signalScavenger();$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:private	signature:()
WTF::TCMalloc_PageHeap::signalScavenger	.\FastMalloc.cpp	/^ALWAYS_INLINE void TCMalloc_PageHeap::signalScavenger()$/;"	f	class:WTF::TCMalloc_PageHeap	signature:()
WTF::TCMalloc_PageHeap::suspendScavenger	.\FastMalloc.cpp	/^  ALWAYS_INLINE void suspendScavenger();$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:private	signature:()
WTF::TCMalloc_PageHeap::suspendScavenger	.\FastMalloc.cpp	/^ALWAYS_INLINE void TCMalloc_PageHeap::suspendScavenger()$/;"	f	class:WTF::TCMalloc_PageHeap	signature:()
WTF::TCMalloc_PageHeap::system_bytes_	.\FastMalloc.cpp	/^  uint64_t system_bytes_;$/;"	m	class:WTF::TCMalloc_PageHeap	file:	access:private
WTF::TCMalloc_ThreadCache	.\FastMalloc.cpp	/^class TCMalloc_ThreadCache {$/;"	c	namespace:WTF	file:
WTF::TCMalloc_ThreadCache::Allocate	.\FastMalloc.cpp	/^  ALWAYS_INLINE void* Allocate(size_t size);$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:(size_t size)
WTF::TCMalloc_ThreadCache::Allocate	.\FastMalloc.cpp	/^ALWAYS_INLINE void* TCMalloc_ThreadCache::Allocate(size_t size) {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:(size_t size)
WTF::TCMalloc_ThreadCache::BecomeIdle	.\FastMalloc.cpp	/^  static void                  BecomeIdle();$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:()
WTF::TCMalloc_ThreadCache::BecomeIdle	.\FastMalloc.cpp	/^void TCMalloc_ThreadCache::BecomeIdle() {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:()
WTF::TCMalloc_ThreadCache::Cleanup	.\FastMalloc.cpp	/^  void Cleanup();$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:()
WTF::TCMalloc_ThreadCache::Cleanup	.\FastMalloc.cpp	/^void TCMalloc_ThreadCache::Cleanup() {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:()
WTF::TCMalloc_ThreadCache::CreateCacheIfNecessary	.\FastMalloc.cpp	/^  static TCMalloc_ThreadCache* CreateCacheIfNecessary();$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:()
WTF::TCMalloc_ThreadCache::CreateCacheIfNecessary	.\FastMalloc.cpp	/^TCMalloc_ThreadCache* TCMalloc_ThreadCache::CreateCacheIfNecessary() {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:()
WTF::TCMalloc_ThreadCache::Deallocate	.\FastMalloc.cpp	/^  void Deallocate(void* ptr, size_t size_class);$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:(void* ptr, size_t size_class)
WTF::TCMalloc_ThreadCache::Deallocate	.\FastMalloc.cpp	/^inline void TCMalloc_ThreadCache::Deallocate(void* ptr, size_t cl) {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:(void* ptr, size_t cl)
WTF::TCMalloc_ThreadCache::DeleteCache	.\FastMalloc.cpp	/^  static void                  DeleteCache(TCMalloc_ThreadCache* heap);$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:(TCMalloc_ThreadCache* heap)
WTF::TCMalloc_ThreadCache::DeleteCache	.\FastMalloc.cpp	/^void TCMalloc_ThreadCache::DeleteCache(TCMalloc_ThreadCache* heap) {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:(TCMalloc_ThreadCache* heap)
WTF::TCMalloc_ThreadCache::DestroyThreadCache	.\FastMalloc.cpp	/^  static void DestroyThreadCache(void* ptr);$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:private	signature:(void* ptr)
WTF::TCMalloc_ThreadCache::DestroyThreadCache	.\FastMalloc.cpp	/^void TCMalloc_ThreadCache::DestroyThreadCache(void* ptr) {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:(void* ptr)
WTF::TCMalloc_ThreadCache::FetchFromCentralCache	.\FastMalloc.cpp	/^  ALWAYS_INLINE void FetchFromCentralCache(size_t cl, size_t allocationSize);$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:(size_t cl, size_t allocationSize)
WTF::TCMalloc_ThreadCache::FetchFromCentralCache	.\FastMalloc.cpp	/^ALWAYS_INLINE void TCMalloc_ThreadCache::FetchFromCentralCache(size_t cl, size_t allocationSize) {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:(size_t cl, size_t allocationSize)
WTF::TCMalloc_ThreadCache::FreeList	.\FastMalloc.cpp	/^  typedef TCMalloc_ThreadCache_FreeList FreeList;$/;"	t	class:WTF::TCMalloc_ThreadCache	file:	access:private
WTF::TCMalloc_ThreadCache::GetCache	.\FastMalloc.cpp	/^  static TCMalloc_ThreadCache* GetCache();$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:()
WTF::TCMalloc_ThreadCache::GetCache	.\FastMalloc.cpp	/^inline TCMalloc_ThreadCache* TCMalloc_ThreadCache::GetCache() {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:()
WTF::TCMalloc_ThreadCache::GetCacheIfPresent	.\FastMalloc.cpp	/^  static TCMalloc_ThreadCache* GetCacheIfPresent();$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:()
WTF::TCMalloc_ThreadCache::GetCacheIfPresent	.\FastMalloc.cpp	/^inline TCMalloc_ThreadCache* TCMalloc_ThreadCache::GetCacheIfPresent() {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:()
WTF::TCMalloc_ThreadCache::GetThreadHeap	.\FastMalloc.cpp	/^  static TCMalloc_ThreadCache* GetThreadHeap();$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:()
WTF::TCMalloc_ThreadCache::GetThreadHeap	.\FastMalloc.cpp	/^inline TCMalloc_ThreadCache* TCMalloc_ThreadCache::GetThreadHeap() {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:()
WTF::TCMalloc_ThreadCache::Init	.\FastMalloc.cpp	/^  void Init(ThreadIdentifier tid);$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:(ThreadIdentifier tid)
WTF::TCMalloc_ThreadCache::Init	.\FastMalloc.cpp	/^void TCMalloc_ThreadCache::Init(ThreadIdentifier tid) {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:(ThreadIdentifier tid)
WTF::TCMalloc_ThreadCache::InitModule	.\FastMalloc.cpp	/^  static void                  InitModule();$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:()
WTF::TCMalloc_ThreadCache::InitModule	.\FastMalloc.cpp	/^void TCMalloc_ThreadCache::InitModule() {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:()
WTF::TCMalloc_ThreadCache::InitTSD	.\FastMalloc.cpp	/^  static void                  InitTSD();$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:()
WTF::TCMalloc_ThreadCache::InitTSD	.\FastMalloc.cpp	/^void TCMalloc_ThreadCache::InitTSD() {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:()
WTF::TCMalloc_ThreadCache::NewHeap	.\FastMalloc.cpp	/^  static inline TCMalloc_ThreadCache* NewHeap(ThreadIdentifier tid);$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:private	signature:(ThreadIdentifier tid)
WTF::TCMalloc_ThreadCache::NewHeap	.\FastMalloc.cpp	/^inline TCMalloc_ThreadCache* TCMalloc_ThreadCache::NewHeap(ThreadIdentifier tid) {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:(ThreadIdentifier tid)
WTF::TCMalloc_ThreadCache::PickNextSample	.\FastMalloc.cpp	/^  void PickNextSample(size_t k);$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:(size_t k)
WTF::TCMalloc_ThreadCache::PickNextSample	.\FastMalloc.cpp	/^void TCMalloc_ThreadCache::PickNextSample(size_t k) {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:(size_t k)
WTF::TCMalloc_ThreadCache::Print	.\FastMalloc.cpp	/^  void Print() const;$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:() const
WTF::TCMalloc_ThreadCache::Print	.\FastMalloc.cpp	/^void TCMalloc_ThreadCache::Print() const {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:() const
WTF::TCMalloc_ThreadCache::RecomputeThreadCacheSize	.\FastMalloc.cpp	/^  static void                  RecomputeThreadCacheSize();$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:()
WTF::TCMalloc_ThreadCache::RecomputeThreadCacheSize	.\FastMalloc.cpp	/^void TCMalloc_ThreadCache::RecomputeThreadCacheSize() {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:()
WTF::TCMalloc_ThreadCache::ReleaseToCentralCache	.\FastMalloc.cpp	/^  void ReleaseToCentralCache(size_t cl, int N);$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:(size_t cl, int N)
WTF::TCMalloc_ThreadCache::ReleaseToCentralCache	.\FastMalloc.cpp	/^inline void TCMalloc_ThreadCache::ReleaseToCentralCache(size_t cl, int N) {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:(size_t cl, int N)
WTF::TCMalloc_ThreadCache::SampleAllocation	.\FastMalloc.cpp	/^  bool SampleAllocation(size_t k);$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:(size_t k)
WTF::TCMalloc_ThreadCache::SampleAllocation	.\FastMalloc.cpp	/^inline bool TCMalloc_ThreadCache::SampleAllocation(size_t k) {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:(size_t k)
WTF::TCMalloc_ThreadCache::Scavenge	.\FastMalloc.cpp	/^  void Scavenge();$/;"	p	class:WTF::TCMalloc_ThreadCache	file:	access:public	signature:()
WTF::TCMalloc_ThreadCache::Scavenge	.\FastMalloc.cpp	/^inline void TCMalloc_ThreadCache::Scavenge() {$/;"	f	class:WTF::TCMalloc_ThreadCache	signature:()
WTF::TCMalloc_ThreadCache::Size	.\FastMalloc.cpp	/^  size_t Size() const { return size_; }$/;"	f	class:WTF::TCMalloc_ThreadCache	access:public	signature:() const
WTF::TCMalloc_ThreadCache::ThreadIdentifier	.\FastMalloc.cpp	/^  typedef DWORD ThreadIdentifier;$/;"	t	class:WTF::TCMalloc_ThreadCache	file:	access:private
WTF::TCMalloc_ThreadCache::ThreadIdentifier	.\FastMalloc.cpp	/^  typedef pthread_t ThreadIdentifier;$/;"	t	class:WTF::TCMalloc_ThreadCache	file:	access:private
WTF::TCMalloc_ThreadCache::bytes_until_sample_	.\FastMalloc.cpp	/^  size_t        bytes_until_sample_;    \/\/ Bytes until we sample next$/;"	m	class:WTF::TCMalloc_ThreadCache	file:	access:private
WTF::TCMalloc_ThreadCache::enumerateFreeObjects	.\FastMalloc.cpp	/^  void enumerateFreeObjects(Finder& finder, const Reader& reader)$/;"	f	class:WTF::TCMalloc_ThreadCache	access:public	signature:(Finder& finder, const Reader& reader)
WTF::TCMalloc_ThreadCache::freelist_length	.\FastMalloc.cpp	/^  int freelist_length(size_t cl) const { return list_[cl].length(); }$/;"	f	class:WTF::TCMalloc_ThreadCache	access:public	signature:(size_t cl) const
WTF::TCMalloc_ThreadCache::in_setspecific_	.\FastMalloc.cpp	/^  bool          in_setspecific_;           \/\/ Called pthread_setspecific?$/;"	m	class:WTF::TCMalloc_ThreadCache	file:	access:private
WTF::TCMalloc_ThreadCache::list_	.\FastMalloc.cpp	/^  FreeList      list_[kNumClasses];     \/\/ Array indexed by size-class$/;"	m	class:WTF::TCMalloc_ThreadCache	file:	access:private
WTF::TCMalloc_ThreadCache::next_	.\FastMalloc.cpp	/^  TCMalloc_ThreadCache* next_;$/;"	m	class:WTF::TCMalloc_ThreadCache	file:	access:public
WTF::TCMalloc_ThreadCache::prev_	.\FastMalloc.cpp	/^  TCMalloc_ThreadCache* prev_;$/;"	m	class:WTF::TCMalloc_ThreadCache	file:	access:public
WTF::TCMalloc_ThreadCache::rnd_	.\FastMalloc.cpp	/^  uint32_t      rnd_;                   \/\/ Cheap random number generator$/;"	m	class:WTF::TCMalloc_ThreadCache	file:	access:private
WTF::TCMalloc_ThreadCache::size_	.\FastMalloc.cpp	/^  size_t        size_;                  \/\/ Combined size of data$/;"	m	class:WTF::TCMalloc_ThreadCache	file:	access:private
WTF::TCMalloc_ThreadCache::tid_	.\FastMalloc.cpp	/^  ThreadIdentifier tid_;                \/\/ Which thread owns it$/;"	m	class:WTF::TCMalloc_ThreadCache	file:	access:private
WTF::TCMalloc_ThreadCache_FreeList	.\FastMalloc.cpp	/^class TCMalloc_ThreadCache_FreeList {$/;"	c	namespace:WTF	file:
WTF::TCMalloc_ThreadCache_FreeList::Init	.\FastMalloc.cpp	/^  void Init() {$/;"	f	class:WTF::TCMalloc_ThreadCache_FreeList	access:public	signature:()
WTF::TCMalloc_ThreadCache_FreeList::Pop	.\FastMalloc.cpp	/^  ALWAYS_INLINE void* Pop() {$/;"	f	class:WTF::TCMalloc_ThreadCache_FreeList	access:public	signature:()
WTF::TCMalloc_ThreadCache_FreeList::PopRange	.\FastMalloc.cpp	/^  void PopRange(int N, void **start, void **end) {$/;"	f	class:WTF::TCMalloc_ThreadCache_FreeList	access:public	signature:(int N, void **start, void **end)
WTF::TCMalloc_ThreadCache_FreeList::Push	.\FastMalloc.cpp	/^  ALWAYS_INLINE void Push(void* ptr) {$/;"	f	class:WTF::TCMalloc_ThreadCache_FreeList	access:public	signature:(void* ptr)
WTF::TCMalloc_ThreadCache_FreeList::PushRange	.\FastMalloc.cpp	/^  void PushRange(int N, void *start, void *end) {$/;"	f	class:WTF::TCMalloc_ThreadCache_FreeList	access:public	signature:(int N, void *start, void *end)
WTF::TCMalloc_ThreadCache_FreeList::clear_lowwatermark	.\FastMalloc.cpp	/^  void clear_lowwatermark() { lowater_ = length_; }$/;"	f	class:WTF::TCMalloc_ThreadCache_FreeList	access:public	signature:()
WTF::TCMalloc_ThreadCache_FreeList::empty	.\FastMalloc.cpp	/^  bool empty() const {$/;"	f	class:WTF::TCMalloc_ThreadCache_FreeList	access:public	signature:() const
WTF::TCMalloc_ThreadCache_FreeList::enumerateFreeObjects	.\FastMalloc.cpp	/^  void enumerateFreeObjects(Finder& finder, const Reader& reader)$/;"	f	class:WTF::TCMalloc_ThreadCache_FreeList	access:public	signature:(Finder& finder, const Reader& reader)
WTF::TCMalloc_ThreadCache_FreeList::length	.\FastMalloc.cpp	/^  int length() const {$/;"	f	class:WTF::TCMalloc_ThreadCache_FreeList	access:public	signature:() const
WTF::TCMalloc_ThreadCache_FreeList::length_	.\FastMalloc.cpp	/^  uint16_t length_;     \/\/ Current length$/;"	m	class:WTF::TCMalloc_ThreadCache_FreeList	file:	access:private
WTF::TCMalloc_ThreadCache_FreeList::list_	.\FastMalloc.cpp	/^  void*    list_;       \/\/ Linked list of nodes$/;"	m	class:WTF::TCMalloc_ThreadCache_FreeList	file:	access:private
WTF::TCMalloc_ThreadCache_FreeList::lowater_	.\FastMalloc.cpp	/^  uint16_t lowater_;    \/\/ Low water mark for list length$/;"	m	class:WTF::TCMalloc_ThreadCache_FreeList	file:	access:private
WTF::TCMalloc_ThreadCache_FreeList::lowwatermark	.\FastMalloc.cpp	/^  int lowwatermark() const { return lowater_; }$/;"	f	class:WTF::TCMalloc_ThreadCache_FreeList	access:public	signature:() const
WTF::THREADNAME_INFO	.\ThreadingWin.cpp	/^} THREADNAME_INFO;$/;"	t	namespace:WTF	typeref:struct:WTF::tagTHREADNAME_INFO	file:
WTF::TemporaryChange	.\TemporaryChange.h	/^class TemporaryChange {$/;"	c	namespace:WTF
WTF::TemporaryChange::TemporaryChange	.\TemporaryChange.h	/^    TemporaryChange(T& scopedVariable, T newValue)$/;"	f	class:WTF::TemporaryChange	access:public	signature:(T& scopedVariable, T newValue)
WTF::TemporaryChange::WTF_MAKE_NONCOPYABLE	.\TemporaryChange.h	/^    WTF_MAKE_NONCOPYABLE(TemporaryChange);$/;"	p	class:WTF::TemporaryChange	access:private	signature:(TemporaryChange)
WTF::TemporaryChange::m_originalValue	.\TemporaryChange.h	/^    T m_originalValue;$/;"	m	class:WTF::TemporaryChange	access:private
WTF::TemporaryChange::m_scopedVariable	.\TemporaryChange.h	/^    T& m_scopedVariable;$/;"	m	class:WTF::TemporaryChange	access:private
WTF::TemporaryChange::~TemporaryChange	.\TemporaryChange.h	/^    ~TemporaryChange()$/;"	f	class:WTF::TemporaryChange	access:public	signature:()
WTF::TestBaseClass	.\TypeTraits.cpp	/^class TestBaseClass {$/;"	c	namespace:WTF	file:
WTF::TestDerivedClass	.\TypeTraits.cpp	/^class TestDerivedClass : public TestBaseClass<int> {$/;"	c	namespace:WTF	file:	inherits:TestBaseClass
WTF::TextCaseInsensitive	.\text\StringImpl.h	/^enum TextCaseSensitivity { TextCaseSensitive, TextCaseInsensitive };$/;"	e	enum:WTF::TextCaseSensitivity
WTF::TextCaseSensitive	.\text\StringImpl.h	/^enum TextCaseSensitivity { TextCaseSensitive, TextCaseInsensitive };$/;"	e	enum:WTF::TextCaseSensitivity
WTF::TextCaseSensitivity	.\text\StringImpl.h	/^enum TextCaseSensitivity { TextCaseSensitive, TextCaseInsensitive };$/;"	g	namespace:WTF
WTF::TextPosition	.\text\TextPosition.h	/^class TextPosition {$/;"	c	namespace:WTF
WTF::TextPosition::TextPosition	.\text\TextPosition.h	/^    TextPosition() { }$/;"	f	class:WTF::TextPosition	access:public	signature:()
WTF::TextPosition::TextPosition	.\text\TextPosition.h	/^    TextPosition(OrdinalNumber line, OrdinalNumber column)$/;"	f	class:WTF::TextPosition	access:public	signature:(OrdinalNumber line, OrdinalNumber column)
WTF::TextPosition::belowRangePosition	.\text\TextPosition.h	/^    static TextPosition belowRangePosition() { return TextPosition(OrdinalNumber::beforeFirst(), OrdinalNumber::beforeFirst()); }$/;"	f	class:WTF::TextPosition	access:public	signature:()
WTF::TextPosition::m_column	.\text\TextPosition.h	/^    OrdinalNumber m_column;$/;"	m	class:WTF::TextPosition	access:public
WTF::TextPosition::m_line	.\text\TextPosition.h	/^    OrdinalNumber m_line;$/;"	m	class:WTF::TextPosition	access:public
WTF::TextPosition::minimumPosition	.\text\TextPosition.h	/^    static TextPosition minimumPosition() { return TextPosition(OrdinalNumber::first(), OrdinalNumber::first()); }$/;"	f	class:WTF::TextPosition	access:public	signature:()
WTF::TextPosition::operator !=	.\text\TextPosition.h	/^    bool operator!=(const TextPosition& other) { return !((*this) == other); }$/;"	f	class:WTF::TextPosition	access:public	signature:(const TextPosition& other)
WTF::TextPosition::operator ==	.\text\TextPosition.h	/^    bool operator==(const TextPosition& other) { return m_line == other.m_line && m_column == other.m_column; }$/;"	f	class:WTF::TextPosition	access:public	signature:(const TextPosition& other)
WTF::ThreadCondition	.\ThreadingPrimitives.h	/^class ThreadCondition {$/;"	c	namespace:WTF
WTF::ThreadCondition::ThreadCondition	.\ThreadingPrimitives.h	/^    WTF_EXPORT_PRIVATE ThreadCondition();$/;"	p	class:WTF::ThreadCondition	access:public	signature:()
WTF::ThreadCondition::ThreadCondition	.\ThreadingPthreads.cpp	/^ThreadCondition::ThreadCondition()$/;"	f	class:WTF::ThreadCondition	signature:()
WTF::ThreadCondition::ThreadCondition	.\ThreadingWin.cpp	/^ThreadCondition::ThreadCondition()$/;"	f	class:WTF::ThreadCondition	signature:()
WTF::ThreadCondition::WTF_MAKE_NONCOPYABLE	.\ThreadingPrimitives.h	/^    WTF_MAKE_NONCOPYABLE(ThreadCondition);$/;"	p	class:WTF::ThreadCondition	access:private	signature:(ThreadCondition)
WTF::ThreadCondition::broadcast	.\ThreadingPrimitives.h	/^    WTF_EXPORT_PRIVATE void broadcast();$/;"	p	class:WTF::ThreadCondition	access:public	signature:()
WTF::ThreadCondition::broadcast	.\ThreadingPthreads.cpp	/^void ThreadCondition::broadcast()$/;"	f	class:WTF::ThreadCondition	signature:()
WTF::ThreadCondition::broadcast	.\ThreadingWin.cpp	/^void ThreadCondition::broadcast()$/;"	f	class:WTF::ThreadCondition	signature:()
WTF::ThreadCondition::m_condition	.\ThreadingPrimitives.h	/^    PlatformCondition m_condition;$/;"	m	class:WTF::ThreadCondition	access:private
WTF::ThreadCondition::signal	.\ThreadingPrimitives.h	/^    WTF_EXPORT_PRIVATE void signal();$/;"	p	class:WTF::ThreadCondition	access:public	signature:()
WTF::ThreadCondition::signal	.\ThreadingPthreads.cpp	/^void ThreadCondition::signal()$/;"	f	class:WTF::ThreadCondition	signature:()
WTF::ThreadCondition::signal	.\ThreadingWin.cpp	/^void ThreadCondition::signal()$/;"	f	class:WTF::ThreadCondition	signature:()
WTF::ThreadCondition::timedWait	.\ThreadingPrimitives.h	/^    WTF_EXPORT_PRIVATE bool timedWait(Mutex&, double absoluteTime);$/;"	p	class:WTF::ThreadCondition	access:public	signature:(Mutex&, double absoluteTime)
WTF::ThreadCondition::timedWait	.\ThreadingPthreads.cpp	/^bool ThreadCondition::timedWait(Mutex& mutex, double absoluteTime)$/;"	f	class:WTF::ThreadCondition	signature:(Mutex& mutex, double absoluteTime)
WTF::ThreadCondition::timedWait	.\ThreadingWin.cpp	/^bool ThreadCondition::timedWait(Mutex& mutex, double absoluteTime)$/;"	f	class:WTF::ThreadCondition	signature:(Mutex& mutex, double absoluteTime)
WTF::ThreadCondition::wait	.\ThreadingPrimitives.h	/^    WTF_EXPORT_PRIVATE void wait(Mutex& mutex);$/;"	p	class:WTF::ThreadCondition	access:public	signature:(Mutex& mutex)
WTF::ThreadCondition::wait	.\ThreadingPthreads.cpp	/^void ThreadCondition::wait(Mutex& mutex)$/;"	f	class:WTF::ThreadCondition	signature:(Mutex& mutex)
WTF::ThreadCondition::wait	.\ThreadingWin.cpp	/^void ThreadCondition::wait(Mutex& mutex)$/;"	f	class:WTF::ThreadCondition	signature:(Mutex& mutex)
WTF::ThreadCondition::~ThreadCondition	.\ThreadingPrimitives.h	/^    WTF_EXPORT_PRIVATE ~ThreadCondition();$/;"	p	class:WTF::ThreadCondition	access:public	signature:()
WTF::ThreadCondition::~ThreadCondition	.\ThreadingPthreads.cpp	/^ThreadCondition::~ThreadCondition()$/;"	f	class:WTF::ThreadCondition	signature:()
WTF::ThreadCondition::~ThreadCondition	.\ThreadingWin.cpp	/^ThreadCondition::~ThreadCondition()$/;"	f	class:WTF::ThreadCondition	signature:()
WTF::ThreadFunction	.\ThreadFunctionInvocation.h	/^typedef void (*ThreadFunction)(void* argument);$/;"	t	namespace:WTF
WTF::ThreadFunction	.\Threading.h	/^typedef void (*ThreadFunction)(void* argument);$/;"	t	namespace:WTF
WTF::ThreadFunctionInvocation	.\ThreadFunctionInvocation.h	/^struct ThreadFunctionInvocation {$/;"	s	namespace:WTF
WTF::ThreadFunctionInvocation::ThreadFunctionInvocation	.\ThreadFunctionInvocation.h	/^    ThreadFunctionInvocation(ThreadFunction function, void* data)$/;"	f	struct:WTF::ThreadFunctionInvocation	access:public	signature:(ThreadFunction function, void* data)
WTF::ThreadFunctionInvocation::data	.\ThreadFunctionInvocation.h	/^    void* data;$/;"	m	struct:WTF::ThreadFunctionInvocation	access:public
WTF::ThreadFunctionInvocation::function	.\ThreadFunctionInvocation.h	/^    ThreadFunction function;$/;"	m	struct:WTF::ThreadFunctionInvocation	access:public
WTF::ThreadFunctionWithReturnValue	.\Threading.cpp	/^typedef void* (*ThreadFunctionWithReturnValue)(void* argument);$/;"	t	namespace:WTF	file:
WTF::ThreadFunctionWithReturnValueInvocation	.\Threading.cpp	/^struct ThreadFunctionWithReturnValueInvocation {$/;"	s	namespace:WTF	file:
WTF::ThreadFunctionWithReturnValueInvocation::ThreadFunctionWithReturnValueInvocation	.\Threading.cpp	/^    ThreadFunctionWithReturnValueInvocation(ThreadFunctionWithReturnValue function, void* data)$/;"	f	struct:WTF::ThreadFunctionWithReturnValueInvocation	access:public	signature:(ThreadFunctionWithReturnValue function, void* data)
WTF::ThreadFunctionWithReturnValueInvocation::data	.\Threading.cpp	/^    void* data;$/;"	m	struct:WTF::ThreadFunctionWithReturnValueInvocation	file:	access:public
WTF::ThreadFunctionWithReturnValueInvocation::function	.\Threading.cpp	/^    ThreadFunctionWithReturnValue function;$/;"	m	struct:WTF::ThreadFunctionWithReturnValueInvocation	file:	access:public
WTF::ThreadIdentifier	.\MainThread.h	/^typedef uint32_t ThreadIdentifier;$/;"	t	namespace:WTF
WTF::ThreadIdentifier	.\Threading.h	/^typedef uint32_t ThreadIdentifier;$/;"	t	namespace:WTF
WTF::ThreadIdentifierData	.\ThreadIdentifierDataPthreads.h	/^class ThreadIdentifierData {$/;"	c	namespace:WTF
WTF::ThreadIdentifierData::ThreadIdentifierData	.\ThreadIdentifierDataPthreads.h	/^    ThreadIdentifierData(ThreadIdentifier identifier)$/;"	f	class:WTF::ThreadIdentifierData	access:private	signature:(ThreadIdentifier identifier)
WTF::ThreadIdentifierData::WTF_MAKE_NONCOPYABLE	.\ThreadIdentifierDataPthreads.h	/^    WTF_MAKE_NONCOPYABLE(ThreadIdentifierData);$/;"	p	class:WTF::ThreadIdentifierData	access:private	signature:(ThreadIdentifierData)
WTF::ThreadIdentifierData::destruct	.\ThreadIdentifierDataPthreads.cpp	/^void ThreadIdentifierData::destruct(void* data)$/;"	f	class:WTF::ThreadIdentifierData	signature:(void* data)
WTF::ThreadIdentifierData::destruct	.\ThreadIdentifierDataPthreads.h	/^    static void destruct(void* data);$/;"	p	class:WTF::ThreadIdentifierData	access:private	signature:(void* data)
WTF::ThreadIdentifierData::identifier	.\ThreadIdentifierDataPthreads.cpp	/^ThreadIdentifier ThreadIdentifierData::identifier()$/;"	f	class:WTF::ThreadIdentifierData	signature:()
WTF::ThreadIdentifierData::identifier	.\ThreadIdentifierDataPthreads.h	/^    static ThreadIdentifier identifier();$/;"	p	class:WTF::ThreadIdentifierData	access:public	signature:()
WTF::ThreadIdentifierData::initialize	.\ThreadIdentifierDataPthreads.cpp	/^void ThreadIdentifierData::initialize(ThreadIdentifier id)$/;"	f	class:WTF::ThreadIdentifierData	signature:(ThreadIdentifier id)
WTF::ThreadIdentifierData::initialize	.\ThreadIdentifierDataPthreads.h	/^    static void initialize(ThreadIdentifier identifier);$/;"	p	class:WTF::ThreadIdentifierData	access:public	signature:(ThreadIdentifier identifier)
WTF::ThreadIdentifierData::initializeOnce	.\ThreadIdentifierDataPthreads.cpp	/^void ThreadIdentifierData::initializeOnce()$/;"	f	class:WTF::ThreadIdentifierData	signature:()
WTF::ThreadIdentifierData::initializeOnce	.\ThreadIdentifierDataPthreads.h	/^    static void initializeOnce();$/;"	p	class:WTF::ThreadIdentifierData	access:public	signature:()
WTF::ThreadIdentifierData::m_identifier	.\ThreadIdentifierDataPthreads.h	/^    ThreadIdentifier m_identifier;$/;"	m	class:WTF::ThreadIdentifierData	access:private
WTF::ThreadIdentifierData::m_isDestroyedOnce	.\ThreadIdentifierDataPthreads.h	/^    bool m_isDestroyedOnce;$/;"	m	class:WTF::ThreadIdentifierData	access:private
WTF::ThreadIdentifierData::m_key	.\ThreadIdentifierDataPthreads.cpp	/^pthread_key_t ThreadIdentifierData::m_key = PTHREAD_KEYS_MAX;$/;"	m	class:WTF::ThreadIdentifierData	file:
WTF::ThreadIdentifierData::m_key	.\ThreadIdentifierDataPthreads.h	/^    static pthread_key_t m_key;$/;"	m	class:WTF::ThreadIdentifierData	access:private
WTF::ThreadIdentifierData::~ThreadIdentifierData	.\ThreadIdentifierDataPthreads.cpp	/^ThreadIdentifierData::~ThreadIdentifierData()$/;"	f	class:WTF::ThreadIdentifierData	signature:()
WTF::ThreadIdentifierData::~ThreadIdentifierData	.\ThreadIdentifierDataPthreads.h	/^    ~ThreadIdentifierData();$/;"	p	class:WTF::ThreadIdentifierData	access:public	signature:()
WTF::ThreadMap	.\ThreadingPthreads.cpp	/^typedef HashMap<ThreadIdentifier, pthread_t> ThreadMap;$/;"	t	namespace:WTF	file:
WTF::ThreadRestrictionVerifier	.\ThreadRestrictionVerifier.h	/^class ThreadRestrictionVerifier {$/;"	c	namespace:WTF
WTF::ThreadRestrictionVerifier::MutexVerificationMode	.\ThreadRestrictionVerifier.h	/^        MutexVerificationMode,$/;"	e	enum:WTF::ThreadRestrictionVerifier::VerificationMode
WTF::ThreadRestrictionVerifier::NoVerificationMode	.\ThreadRestrictionVerifier.h	/^        NoVerificationMode,$/;"	e	enum:WTF::ThreadRestrictionVerifier::VerificationMode
WTF::ThreadRestrictionVerifier::SingleDispatchQueueVerificationMode	.\ThreadRestrictionVerifier.h	/^        SingleDispatchQueueVerificationMode,$/;"	e	enum:WTF::ThreadRestrictionVerifier::VerificationMode
WTF::ThreadRestrictionVerifier::SingleThreadVerificationMode	.\ThreadRestrictionVerifier.h	/^        SingleThreadVerificationMode,$/;"	e	enum:WTF::ThreadRestrictionVerifier::VerificationMode
WTF::ThreadRestrictionVerifier::ThreadRestrictionVerifier	.\ThreadRestrictionVerifier.h	/^    ThreadRestrictionVerifier()$/;"	f	class:WTF::ThreadRestrictionVerifier	access:public	signature:()
WTF::ThreadRestrictionVerifier::VerificationMode	.\ThreadRestrictionVerifier.h	/^    enum VerificationMode {$/;"	g	class:WTF::ThreadRestrictionVerifier	access:private
WTF::ThreadRestrictionVerifier::isSafeToUse	.\ThreadRestrictionVerifier.h	/^    bool isSafeToUse() const$/;"	f	class:WTF::ThreadRestrictionVerifier	access:public	signature:() const
WTF::ThreadRestrictionVerifier::m_mode	.\ThreadRestrictionVerifier.h	/^    VerificationMode m_mode;$/;"	m	class:WTF::ThreadRestrictionVerifier	access:private
WTF::ThreadRestrictionVerifier::m_mutex	.\ThreadRestrictionVerifier.h	/^    Mutex* m_mutex;$/;"	m	class:WTF::ThreadRestrictionVerifier	access:private
WTF::ThreadRestrictionVerifier::m_owningQueue	.\ThreadRestrictionVerifier.h	/^    dispatch_queue_t m_owningQueue;$/;"	m	class:WTF::ThreadRestrictionVerifier	access:private
WTF::ThreadRestrictionVerifier::m_owningThread	.\ThreadRestrictionVerifier.h	/^    ThreadIdentifier m_owningThread;$/;"	m	class:WTF::ThreadRestrictionVerifier	access:private
WTF::ThreadRestrictionVerifier::m_shared	.\ThreadRestrictionVerifier.h	/^    bool m_shared;$/;"	m	class:WTF::ThreadRestrictionVerifier	access:private
WTF::ThreadRestrictionVerifier::setDispatchQueueMode	.\ThreadRestrictionVerifier.h	/^    void setDispatchQueueMode(dispatch_queue_t queue)$/;"	f	class:WTF::ThreadRestrictionVerifier	access:public	signature:(dispatch_queue_t queue)
WTF::ThreadRestrictionVerifier::setMutexMode	.\ThreadRestrictionVerifier.h	/^    void setMutexMode(Mutex& mutex)$/;"	f	class:WTF::ThreadRestrictionVerifier	access:public	signature:(Mutex& mutex)
WTF::ThreadRestrictionVerifier::setShared	.\ThreadRestrictionVerifier.h	/^    void setShared(bool shared)$/;"	f	class:WTF::ThreadRestrictionVerifier	access:public	signature:(bool shared)
WTF::ThreadRestrictionVerifier::turnOffVerification	.\ThreadRestrictionVerifier.h	/^    void turnOffVerification()$/;"	f	class:WTF::ThreadRestrictionVerifier	access:public	signature:()
WTF::ThreadRestrictionVerifier::~ThreadRestrictionVerifier	.\ThreadRestrictionVerifier.h	/^    ~ThreadRestrictionVerifier()$/;"	f	class:WTF::ThreadRestrictionVerifier	access:public	signature:()
WTF::ThreadSafeRefCounted	.\ThreadSafeRefCounted.h	/^template<class T> class ThreadSafeRefCounted : public ThreadSafeRefCountedBase {$/;"	c	namespace:WTF	inherits:ThreadSafeRefCountedBase
WTF::ThreadSafeRefCounted::ThreadSafeRefCounted	.\ThreadSafeRefCounted.h	/^    ThreadSafeRefCounted()$/;"	f	class:WTF::ThreadSafeRefCounted	access:protected	signature:()
WTF::ThreadSafeRefCounted::deref	.\ThreadSafeRefCounted.h	/^    void deref()$/;"	f	class:WTF::ThreadSafeRefCounted	access:public	signature:()
WTF::ThreadSafeRefCountedBase	.\ThreadSafeRefCounted.h	/^class ThreadSafeRefCountedBase {$/;"	c	namespace:WTF
WTF::ThreadSafeRefCountedBase::ThreadSafeRefCountedBase	.\ThreadSafeRefCounted.h	/^    ThreadSafeRefCountedBase(int initialRefCount = 1)$/;"	f	class:WTF::ThreadSafeRefCountedBase	access:public	signature:(int initialRefCount = 1)
WTF::ThreadSafeRefCountedBase::WTF_MAKE_FAST_ALLOCATED	.\ThreadSafeRefCounted.h	/^    WTF_MAKE_FAST_ALLOCATED;$/;"	m	class:WTF::ThreadSafeRefCountedBase	access:private
WTF::ThreadSafeRefCountedBase::WTF_MAKE_NONCOPYABLE	.\ThreadSafeRefCounted.h	/^    WTF_MAKE_NONCOPYABLE(ThreadSafeRefCountedBase);$/;"	p	class:WTF::ThreadSafeRefCountedBase	access:private	signature:(ThreadSafeRefCountedBase)
WTF::ThreadSafeRefCountedBase::derefBase	.\ThreadSafeRefCounted.h	/^    bool derefBase()$/;"	f	class:WTF::ThreadSafeRefCountedBase	access:protected	signature:()
WTF::ThreadSafeRefCountedBase::hasOneRef	.\ThreadSafeRefCounted.h	/^    bool hasOneRef()$/;"	f	class:WTF::ThreadSafeRefCountedBase	access:public	signature:()
WTF::ThreadSafeRefCountedBase::m_mutex	.\ThreadSafeRefCounted.h	/^    mutable Mutex m_mutex;$/;"	m	class:WTF::ThreadSafeRefCountedBase	access:private
WTF::ThreadSafeRefCountedBase::m_refCount	.\ThreadSafeRefCounted.h	/^    int m_refCount;$/;"	m	class:WTF::ThreadSafeRefCountedBase	access:private
WTF::ThreadSafeRefCountedBase::ref	.\ThreadSafeRefCounted.h	/^    void ref()$/;"	f	class:WTF::ThreadSafeRefCountedBase	access:public	signature:()
WTF::ThreadSafeRefCountedBase::refCount	.\ThreadSafeRefCounted.h	/^    int refCount() const$/;"	f	class:WTF::ThreadSafeRefCountedBase	access:public	signature:() const
WTF::ThreadSpecific	.\ThreadSpecific.h	/^template<typename T> class ThreadSpecific {$/;"	c	namespace:WTF
WTF::ThreadSpecific::Data	.\ThreadSpecific.h	/^    struct Data {$/;"	s	class:WTF::ThreadSpecific	access:private
WTF::ThreadSpecific::Data::Data	.\ThreadSpecific.h	/^        Data(T* value, ThreadSpecific<T>* owner) : value(value), owner(owner) {}$/;"	f	struct:WTF::ThreadSpecific::Data	access:public	signature:(T* value, ThreadSpecific<T>* owner)
WTF::ThreadSpecific::Data::WTF_MAKE_NONCOPYABLE	.\ThreadSpecific.h	/^        WTF_MAKE_NONCOPYABLE(Data);$/;"	p	struct:WTF::ThreadSpecific::Data	access:public	signature:(Data)
WTF::ThreadSpecific::Data::destructor	.\ThreadSpecific.h	/^        void (*destructor)(void*);$/;"	m	struct:WTF::ThreadSpecific::Data	access:public
WTF::ThreadSpecific::Data::owner	.\ThreadSpecific.h	/^        ThreadSpecific<T>* owner;$/;"	m	struct:WTF::ThreadSpecific::Data	access:public
WTF::ThreadSpecific::Data::value	.\ThreadSpecific.h	/^        T* value;$/;"	m	struct:WTF::ThreadSpecific::Data	access:public
WTF::ThreadSpecific::ThreadSpecific	.\ThreadSpecific.h	/^    ThreadSpecific();$/;"	p	class:WTF::ThreadSpecific	access:public	signature:()
WTF::ThreadSpecific::ThreadSpecific	.\ThreadSpecific.h	/^inline ThreadSpecific<T>::ThreadSpecific()$/;"	f	class:WTF::ThreadSpecific	signature:()
WTF::ThreadSpecific::ThreadSpecificThreadExit	.\ThreadSpecific.h	/^    friend void ThreadSpecificThreadExit();$/;"	p	class:WTF::ThreadSpecific	access:friend	signature:()
WTF::ThreadSpecific::WTF_MAKE_NONCOPYABLE	.\ThreadSpecific.h	/^    WTF_MAKE_NONCOPYABLE(ThreadSpecific);$/;"	p	class:WTF::ThreadSpecific	access:private	signature:(ThreadSpecific)
WTF::ThreadSpecific::destroy	.\ThreadSpecific.h	/^    void static destroy(void* ptr);$/;"	p	class:WTF::ThreadSpecific	access:private	signature:(void* ptr)
WTF::ThreadSpecific::destroy	.\ThreadSpecific.h	/^inline void ThreadSpecific<T>::destroy(void* ptr)$/;"	f	class:WTF::ThreadSpecific	signature:(void* ptr)
WTF::ThreadSpecific::get	.\ThreadSpecific.h	/^    T* get();$/;"	p	class:WTF::ThreadSpecific	access:private	signature:()
WTF::ThreadSpecific::get	.\ThreadSpecific.h	/^inline T* ThreadSpecific<T>::get()$/;"	f	class:WTF::ThreadSpecific	signature:()
WTF::ThreadSpecific::isSet	.\ThreadSpecific.h	/^    bool isSet(); \/\/ Useful as a fast check to see if this thread has set this value.$/;"	p	class:WTF::ThreadSpecific	access:public	signature:()
WTF::ThreadSpecific::isSet	.\ThreadSpecific.h	/^inline bool ThreadSpecific<T>::isSet()$/;"	f	class:WTF::ThreadSpecific	signature:()
WTF::ThreadSpecific::m_index	.\ThreadSpecific.h	/^    int m_index;$/;"	m	class:WTF::ThreadSpecific	access:private
WTF::ThreadSpecific::m_key	.\ThreadSpecific.h	/^    pthread_key_t m_key;$/;"	m	class:WTF::ThreadSpecific	access:private
WTF::ThreadSpecific::operator *	.\ThreadSpecific.h	/^    T& operator*();$/;"	p	class:WTF::ThreadSpecific	access:public	signature:()
WTF::ThreadSpecific::operator *	.\ThreadSpecific.h	/^inline T& ThreadSpecific<T>::operator*()$/;"	f	class:WTF::ThreadSpecific	signature:()
WTF::ThreadSpecific::operator ->	.\ThreadSpecific.h	/^    T* operator->();$/;"	p	class:WTF::ThreadSpecific	access:public	signature:()
WTF::ThreadSpecific::operator ->	.\ThreadSpecific.h	/^inline T* ThreadSpecific<T>::operator->()$/;"	f	class:WTF::ThreadSpecific	signature:()
WTF::ThreadSpecific::operator T*	.\ThreadSpecific.h	/^    operator T*();$/;"	p	class:WTF::ThreadSpecific	access:public	signature:()
WTF::ThreadSpecific::operator T*	.\ThreadSpecific.h	/^inline ThreadSpecific<T>::operator T*()$/;"	f	class:WTF::ThreadSpecific	signature:()
WTF::ThreadSpecific::set	.\ThreadSpecific.h	/^    void set(T*);$/;"	p	class:WTF::ThreadSpecific	access:private	signature:(T*)
WTF::ThreadSpecific::set	.\ThreadSpecific.h	/^inline void ThreadSpecific<T>::set(T* ptr)$/;"	f	class:WTF::ThreadSpecific	signature:(T* ptr)
WTF::ThreadSpecific::~ThreadSpecific	.\ThreadSpecific.h	/^    ~ThreadSpecific();$/;"	p	class:WTF::ThreadSpecific	access:private	signature:()
WTF::ThreadSpecific::~ThreadSpecific	.\ThreadSpecific.h	/^inline ThreadSpecific<T>::~ThreadSpecific()$/;"	f	class:WTF::ThreadSpecific	signature:()
WTF::ThreadSpecificThreadExit	.\ThreadSpecific.h	/^void ThreadSpecificThreadExit();$/;"	p	namespace:WTF	signature:()
WTF::ThreadSpecificThreadExit	.\ThreadSpecificWin.cpp	/^void ThreadSpecificThreadExit()$/;"	f	namespace:WTF	signature:()
WTF::ThreadingWindowWndProc	.\win\MainThreadWin.cpp	/^LRESULT CALLBACK ThreadingWindowWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)$/;"	f	namespace:WTF	signature:(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
WTF::TryMallocReturnValue	.\FastMalloc.h	/^    struct TryMallocReturnValue {$/;"	s	namespace:WTF
WTF::TryMallocReturnValue::TryMallocReturnValue	.\FastMalloc.h	/^        TryMallocReturnValue(const TryMallocReturnValue& source)$/;"	f	struct:WTF::TryMallocReturnValue	access:public	signature:(const TryMallocReturnValue& source)
WTF::TryMallocReturnValue::TryMallocReturnValue	.\FastMalloc.h	/^        TryMallocReturnValue(void* data)$/;"	f	struct:WTF::TryMallocReturnValue	access:public	signature:(void* data)
WTF::TryMallocReturnValue::WARN_UNUSED_RETURN	.\FastMalloc.h	/^        template <typename T> bool getValue(T& data) WARN_UNUSED_RETURN;$/;"	m	struct:WTF::TryMallocReturnValue	access:public
WTF::TryMallocReturnValue::getValue	.\FastMalloc.h	/^    template <typename T> bool TryMallocReturnValue::getValue(T& data)$/;"	f	class:WTF::TryMallocReturnValue	signature:(T& data)
WTF::TryMallocReturnValue::m_data	.\FastMalloc.h	/^        mutable void* m_data;$/;"	m	struct:WTF::TryMallocReturnValue	access:private
WTF::TryMallocReturnValue::operator PossiblyNull<T>	.\FastMalloc.h	/^        template <typename T> operator PossiblyNull<T>()$/;"	f	struct:WTF::TryMallocReturnValue	access:public	signature:()
WTF::TryMallocReturnValue::~TryMallocReturnValue	.\FastMalloc.h	/^        ~TryMallocReturnValue() { ASSERT(!m_data); }$/;"	f	struct:WTF::TryMallocReturnValue	access:public	signature:()
WTF::TypedArrayBase	.\TypedArrayBase.h	/^class TypedArrayBase : public ArrayBufferView {$/;"	c	namespace:WTF	inherits:ArrayBufferView
WTF::TypedArrayBase::TypedArrayBase	.\TypedArrayBase.h	/^    TypedArrayBase(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::TypedArrayBase	access:protected	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
WTF::TypedArrayBase::byteLength	.\TypedArrayBase.h	/^    virtual unsigned byteLength() const$/;"	f	class:WTF::TypedArrayBase	access:public	signature:() const
WTF::TypedArrayBase::create	.\TypedArrayBase.h	/^    static PassRefPtr<Subclass> create(PassRefPtr<ArrayBuffer> buffer,$/;"	f	class:WTF::TypedArrayBase	access:protected	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
WTF::TypedArrayBase::create	.\TypedArrayBase.h	/^    static PassRefPtr<Subclass> create(const T* array, unsigned length)$/;"	f	class:WTF::TypedArrayBase	access:protected	signature:(const T* array, unsigned length)
WTF::TypedArrayBase::create	.\TypedArrayBase.h	/^    static PassRefPtr<Subclass> create(unsigned length)$/;"	f	class:WTF::TypedArrayBase	access:protected	signature:(unsigned length)
WTF::TypedArrayBase::data	.\TypedArrayBase.h	/^    T* data() const { return static_cast<T*>(baseAddress()); }$/;"	f	class:WTF::TypedArrayBase	access:public	signature:() const
WTF::TypedArrayBase::length	.\TypedArrayBase.h	/^    unsigned length() const$/;"	f	class:WTF::TypedArrayBase	access:public	signature:() const
WTF::TypedArrayBase::m_length	.\TypedArrayBase.h	/^    unsigned m_length;$/;"	m	class:WTF::TypedArrayBase	access:protected
WTF::TypedArrayBase::neuter	.\TypedArrayBase.h	/^    virtual void neuter()$/;"	f	class:WTF::TypedArrayBase	access:protected	signature:()
WTF::TypedArrayBase::set	.\TypedArrayBase.h	/^    bool set(TypedArrayBase<T>* array, unsigned offset)$/;"	f	class:WTF::TypedArrayBase	access:public	signature:(TypedArrayBase<T>* array, unsigned offset)
WTF::TypedArrayBase::setRange	.\TypedArrayBase.h	/^    bool setRange(const T* data, size_t dataLength, unsigned offset)$/;"	f	class:WTF::TypedArrayBase	access:public	signature:(const T* data, size_t dataLength, unsigned offset)
WTF::TypedArrayBase::subarrayImpl	.\TypedArrayBase.h	/^    PassRefPtr<Subclass> subarrayImpl(int start, int end) const$/;"	f	class:WTF::TypedArrayBase	access:protected	signature:(int start, int end) const
WTF::TypedArrayBase::zeroRange	.\TypedArrayBase.h	/^    bool zeroRange(unsigned offset, size_t length)$/;"	f	class:WTF::TypedArrayBase	access:public	signature:(unsigned offset, size_t length)
WTF::U	.\dtoa.cpp	/^} U;$/;"	t	namespace:WTF	typeref:union:WTF::__anon4	file:
WTF::UCharBuffer	.\text\AtomicString.cpp	/^struct UCharBuffer {$/;"	s	namespace:WTF	file:
WTF::UCharBuffer::length	.\text\AtomicString.cpp	/^    unsigned length;$/;"	m	struct:WTF::UCharBuffer	file:	access:public
WTF::UCharBuffer::s	.\text\AtomicString.cpp	/^    const UChar* s;$/;"	m	struct:WTF::UCharBuffer	file:	access:public
WTF::UCharBufferTranslator	.\text\AtomicString.cpp	/^struct UCharBufferTranslator {$/;"	s	namespace:WTF	file:
WTF::UCharBufferTranslator::equal	.\text\AtomicString.cpp	/^    static bool equal(StringImpl* const& str, const UCharBuffer& buf)$/;"	f	struct:WTF::UCharBufferTranslator	access:public	signature:(StringImpl* const& str, const UCharBuffer& buf)
WTF::UCharBufferTranslator::hash	.\text\AtomicString.cpp	/^    static unsigned hash(const UCharBuffer& buf)$/;"	f	struct:WTF::UCharBufferTranslator	access:public	signature:(const UCharBuffer& buf)
WTF::UCharBufferTranslator::translate	.\text\AtomicString.cpp	/^    static void translate(StringImpl*& location, const UCharBuffer& buf, unsigned hash)$/;"	f	struct:WTF::UCharBufferTranslator	access:public	signature:(StringImpl*& location, const UCharBuffer& buf, unsigned hash)
WTF::UCharPredicate	.\text\StringImpl.cpp	/^class UCharPredicate {$/;"	c	namespace:WTF	file:
WTF::UCharPredicate::UCharPredicate	.\text\StringImpl.cpp	/^    inline UCharPredicate(CharacterMatchFunctionPtr function): m_function(function) { }$/;"	f	class:WTF::UCharPredicate	access:public	signature:(CharacterMatchFunctionPtr function)
WTF::UCharPredicate::m_function	.\text\StringImpl.cpp	/^    const CharacterMatchFunctionPtr m_function;$/;"	m	class:WTF::UCharPredicate	file:	access:private
WTF::UCharPredicate::operator ()	.\text\StringImpl.cpp	/^    inline bool operator()(UChar ch) const$/;"	f	class:WTF::UCharPredicate	access:public	signature:(UChar ch) const
WTF::URLBuffer	.\url\src\URLBuffer.h	/^class URLBuffer {$/;"	c	namespace:WTF
WTF::URLBuffer::URLBuffer	.\url\src\URLBuffer.h	/^    URLBuffer() : m_buffer(0), m_capacity(0), m_length(0) { }$/;"	f	class:WTF::URLBuffer	access:public	signature:()
WTF::URLBuffer::append	.\url\src\URLBuffer.h	/^    void append(CharacterType ch)$/;"	f	class:WTF::URLBuffer	access:public	signature:(CharacterType ch)
WTF::URLBuffer::append	.\url\src\URLBuffer.h	/^    void append(const CharacterType* str, int strLength)$/;"	f	class:WTF::URLBuffer	access:public	signature:(const CharacterType* str, int strLength)
WTF::URLBuffer::at	.\url\src\URLBuffer.h	/^    inline char at(int offset) const { return m_buffer[offset]; }$/;"	f	class:WTF::URLBuffer	access:public	signature:(int offset) const
WTF::URLBuffer::capacity	.\url\src\URLBuffer.h	/^    int capacity() const { return m_capacity; }$/;"	f	class:WTF::URLBuffer	access:public	signature:() const
WTF::URLBuffer::data	.\url\src\URLBuffer.h	/^    CharacterType* data() { return m_buffer; }$/;"	f	class:WTF::URLBuffer	access:public	signature:()
WTF::URLBuffer::data	.\url\src\URLBuffer.h	/^    const CharacterType* data() const { return m_buffer; }$/;"	f	class:WTF::URLBuffer	access:public	signature:() const
WTF::URLBuffer::grow	.\url\src\URLBuffer.h	/^    bool grow(int minimumAdditionalCapacity)$/;"	f	class:WTF::URLBuffer	access:protected	signature:(int minimumAdditionalCapacity)
WTF::URLBuffer::length	.\url\src\URLBuffer.h	/^    int length() const { return m_length; }$/;"	f	class:WTF::URLBuffer	access:public	signature:() const
WTF::URLBuffer::m_buffer	.\url\src\URLBuffer.h	/^    CharacterType* m_buffer;$/;"	m	class:WTF::URLBuffer	access:protected
WTF::URLBuffer::m_capacity	.\url\src\URLBuffer.h	/^    int m_capacity;$/;"	m	class:WTF::URLBuffer	access:protected
WTF::URLBuffer::m_length	.\url\src\URLBuffer.h	/^    int m_length; \/\/ Used characters in the buffer.$/;"	m	class:WTF::URLBuffer	access:protected
WTF::URLBuffer::resize	.\url\src\URLBuffer.h	/^    virtual void resize(int) = 0;$/;"	p	class:WTF::URLBuffer	access:public	signature:(int)
WTF::URLBuffer::set	.\url\src\URLBuffer.h	/^    inline void set(int offset, CharacterType ch)$/;"	f	class:WTF::URLBuffer	access:public	signature:(int offset, CharacterType ch)
WTF::URLBuffer::setLength	.\url\src\URLBuffer.h	/^    void setLength(int length)$/;"	f	class:WTF::URLBuffer	access:public	signature:(int length)
WTF::URLBuffer::~URLBuffer	.\url\src\URLBuffer.h	/^    virtual ~URLBuffer() { }$/;"	f	class:WTF::URLBuffer	access:public	signature:()
WTF::URLCharacterTypes	.\url\src\URLCharacterTypes.h	/^class URLCharacterTypes {$/;"	c	namespace:WTF
WTF::URLCharacterTypes::CharTypes	.\url\src\URLCharacterTypes.h	/^    enum CharTypes {$/;"	g	class:WTF::URLCharacterTypes	access:private
WTF::URLCharacterTypes::DecimalCharacter	.\url\src\URLCharacterTypes.h	/^        DecimalCharacter = 1 << 4,$/;"	e	enum:WTF::URLCharacterTypes::CharTypes
WTF::URLCharacterTypes::HexCharacter	.\url\src\URLCharacterTypes.h	/^        HexCharacter = 1 << 3,$/;"	e	enum:WTF::URLCharacterTypes::CharTypes
WTF::URLCharacterTypes::IPv4Character	.\url\src\URLCharacterTypes.h	/^        IPv4Character = 1 << 2,$/;"	e	enum:WTF::URLCharacterTypes::CharTypes
WTF::URLCharacterTypes::InvalidCharacter	.\url\src\URLCharacterTypes.h	/^        InvalidCharacter = 0,$/;"	e	enum:WTF::URLCharacterTypes::CharTypes
WTF::URLCharacterTypes::OctalCharacter	.\url\src\URLCharacterTypes.h	/^        OctalCharacter = 1 << 5,$/;"	e	enum:WTF::URLCharacterTypes::CharTypes
WTF::URLCharacterTypes::QueryCharacter	.\url\src\URLCharacterTypes.h	/^        QueryCharacter = 1 << 0,$/;"	e	enum:WTF::URLCharacterTypes::CharTypes
WTF::URLCharacterTypes::UserInfoCharacter	.\url\src\URLCharacterTypes.h	/^        UserInfoCharacter = 1 << 1,$/;"	e	enum:WTF::URLCharacterTypes::CharTypes
WTF::URLCharacterTypes::characterTypeTable	.\url\src\URLCharacterTypes.cpp	/^const unsigned char URLCharacterTypes::characterTypeTable[0x100] = {$/;"	m	class:WTF::URLCharacterTypes	file:
WTF::URLCharacterTypes::characterTypeTable	.\url\src\URLCharacterTypes.h	/^    static const unsigned char characterTypeTable[0x100];$/;"	m	class:WTF::URLCharacterTypes	access:private
WTF::URLCharacterTypes::isCharOfType	.\url\src\URLCharacterTypes.h	/^    static inline bool isCharOfType(unsigned char c, CharTypes type)$/;"	f	class:WTF::URLCharacterTypes	access:private	signature:(unsigned char c, CharTypes type)
WTF::URLCharacterTypes::isHexChar	.\url\src\URLCharacterTypes.h	/^    static inline bool isHexChar(unsigned char c) { return isCharOfType(c, HexCharacter); }$/;"	f	class:WTF::URLCharacterTypes	access:public	signature:(unsigned char c)
WTF::URLCharacterTypes::isIPv4Char	.\url\src\URLCharacterTypes.h	/^    static inline bool isIPv4Char(unsigned char c) { return isCharOfType(c, IPv4Character); }$/;"	f	class:WTF::URLCharacterTypes	access:public	signature:(unsigned char c)
WTF::URLCharacterTypes::isQueryChar	.\url\src\URLCharacterTypes.h	/^    static inline bool isQueryChar(unsigned char c) { return isCharOfType(c, QueryCharacter); }$/;"	f	class:WTF::URLCharacterTypes	access:public	signature:(unsigned char c)
WTF::URLComponent	.\url\src\URLComponent.h	/^class URLComponent {$/;"	c	namespace:WTF
WTF::URLComponent::URLComponent	.\url\src\URLComponent.h	/^    URLComponent() : m_begin(0), m_length(-1) { }$/;"	f	class:WTF::URLComponent	access:public	signature:()
WTF::URLComponent::URLComponent	.\url\src\URLComponent.h	/^    URLComponent(int begin, int length) : m_begin(begin), m_length(length) { }$/;"	f	class:WTF::URLComponent	access:public	signature:(int begin, int length)
WTF::URLComponent::begin	.\url\src\URLComponent.h	/^    int begin() const { return m_begin; }$/;"	f	class:WTF::URLComponent	access:public	signature:() const
WTF::URLComponent::end	.\url\src\URLComponent.h	/^    int end() const { return m_begin + m_length; }$/;"	f	class:WTF::URLComponent	access:public	signature:() const
WTF::URLComponent::fromRange	.\url\src\URLComponent.h	/^    static inline URLComponent fromRange(int begin, int end)$/;"	f	class:WTF::URLComponent	access:public	signature:(int begin, int end)
WTF::URLComponent::isEmptyOrInvalid	.\url\src\URLComponent.h	/^    bool isEmptyOrInvalid() const { return m_length <= 0; }$/;"	f	class:WTF::URLComponent	access:public	signature:() const
WTF::URLComponent::isNonEmpty	.\url\src\URLComponent.h	/^    bool isNonEmpty() const { return m_length > 0; }$/;"	f	class:WTF::URLComponent	access:public	signature:() const
WTF::URLComponent::isValid	.\url\src\URLComponent.h	/^    bool isValid() const { return m_length != -1; }$/;"	f	class:WTF::URLComponent	access:public	signature:() const
WTF::URLComponent::length	.\url\src\URLComponent.h	/^    int length() const { return m_length; }$/;"	f	class:WTF::URLComponent	access:public	signature:() const
WTF::URLComponent::m_begin	.\url\src\URLComponent.h	/^    int m_begin; \/\/ Byte offset in the string of this component.$/;"	m	class:WTF::URLComponent	access:private
WTF::URLComponent::m_length	.\url\src\URLComponent.h	/^    int m_length; \/\/ Will be -1 if the component is unspecified.$/;"	m	class:WTF::URLComponent	access:private
WTF::URLComponent::operator ==	.\url\src\URLComponent.h	/^    bool operator==(const URLComponent& other) const { return m_begin == other.m_begin && m_length == other.m_length; }$/;"	f	class:WTF::URLComponent	access:public	signature:(const URLComponent& other) const
WTF::URLComponent::reset	.\url\src\URLComponent.h	/^    void reset()$/;"	f	class:WTF::URLComponent	access:public	signature:()
WTF::URLComponent::setBegin	.\url\src\URLComponent.h	/^    void setBegin(int begin) { m_begin = begin; }$/;"	f	class:WTF::URLComponent	access:public	signature:(int begin)
WTF::URLComponent::setLength	.\url\src\URLComponent.h	/^    void setLength(int length) { m_length = length; }$/;"	f	class:WTF::URLComponent	access:public	signature:(int length)
WTF::URLParser	.\url\src\URLParser.h	/^class URLParser {$/;"	c	namespace:WTF
WTF::URLParser::InvalidPort	.\url\src\URLParser.h	/^        InvalidPort = -2,$/;"	e	enum:WTF::URLParser::SpecialPort
WTF::URLParser::SpecialPort	.\url\src\URLParser.h	/^    enum SpecialPort {$/;"	g	class:WTF::URLParser	access:public
WTF::URLParser::URLParser	.\url\src\URLParser.h	/^    URLParser();$/;"	p	class:WTF::URLParser	access:private	signature:()
WTF::URLParser::UnspecifiedPort	.\url\src\URLParser.h	/^        UnspecifiedPort = -1,$/;"	e	enum:WTF::URLParser::SpecialPort
WTF::URLParser::consecutiveSlashes	.\url\src\URLParser.h	/^    static inline int consecutiveSlashes(const CharacterType *string, int beginOffset, int stringLength)$/;"	f	class:WTF::URLParser	access:public	signature:(const CharacterType *string, int beginOffset, int stringLength)
WTF::URLParser::extractFileName	.\url\src\URLParser.h	/^    static void extractFileName(const CharacterType* spec, const URLComponent& path, URLComponent& fileName)$/;"	f	class:WTF::URLParser	access:public	signature:(const CharacterType* spec, const URLComponent& path, URLComponent& fileName)
WTF::URLParser::extractQueryKeyValue	.\url\src\URLParser.h	/^    static bool extractQueryKeyValue(const CharacterType* spec, URLComponent& query, URLComponent& key, URLComponent& value)$/;"	f	class:WTF::URLParser	access:public	signature:(const CharacterType* spec, URLComponent& query, URLComponent& key, URLComponent& value)
WTF::URLParser::extractScheme	.\url\src\URLParser.h	/^    static bool extractScheme(const CharacterType* spec, int specLength, URLComponent& scheme)$/;"	f	class:WTF::URLParser	access:public	signature:(const CharacterType* spec, int specLength, URLComponent& scheme)
WTF::URLParser::isPortDigit	.\url\src\URLParser.h	/^    static inline bool isPortDigit(CharacterType ch)$/;"	f	class:WTF::URLParser	access:private	signature:(CharacterType ch)
WTF::URLParser::isPossibleAuthorityTerminator	.\url\src\URLParser.h	/^    static bool isPossibleAuthorityTerminator(CharacterType ch)$/;"	f	class:WTF::URLParser	access:public	signature:(CharacterType ch)
WTF::URLParser::isURLSlash	.\url\src\URLParser.h	/^    static inline bool isURLSlash(CharacterType ch)$/;"	f	class:WTF::URLParser	access:public	signature:(CharacterType ch)
WTF::URLParser::nextAuthorityTerminator	.\url\src\URLParser.h	/^    static int nextAuthorityTerminator(const CharacterType* spec, int startOffset, int specLength)$/;"	f	class:WTF::URLParser	access:private	signature:(const CharacterType* spec, int startOffset, int specLength)
WTF::URLParser::parseAfterScheme	.\url\src\URLParser.h	/^    static void parseAfterScheme(const CharacterType* spec, int specLength, int afterScheme, URLSegments& parsed)$/;"	f	class:WTF::URLParser	access:public	signature:(const CharacterType* spec, int specLength, int afterScheme, URLSegments& parsed)
WTF::URLParser::parseAuthority	.\url\src\URLParser.h	/^    static void parseAuthority(const CharacterType* spec, const URLComponent& auth, URLComponent& username, URLComponent& password, URLComponent& host, URLComponent& port)$/;"	f	class:WTF::URLParser	access:public	signature:(const CharacterType* spec, const URLComponent& auth, URLComponent& username, URLComponent& password, URLComponent& host, URLComponent& port)
WTF::URLParser::parseMailtoURL	.\url\src\URLParser.h	/^    static void parseMailtoURL(const CharacterType* spec, int specLength, URLSegments& parsed)$/;"	f	class:WTF::URLParser	access:public	signature:(const CharacterType* spec, int specLength, URLSegments& parsed)
WTF::URLParser::parsePath	.\url\src\URLParser.h	/^    static void parsePath(const CharacterType* spec, const URLComponent& path, URLComponent& filepath, URLComponent& query, URLComponent& fragment)$/;"	f	class:WTF::URLParser	access:public	signature:(const CharacterType* spec, const URLComponent& path, URLComponent& filepath, URLComponent& query, URLComponent& fragment)
WTF::URLParser::parsePathURL	.\url\src\URLParser.h	/^    static void parsePathURL(const CharacterType* spec, int specLength, URLSegments& parsed)$/;"	f	class:WTF::URLParser	access:public	signature:(const CharacterType* spec, int specLength, URLSegments& parsed)
WTF::URLParser::parsePort	.\url\src\URLParser.h	/^    static int parsePort(const CharacterType* spec, const URLComponent& component)$/;"	f	class:WTF::URLParser	access:public	signature:(const CharacterType* spec, const URLComponent& component)
WTF::URLParser::parseServerInfo	.\url\src\URLParser.h	/^    static void parseServerInfo(const CharacterType* spec, const URLComponent& serverInfo, URLComponent& host, URLComponent& port)$/;"	f	class:WTF::URLParser	access:private	signature:(const CharacterType* spec, const URLComponent& serverInfo, URLComponent& host, URLComponent& port)
WTF::URLParser::parseStandardURL	.\url\src\URLParser.h	/^    static void parseStandardURL(const CharacterType* spec, int specLength, URLSegments& parsed)$/;"	f	class:WTF::URLParser	access:public	signature:(const CharacterType* spec, int specLength, URLSegments& parsed)
WTF::URLParser::parseUserInfo	.\url\src\URLParser.h	/^    static void parseUserInfo(const CharacterType* spec, const URLComponent& user, URLComponent& username, URLComponent& password)$/;"	f	class:WTF::URLParser	access:private	signature:(const CharacterType* spec, const URLComponent& user, URLComponent& username, URLComponent& password)
WTF::URLParser::shouldTrimFromURL	.\url\src\URLParser.h	/^    static inline bool shouldTrimFromURL(CharacterType ch)$/;"	f	class:WTF::URLParser	access:public	signature:(CharacterType ch)
WTF::URLParser::trimURL	.\url\src\URLParser.h	/^    static inline void trimURL(const CharacterType* spec, int& begin, int& end)$/;"	f	class:WTF::URLParser	access:public	signature:(const CharacterType* spec, int& begin, int& end)
WTF::URLQueryCanonicalizer	.\url\src\URLQueryCanonicalizer.h	/^class URLQueryCanonicalizer {$/;"	c	namespace:WTF
WTF::URLQueryCanonicalizer::appendRaw8BitQueryString	.\url\src\URLQueryCanonicalizer.h	/^    static void appendRaw8BitQueryString(const InChar* source, int length, URLBuffer<OutChar>* buffer)$/;"	f	class:WTF::URLQueryCanonicalizer	access:private	signature:(const InChar* source, int length, URLBuffer<OutChar>* buffer)
WTF::URLQueryCanonicalizer::canonicalize	.\url\src\URLQueryCanonicalizer.h	/^    static void canonicalize(const InChar* spec, const URLComponent& query, URLBuffer<OutChar>& buffer, URLComponent& resultQuery)$/;"	f	class:WTF::URLQueryCanonicalizer	access:public	signature:(const InChar* spec, const URLComponent& query, URLBuffer<OutChar>& buffer, URLComponent& resultQuery)
WTF::URLQueryCanonicalizer::convertToQueryEncoding	.\url\src\URLQueryCanonicalizer.h	/^    static void convertToQueryEncoding(const InChar* spec, const URLComponent& query, URLBuffer<OutChar>& buffer)$/;"	f	class:WTF::URLQueryCanonicalizer	access:private	signature:(const InChar* spec, const URLComponent& query, URLBuffer<OutChar>& buffer)
WTF::URLQueryCanonicalizer::isAllASCII	.\url\src\URLQueryCanonicalizer.h	/^    static bool isAllASCII(const InChar* spec, const URLComponent& query)$/;"	f	class:WTF::URLQueryCanonicalizer	access:private	signature:(const InChar* spec, const URLComponent& query)
WTF::URLQueryCanonicalizer::isRaw8Bit	.\url\src\URLQueryCanonicalizer.h	/^    static bool isRaw8Bit(const InChar* source, int length)$/;"	f	class:WTF::URLQueryCanonicalizer	access:private	signature:(const InChar* source, int length)
WTF::URLSegments	.\url\src\URLSegments.h	/^class URLSegments {$/;"	c	namespace:WTF
WTF::URLSegments::ComponentType	.\url\src\URLSegments.h	/^    enum ComponentType {$/;"	g	class:WTF::URLSegments	access:public
WTF::URLSegments::Fragment	.\url\src\URLSegments.h	/^        Fragment,$/;"	e	enum:WTF::URLSegments::ComponentType
WTF::URLSegments::Host	.\url\src\URLSegments.h	/^        Host,$/;"	e	enum:WTF::URLSegments::ComponentType
WTF::URLSegments::Password	.\url\src\URLSegments.h	/^        Password,$/;"	e	enum:WTF::URLSegments::ComponentType
WTF::URLSegments::Path	.\url\src\URLSegments.h	/^        Path,$/;"	e	enum:WTF::URLSegments::ComponentType
WTF::URLSegments::Port	.\url\src\URLSegments.h	/^        Port,$/;"	e	enum:WTF::URLSegments::ComponentType
WTF::URLSegments::Query	.\url\src\URLSegments.h	/^        Query,$/;"	e	enum:WTF::URLSegments::ComponentType
WTF::URLSegments::Scheme	.\url\src\URLSegments.h	/^        Scheme,$/;"	e	enum:WTF::URLSegments::ComponentType
WTF::URLSegments::URLSegments	.\url\src\URLSegments.h	/^    URLSegments() { }$/;"	f	class:WTF::URLSegments	access:public	signature:()
WTF::URLSegments::Username	.\url\src\URLSegments.h	/^        Username,$/;"	e	enum:WTF::URLSegments::ComponentType
WTF::URLSegments::charactersBefore	.\url\src\URLSegments.cpp	/^int URLSegments::charactersBefore(ComponentType type, bool includeDelimiter) const$/;"	f	class:WTF::URLSegments	signature:(ComponentType type, bool includeDelimiter) const
WTF::URLSegments::charactersBefore	.\url\src\URLSegments.h	/^    int charactersBefore(ComponentType, bool includeDelimiter) const;$/;"	p	class:WTF::URLSegments	access:public	signature:(ComponentType, bool includeDelimiter) const
WTF::URLSegments::fragment	.\url\src\URLSegments.h	/^    URLComponent fragment;$/;"	m	class:WTF::URLSegments	access:public
WTF::URLSegments::host	.\url\src\URLSegments.h	/^    URLComponent host;$/;"	m	class:WTF::URLSegments	access:public
WTF::URLSegments::length	.\url\src\URLSegments.cpp	/^int URLSegments::length() const$/;"	f	class:WTF::URLSegments	signature:() const
WTF::URLSegments::length	.\url\src\URLSegments.h	/^    int length() const;$/;"	p	class:WTF::URLSegments	access:public	signature:() const
WTF::URLSegments::password	.\url\src\URLSegments.h	/^    URLComponent password;$/;"	m	class:WTF::URLSegments	access:public
WTF::URLSegments::path	.\url\src\URLSegments.h	/^    URLComponent path;$/;"	m	class:WTF::URLSegments	access:public
WTF::URLSegments::port	.\url\src\URLSegments.h	/^    URLComponent port;$/;"	m	class:WTF::URLSegments	access:public
WTF::URLSegments::query	.\url\src\URLSegments.h	/^    URLComponent query;$/;"	m	class:WTF::URLSegments	access:public
WTF::URLSegments::scheme	.\url\src\URLSegments.h	/^    URLComponent scheme;$/;"	m	class:WTF::URLSegments	access:public
WTF::URLSegments::username	.\url\src\URLSegments.h	/^    URLComponent username;$/;"	m	class:WTF::URLSegments	access:public
WTF::URLString	.\url\api\URLString.h	/^class URLString {$/;"	c	namespace:WTF
WTF::URLString::URLString	.\url\api\URLString.h	/^    URLString() { }$/;"	f	class:WTF::URLString	access:public	signature:()
WTF::URLString::URLString	.\url\api\URLString.h	/^    explicit URLString(const String& string)$/;"	f	class:WTF::URLString	access:private	signature:(const String& string)
WTF::URLString::m_string	.\url\api\URLString.h	/^    String m_string;$/;"	m	class:WTF::URLString	access:private
WTF::URLString::string	.\url\api\URLString.h	/^    const String& string() const { return m_string;}$/;"	f	class:WTF::URLString	access:public	signature:() const
WTF::Uint16Array	.\Uint16Array.h	/^class Uint16Array : public IntegralTypedArrayBase<unsigned short> {$/;"	c	namespace:WTF	inherits:IntegralTypedArrayBase
WTF::Uint16Array::Uint16Array	.\Uint16Array.h	/^    inline Uint16Array(PassRefPtr<ArrayBuffer>,$/;"	p	class:WTF::Uint16Array	access:private	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
WTF::Uint16Array::Uint16Array	.\Uint16Array.h	/^Uint16Array::Uint16Array(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Uint16Array	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
WTF::Uint16Array::create	.\Uint16Array.h	/^    static inline PassRefPtr<Uint16Array> create(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length);$/;"	p	class:WTF::Uint16Array	access:public	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
WTF::Uint16Array::create	.\Uint16Array.h	/^    static inline PassRefPtr<Uint16Array> create(const unsigned short* array, unsigned length);$/;"	p	class:WTF::Uint16Array	access:public	signature:(const unsigned short* array, unsigned length)
WTF::Uint16Array::create	.\Uint16Array.h	/^    static inline PassRefPtr<Uint16Array> create(unsigned length);$/;"	p	class:WTF::Uint16Array	access:public	signature:(unsigned length)
WTF::Uint16Array::create	.\Uint16Array.h	/^PassRefPtr<Uint16Array> Uint16Array::create(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Uint16Array	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
WTF::Uint16Array::create	.\Uint16Array.h	/^PassRefPtr<Uint16Array> Uint16Array::create(const unsigned short* array, unsigned length)$/;"	f	class:WTF::Uint16Array	signature:(const unsigned short* array, unsigned length)
WTF::Uint16Array::create	.\Uint16Array.h	/^PassRefPtr<Uint16Array> Uint16Array::create(unsigned length)$/;"	f	class:WTF::Uint16Array	signature:(unsigned length)
WTF::Uint16Array::isUnsignedShortArray	.\Uint16Array.h	/^    virtual bool isUnsignedShortArray() const { return true; }$/;"	f	class:WTF::Uint16Array	access:private	signature:() const
WTF::Uint16Array::set	.\Uint16Array.h	/^    bool set(TypedArrayBase<unsigned short>* array, unsigned offset) { return TypedArrayBase<unsigned short>::set(array, offset); }$/;"	f	class:WTF::Uint16Array	access:public	signature:(TypedArrayBase<unsigned short>* array, unsigned offset)
WTF::Uint16Array::set	.\Uint16Array.h	/^    void set(unsigned index, double value) { IntegralTypedArrayBase<unsigned short>::set(index, value); }$/;"	f	class:WTF::Uint16Array	access:public	signature:(unsigned index, double value)
WTF::Uint16Array::subarray	.\Uint16Array.h	/^    inline PassRefPtr<Uint16Array> subarray(int start) const;$/;"	p	class:WTF::Uint16Array	access:public	signature:(int start) const
WTF::Uint16Array::subarray	.\Uint16Array.h	/^    inline PassRefPtr<Uint16Array> subarray(int start, int end) const;$/;"	p	class:WTF::Uint16Array	access:public	signature:(int start, int end) const
WTF::Uint16Array::subarray	.\Uint16Array.h	/^PassRefPtr<Uint16Array> Uint16Array::subarray(int start) const$/;"	f	class:WTF::Uint16Array	signature:(int start) const
WTF::Uint16Array::subarray	.\Uint16Array.h	/^PassRefPtr<Uint16Array> Uint16Array::subarray(int start, int end) const$/;"	f	class:WTF::Uint16Array	signature:(int start, int end) const
WTF::Uint32Array	.\Uint32Array.h	/^class Uint32Array : public IntegralTypedArrayBase<unsigned int> {$/;"	c	namespace:WTF	inherits:IntegralTypedArrayBase
WTF::Uint32Array::Uint32Array	.\Uint32Array.h	/^    inline Uint32Array(PassRefPtr<ArrayBuffer>,$/;"	p	class:WTF::Uint32Array	access:private	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
WTF::Uint32Array::Uint32Array	.\Uint32Array.h	/^Uint32Array::Uint32Array(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Uint32Array	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
WTF::Uint32Array::create	.\Uint32Array.h	/^    static inline PassRefPtr<Uint32Array> create(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length);$/;"	p	class:WTF::Uint32Array	access:public	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
WTF::Uint32Array::create	.\Uint32Array.h	/^    static inline PassRefPtr<Uint32Array> create(const unsigned int* array, unsigned length);$/;"	p	class:WTF::Uint32Array	access:public	signature:(const unsigned int* array, unsigned length)
WTF::Uint32Array::create	.\Uint32Array.h	/^    static inline PassRefPtr<Uint32Array> create(unsigned length);$/;"	p	class:WTF::Uint32Array	access:public	signature:(unsigned length)
WTF::Uint32Array::create	.\Uint32Array.h	/^PassRefPtr<Uint32Array> Uint32Array::create(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Uint32Array	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
WTF::Uint32Array::create	.\Uint32Array.h	/^PassRefPtr<Uint32Array> Uint32Array::create(const unsigned int* array, unsigned length)$/;"	f	class:WTF::Uint32Array	signature:(const unsigned int* array, unsigned length)
WTF::Uint32Array::create	.\Uint32Array.h	/^PassRefPtr<Uint32Array> Uint32Array::create(unsigned length)$/;"	f	class:WTF::Uint32Array	signature:(unsigned length)
WTF::Uint32Array::isUnsignedIntArray	.\Uint32Array.h	/^    virtual bool isUnsignedIntArray() const { return true; }$/;"	f	class:WTF::Uint32Array	access:private	signature:() const
WTF::Uint32Array::set	.\Uint32Array.h	/^    bool set(TypedArrayBase<unsigned int>* array, unsigned offset) { return TypedArrayBase<unsigned int>::set(array, offset); }$/;"	f	class:WTF::Uint32Array	access:public	signature:(TypedArrayBase<unsigned int>* array, unsigned offset)
WTF::Uint32Array::set	.\Uint32Array.h	/^    void set(unsigned index, double value) { IntegralTypedArrayBase<unsigned int>::set(index, value); }$/;"	f	class:WTF::Uint32Array	access:public	signature:(unsigned index, double value)
WTF::Uint32Array::subarray	.\Uint32Array.h	/^    inline PassRefPtr<Uint32Array> subarray(int start) const;$/;"	p	class:WTF::Uint32Array	access:public	signature:(int start) const
WTF::Uint32Array::subarray	.\Uint32Array.h	/^    inline PassRefPtr<Uint32Array> subarray(int start, int end) const;$/;"	p	class:WTF::Uint32Array	access:public	signature:(int start, int end) const
WTF::Uint32Array::subarray	.\Uint32Array.h	/^PassRefPtr<Uint32Array> Uint32Array::subarray(int start) const$/;"	f	class:WTF::Uint32Array	signature:(int start) const
WTF::Uint32Array::subarray	.\Uint32Array.h	/^PassRefPtr<Uint32Array> Uint32Array::subarray(int start, int end) const$/;"	f	class:WTF::Uint32Array	signature:(int start, int end) const
WTF::Uint8Array	.\Uint8Array.h	/^class Uint8Array : public IntegralTypedArrayBase<unsigned char> {$/;"	c	namespace:WTF	inherits:IntegralTypedArrayBase
WTF::Uint8Array::Uint8Array	.\Uint8Array.h	/^    inline Uint8Array(PassRefPtr<ArrayBuffer>,$/;"	p	class:WTF::Uint8Array	access:protected	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
WTF::Uint8Array::Uint8Array	.\Uint8Array.h	/^Uint8Array::Uint8Array(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Uint8Array	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
WTF::Uint8Array::create	.\Uint8Array.h	/^    static inline PassRefPtr<Uint8Array> create(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length);$/;"	p	class:WTF::Uint8Array	access:public	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
WTF::Uint8Array::create	.\Uint8Array.h	/^    static inline PassRefPtr<Uint8Array> create(const unsigned char* array, unsigned length);$/;"	p	class:WTF::Uint8Array	access:public	signature:(const unsigned char* array, unsigned length)
WTF::Uint8Array::create	.\Uint8Array.h	/^    static inline PassRefPtr<Uint8Array> create(unsigned length);$/;"	p	class:WTF::Uint8Array	access:public	signature:(unsigned length)
WTF::Uint8Array::create	.\Uint8Array.h	/^PassRefPtr<Uint8Array> Uint8Array::create(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Uint8Array	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
WTF::Uint8Array::create	.\Uint8Array.h	/^PassRefPtr<Uint8Array> Uint8Array::create(const unsigned char* array, unsigned length)$/;"	f	class:WTF::Uint8Array	signature:(const unsigned char* array, unsigned length)
WTF::Uint8Array::create	.\Uint8Array.h	/^PassRefPtr<Uint8Array> Uint8Array::create(unsigned length)$/;"	f	class:WTF::Uint8Array	signature:(unsigned length)
WTF::Uint8Array::isUnsignedByteArray	.\Uint8Array.h	/^    virtual bool isUnsignedByteArray() const { return true; }$/;"	f	class:WTF::Uint8Array	access:protected	signature:() const
WTF::Uint8Array::set	.\Uint8Array.h	/^    bool set(TypedArrayBase<unsigned char>* array, unsigned offset) { return TypedArrayBase<unsigned char>::set(array, offset); }$/;"	f	class:WTF::Uint8Array	access:public	signature:(TypedArrayBase<unsigned char>* array, unsigned offset)
WTF::Uint8Array::set	.\Uint8Array.h	/^    void set(unsigned index, double value) { IntegralTypedArrayBase<unsigned char>::set(index, value); }$/;"	f	class:WTF::Uint8Array	access:public	signature:(unsigned index, double value)
WTF::Uint8Array::subarray	.\Uint8Array.h	/^    inline PassRefPtr<Uint8Array> subarray(int start) const;$/;"	p	class:WTF::Uint8Array	access:public	signature:(int start) const
WTF::Uint8Array::subarray	.\Uint8Array.h	/^    inline PassRefPtr<Uint8Array> subarray(int start, int end) const;$/;"	p	class:WTF::Uint8Array	access:public	signature:(int start, int end) const
WTF::Uint8Array::subarray	.\Uint8Array.h	/^PassRefPtr<Uint8Array> Uint8Array::subarray(int start) const$/;"	f	class:WTF::Uint8Array	signature:(int start) const
WTF::Uint8Array::subarray	.\Uint8Array.h	/^PassRefPtr<Uint8Array> Uint8Array::subarray(int start, int end) const$/;"	f	class:WTF::Uint8Array	signature:(int start, int end) const
WTF::Uint8ClampedArray	.\Uint8ClampedArray.h	/^class Uint8ClampedArray : public Uint8Array {$/;"	c	namespace:WTF	inherits:Uint8Array
WTF::Uint8ClampedArray::Uint8ClampedArray	.\Uint8ClampedArray.h	/^    inline Uint8ClampedArray(PassRefPtr<ArrayBuffer>,$/;"	p	class:WTF::Uint8ClampedArray	access:private	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
WTF::Uint8ClampedArray::Uint8ClampedArray	.\Uint8ClampedArray.h	/^Uint8ClampedArray::Uint8ClampedArray(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Uint8ClampedArray	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
WTF::Uint8ClampedArray::create	.\Uint8ClampedArray.h	/^    static inline PassRefPtr<Uint8ClampedArray> create(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length);$/;"	p	class:WTF::Uint8ClampedArray	access:public	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
WTF::Uint8ClampedArray::create	.\Uint8ClampedArray.h	/^    static inline PassRefPtr<Uint8ClampedArray> create(const unsigned char* array, unsigned length);$/;"	p	class:WTF::Uint8ClampedArray	access:public	signature:(const unsigned char* array, unsigned length)
WTF::Uint8ClampedArray::create	.\Uint8ClampedArray.h	/^    static inline PassRefPtr<Uint8ClampedArray> create(unsigned length);$/;"	p	class:WTF::Uint8ClampedArray	access:public	signature:(unsigned length)
WTF::Uint8ClampedArray::create	.\Uint8ClampedArray.h	/^PassRefPtr<Uint8ClampedArray> Uint8ClampedArray::create(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Uint8ClampedArray	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
WTF::Uint8ClampedArray::create	.\Uint8ClampedArray.h	/^PassRefPtr<Uint8ClampedArray> Uint8ClampedArray::create(const unsigned char* array, unsigned length)$/;"	f	class:WTF::Uint8ClampedArray	signature:(const unsigned char* array, unsigned length)
WTF::Uint8ClampedArray::create	.\Uint8ClampedArray.h	/^PassRefPtr<Uint8ClampedArray> Uint8ClampedArray::create(unsigned length)$/;"	f	class:WTF::Uint8ClampedArray	signature:(unsigned length)
WTF::Uint8ClampedArray::isUnsignedByteClampedArray	.\Uint8ClampedArray.h	/^    virtual bool isUnsignedByteClampedArray() const { return true; }$/;"	f	class:WTF::Uint8ClampedArray	access:private	signature:() const
WTF::Uint8ClampedArray::set	.\Uint8ClampedArray.h	/^    bool set(TypedArrayBase<unsigned char>* array, unsigned offset) { return TypedArrayBase<unsigned char>::set(array, offset); }$/;"	f	class:WTF::Uint8ClampedArray	access:public	signature:(TypedArrayBase<unsigned char>* array, unsigned offset)
WTF::Uint8ClampedArray::set	.\Uint8ClampedArray.h	/^    inline void set(unsigned index, double value);$/;"	p	class:WTF::Uint8ClampedArray	access:public	signature:(unsigned index, double value)
WTF::Uint8ClampedArray::set	.\Uint8ClampedArray.h	/^void Uint8ClampedArray::set(unsigned index, double value)$/;"	f	class:WTF::Uint8ClampedArray	signature:(unsigned index, double value)
WTF::Uint8ClampedArray::subarray	.\Uint8ClampedArray.h	/^    inline PassRefPtr<Uint8ClampedArray> subarray(int start) const;$/;"	p	class:WTF::Uint8ClampedArray	access:public	signature:(int start) const
WTF::Uint8ClampedArray::subarray	.\Uint8ClampedArray.h	/^    inline PassRefPtr<Uint8ClampedArray> subarray(int start, int end) const;$/;"	p	class:WTF::Uint8ClampedArray	access:public	signature:(int start, int end) const
WTF::Uint8ClampedArray::subarray	.\Uint8ClampedArray.h	/^PassRefPtr<Uint8ClampedArray> Uint8ClampedArray::subarray(int start) const$/;"	f	class:WTF::Uint8ClampedArray	signature:(int start) const
WTF::Uint8ClampedArray::subarray	.\Uint8ClampedArray.h	/^PassRefPtr<Uint8ClampedArray> Uint8ClampedArray::subarray(int start, int end) const$/;"	f	class:WTF::Uint8ClampedArray	signature:(int start, int end) const
WTF::Unicode	.\unicode\CharacterNames.h	/^namespace Unicode {$/;"	n	namespace:WTF
WTF::Unicode	.\unicode\UTF8.cpp	/^namespace Unicode {$/;"	n	namespace:WTF	file:
WTF::Unicode	.\unicode\UTF8.h	/^namespace Unicode {$/;"	n	namespace:WTF
WTF::Unicode	.\unicode\glib\UnicodeGLib.cpp	/^namespace Unicode {$/;"	n	namespace:WTF	file:
WTF::Unicode	.\unicode\glib\UnicodeGLib.h	/^namespace Unicode {$/;"	n	namespace:WTF
WTF::Unicode	.\unicode\icu\UnicodeIcu.h	/^namespace Unicode {$/;"	n	namespace:WTF
WTF::Unicode	.\unicode\qt4\UnicodeQt4.h	/^namespace Unicode {$/;"	n	namespace:WTF
WTF::Unicode	.\unicode\wince\UnicodeWinCE.cpp	/^namespace Unicode {$/;"	n	namespace:WTF	file:
WTF::Unicode	.\unicode\wince\UnicodeWinCE.h	/^namespace Unicode {$/;"	n	namespace:WTF
WTF::Unicode::ArabicNumber	.\unicode\glib\UnicodeGLib.h	/^    ArabicNumber,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::ArabicNumber	.\unicode\icu\UnicodeIcu.h	/^    ArabicNumber = U_ARABIC_NUMBER,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::ArabicNumber	.\unicode\qt4\UnicodeQt4.h	/^    ArabicNumber = QChar::DirAN,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::ArabicNumber	.\unicode\wince\UnicodeWinCE.h	/^    ArabicNumber = UnicodeCE::U_ARABIC_NUMBER,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::BlockSeparator	.\unicode\glib\UnicodeGLib.h	/^    BlockSeparator,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::BlockSeparator	.\unicode\icu\UnicodeIcu.h	/^    BlockSeparator = U_BLOCK_SEPARATOR,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::BlockSeparator	.\unicode\qt4\UnicodeQt4.h	/^    BlockSeparator = QChar::DirB,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::BlockSeparator	.\unicode\wince\UnicodeWinCE.h	/^    BlockSeparator = UnicodeCE::U_BLOCK_SEPARATOR,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::BoundaryNeutral	.\unicode\glib\UnicodeGLib.h	/^    BoundaryNeutral$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::BoundaryNeutral	.\unicode\icu\UnicodeIcu.h	/^    BoundaryNeutral = U_BOUNDARY_NEUTRAL$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::BoundaryNeutral	.\unicode\qt4\UnicodeQt4.h	/^    BoundaryNeutral = QChar::DirBN$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::BoundaryNeutral	.\unicode\wince\UnicodeWinCE.h	/^    BoundaryNeutral = UnicodeCE::U_BOUNDARY_NEUTRAL$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::CharCategory	.\unicode\glib\UnicodeGLib.h	/^enum CharCategory {$/;"	g	namespace:WTF::Unicode
WTF::Unicode::CharCategory	.\unicode\icu\UnicodeIcu.h	/^enum CharCategory {$/;"	g	namespace:WTF::Unicode
WTF::Unicode::CharCategory	.\unicode\qt4\UnicodeQt4.h	/^enum CharCategory {$/;"	g	namespace:WTF::Unicode
WTF::Unicode::CharCategory	.\unicode\wince\UnicodeWinCE.h	/^enum CharCategory {$/;"	g	namespace:WTF::Unicode
WTF::Unicode::CommonNumberSeparator	.\unicode\glib\UnicodeGLib.h	/^    CommonNumberSeparator,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::CommonNumberSeparator	.\unicode\icu\UnicodeIcu.h	/^    CommonNumberSeparator = U_COMMON_NUMBER_SEPARATOR,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::CommonNumberSeparator	.\unicode\qt4\UnicodeQt4.h	/^    CommonNumberSeparator = QChar::DirCS,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::CommonNumberSeparator	.\unicode\wince\UnicodeWinCE.h	/^    CommonNumberSeparator = UnicodeCE::U_COMMON_NUMBER_SEPARATOR,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::ConversionResult	.\unicode\UTF8.h	/^    } ConversionResult;$/;"	t	namespace:WTF::Unicode	typeref:enum:WTF::Unicode::__anon13
WTF::Unicode::DecompositionCanonical	.\unicode\glib\UnicodeGLib.h	/^    DecompositionCanonical,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionCanonical	.\unicode\icu\UnicodeIcu.h	/^    DecompositionCanonical = U_DT_CANONICAL,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionCanonical	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionCanonical = QChar::Canonical,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionCanonical	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionCanonical = UnicodeCE::U_DT_CANONICAL,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionCircle	.\unicode\glib\UnicodeGLib.h	/^    DecompositionCircle,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionCircle	.\unicode\icu\UnicodeIcu.h	/^    DecompositionCircle = U_DT_CIRCLE,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionCircle	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionCircle = QChar::Circle,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionCircle	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionCircle = UnicodeCE::U_DT_CIRCLE,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionCompat	.\unicode\glib\UnicodeGLib.h	/^    DecompositionCompat,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionCompat	.\unicode\icu\UnicodeIcu.h	/^    DecompositionCompat = U_DT_COMPAT,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionCompat	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionCompat = QChar::Compat,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionCompat	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionCompat = UnicodeCE::U_DT_COMPAT,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionFinal	.\unicode\glib\UnicodeGLib.h	/^    DecompositionFinal,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionFinal	.\unicode\icu\UnicodeIcu.h	/^    DecompositionFinal = U_DT_FINAL,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionFinal	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionFinal = QChar::Final,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionFinal	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionFinal = UnicodeCE::U_DT_FINAL,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionFont	.\unicode\glib\UnicodeGLib.h	/^    DecompositionFont,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionFont	.\unicode\icu\UnicodeIcu.h	/^    DecompositionFont = U_DT_FONT,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionFont	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionFont = QChar::Font,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionFont	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionFont = UnicodeCE::U_DT_FONT,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionFraction	.\unicode\glib\UnicodeGLib.h	/^    DecompositionFraction,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionFraction	.\unicode\icu\UnicodeIcu.h	/^    DecompositionFraction = U_DT_FRACTION,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionFraction	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionFraction = QChar::Fraction,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionFraction	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionFraction = UnicodeCE::U_DT_FRACTION,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionInitial	.\unicode\glib\UnicodeGLib.h	/^    DecompositionInitial,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionInitial	.\unicode\icu\UnicodeIcu.h	/^    DecompositionInitial = U_DT_INITIAL,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionInitial	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionInitial = QChar::Initial,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionInitial	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionInitial = UnicodeCE::U_DT_INITIAL,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionIsolated	.\unicode\glib\UnicodeGLib.h	/^    DecompositionIsolated,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionIsolated	.\unicode\icu\UnicodeIcu.h	/^    DecompositionIsolated = U_DT_ISOLATED,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionIsolated	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionIsolated = QChar::Isolated,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionIsolated	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionIsolated = UnicodeCE::U_DT_ISOLATED,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionMedial	.\unicode\glib\UnicodeGLib.h	/^    DecompositionMedial,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionMedial	.\unicode\icu\UnicodeIcu.h	/^    DecompositionMedial = U_DT_MEDIAL,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionMedial	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionMedial = QChar::Medial,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionMedial	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionMedial = UnicodeCE::U_DT_MEDIAL,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionNarrow	.\unicode\glib\UnicodeGLib.h	/^    DecompositionNarrow,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionNarrow	.\unicode\icu\UnicodeIcu.h	/^    DecompositionNarrow = U_DT_NARROW,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionNarrow	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionNarrow = QChar::Narrow,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionNarrow	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionNarrow = UnicodeCE::U_DT_NARROW,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionNoBreak	.\unicode\glib\UnicodeGLib.h	/^    DecompositionNoBreak,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionNoBreak	.\unicode\icu\UnicodeIcu.h	/^    DecompositionNoBreak = U_DT_NOBREAK,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionNoBreak	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionNoBreak = QChar::NoBreak,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionNoBreak	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionNoBreak = UnicodeCE::U_DT_NOBREAK,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionNone	.\unicode\glib\UnicodeGLib.h	/^    DecompositionNone,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionNone	.\unicode\icu\UnicodeIcu.h	/^    DecompositionNone = U_DT_NONE,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionNone	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionNone = QChar::NoDecomposition,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionNone	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionNone = UnicodeCE::U_DT_NONE,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionSmall	.\unicode\glib\UnicodeGLib.h	/^    DecompositionSmall,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionSmall	.\unicode\icu\UnicodeIcu.h	/^    DecompositionSmall = U_DT_SMALL,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionSmall	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionSmall = QChar::Small,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionSmall	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionSmall = UnicodeCE::U_DT_SMALL,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionSquare	.\unicode\glib\UnicodeGLib.h	/^    DecompositionSquare,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionSquare	.\unicode\icu\UnicodeIcu.h	/^    DecompositionSquare = U_DT_SQUARE,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionSquare	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionSquare = QChar::Square,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionSquare	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionSquare = UnicodeCE::U_DT_SQUARE,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionSub	.\unicode\glib\UnicodeGLib.h	/^    DecompositionSub,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionSub	.\unicode\icu\UnicodeIcu.h	/^    DecompositionSub = U_DT_SUB,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionSub	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionSub = QChar::Sub,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionSub	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionSub = UnicodeCE::U_DT_SUB,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionSuper	.\unicode\glib\UnicodeGLib.h	/^    DecompositionSuper,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionSuper	.\unicode\icu\UnicodeIcu.h	/^    DecompositionSuper = U_DT_SUPER,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionSuper	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionSuper = QChar::Super,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionSuper	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionSuper = UnicodeCE::U_DT_SUPER,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionType	.\unicode\glib\UnicodeGLib.h	/^enum DecompositionType {$/;"	g	namespace:WTF::Unicode
WTF::Unicode::DecompositionType	.\unicode\icu\UnicodeIcu.h	/^enum DecompositionType {$/;"	g	namespace:WTF::Unicode
WTF::Unicode::DecompositionType	.\unicode\qt4\UnicodeQt4.h	/^enum DecompositionType {$/;"	g	namespace:WTF::Unicode
WTF::Unicode::DecompositionType	.\unicode\wince\UnicodeWinCE.h	/^enum DecompositionType {$/;"	g	namespace:WTF::Unicode
WTF::Unicode::DecompositionVertical	.\unicode\glib\UnicodeGLib.h	/^    DecompositionVertical,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionVertical	.\unicode\icu\UnicodeIcu.h	/^    DecompositionVertical = U_DT_VERTICAL,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionVertical	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionVertical = QChar::Vertical,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionVertical	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionVertical = UnicodeCE::U_DT_VERTICAL,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionWide	.\unicode\glib\UnicodeGLib.h	/^    DecompositionWide,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionWide	.\unicode\icu\UnicodeIcu.h	/^    DecompositionWide = U_DT_WIDE,$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionWide	.\unicode\qt4\UnicodeQt4.h	/^    DecompositionWide = QChar::Wide$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::DecompositionWide	.\unicode\wince\UnicodeWinCE.h	/^    DecompositionWide = UnicodeCE::U_DT_WIDE$/;"	e	enum:WTF::Unicode::DecompositionType
WTF::Unicode::Direction	.\unicode\glib\UnicodeGLib.h	/^enum Direction {$/;"	g	namespace:WTF::Unicode
WTF::Unicode::Direction	.\unicode\icu\UnicodeIcu.h	/^enum Direction {$/;"	g	namespace:WTF::Unicode
WTF::Unicode::Direction	.\unicode\qt4\UnicodeQt4.h	/^enum Direction {$/;"	g	namespace:WTF::Unicode
WTF::Unicode::Direction	.\unicode\wince\UnicodeWinCE.h	/^enum Direction {$/;"	g	namespace:WTF::Unicode
WTF::Unicode::EuropeanNumber	.\unicode\glib\UnicodeGLib.h	/^    EuropeanNumber,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::EuropeanNumber	.\unicode\icu\UnicodeIcu.h	/^    EuropeanNumber = U_EUROPEAN_NUMBER,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::EuropeanNumber	.\unicode\qt4\UnicodeQt4.h	/^    EuropeanNumber = QChar::DirEN,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::EuropeanNumber	.\unicode\wince\UnicodeWinCE.h	/^    EuropeanNumber = UnicodeCE::U_EUROPEAN_NUMBER,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::EuropeanNumberSeparator	.\unicode\glib\UnicodeGLib.h	/^    EuropeanNumberSeparator,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::EuropeanNumberSeparator	.\unicode\icu\UnicodeIcu.h	/^    EuropeanNumberSeparator = U_EUROPEAN_NUMBER_SEPARATOR,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::EuropeanNumberSeparator	.\unicode\qt4\UnicodeQt4.h	/^    EuropeanNumberSeparator = QChar::DirES,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::EuropeanNumberSeparator	.\unicode\wince\UnicodeWinCE.h	/^    EuropeanNumberSeparator = UnicodeCE::U_EUROPEAN_NUMBER_SEPARATOR,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::EuropeanNumberTerminator	.\unicode\glib\UnicodeGLib.h	/^    EuropeanNumberTerminator,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::EuropeanNumberTerminator	.\unicode\icu\UnicodeIcu.h	/^    EuropeanNumberTerminator = U_EUROPEAN_NUMBER_TERMINATOR,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::EuropeanNumberTerminator	.\unicode\qt4\UnicodeQt4.h	/^    EuropeanNumberTerminator = QChar::DirET,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::EuropeanNumberTerminator	.\unicode\wince\UnicodeWinCE.h	/^    EuropeanNumberTerminator = UnicodeCE::U_EUROPEAN_NUMBER_TERMINATOR,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::LeftToRight	.\unicode\glib\UnicodeGLib.h	/^    LeftToRight,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::LeftToRight	.\unicode\icu\UnicodeIcu.h	/^    LeftToRight = U_LEFT_TO_RIGHT,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::LeftToRight	.\unicode\qt4\UnicodeQt4.h	/^    LeftToRight = QChar::DirL,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::LeftToRight	.\unicode\wince\UnicodeWinCE.h	/^    LeftToRight = UnicodeCE::U_LEFT_TO_RIGHT,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::LeftToRightEmbedding	.\unicode\glib\UnicodeGLib.h	/^    LeftToRightEmbedding,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::LeftToRightEmbedding	.\unicode\icu\UnicodeIcu.h	/^    LeftToRightEmbedding = U_LEFT_TO_RIGHT_EMBEDDING,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::LeftToRightEmbedding	.\unicode\qt4\UnicodeQt4.h	/^    LeftToRightEmbedding = QChar::DirLRE,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::LeftToRightEmbedding	.\unicode\wince\UnicodeWinCE.h	/^    LeftToRightEmbedding = UnicodeCE::U_LEFT_TO_RIGHT_EMBEDDING,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::LeftToRightOverride	.\unicode\glib\UnicodeGLib.h	/^    LeftToRightOverride,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::LeftToRightOverride	.\unicode\icu\UnicodeIcu.h	/^    LeftToRightOverride = U_LEFT_TO_RIGHT_OVERRIDE,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::LeftToRightOverride	.\unicode\qt4\UnicodeQt4.h	/^    LeftToRightOverride = QChar::DirLRO,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::LeftToRightOverride	.\unicode\wince\UnicodeWinCE.h	/^    LeftToRightOverride = UnicodeCE::U_LEFT_TO_RIGHT_OVERRIDE,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::Letter_Lowercase	.\unicode\glib\UnicodeGLib.h	/^    Letter_Lowercase = U_MASK(G_UNICODE_LOWERCASE_LETTER),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Letter_Lowercase	.\unicode\icu\UnicodeIcu.h	/^    Letter_Lowercase = U_MASK(U_LOWERCASE_LETTER),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Letter_Lowercase	.\unicode\qt4\UnicodeQt4.h	/^    Letter_Lowercase = U_MASK(QChar::Letter_Lowercase),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Letter_Lowercase	.\unicode\wince\UnicodeWinCE.h	/^    Letter_Lowercase = TO_MASK(UnicodeCE::U_LOWERCASE_LETTER),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Letter_Modifier	.\unicode\glib\UnicodeGLib.h	/^    Letter_Modifier = U_MASK(G_UNICODE_MODIFIER_LETTER),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Letter_Modifier	.\unicode\icu\UnicodeIcu.h	/^    Letter_Modifier = U_MASK(U_MODIFIER_LETTER),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Letter_Modifier	.\unicode\qt4\UnicodeQt4.h	/^    Letter_Modifier = U_MASK(QChar::Letter_Modifier),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Letter_Modifier	.\unicode\wince\UnicodeWinCE.h	/^    Letter_Modifier = TO_MASK(UnicodeCE::U_MODIFIER_LETTER),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Letter_Other	.\unicode\glib\UnicodeGLib.h	/^    Letter_Other = U_MASK(G_UNICODE_OTHER_LETTER),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Letter_Other	.\unicode\icu\UnicodeIcu.h	/^    Letter_Other = U_MASK(U_OTHER_LETTER),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Letter_Other	.\unicode\qt4\UnicodeQt4.h	/^    Letter_Other = U_MASK(QChar::Letter_Other),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Letter_Other	.\unicode\wince\UnicodeWinCE.h	/^    Letter_Other = TO_MASK(UnicodeCE::U_OTHER_LETTER),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Letter_Titlecase	.\unicode\glib\UnicodeGLib.h	/^    Letter_Titlecase = U_MASK(G_UNICODE_TITLECASE_LETTER),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Letter_Titlecase	.\unicode\icu\UnicodeIcu.h	/^    Letter_Titlecase = U_MASK(U_TITLECASE_LETTER),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Letter_Titlecase	.\unicode\qt4\UnicodeQt4.h	/^    Letter_Titlecase = U_MASK(QChar::Letter_Titlecase),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Letter_Titlecase	.\unicode\wince\UnicodeWinCE.h	/^    Letter_Titlecase = TO_MASK(UnicodeCE::U_TITLECASE_LETTER),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Letter_Uppercase	.\unicode\glib\UnicodeGLib.h	/^    Letter_Uppercase = U_MASK(G_UNICODE_UPPERCASE_LETTER),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Letter_Uppercase	.\unicode\icu\UnicodeIcu.h	/^    Letter_Uppercase = U_MASK(U_UPPERCASE_LETTER),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Letter_Uppercase	.\unicode\qt4\UnicodeQt4.h	/^    Letter_Uppercase = U_MASK(QChar::Letter_Uppercase),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Letter_Uppercase	.\unicode\wince\UnicodeWinCE.h	/^    Letter_Uppercase = TO_MASK(UnicodeCE::U_UPPERCASE_LETTER),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Mark_Enclosing	.\unicode\glib\UnicodeGLib.h	/^    Mark_Enclosing = U_MASK(G_UNICODE_ENCLOSING_MARK),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Mark_Enclosing	.\unicode\icu\UnicodeIcu.h	/^    Mark_Enclosing = U_MASK(U_ENCLOSING_MARK),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Mark_Enclosing	.\unicode\qt4\UnicodeQt4.h	/^    Mark_Enclosing = U_MASK(QChar::Mark_Enclosing),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Mark_Enclosing	.\unicode\wince\UnicodeWinCE.h	/^    Mark_Enclosing = TO_MASK(UnicodeCE::U_ENCLOSING_MARK),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Mark_NonSpacing	.\unicode\glib\UnicodeGLib.h	/^    Mark_NonSpacing = U_MASK(G_UNICODE_NON_SPACING_MARK),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Mark_NonSpacing	.\unicode\icu\UnicodeIcu.h	/^    Mark_NonSpacing = U_MASK(U_NON_SPACING_MARK),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Mark_NonSpacing	.\unicode\qt4\UnicodeQt4.h	/^    Mark_NonSpacing = U_MASK(QChar::Mark_NonSpacing),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Mark_NonSpacing	.\unicode\wince\UnicodeWinCE.h	/^    Mark_NonSpacing = TO_MASK(UnicodeCE::U_NON_SPACING_MARK),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Mark_SpacingCombining	.\unicode\glib\UnicodeGLib.h	/^    Mark_SpacingCombining = U_MASK(G_UNICODE_COMBINING_MARK),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Mark_SpacingCombining	.\unicode\icu\UnicodeIcu.h	/^    Mark_SpacingCombining = U_MASK(U_COMBINING_SPACING_MARK),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Mark_SpacingCombining	.\unicode\qt4\UnicodeQt4.h	/^    Mark_SpacingCombining = U_MASK(QChar::Mark_SpacingCombining),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Mark_SpacingCombining	.\unicode\wince\UnicodeWinCE.h	/^    Mark_SpacingCombining = TO_MASK(UnicodeCE::U_COMBINING_SPACING_MARK),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::NoCategory	.\unicode\glib\UnicodeGLib.h	/^    NoCategory =  0,$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::NoCategory	.\unicode\icu\UnicodeIcu.h	/^    NoCategory =  0,$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::NoCategory	.\unicode\qt4\UnicodeQt4.h	/^    NoCategory = 0,$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::NoCategory	.\unicode\wince\UnicodeWinCE.h	/^    NoCategory =  0,$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::NonSpacingMark	.\unicode\glib\UnicodeGLib.h	/^    NonSpacingMark,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::NonSpacingMark	.\unicode\icu\UnicodeIcu.h	/^    NonSpacingMark = U_DIR_NON_SPACING_MARK,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::NonSpacingMark	.\unicode\qt4\UnicodeQt4.h	/^    NonSpacingMark = QChar::DirNSM,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::NonSpacingMark	.\unicode\wince\UnicodeWinCE.h	/^    NonSpacingMark = UnicodeCE::U_DIR_NON_SPACING_MARK,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::Number_DecimalDigit	.\unicode\glib\UnicodeGLib.h	/^    Number_DecimalDigit = U_MASK(G_UNICODE_DECIMAL_NUMBER),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Number_DecimalDigit	.\unicode\icu\UnicodeIcu.h	/^    Number_DecimalDigit = U_MASK(U_DECIMAL_DIGIT_NUMBER),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Number_DecimalDigit	.\unicode\qt4\UnicodeQt4.h	/^    Number_DecimalDigit = U_MASK(QChar::Number_DecimalDigit),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Number_DecimalDigit	.\unicode\wince\UnicodeWinCE.h	/^    Number_DecimalDigit = TO_MASK(UnicodeCE::U_DECIMAL_DIGIT_NUMBER),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Number_Letter	.\unicode\glib\UnicodeGLib.h	/^    Number_Letter = U_MASK(G_UNICODE_LETTER_NUMBER),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Number_Letter	.\unicode\icu\UnicodeIcu.h	/^    Number_Letter = U_MASK(U_LETTER_NUMBER),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Number_Letter	.\unicode\qt4\UnicodeQt4.h	/^    Number_Letter = U_MASK(QChar::Number_Letter),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Number_Letter	.\unicode\wince\UnicodeWinCE.h	/^    Number_Letter = TO_MASK(UnicodeCE::U_LETTER_NUMBER),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Number_Other	.\unicode\glib\UnicodeGLib.h	/^    Number_Other = U_MASK(G_UNICODE_OTHER_NUMBER),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Number_Other	.\unicode\icu\UnicodeIcu.h	/^    Number_Other = U_MASK(U_OTHER_NUMBER),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Number_Other	.\unicode\qt4\UnicodeQt4.h	/^    Number_Other = U_MASK(QChar::Number_Other),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Number_Other	.\unicode\wince\UnicodeWinCE.h	/^    Number_Other = TO_MASK(UnicodeCE::U_OTHER_NUMBER),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::OtherNeutral	.\unicode\glib\UnicodeGLib.h	/^    OtherNeutral,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::OtherNeutral	.\unicode\icu\UnicodeIcu.h	/^    OtherNeutral = U_OTHER_NEUTRAL,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::OtherNeutral	.\unicode\qt4\UnicodeQt4.h	/^    OtherNeutral = QChar::DirON,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::OtherNeutral	.\unicode\wince\UnicodeWinCE.h	/^    OtherNeutral = UnicodeCE::U_OTHER_NEUTRAL,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::Other_Control	.\unicode\glib\UnicodeGLib.h	/^    Other_Control = U_MASK(G_UNICODE_CONTROL),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Other_Control	.\unicode\icu\UnicodeIcu.h	/^    Other_Control = U_MASK(U_CONTROL_CHAR),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Other_Control	.\unicode\qt4\UnicodeQt4.h	/^    Other_Control = U_MASK(QChar::Other_Control),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Other_Control	.\unicode\wince\UnicodeWinCE.h	/^    Other_Control = TO_MASK(UnicodeCE::U_CONTROL_CHAR),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Other_Format	.\unicode\glib\UnicodeGLib.h	/^    Other_Format = U_MASK(G_UNICODE_FORMAT),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Other_Format	.\unicode\icu\UnicodeIcu.h	/^    Other_Format = U_MASK(U_FORMAT_CHAR),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Other_Format	.\unicode\qt4\UnicodeQt4.h	/^    Other_Format = U_MASK(QChar::Other_Format),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Other_Format	.\unicode\wince\UnicodeWinCE.h	/^    Other_Format = TO_MASK(UnicodeCE::U_FORMAT_CHAR),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Other_NotAssigned	.\unicode\glib\UnicodeGLib.h	/^    Other_NotAssigned = U_MASK(G_UNICODE_UNASSIGNED),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Other_NotAssigned	.\unicode\icu\UnicodeIcu.h	/^    Other_NotAssigned = U_MASK(U_GENERAL_OTHER_TYPES),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Other_NotAssigned	.\unicode\qt4\UnicodeQt4.h	/^    Other_NotAssigned = U_MASK(QChar::Other_NotAssigned),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Other_NotAssigned	.\unicode\wince\UnicodeWinCE.h	/^    Other_NotAssigned = TO_MASK(UnicodeCE::U_GENERAL_OTHER_TYPES),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Other_PrivateUse	.\unicode\glib\UnicodeGLib.h	/^    Other_PrivateUse = U_MASK(G_UNICODE_PRIVATE_USE),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Other_PrivateUse	.\unicode\icu\UnicodeIcu.h	/^    Other_PrivateUse = U_MASK(U_PRIVATE_USE_CHAR),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Other_PrivateUse	.\unicode\qt4\UnicodeQt4.h	/^    Other_PrivateUse = U_MASK(QChar::Other_PrivateUse),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Other_PrivateUse	.\unicode\wince\UnicodeWinCE.h	/^    Other_PrivateUse = TO_MASK(UnicodeCE::U_PRIVATE_USE_CHAR),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Other_Surrogate	.\unicode\glib\UnicodeGLib.h	/^    Other_Surrogate = U_MASK(G_UNICODE_SURROGATE),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Other_Surrogate	.\unicode\icu\UnicodeIcu.h	/^    Other_Surrogate = U_MASK(U_SURROGATE),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Other_Surrogate	.\unicode\qt4\UnicodeQt4.h	/^    Other_Surrogate = U_MASK(QChar::Other_Surrogate),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Other_Surrogate	.\unicode\wince\UnicodeWinCE.h	/^    Other_Surrogate = TO_MASK(UnicodeCE::U_SURROGATE),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::PopDirectionalFormat	.\unicode\glib\UnicodeGLib.h	/^    PopDirectionalFormat,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::PopDirectionalFormat	.\unicode\icu\UnicodeIcu.h	/^    PopDirectionalFormat = U_POP_DIRECTIONAL_FORMAT,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::PopDirectionalFormat	.\unicode\qt4\UnicodeQt4.h	/^    PopDirectionalFormat = QChar::DirPDF,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::PopDirectionalFormat	.\unicode\wince\UnicodeWinCE.h	/^    PopDirectionalFormat = UnicodeCE::U_POP_DIRECTIONAL_FORMAT,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::Punctuation_Close	.\unicode\glib\UnicodeGLib.h	/^    Punctuation_Close = U_MASK(G_UNICODE_CLOSE_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Punctuation_Close	.\unicode\icu\UnicodeIcu.h	/^    Punctuation_Close = U_MASK(U_END_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Punctuation_Close	.\unicode\qt4\UnicodeQt4.h	/^    Punctuation_Close = U_MASK(QChar::Punctuation_Close),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Punctuation_Close	.\unicode\wince\UnicodeWinCE.h	/^    Punctuation_Close = TO_MASK(UnicodeCE::U_END_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Punctuation_Connector	.\unicode\glib\UnicodeGLib.h	/^    Punctuation_Connector = U_MASK(G_UNICODE_CONNECT_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Punctuation_Connector	.\unicode\icu\UnicodeIcu.h	/^    Punctuation_Connector = U_MASK(U_CONNECTOR_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Punctuation_Connector	.\unicode\qt4\UnicodeQt4.h	/^    Punctuation_Connector = U_MASK(QChar::Punctuation_Connector),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Punctuation_Connector	.\unicode\wince\UnicodeWinCE.h	/^    Punctuation_Connector = TO_MASK(UnicodeCE::U_CONNECTOR_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Punctuation_Dash	.\unicode\glib\UnicodeGLib.h	/^    Punctuation_Dash = U_MASK(G_UNICODE_DASH_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Punctuation_Dash	.\unicode\icu\UnicodeIcu.h	/^    Punctuation_Dash = U_MASK(U_DASH_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Punctuation_Dash	.\unicode\qt4\UnicodeQt4.h	/^    Punctuation_Dash = U_MASK(QChar::Punctuation_Dash),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Punctuation_Dash	.\unicode\wince\UnicodeWinCE.h	/^    Punctuation_Dash = TO_MASK(UnicodeCE::U_DASH_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Punctuation_FinalQuote	.\unicode\glib\UnicodeGLib.h	/^    Punctuation_FinalQuote = U_MASK(G_UNICODE_FINAL_PUNCTUATION)$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Punctuation_FinalQuote	.\unicode\icu\UnicodeIcu.h	/^    Punctuation_FinalQuote = U_MASK(U_FINAL_PUNCTUATION)$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Punctuation_FinalQuote	.\unicode\qt4\UnicodeQt4.h	/^    Punctuation_FinalQuote = U_MASK(QChar::Punctuation_FinalQuote),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Punctuation_FinalQuote	.\unicode\wince\UnicodeWinCE.h	/^    Punctuation_FinalQuote = TO_MASK(UnicodeCE::U_FINAL_PUNCTUATION)$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Punctuation_InitialQuote	.\unicode\glib\UnicodeGLib.h	/^    Punctuation_InitialQuote = U_MASK(G_UNICODE_INITIAL_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Punctuation_InitialQuote	.\unicode\icu\UnicodeIcu.h	/^    Punctuation_InitialQuote = U_MASK(U_INITIAL_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Punctuation_InitialQuote	.\unicode\qt4\UnicodeQt4.h	/^    Punctuation_InitialQuote = U_MASK(QChar::Punctuation_InitialQuote),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Punctuation_InitialQuote	.\unicode\wince\UnicodeWinCE.h	/^    Punctuation_InitialQuote = TO_MASK(UnicodeCE::U_INITIAL_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Punctuation_Open	.\unicode\glib\UnicodeGLib.h	/^    Punctuation_Open = U_MASK(G_UNICODE_OPEN_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Punctuation_Open	.\unicode\icu\UnicodeIcu.h	/^    Punctuation_Open = U_MASK(U_START_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Punctuation_Open	.\unicode\qt4\UnicodeQt4.h	/^    Punctuation_Open = U_MASK(QChar::Punctuation_Open),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Punctuation_Open	.\unicode\wince\UnicodeWinCE.h	/^    Punctuation_Open = TO_MASK(UnicodeCE::U_START_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Punctuation_Other	.\unicode\glib\UnicodeGLib.h	/^    Punctuation_Other = U_MASK(G_UNICODE_OTHER_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Punctuation_Other	.\unicode\icu\UnicodeIcu.h	/^    Punctuation_Other = U_MASK(U_OTHER_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Punctuation_Other	.\unicode\qt4\UnicodeQt4.h	/^    Punctuation_Other = U_MASK(QChar::Punctuation_Other),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Punctuation_Other	.\unicode\wince\UnicodeWinCE.h	/^    Punctuation_Other = TO_MASK(UnicodeCE::U_OTHER_PUNCTUATION),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::RightToLeft	.\unicode\glib\UnicodeGLib.h	/^    RightToLeft,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::RightToLeft	.\unicode\icu\UnicodeIcu.h	/^    RightToLeft = U_RIGHT_TO_LEFT,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::RightToLeft	.\unicode\qt4\UnicodeQt4.h	/^    RightToLeft = QChar::DirR,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::RightToLeft	.\unicode\wince\UnicodeWinCE.h	/^    RightToLeft = UnicodeCE::U_RIGHT_TO_LEFT,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::RightToLeftArabic	.\unicode\glib\UnicodeGLib.h	/^    RightToLeftArabic,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::RightToLeftArabic	.\unicode\icu\UnicodeIcu.h	/^    RightToLeftArabic = U_RIGHT_TO_LEFT_ARABIC,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::RightToLeftArabic	.\unicode\qt4\UnicodeQt4.h	/^    RightToLeftArabic = QChar::DirAL,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::RightToLeftArabic	.\unicode\wince\UnicodeWinCE.h	/^    RightToLeftArabic = UnicodeCE::U_RIGHT_TO_LEFT_ARABIC,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::RightToLeftEmbedding	.\unicode\glib\UnicodeGLib.h	/^    RightToLeftEmbedding,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::RightToLeftEmbedding	.\unicode\icu\UnicodeIcu.h	/^    RightToLeftEmbedding = U_RIGHT_TO_LEFT_EMBEDDING,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::RightToLeftEmbedding	.\unicode\qt4\UnicodeQt4.h	/^    RightToLeftEmbedding = QChar::DirRLE,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::RightToLeftEmbedding	.\unicode\wince\UnicodeWinCE.h	/^    RightToLeftEmbedding = UnicodeCE::U_RIGHT_TO_LEFT_EMBEDDING,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::RightToLeftOverride	.\unicode\glib\UnicodeGLib.h	/^    RightToLeftOverride,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::RightToLeftOverride	.\unicode\icu\UnicodeIcu.h	/^    RightToLeftOverride = U_RIGHT_TO_LEFT_OVERRIDE,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::RightToLeftOverride	.\unicode\qt4\UnicodeQt4.h	/^    RightToLeftOverride = QChar::DirRLO,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::RightToLeftOverride	.\unicode\wince\UnicodeWinCE.h	/^    RightToLeftOverride = UnicodeCE::U_RIGHT_TO_LEFT_OVERRIDE,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::SegmentSeparator	.\unicode\glib\UnicodeGLib.h	/^    SegmentSeparator,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::SegmentSeparator	.\unicode\icu\UnicodeIcu.h	/^    SegmentSeparator = U_SEGMENT_SEPARATOR,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::SegmentSeparator	.\unicode\qt4\UnicodeQt4.h	/^    SegmentSeparator = QChar::DirS,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::SegmentSeparator	.\unicode\wince\UnicodeWinCE.h	/^    SegmentSeparator = UnicodeCE::U_SEGMENT_SEPARATOR,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::Separator_Line	.\unicode\glib\UnicodeGLib.h	/^    Separator_Line = U_MASK(G_UNICODE_LINE_SEPARATOR),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Separator_Line	.\unicode\icu\UnicodeIcu.h	/^    Separator_Line = U_MASK(U_LINE_SEPARATOR),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Separator_Line	.\unicode\qt4\UnicodeQt4.h	/^    Separator_Line = U_MASK(QChar::Separator_Line),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Separator_Line	.\unicode\wince\UnicodeWinCE.h	/^    Separator_Line = TO_MASK(UnicodeCE::U_LINE_SEPARATOR),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Separator_Paragraph	.\unicode\glib\UnicodeGLib.h	/^    Separator_Paragraph = U_MASK(G_UNICODE_PARAGRAPH_SEPARATOR),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Separator_Paragraph	.\unicode\icu\UnicodeIcu.h	/^    Separator_Paragraph = U_MASK(U_PARAGRAPH_SEPARATOR),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Separator_Paragraph	.\unicode\qt4\UnicodeQt4.h	/^    Separator_Paragraph = U_MASK(QChar::Separator_Paragraph),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Separator_Paragraph	.\unicode\wince\UnicodeWinCE.h	/^    Separator_Paragraph = TO_MASK(UnicodeCE::U_PARAGRAPH_SEPARATOR),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Separator_Space	.\unicode\glib\UnicodeGLib.h	/^    Separator_Space = U_MASK(G_UNICODE_SPACE_SEPARATOR),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Separator_Space	.\unicode\icu\UnicodeIcu.h	/^    Separator_Space = U_MASK(U_SPACE_SEPARATOR),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Separator_Space	.\unicode\qt4\UnicodeQt4.h	/^    Separator_Space = U_MASK(QChar::Separator_Space),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Separator_Space	.\unicode\wince\UnicodeWinCE.h	/^    Separator_Space = TO_MASK(UnicodeCE::U_SPACE_SEPARATOR),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Symbol_Currency	.\unicode\glib\UnicodeGLib.h	/^    Symbol_Currency = U_MASK(G_UNICODE_CURRENCY_SYMBOL),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Symbol_Currency	.\unicode\icu\UnicodeIcu.h	/^    Symbol_Currency = U_MASK(U_CURRENCY_SYMBOL),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Symbol_Currency	.\unicode\qt4\UnicodeQt4.h	/^    Symbol_Currency = U_MASK(QChar::Symbol_Currency),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Symbol_Currency	.\unicode\wince\UnicodeWinCE.h	/^    Symbol_Currency = TO_MASK(UnicodeCE::U_CURRENCY_SYMBOL),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Symbol_Math	.\unicode\glib\UnicodeGLib.h	/^    Symbol_Math = U_MASK(G_UNICODE_MATH_SYMBOL),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Symbol_Math	.\unicode\icu\UnicodeIcu.h	/^    Symbol_Math = U_MASK(U_MATH_SYMBOL),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Symbol_Math	.\unicode\qt4\UnicodeQt4.h	/^    Symbol_Math = U_MASK(QChar::Symbol_Math),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Symbol_Math	.\unicode\wince\UnicodeWinCE.h	/^    Symbol_Math = TO_MASK(UnicodeCE::U_MATH_SYMBOL),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Symbol_Modifier	.\unicode\glib\UnicodeGLib.h	/^    Symbol_Modifier = U_MASK(G_UNICODE_MODIFIER_SYMBOL),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Symbol_Modifier	.\unicode\icu\UnicodeIcu.h	/^    Symbol_Modifier = U_MASK(U_MODIFIER_SYMBOL),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Symbol_Modifier	.\unicode\qt4\UnicodeQt4.h	/^    Symbol_Modifier = U_MASK(QChar::Symbol_Modifier),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Symbol_Modifier	.\unicode\wince\UnicodeWinCE.h	/^    Symbol_Modifier = TO_MASK(UnicodeCE::U_MODIFIER_SYMBOL),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Symbol_Other	.\unicode\glib\UnicodeGLib.h	/^    Symbol_Other = U_MASK(G_UNICODE_OTHER_SYMBOL),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Symbol_Other	.\unicode\icu\UnicodeIcu.h	/^    Symbol_Other = U_MASK(U_OTHER_SYMBOL),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Symbol_Other	.\unicode\qt4\UnicodeQt4.h	/^    Symbol_Other = U_MASK(QChar::Symbol_Other)$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::Symbol_Other	.\unicode\wince\UnicodeWinCE.h	/^    Symbol_Other = TO_MASK(UnicodeCE::U_OTHER_SYMBOL),$/;"	e	enum:WTF::Unicode::CharCategory
WTF::Unicode::UTF8CaseFunction	.\unicode\glib\UnicodeGLib.cpp	/^typedef gchar* (*UTF8CaseFunction)(const gchar*, gssize length);$/;"	t	namespace:WTF::Unicode	file:
WTF::Unicode::UTF8SequenceLength	.\unicode\UTF8.cpp	/^int UTF8SequenceLength(char b0)$/;"	f	namespace:WTF::Unicode	signature:(char b0)
WTF::Unicode::UTF8SequenceLength	.\unicode\UTF8.h	/^    int UTF8SequenceLength(char);$/;"	p	namespace:WTF::Unicode	signature:(char)
WTF::Unicode::WhiteSpaceNeutral	.\unicode\glib\UnicodeGLib.h	/^    WhiteSpaceNeutral,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::WhiteSpaceNeutral	.\unicode\icu\UnicodeIcu.h	/^    WhiteSpaceNeutral = U_WHITE_SPACE_NEUTRAL,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::WhiteSpaceNeutral	.\unicode\qt4\UnicodeQt4.h	/^    WhiteSpaceNeutral = QChar::DirWS,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::WhiteSpaceNeutral	.\unicode\wince\UnicodeWinCE.h	/^    WhiteSpaceNeutral = UnicodeCE::U_WHITE_SPACE_NEUTRAL,$/;"	e	enum:WTF::Unicode::Direction
WTF::Unicode::aegeanWordSeparatorDot	.\unicode\CharacterNames.h	/^const UChar32 aegeanWordSeparatorDot = 0x10101;$/;"	v
WTF::Unicode::aegeanWordSeparatorLine	.\unicode\CharacterNames.h	/^const UChar32 aegeanWordSeparatorLine = 0x10100;$/;"	v
WTF::Unicode::blackCircle	.\unicode\CharacterNames.h	/^const UChar blackCircle = 0x25CF;$/;"	v
WTF::Unicode::blackSquare	.\unicode\CharacterNames.h	/^const UChar blackSquare = 0x25A0;$/;"	v
WTF::Unicode::blackUpPointingTriangle	.\unicode\CharacterNames.h	/^const UChar blackUpPointingTriangle = 0x25B2;$/;"	v
WTF::Unicode::bullet	.\unicode\CharacterNames.h	/^const UChar bullet = 0x2022;$/;"	v
WTF::Unicode::bullseye	.\unicode\CharacterNames.h	/^const UChar bullseye = 0x25CE;$/;"	v
WTF::Unicode::calculateStringHashAndLengthFromUTF8	.\unicode\UTF8.cpp	/^unsigned calculateStringHashAndLengthFromUTF8(const char* data, const char* dataEnd, unsigned& dataLength, unsigned& utf16Length)$/;"	f	namespace:WTF::Unicode	signature:(const char* data, const char* dataEnd, unsigned& dataLength, unsigned& utf16Length)
WTF::Unicode::calculateStringHashAndLengthFromUTF8	.\unicode\UTF8.h	/^    unsigned calculateStringHashAndLengthFromUTF8(const char* data, const char* dataEnd, unsigned& dataLength, unsigned& utf16Length);$/;"	p	namespace:WTF::Unicode	signature:(const char* data, const char* dataEnd, unsigned& dataLength, unsigned& utf16Length)
WTF::Unicode::carriageReturn	.\unicode\CharacterNames.h	/^const UChar carriageReturn = 0x000D;$/;"	v
WTF::Unicode::category	.\unicode\glib\UnicodeGLib.h	/^inline CharCategory category(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::category	.\unicode\icu\UnicodeIcu.h	/^inline CharCategory category(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::category	.\unicode\qt4\UnicodeQt4.h	/^inline CharCategory category(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::category	.\unicode\wince\UnicodeWinCE.cpp	/^CharCategory category(unsigned int c)$/;"	f	namespace:WTF::Unicode	signature:(unsigned int c)
WTF::Unicode::category	.\unicode\wince\UnicodeWinCE.h	/^CharCategory category(unsigned int);$/;"	p	namespace:WTF::Unicode	signature:(unsigned int)
WTF::Unicode::combiningClass	.\unicode\glib\UnicodeGLib.h	/^inline uint8_t combiningClass(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::combiningClass	.\unicode\icu\UnicodeIcu.h	/^inline uint8_t combiningClass(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::combiningClass	.\unicode\qt4\UnicodeQt4.h	/^inline uint8_t combiningClass(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::combiningClass	.\unicode\wince\UnicodeWinCE.cpp	/^unsigned char combiningClass(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::combiningClass	.\unicode\wince\UnicodeWinCE.h	/^unsigned char combiningClass(UChar32);$/;"	p	namespace:WTF::Unicode	signature:(UChar32)
WTF::Unicode::conversionOK	.\unicode\UTF8.h	/^            conversionOK,       \/\/ conversion successful$/;"	e	enum:WTF::Unicode::__anon13
WTF::Unicode::convertCase	.\unicode\glib\UnicodeGLib.cpp	/^static int convertCase(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error, UTF8CaseFunction caseFunction)$/;"	f	namespace:WTF::Unicode	file:	signature:(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error, UTF8CaseFunction caseFunction)
WTF::Unicode::convertLatin1ToUTF8	.\unicode\UTF8.cpp	/^ConversionResult convertLatin1ToUTF8($/;"	f	namespace:WTF::Unicode	signature:( const LChar** sourceStart, const LChar* sourceEnd, char** targetStart, char* targetEnd)
WTF::Unicode::convertLatin1ToUTF8	.\unicode\UTF8.h	/^    ConversionResult convertLatin1ToUTF8($/;"	p	namespace:WTF::Unicode	signature:( const LChar** sourceStart, const LChar* sourceEnd, char** targetStart, char* targetEnd)
WTF::Unicode::convertUTF16ToUTF8	.\unicode\UTF8.cpp	/^ConversionResult convertUTF16ToUTF8($/;"	f	namespace:WTF::Unicode	signature:( const UChar** sourceStart, const UChar* sourceEnd, char** targetStart, char* targetEnd, bool strict)
WTF::Unicode::convertUTF16ToUTF8	.\unicode\UTF8.h	/^    WTF_EXPORT_PRIVATE ConversionResult convertUTF16ToUTF8($/;"	p	namespace:WTF::Unicode	signature:( const UChar** sourceStart, const UChar* sourceEnd, char** targetStart, char* targetEnd, bool strict = true)
WTF::Unicode::convertUTF8ToUTF16	.\unicode\UTF8.cpp	/^ConversionResult convertUTF8ToUTF16($/;"	f	namespace:WTF::Unicode	signature:( const char** sourceStart, const char* sourceEnd, UChar** targetStart, UChar* targetEnd, bool strict)
WTF::Unicode::convertUTF8ToUTF16	.\unicode\UTF8.h	/^    WTF_EXPORT_PRIVATE ConversionResult convertUTF8ToUTF16($/;"	p	namespace:WTF::Unicode	signature:( const char** sourceStart, const char* sourceEnd, UChar** targetStart, UChar* targetEnd, bool strict = true)
WTF::Unicode::decodeUTF8Sequence	.\unicode\UTF8.cpp	/^int decodeUTF8Sequence(const char* sequence)$/;"	f	namespace:WTF::Unicode	signature:(const char* sequence)
WTF::Unicode::decodeUTF8Sequence	.\unicode\UTF8.h	/^    int decodeUTF8Sequence(const char*);$/;"	p	namespace:WTF::Unicode	signature:(const char*)
WTF::Unicode::decompositionType	.\unicode\glib\UnicodeGLib.h	/^inline DecompositionType decompositionType(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::decompositionType	.\unicode\icu\UnicodeIcu.h	/^inline DecompositionType decompositionType(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::decompositionType	.\unicode\qt4\UnicodeQt4.h	/^inline DecompositionType decompositionType(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::decompositionType	.\unicode\wince\UnicodeWinCE.cpp	/^DecompositionType decompositionType(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::decompositionType	.\unicode\wince\UnicodeWinCE.h	/^DecompositionType decompositionType(UChar32);$/;"	p	namespace:WTF::Unicode	signature:(UChar32)
WTF::Unicode::digitValue	.\unicode\glib\UnicodeGLib.h	/^inline int digitValue(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::digitValue	.\unicode\wince\UnicodeWinCE.cpp	/^int digitValue(UChar c)$/;"	f	namespace:WTF::Unicode	signature:(UChar c)
WTF::Unicode::digitValue	.\unicode\wince\UnicodeWinCE.h	/^int digitValue(UChar);$/;"	p	namespace:WTF::Unicode	signature:(UChar)
WTF::Unicode::direction	.\unicode\glib\UnicodeGLib.cpp	/^Direction direction(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::direction	.\unicode\glib\UnicodeGLib.h	/^Direction direction(UChar32);$/;"	p	namespace:WTF::Unicode	signature:(UChar32)
WTF::Unicode::direction	.\unicode\icu\UnicodeIcu.h	/^inline Direction direction(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::direction	.\unicode\qt4\UnicodeQt4.h	/^inline Direction direction(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::direction	.\unicode\wince\UnicodeWinCE.cpp	/^Direction direction(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::direction	.\unicode\wince\UnicodeWinCE.h	/^Direction direction(UChar32);$/;"	p	namespace:WTF::Unicode	signature:(UChar32)
WTF::Unicode::equalUTF16WithUTF8	.\unicode\UTF8.cpp	/^bool equalUTF16WithUTF8(const UChar* a, const UChar* aEnd, const char* b, const char* bEnd)$/;"	f	namespace:WTF::Unicode	signature:(const UChar* a, const UChar* aEnd, const char* b, const char* bEnd)
WTF::Unicode::equalUTF16WithUTF8	.\unicode\UTF8.h	/^    bool equalUTF16WithUTF8(const UChar* a, const UChar* aEnd, const char* b, const char* bEnd);$/;"	p	namespace:WTF::Unicode	signature:(const UChar* a, const UChar* aEnd, const char* b, const char* bEnd)
WTF::Unicode::ethiopicPrefaceColon	.\unicode\CharacterNames.h	/^const UChar ethiopicPrefaceColon = 0x1366;$/;"	v
WTF::Unicode::ethiopicWordspace	.\unicode\CharacterNames.h	/^const UChar ethiopicWordspace = 0x1361;$/;"	v
WTF::Unicode::firstByteMark	.\unicode\UTF8.cpp	/^static const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };$/;"	v	file:
WTF::Unicode::fisheye	.\unicode\CharacterNames.h	/^const UChar fisheye = 0x25C9;$/;"	v
WTF::Unicode::foldCase	.\unicode\glib\UnicodeGLib.cpp	/^UChar32 foldCase(UChar32 ch)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 ch)
WTF::Unicode::foldCase	.\unicode\glib\UnicodeGLib.cpp	/^int foldCase(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)$/;"	f	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)
WTF::Unicode::foldCase	.\unicode\glib\UnicodeGLib.h	/^UChar32 foldCase(UChar32);$/;"	p	namespace:WTF::Unicode	signature:(UChar32)
WTF::Unicode::foldCase	.\unicode\glib\UnicodeGLib.h	/^int foldCase(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error);$/;"	p	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)
WTF::Unicode::foldCase	.\unicode\icu\UnicodeIcu.h	/^inline UChar32 foldCase(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::foldCase	.\unicode\icu\UnicodeIcu.h	/^inline int foldCase(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)$/;"	f	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)
WTF::Unicode::foldCase	.\unicode\qt4\UnicodeQt4.h	/^inline UChar32 foldCase(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::foldCase	.\unicode\qt4\UnicodeQt4.h	/^inline int foldCase(UChar* result, int resultLength, const UChar* src, int srcLength,  bool* error)$/;"	f	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)
WTF::Unicode::foldCase	.\unicode\wince\UnicodeWinCE.cpp	/^UChar foldCase(UChar c)$/;"	f	namespace:WTF::Unicode	signature:(UChar c)
WTF::Unicode::foldCase	.\unicode\wince\UnicodeWinCE.cpp	/^int foldCase(UChar* result, int resultLength, const UChar* source, int sourceLength, bool* isError)$/;"	f	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* source, int sourceLength, bool* isError)
WTF::Unicode::foldCase	.\unicode\wince\UnicodeWinCE.h	/^UChar foldCase(UChar);$/;"	p	namespace:WTF::Unicode	signature:(UChar)
WTF::Unicode::foldCase	.\unicode\wince\UnicodeWinCE.h	/^int foldCase(UChar* result, int resultLength, const UChar* source, int sourceLength, bool* isError);$/;"	p	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* source, int sourceLength, bool* isError)
WTF::Unicode::getUTF16LengthFromUTF8	.\unicode\glib\UnicodeGLib.cpp	/^static int getUTF16LengthFromUTF8(const gchar* utf8String, int length)$/;"	f	namespace:WTF::Unicode	file:	signature:(const gchar* utf8String, int length)
WTF::Unicode::hasLineBreakingPropertyComplexContext	.\unicode\glib\UnicodeGLib.h	/^inline bool hasLineBreakingPropertyComplexContext(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::hasLineBreakingPropertyComplexContext	.\unicode\icu\UnicodeIcu.h	/^inline bool hasLineBreakingPropertyComplexContext(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::hasLineBreakingPropertyComplexContext	.\unicode\qt4\UnicodeQt4.h	/^inline bool hasLineBreakingPropertyComplexContext(UChar32)$/;"	f	namespace:WTF::Unicode	signature:(UChar32)
WTF::Unicode::hasLineBreakingPropertyComplexContext	.\unicode\wince\UnicodeWinCE.h	/^inline bool hasLineBreakingPropertyComplexContext(UChar32)$/;"	f	namespace:WTF::Unicode	signature:(UChar32)
WTF::Unicode::hasLineBreakingPropertyComplexContextOrIdeographic	.\unicode\glib\UnicodeGLib.h	/^inline bool hasLineBreakingPropertyComplexContextOrIdeographic(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::hasLineBreakingPropertyComplexContextOrIdeographic	.\unicode\icu\UnicodeIcu.h	/^inline bool hasLineBreakingPropertyComplexContextOrIdeographic(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::hebrewPunctuationGeresh	.\unicode\CharacterNames.h	/^const UChar hebrewPunctuationGeresh = 0x05F3;$/;"	v
WTF::Unicode::hebrewPunctuationGershayim	.\unicode\CharacterNames.h	/^const UChar hebrewPunctuationGershayim = 0x05F4;$/;"	v
WTF::Unicode::horizontalEllipsis	.\unicode\CharacterNames.h	/^const UChar horizontalEllipsis = 0x2026;$/;"	v
WTF::Unicode::hyphen	.\unicode\CharacterNames.h	/^const UChar hyphen = 0x2010;$/;"	v
WTF::Unicode::hyphenMinus	.\unicode\CharacterNames.h	/^const UChar hyphenMinus = 0x002D;$/;"	v
WTF::Unicode::ideographicComma	.\unicode\CharacterNames.h	/^const UChar ideographicComma = 0x3001;$/;"	v
WTF::Unicode::ideographicFullStop	.\unicode\CharacterNames.h	/^const UChar ideographicFullStop = 0x3002;$/;"	v
WTF::Unicode::ideographicSpace	.\unicode\CharacterNames.h	/^const UChar ideographicSpace = 0x3000;$/;"	v
WTF::Unicode::inlineUTF8SequenceLength	.\unicode\UTF8.cpp	/^inline int inlineUTF8SequenceLength(char b0)$/;"	f	namespace:WTF::Unicode	signature:(char b0)
WTF::Unicode::inlineUTF8SequenceLengthNonASCII	.\unicode\UTF8.cpp	/^inline int inlineUTF8SequenceLengthNonASCII(char b0)$/;"	f	namespace:WTF::Unicode	signature:(char b0)
WTF::Unicode::isAlphanumeric	.\unicode\glib\UnicodeGLib.h	/^inline bool isAlphanumeric(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::isAlphanumeric	.\unicode\icu\UnicodeIcu.h	/^inline bool isAlphanumeric(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::isAlphanumeric	.\unicode\wince\UnicodeWinCE.cpp	/^bool isAlphanumeric(UChar c)$/;"	f	namespace:WTF::Unicode	signature:(UChar c)
WTF::Unicode::isAlphanumeric	.\unicode\wince\UnicodeWinCE.h	/^bool isAlphanumeric(UChar);$/;"	p	namespace:WTF::Unicode	signature:(UChar)
WTF::Unicode::isArabicChar	.\unicode\glib\UnicodeGLib.h	/^inline bool isArabicChar(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::isArabicChar	.\unicode\icu\UnicodeIcu.h	/^inline bool isArabicChar(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::isArabicChar	.\unicode\qt4\UnicodeQt4.h	/^inline bool isArabicChar(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::isArabicChar	.\unicode\wince\UnicodeWinCE.h	/^inline bool isArabicChar(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::isDigit	.\unicode\glib\UnicodeGLib.h	/^inline bool isDigit(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::isDigit	.\unicode\wince\UnicodeWinCE.cpp	/^bool isDigit(UChar c)$/;"	f	namespace:WTF::Unicode	signature:(UChar c)
WTF::Unicode::isDigit	.\unicode\wince\UnicodeWinCE.h	/^bool isDigit(UChar);$/;"	p	namespace:WTF::Unicode	signature:(UChar)
WTF::Unicode::isFormatChar	.\unicode\glib\UnicodeGLib.h	/^inline bool isFormatChar(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::isHighSurrogate	.\unicode\wince\UnicodeWinCE.h	/^inline bool isHighSurrogate(UChar c) { return (c & 0xfc00) == 0xd800; }$/;"	f	namespace:WTF::Unicode	signature:(UChar c)
WTF::Unicode::isLegalUTF8	.\unicode\UTF8.cpp	/^static bool isLegalUTF8(const unsigned char* source, int length)$/;"	f	namespace:WTF::Unicode	file:	signature:(const unsigned char* source, int length)
WTF::Unicode::isLetter	.\unicode\wince\UnicodeWinCE.cpp	/^bool isLetter(UChar c)$/;"	f	namespace:WTF::Unicode	signature:(UChar c)
WTF::Unicode::isLetter	.\unicode\wince\UnicodeWinCE.h	/^bool isLetter(UChar);$/;"	p	namespace:WTF::Unicode	signature:(UChar)
WTF::Unicode::isLowSurrogate	.\unicode\wince\UnicodeWinCE.h	/^inline bool isLowSurrogate(UChar c) { return (c & 0xfc00) == 0xdc00; }$/;"	f	namespace:WTF::Unicode	signature:(UChar c)
WTF::Unicode::isLower	.\unicode\glib\UnicodeGLib.h	/^inline bool isLower(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::isLower	.\unicode\icu\UnicodeIcu.h	/^inline bool isLower(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::isLower	.\unicode\qt4\UnicodeQt4.h	/^inline bool isLower(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::isLower	.\unicode\wince\UnicodeWinCE.cpp	/^bool isLower(UChar c)$/;"	f	namespace:WTF::Unicode	signature:(UChar c)
WTF::Unicode::isLower	.\unicode\wince\UnicodeWinCE.h	/^bool isLower(UChar);$/;"	p	namespace:WTF::Unicode	signature:(UChar)
WTF::Unicode::isPrintableChar	.\unicode\glib\UnicodeGLib.h	/^inline bool isPrintableChar(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::isPrintableChar	.\unicode\icu\UnicodeIcu.h	/^inline bool isPrintableChar(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::isPrintableChar	.\unicode\qt4\UnicodeQt4.h	/^inline bool isPrintableChar(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::isPrintableChar	.\unicode\wince\UnicodeWinCE.cpp	/^bool isPrintableChar(UChar c)$/;"	f	namespace:WTF::Unicode	signature:(UChar c)
WTF::Unicode::isPrintableChar	.\unicode\wince\UnicodeWinCE.h	/^bool isPrintableChar(UChar);$/;"	p	namespace:WTF::Unicode	signature:(UChar)
WTF::Unicode::isPunct	.\unicode\glib\UnicodeGLib.h	/^inline bool isPunct(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::isPunct	.\unicode\icu\UnicodeIcu.h	/^inline bool isPunct(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::isPunct	.\unicode\qt4\UnicodeQt4.h	/^inline bool isPunct(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::isPunct	.\unicode\wince\UnicodeWinCE.cpp	/^bool isPunct(UChar c)$/;"	f	namespace:WTF::Unicode	signature:(UChar c)
WTF::Unicode::isPunct	.\unicode\wince\UnicodeWinCE.h	/^bool isPunct(UChar);$/;"	p	namespace:WTF::Unicode	signature:(UChar)
WTF::Unicode::isSeparatorSpace	.\unicode\glib\UnicodeGLib.h	/^inline bool isSeparatorSpace(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::isSeparatorSpace	.\unicode\icu\UnicodeIcu.h	/^inline bool isSeparatorSpace(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::isSeparatorSpace	.\unicode\qt4\UnicodeQt4.h	/^inline bool isSeparatorSpace(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::isSeparatorSpace	.\unicode\wince\UnicodeWinCE.h	/^inline bool isSeparatorSpace(UChar c) { return category(c) == Separator_Space; }$/;"	f	namespace:WTF::Unicode	signature:(UChar c)
WTF::Unicode::isSpace	.\unicode\wince\UnicodeWinCE.cpp	/^bool isSpace(UChar c)$/;"	f	namespace:WTF::Unicode	signature:(UChar c)
WTF::Unicode::isSpace	.\unicode\wince\UnicodeWinCE.h	/^bool isSpace(UChar);$/;"	p	namespace:WTF::Unicode	signature:(UChar)
WTF::Unicode::isUpper	.\unicode\wince\UnicodeWinCE.cpp	/^bool isUpper(UChar c)$/;"	f	namespace:WTF::Unicode	signature:(UChar c)
WTF::Unicode::isUpper	.\unicode\wince\UnicodeWinCE.h	/^bool isUpper(UChar);$/;"	p	namespace:WTF::Unicode	signature:(UChar)
WTF::Unicode::leftDoubleQuotationMark	.\unicode\CharacterNames.h	/^const UChar leftDoubleQuotationMark = 0x201C;$/;"	v
WTF::Unicode::leftSingleQuotationMark	.\unicode\CharacterNames.h	/^const UChar leftSingleQuotationMark = 0x2018;$/;"	v
WTF::Unicode::leftToRightEmbed	.\unicode\CharacterNames.h	/^const UChar leftToRightEmbed = 0x202A;$/;"	v
WTF::Unicode::leftToRightMark	.\unicode\CharacterNames.h	/^const UChar leftToRightMark = 0x200E;$/;"	v
WTF::Unicode::leftToRightOverride	.\unicode\CharacterNames.h	/^const UChar leftToRightOverride = 0x202D;$/;"	v
WTF::Unicode::minusSign	.\unicode\CharacterNames.h	/^const UChar minusSign = 0x2212;$/;"	v
WTF::Unicode::mirroredChar	.\unicode\glib\UnicodeGLib.h	/^inline UChar32 mirroredChar(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::mirroredChar	.\unicode\icu\UnicodeIcu.h	/^inline UChar32 mirroredChar(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::mirroredChar	.\unicode\qt4\UnicodeQt4.h	/^inline UChar32 mirroredChar(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::mirroredChar	.\unicode\wince\UnicodeWinCE.cpp	/^UChar mirroredChar(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::mirroredChar	.\unicode\wince\UnicodeWinCE.h	/^UChar mirroredChar(UChar32);$/;"	p	namespace:WTF::Unicode	signature:(UChar32)
WTF::Unicode::newlineCharacter	.\unicode\CharacterNames.h	/^const UChar newlineCharacter = 0x000A;$/;"	v
WTF::Unicode::noBreakSpace	.\unicode\CharacterNames.h	/^const UChar noBreakSpace = 0x00A0;$/;"	v
WTF::Unicode::objectReplacementCharacter	.\unicode\CharacterNames.h	/^const UChar objectReplacementCharacter = 0xFFFC;$/;"	v
WTF::Unicode::offsetsFromUTF8	.\unicode\UTF8.cpp	/^static const UChar32 offsetsFromUTF8[6] = { 0x00000000UL, 0x00003080UL, 0x000E2080UL, $/;"	v	file:
WTF::Unicode::popDirectionalFormatting	.\unicode\CharacterNames.h	/^const UChar popDirectionalFormatting = 0x202C;$/;"	v
WTF::Unicode::readUTF8Sequence	.\unicode\UTF8.cpp	/^static inline UChar32 readUTF8Sequence(const char*& sequence, unsigned length)$/;"	f	namespace:WTF::Unicode	file:	signature:(const char*& sequence, unsigned length)
WTF::Unicode::replacementCharacter	.\unicode\CharacterNames.h	/^const UChar replacementCharacter = 0xFFFD;$/;"	v
WTF::Unicode::rightDoubleQuotationMark	.\unicode\CharacterNames.h	/^const UChar rightDoubleQuotationMark = 0x201D;$/;"	v
WTF::Unicode::rightSingleQuotationMark	.\unicode\CharacterNames.h	/^const UChar rightSingleQuotationMark = 0x2019;$/;"	v
WTF::Unicode::rightToLeftEmbed	.\unicode\CharacterNames.h	/^const UChar rightToLeftEmbed = 0x202B;$/;"	v
WTF::Unicode::rightToLeftMark	.\unicode\CharacterNames.h	/^const UChar rightToLeftMark = 0x200F;$/;"	v
WTF::Unicode::rightToLeftOverride	.\unicode\CharacterNames.h	/^const UChar rightToLeftOverride = 0x202E;$/;"	v
WTF::Unicode::sesameDot	.\unicode\CharacterNames.h	/^const UChar sesameDot = 0xFE45;$/;"	v
WTF::Unicode::smallLetterSharpS	.\unicode\CharacterNames.h	/^const UChar smallLetterSharpS = 0x00DF;$/;"	v
WTF::Unicode::softHyphen	.\unicode\CharacterNames.h	/^const UChar softHyphen = 0x00AD;$/;"	v
WTF::Unicode::sourceExhausted	.\unicode\UTF8.h	/^            sourceExhausted,    \/\/ partial character in source, but hit end$/;"	e	enum:WTF::Unicode::__anon13
WTF::Unicode::sourceIllegal	.\unicode\UTF8.h	/^            sourceIllegal       \/\/ source sequence is illegal\/malformed$/;"	e	enum:WTF::Unicode::__anon13
WTF::Unicode::space	.\unicode\CharacterNames.h	/^const UChar space = 0x0020;$/;"	v
WTF::Unicode::surrogateToUcs4	.\unicode\wince\UnicodeWinCE.h	/^inline UChar32 surrogateToUcs4(UChar high, UChar low)$/;"	f	namespace:WTF::Unicode	signature:(UChar high, UChar low)
WTF::Unicode::targetExhausted	.\unicode\UTF8.h	/^            targetExhausted,    \/\/ insuff. room in target for conversion$/;"	e	enum:WTF::Unicode::__anon13
WTF::Unicode::tibetanMarkDelimiterTshegBstar	.\unicode\CharacterNames.h	/^const UChar tibetanMarkDelimiterTshegBstar = 0x0F0C;$/;"	v
WTF::Unicode::tibetanMarkIntersyllabicTsheg	.\unicode\CharacterNames.h	/^const UChar tibetanMarkIntersyllabicTsheg = 0x0F0B;$/;"	v
WTF::Unicode::toLower	.\unicode\glib\UnicodeGLib.cpp	/^int toLower(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)$/;"	f	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)
WTF::Unicode::toLower	.\unicode\glib\UnicodeGLib.h	/^inline UChar32 toLower(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::toLower	.\unicode\glib\UnicodeGLib.h	/^int toLower(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error);$/;"	p	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)
WTF::Unicode::toLower	.\unicode\icu\UnicodeIcu.h	/^inline UChar32 toLower(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::toLower	.\unicode\icu\UnicodeIcu.h	/^inline int toLower(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)$/;"	f	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)
WTF::Unicode::toLower	.\unicode\qt4\UnicodeQt4.h	/^inline UChar32 toLower(UChar32 ch)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 ch)
WTF::Unicode::toLower	.\unicode\qt4\UnicodeQt4.h	/^inline int toLower(UChar* result, int resultLength, const UChar* src, int srcLength,  bool* error)$/;"	f	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)
WTF::Unicode::toLower	.\unicode\wince\UnicodeWinCE.cpp	/^UChar toLower(UChar c)$/;"	f	namespace:WTF::Unicode	signature:(UChar c)
WTF::Unicode::toLower	.\unicode\wince\UnicodeWinCE.cpp	/^int toLower(UChar* result, int resultLength, const UChar* source, int sourceLength, bool* isError)$/;"	f	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* source, int sourceLength, bool* isError)
WTF::Unicode::toLower	.\unicode\wince\UnicodeWinCE.h	/^UChar toLower(UChar);$/;"	p	namespace:WTF::Unicode	signature:(UChar)
WTF::Unicode::toLower	.\unicode\wince\UnicodeWinCE.h	/^int toLower(UChar* result, int resultLength, const UChar* source, int sourceLength, bool* isError);$/;"	p	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* source, int sourceLength, bool* isError)
WTF::Unicode::toTitleCase	.\unicode\glib\UnicodeGLib.h	/^inline UChar32 toTitleCase(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::toTitleCase	.\unicode\icu\UnicodeIcu.h	/^inline UChar32 toTitleCase(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::toTitleCase	.\unicode\qt4\UnicodeQt4.h	/^inline int toTitleCase(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::toTitleCase	.\unicode\wince\UnicodeWinCE.cpp	/^UChar toTitleCase(UChar c)$/;"	f	namespace:WTF::Unicode	signature:(UChar c)
WTF::Unicode::toTitleCase	.\unicode\wince\UnicodeWinCE.h	/^UChar toTitleCase(UChar);$/;"	p	namespace:WTF::Unicode	signature:(UChar)
WTF::Unicode::toUpper	.\unicode\glib\UnicodeGLib.cpp	/^int toUpper(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)$/;"	f	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)
WTF::Unicode::toUpper	.\unicode\glib\UnicodeGLib.h	/^inline UChar32 toUpper(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::toUpper	.\unicode\glib\UnicodeGLib.h	/^int toUpper(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error);$/;"	p	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)
WTF::Unicode::toUpper	.\unicode\icu\UnicodeIcu.h	/^inline UChar32 toUpper(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::toUpper	.\unicode\icu\UnicodeIcu.h	/^inline int toUpper(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)$/;"	f	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)
WTF::Unicode::toUpper	.\unicode\qt4\UnicodeQt4.h	/^inline UChar32 toUpper(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
WTF::Unicode::toUpper	.\unicode\qt4\UnicodeQt4.h	/^inline int toUpper(UChar* result, int resultLength, const UChar* src, int srcLength,  bool* error)$/;"	f	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)
WTF::Unicode::toUpper	.\unicode\wince\UnicodeWinCE.cpp	/^UChar toUpper(UChar c)$/;"	f	namespace:WTF::Unicode	signature:(UChar c)
WTF::Unicode::toUpper	.\unicode\wince\UnicodeWinCE.cpp	/^int toUpper(UChar* result, int resultLength, const UChar* source, int sourceLength, bool* isError)$/;"	f	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* source, int sourceLength, bool* isError)
WTF::Unicode::toUpper	.\unicode\wince\UnicodeWinCE.h	/^UChar toUpper(UChar);$/;"	p	namespace:WTF::Unicode	signature:(UChar)
WTF::Unicode::toUpper	.\unicode\wince\UnicodeWinCE.h	/^int toUpper(UChar* result, int resultLength, const UChar* source, int sourceLength, bool* isError);$/;"	p	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* source, int sourceLength, bool* isError)
WTF::Unicode::ugariticWordDivider	.\unicode\CharacterNames.h	/^const UChar32 ugariticWordDivider = 0x1039F;$/;"	v
WTF::Unicode::umemcasecmp	.\unicode\glib\UnicodeGLib.cpp	/^int umemcasecmp(const UChar* a, const UChar* b, int len)$/;"	f	namespace:WTF::Unicode	signature:(const UChar* a, const UChar* b, int len)
WTF::Unicode::umemcasecmp	.\unicode\glib\UnicodeGLib.h	/^int umemcasecmp(const UChar*, const UChar*, int len);$/;"	p	namespace:WTF::Unicode	signature:(const UChar*, const UChar*, int len)
WTF::Unicode::umemcasecmp	.\unicode\icu\UnicodeIcu.h	/^inline int umemcasecmp(const UChar* a, const UChar* b, int len)$/;"	f	namespace:WTF::Unicode	signature:(const UChar* a, const UChar* b, int len)
WTF::Unicode::umemcasecmp	.\unicode\qt4\UnicodeQt4.h	/^inline int umemcasecmp(const UChar* a, const UChar* b, int len)$/;"	f	namespace:WTF::Unicode	signature:(const UChar* a, const UChar* b, int len)
WTF::Unicode::umemcasecmp	.\unicode\wince\UnicodeWinCE.h	/^inline int umemcasecmp(const UChar* a, const UChar* b, int len)$/;"	f	namespace:WTF::Unicode	signature:(const UChar* a, const UChar* b, int len)
WTF::Unicode::whiteBullet	.\unicode\CharacterNames.h	/^const UChar whiteBullet = 0x25E6;$/;"	v
WTF::Unicode::whiteCircle	.\unicode\CharacterNames.h	/^const UChar whiteCircle = 0x25CB;$/;"	v
WTF::Unicode::whiteSesameDot	.\unicode\CharacterNames.h	/^const UChar whiteSesameDot = 0xFE46;$/;"	v
WTF::Unicode::whiteUpPointingTriangle	.\unicode\CharacterNames.h	/^const UChar whiteUpPointingTriangle = 0x25B3;$/;"	v
WTF::Unicode::yenSign	.\unicode\CharacterNames.h	/^const UChar yenSign = 0x00A5;$/;"	v
WTF::Unicode::zeroWidthJoiner	.\unicode\CharacterNames.h	/^const UChar zeroWidthJoiner = 0x200D;$/;"	v
WTF::Unicode::zeroWidthNoBreakSpace	.\unicode\CharacterNames.h	/^const UChar zeroWidthNoBreakSpace = 0xFEFF;$/;"	v
WTF::Unicode::zeroWidthNonJoiner	.\unicode\CharacterNames.h	/^const UChar zeroWidthNonJoiner = 0x200C;$/;"	v
WTF::Unicode::zeroWidthSpace	.\unicode\CharacterNames.h	/^const UChar zeroWidthSpace = 0x200B;$/;"	v
WTF::UnionFind	.\UnionFind.h	/^class UnionFind {$/;"	c	namespace:WTF
WTF::UnionFind::UnionFind	.\UnionFind.h	/^    UnionFind()$/;"	f	class:WTF::UnionFind	access:public	signature:()
WTF::UnionFind::find	.\UnionFind.h	/^    T* find()$/;"	f	class:WTF::UnionFind	access:public	signature:()
WTF::UnionFind::m_parent	.\UnionFind.h	/^    T* m_parent;$/;"	m	class:WTF::UnionFind	access:private
WTF::UnionFind::unify	.\UnionFind.h	/^    void unify(T* other)$/;"	f	class:WTF::UnionFind	access:public	signature:(T* other)
WTF::UnsignedWithZeroKeyHashTraits	.\HashTraits.h	/^    template<typename T> struct UnsignedWithZeroKeyHashTraits : GenericHashTraits<T> {$/;"	s	namespace:WTF	inherits:GenericHashTraits
WTF::UnsignedWithZeroKeyHashTraits::constructDeletedValue	.\HashTraits.h	/^        static void constructDeletedValue(T& slot) { slot = std::numeric_limits<T>::max() - 1; }$/;"	f	struct:WTF::UnsignedWithZeroKeyHashTraits	access:public	signature:(T& slot)
WTF::UnsignedWithZeroKeyHashTraits::emptyValue	.\HashTraits.h	/^        static T emptyValue() { return std::numeric_limits<T>::max(); }$/;"	f	struct:WTF::UnsignedWithZeroKeyHashTraits	access:public	signature:()
WTF::UnsignedWithZeroKeyHashTraits::emptyValueIsZero	.\HashTraits.h	/^        static const bool emptyValueIsZero = false;$/;"	m	struct:WTF::UnsignedWithZeroKeyHashTraits	access:public
WTF::UnsignedWithZeroKeyHashTraits::isDeletedValue	.\HashTraits.h	/^        static bool isDeletedValue(T value) { return value == std::numeric_limits<T>::max() - 1; }$/;"	f	struct:WTF::UnsignedWithZeroKeyHashTraits	access:public	signature:(T value)
WTF::UnsignedWithZeroKeyHashTraits::needsDestruction	.\HashTraits.h	/^        static const bool needsDestruction = false;$/;"	m	struct:WTF::UnsignedWithZeroKeyHashTraits	access:public
WTF::Uppercase	.\HexNumber.h	/^    Uppercase$/;"	e	enum:WTF::HexConversionMode
WTF::ValueCheck	.\ValueCheck.h	/^template<typename P> struct ValueCheck<P*> {$/;"	s	namespace:WTF
WTF::ValueCheck	.\ValueCheck.h	/^template<typename T> struct ValueCheck {$/;"	s	namespace:WTF
WTF::ValueCheck	.\Vector.h	/^    template<typename T> struct ValueCheck<Vector<T> > {$/;"	s	namespace:WTF
WTF::ValueCheck::TraitType	.\ValueCheck.h	/^    typedef P* TraitType;$/;"	t	struct:WTF::ValueCheck	access:public
WTF::ValueCheck::TraitType	.\ValueCheck.h	/^    typedef T TraitType;$/;"	t	struct:WTF::ValueCheck	access:public
WTF::ValueCheck::TraitType	.\Vector.h	/^        typedef Vector<T> TraitType;$/;"	t	struct:WTF::ValueCheck	access:public
WTF::ValueCheck::checkConsistency	.\ValueCheck.h	/^    static void checkConsistency(const P* p)$/;"	f	struct:WTF::ValueCheck	access:public	signature:(const P* p)
WTF::ValueCheck::checkConsistency	.\ValueCheck.h	/^    static void checkConsistency(const T&) { }$/;"	f	struct:WTF::ValueCheck	access:public	signature:(const T&)
WTF::ValueCheck::checkConsistency	.\Vector.h	/^        static void checkConsistency(const Vector<T>& v)$/;"	f	struct:WTF::ValueCheck	access:public	signature:(const Vector<T>& v)
WTF::Vector	.\Vector.h	/^    class Vector {$/;"	c	namespace:WTF
WTF::Vector::Buffer	.\Vector.h	/^        typedef VectorBuffer<T, inlineCapacity> Buffer;$/;"	t	class:WTF::Vector	access:private
WTF::Vector::TypeOperations	.\Vector.h	/^        typedef VectorTypeOperations<T> TypeOperations;$/;"	t	class:WTF::Vector	access:private
WTF::Vector::ValueType	.\Vector.h	/^        typedef T ValueType;$/;"	t	class:WTF::Vector	access:public
WTF::Vector::Vector	.\Vector.h	/^        Vector() $/;"	f	class:WTF::Vector	access:public	signature:()
WTF::Vector::Vector	.\Vector.h	/^        Vector(const Vector&);$/;"	p	class:WTF::Vector	access:public	signature:(const Vector&)
WTF::Vector::Vector	.\Vector.h	/^        Vector(const Vector<T, otherCapacity>&);$/;"	p	class:WTF::Vector	access:public	signature:(const Vector<T, otherCapacity>&)
WTF::Vector::Vector	.\Vector.h	/^        Vector(size_t size, const T& val)$/;"	f	class:WTF::Vector	access:public	signature:(size_t size, const T& val)
WTF::Vector::Vector	.\Vector.h	/^        explicit Vector(size_t size) $/;"	f	class:WTF::Vector	access:public	signature:(size_t size)
WTF::Vector::Vector	.\Vector.h	/^    Vector<T, inlineCapacity>::Vector(const Vector& other)$/;"	f	class:WTF::Vector	signature:(const Vector& other)
WTF::Vector::Vector	.\Vector.h	/^    Vector<T, inlineCapacity>::Vector(const Vector<T, otherCapacity>& other)$/;"	f	class:WTF::Vector	signature:(const Vector<T, otherCapacity>& other)
WTF::Vector::VectorReverseProxy	.\Vector.h	/^        class VectorReverseProxy : private Vector {$/;"	c	class:WTF::Vector	inherits:Vector	access:private
WTF::Vector::VectorReverseProxy::VectorReverseProxy	.\Vector.h	/^            VectorReverseProxy();$/;"	p	class:WTF::Vector::VectorReverseProxy	access:private	signature:()
WTF::Vector::VectorReverseProxy::VectorReverseProxy	.\Vector.h	/^            VectorReverseProxy(const VectorReverseProxy&);$/;"	p	class:WTF::Vector::VectorReverseProxy	access:private	signature:(const VectorReverseProxy&)
WTF::Vector::VectorReverseProxy::begin	.\Vector.h	/^            const_iterator begin() const { return Vector::rbegin(); }$/;"	f	class:WTF::Vector::VectorReverseProxy	access:public	signature:() const
WTF::Vector::VectorReverseProxy::begin	.\Vector.h	/^            iterator begin() { return Vector::rbegin(); }$/;"	f	class:WTF::Vector::VectorReverseProxy	access:public	signature:()
WTF::Vector::VectorReverseProxy::const_iterator	.\Vector.h	/^            typedef typename Vector::const_reverse_iterator const_iterator;$/;"	t	class:WTF::Vector::VectorReverseProxy	access:public
WTF::Vector::VectorReverseProxy::end	.\Vector.h	/^            const_iterator end() const { return Vector::rend(); }$/;"	f	class:WTF::Vector::VectorReverseProxy	access:public	signature:() const
WTF::Vector::VectorReverseProxy::end	.\Vector.h	/^            iterator end() { return Vector::rend(); }$/;"	f	class:WTF::Vector::VectorReverseProxy	access:public	signature:()
WTF::Vector::VectorReverseProxy::iterator	.\Vector.h	/^            typedef typename Vector::reverse_iterator iterator;$/;"	t	class:WTF::Vector::VectorReverseProxy	access:public
WTF::Vector::VectorReverseProxy::operator =	.\Vector.h	/^            VectorReverseProxy& operator=(const VectorReverseProxy&);$/;"	p	class:WTF::Vector::VectorReverseProxy	access:private	signature:(const VectorReverseProxy&)
WTF::Vector::VectorReverseProxy::~VectorReverseProxy	.\Vector.h	/^            ~VectorReverseProxy();$/;"	p	class:WTF::Vector::VectorReverseProxy	access:private	signature:()
WTF::Vector::WTF_MAKE_FAST_ALLOCATED	.\Vector.h	/^        WTF_MAKE_FAST_ALLOCATED;$/;"	m	class:WTF::Vector	access:private
WTF::Vector::append	.\Vector.h	/^        template<size_t otherCapacity> void append(const Vector<T, otherCapacity>&);$/;"	p	class:WTF::Vector	access:public	signature:(const Vector<T, otherCapacity>&)
WTF::Vector::append	.\Vector.h	/^        template<typename U> void append(const U&);$/;"	p	class:WTF::Vector	access:public	signature:(const U&)
WTF::Vector::append	.\Vector.h	/^        template<typename U> void append(const U*, size_t);$/;"	p	class:WTF::Vector	access:public	signature:(const U*, size_t)
WTF::Vector::append	.\Vector.h	/^    ALWAYS_INLINE void Vector<T, inlineCapacity>::append(const U& val)$/;"	f	class:WTF::Vector	signature:(const U& val)
WTF::Vector::append	.\Vector.h	/^    inline void Vector<T, inlineCapacity>::append(const Vector<T, otherCapacity>& val)$/;"	f	class:WTF::Vector	signature:(const Vector<T, otherCapacity>& val)
WTF::Vector::append	.\Vector.h	/^    void Vector<T, inlineCapacity>::append(const U* data, size_t dataSize)$/;"	f	class:WTF::Vector	signature:(const U* data, size_t dataSize)
WTF::Vector::appendRange	.\Vector.h	/^        template<typename Iterator> void appendRange(Iterator start, Iterator end);$/;"	p	class:WTF::Vector	access:public	signature:(Iterator start, Iterator end)
WTF::Vector::appendRange	.\Vector.h	/^    void Vector<T, inlineCapacity>::appendRange(Iterator start, Iterator end)$/;"	f	class:WTF::Vector	signature:(Iterator start, Iterator end)
WTF::Vector::appendSlowCase	.\Vector.h	/^        template<typename U> void appendSlowCase(const U&);$/;"	p	class:WTF::Vector	access:private	signature:(const U&)
WTF::Vector::appendSlowCase	.\Vector.h	/^    void Vector<T, inlineCapacity>::appendSlowCase(const U& val)$/;"	f	class:WTF::Vector	signature:(const U& val)
WTF::Vector::at	.\Vector.h	/^        T& at(size_t i) $/;"	f	class:WTF::Vector	access:public	signature:(size_t i)
WTF::Vector::at	.\Vector.h	/^        const T& at(size_t i) const $/;"	f	class:WTF::Vector	access:public	signature:(size_t i) const
WTF::Vector::begin	.\Vector.h	/^        const_iterator begin() const { return data(); }$/;"	f	class:WTF::Vector	access:public	signature:() const
WTF::Vector::begin	.\Vector.h	/^        iterator begin() { return data(); }$/;"	f	class:WTF::Vector	access:public	signature:()
WTF::Vector::capacity	.\Vector.h	/^        size_t capacity() const { return m_buffer.capacity(); }$/;"	f	class:WTF::Vector	access:public	signature:() const
WTF::Vector::checkConsistency	.\Vector.h	/^        void checkConsistency();$/;"	p	class:WTF::Vector	access:public	signature:()
WTF::Vector::checkConsistency	.\Vector.h	/^    inline void Vector<T, inlineCapacity>::checkConsistency()$/;"	f	class:WTF::Vector	signature:()
WTF::Vector::clear	.\Vector.h	/^        void clear() { shrinkCapacity(0); }$/;"	f	class:WTF::Vector	access:public	signature:()
WTF::Vector::const_iterator	.\Vector.h	/^        typedef const T* const_iterator;$/;"	t	class:WTF::Vector	access:public
WTF::Vector::const_reverse_iterator	.\Vector.h	/^        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:WTF::Vector	access:public
WTF::Vector::contains	.\Vector.h	/^        template<typename U> bool contains(const U&) const;$/;"	p	class:WTF::Vector	access:public	signature:(const U&) const
WTF::Vector::contains	.\Vector.h	/^    bool Vector<T, inlineCapacity>::contains(const U& value) const$/;"	f	class:WTF::Vector	signature:(const U& value) const
WTF::Vector::data	.\Vector.h	/^        T* data() { return m_buffer.buffer(); }$/;"	f	class:WTF::Vector	access:public	signature:()
WTF::Vector::data	.\Vector.h	/^        const T* data() const { return m_buffer.buffer(); }$/;"	f	class:WTF::Vector	access:public	signature:() const
WTF::Vector::dataSlot	.\Vector.h	/^        T** dataSlot() { return m_buffer.bufferSlot(); }$/;"	f	class:WTF::Vector	access:public	signature:()
WTF::Vector::end	.\Vector.h	/^        const_iterator end() const { return begin() + m_size; }$/;"	f	class:WTF::Vector	access:public	signature:() const
WTF::Vector::end	.\Vector.h	/^        iterator end() { return begin() + m_size; }$/;"	f	class:WTF::Vector	access:public	signature:()
WTF::Vector::expandCapacity	.\Vector.h	/^        const T* expandCapacity(size_t newMinCapacity, const T*);$/;"	p	class:WTF::Vector	access:private	signature:(size_t newMinCapacity, const T*)
WTF::Vector::expandCapacity	.\Vector.h	/^        template<typename U> U* expandCapacity(size_t newMinCapacity, U*); $/;"	p	class:WTF::Vector	access:private	signature:(size_t newMinCapacity, U*)
WTF::Vector::expandCapacity	.\Vector.h	/^        void expandCapacity(size_t newMinCapacity);$/;"	p	class:WTF::Vector	access:private	signature:(size_t newMinCapacity)
WTF::Vector::expandCapacity	.\Vector.h	/^    const T* Vector<T, inlineCapacity>::expandCapacity(size_t newMinCapacity, const T* ptr)$/;"	f	class:WTF::Vector	signature:(size_t newMinCapacity, const T* ptr)
WTF::Vector::expandCapacity	.\Vector.h	/^    inline U* Vector<T, inlineCapacity>::expandCapacity(size_t newMinCapacity, U* ptr)$/;"	f	class:WTF::Vector	signature:(size_t newMinCapacity, U* ptr)
WTF::Vector::expandCapacity	.\Vector.h	/^    void Vector<T, inlineCapacity>::expandCapacity(size_t newMinCapacity)$/;"	f	class:WTF::Vector	signature:(size_t newMinCapacity)
WTF::Vector::fill	.\Vector.h	/^        void fill(const T& val) { fill(val, size()); }$/;"	f	class:WTF::Vector	access:public	signature:(const T& val)
WTF::Vector::fill	.\Vector.h	/^        void fill(const T&, size_t);$/;"	p	class:WTF::Vector	access:public	signature:(const T&, size_t)
WTF::Vector::fill	.\Vector.h	/^    void Vector<T, inlineCapacity>::fill(const T& val, size_t newSize)$/;"	f	class:WTF::Vector	signature:(const T& val, size_t newSize)
WTF::Vector::find	.\Vector.h	/^        template<typename U> size_t find(const U&) const;$/;"	p	class:WTF::Vector	access:public	signature:(const U&) const
WTF::Vector::find	.\Vector.h	/^    size_t Vector<T, inlineCapacity>::find(const U& value) const$/;"	f	class:WTF::Vector	signature:(const U& value) const
WTF::Vector::first	.\Vector.h	/^        T& first() { return at(0); }$/;"	f	class:WTF::Vector	access:public	signature:()
WTF::Vector::first	.\Vector.h	/^        const T& first() const { return at(0); }$/;"	f	class:WTF::Vector	access:public	signature:() const
WTF::Vector::grow	.\Vector.h	/^        void grow(size_t size);$/;"	p	class:WTF::Vector	access:public	signature:(size_t size)
WTF::Vector::grow	.\Vector.h	/^    void Vector<T, inlineCapacity>::grow(size_t size)$/;"	f	class:WTF::Vector	signature:(size_t size)
WTF::Vector::insert	.\Vector.h	/^        template<typename U, size_t c> void insert(size_t position, const Vector<U, c>&);$/;"	p	class:WTF::Vector	access:public	signature:(size_t position, const Vector<U, c>&)
WTF::Vector::insert	.\Vector.h	/^        template<typename U> void insert(size_t position, const U&);$/;"	p	class:WTF::Vector	access:public	signature:(size_t position, const U&)
WTF::Vector::insert	.\Vector.h	/^        template<typename U> void insert(size_t position, const U*, size_t);$/;"	p	class:WTF::Vector	access:public	signature:(size_t position, const U*, size_t)
WTF::Vector::insert	.\Vector.h	/^    inline void Vector<T, inlineCapacity>::insert(size_t position, const U& val)$/;"	f	class:WTF::Vector	signature:(size_t position, const U& val)
WTF::Vector::insert	.\Vector.h	/^    inline void Vector<T, inlineCapacity>::insert(size_t position, const Vector<U, c>& val)$/;"	f	class:WTF::Vector	signature:(size_t position, const Vector<U, c>& val)
WTF::Vector::insert	.\Vector.h	/^    void Vector<T, inlineCapacity>::insert(size_t position, const U* data, size_t dataSize)$/;"	f	class:WTF::Vector	signature:(size_t position, const U* data, size_t dataSize)
WTF::Vector::isEmpty	.\Vector.h	/^        bool isEmpty() const { return !size(); }$/;"	f	class:WTF::Vector	access:public	signature:() const
WTF::Vector::iterator	.\Vector.h	/^        typedef T* iterator;$/;"	t	class:WTF::Vector	access:public
WTF::Vector::last	.\Vector.h	/^        T& last() { return at(size() - 1); }$/;"	f	class:WTF::Vector	access:public	signature:()
WTF::Vector::last	.\Vector.h	/^        const T& last() const { return at(size() - 1); }$/;"	f	class:WTF::Vector	access:public	signature:() const
WTF::Vector::m_buffer	.\Vector.h	/^        Buffer m_buffer;$/;"	m	class:WTF::Vector	access:private
WTF::Vector::m_size	.\Vector.h	/^        size_t m_size;$/;"	m	class:WTF::Vector	access:private
WTF::Vector::operator =	.\Vector.h	/^        Vector& operator=(const Vector&);$/;"	p	class:WTF::Vector	access:public	signature:(const Vector&)
WTF::Vector::operator =	.\Vector.h	/^        Vector& operator=(const Vector<T, otherCapacity>&);$/;"	p	class:WTF::Vector	access:public	signature:(const Vector<T, otherCapacity>&)
WTF::Vector::operator =	.\Vector.h	/^    Vector<T, inlineCapacity>& Vector<T, inlineCapacity>::operator=(const Vector<T, inlineCapacity>& other)$/;"	f	class:WTF::Vector	signature:(const Vector<T, inlineCapacity>& other)
WTF::Vector::operator =	.\Vector.h	/^    Vector<T, inlineCapacity>& Vector<T, inlineCapacity>::operator=(const Vector<T, otherCapacity>& other)$/;"	f	class:WTF::Vector	signature:(const Vector<T, otherCapacity>& other)
WTF::Vector::operator []	.\Vector.h	/^        T& operator[](size_t i) { return at(i); }$/;"	f	class:WTF::Vector	access:public	signature:(size_t i)
WTF::Vector::operator []	.\Vector.h	/^        const T& operator[](size_t i) const { return at(i); }$/;"	f	class:WTF::Vector	access:public	signature:(size_t i) const
WTF::Vector::prepend	.\Vector.h	/^        template<typename U, size_t c> void prepend(const Vector<U, c>&);$/;"	p	class:WTF::Vector	access:public	signature:(const Vector<U, c>&)
WTF::Vector::prepend	.\Vector.h	/^        template<typename U> void prepend(const U&);$/;"	p	class:WTF::Vector	access:public	signature:(const U&)
WTF::Vector::prepend	.\Vector.h	/^        template<typename U> void prepend(const U*, size_t);$/;"	p	class:WTF::Vector	access:public	signature:(const U*, size_t)
WTF::Vector::prepend	.\Vector.h	/^    inline void Vector<T, inlineCapacity>::prepend(const U& val)$/;"	f	class:WTF::Vector	signature:(const U& val)
WTF::Vector::prepend	.\Vector.h	/^    inline void Vector<T, inlineCapacity>::prepend(const Vector<U, c>& val)$/;"	f	class:WTF::Vector	signature:(const Vector<U, c>& val)
WTF::Vector::prepend	.\Vector.h	/^    void Vector<T, inlineCapacity>::prepend(const U* data, size_t dataSize)$/;"	f	class:WTF::Vector	signature:(const U* data, size_t dataSize)
WTF::Vector::rbegin	.\Vector.h	/^        const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); }$/;"	f	class:WTF::Vector	access:public	signature:() const
WTF::Vector::rbegin	.\Vector.h	/^        reverse_iterator rbegin() { return reverse_iterator(end()); }$/;"	f	class:WTF::Vector	access:public	signature:()
WTF::Vector::releaseBuffer	.\Vector.h	/^        T* releaseBuffer();$/;"	p	class:WTF::Vector	access:public	signature:()
WTF::Vector::releaseBuffer	.\Vector.h	/^    inline T* Vector<T, inlineCapacity>::releaseBuffer()$/;"	f	class:WTF::Vector	signature:()
WTF::Vector::remove	.\Vector.h	/^        void remove(size_t position);$/;"	p	class:WTF::Vector	access:public	signature:(size_t position)
WTF::Vector::remove	.\Vector.h	/^        void remove(size_t position, size_t length);$/;"	p	class:WTF::Vector	access:public	signature:(size_t position, size_t length)
WTF::Vector::remove	.\Vector.h	/^    inline void Vector<T, inlineCapacity>::remove(size_t position)$/;"	f	class:WTF::Vector	signature:(size_t position)
WTF::Vector::remove	.\Vector.h	/^    inline void Vector<T, inlineCapacity>::remove(size_t position, size_t length)$/;"	f	class:WTF::Vector	signature:(size_t position, size_t length)
WTF::Vector::removeLast	.\Vector.h	/^        void removeLast() $/;"	f	class:WTF::Vector	access:public	signature:()
WTF::Vector::rend	.\Vector.h	/^        const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }$/;"	f	class:WTF::Vector	access:public	signature:() const
WTF::Vector::rend	.\Vector.h	/^        reverse_iterator rend() { return reverse_iterator(begin()); }$/;"	f	class:WTF::Vector	access:public	signature:()
WTF::Vector::reserveCapacity	.\Vector.h	/^        void reserveCapacity(size_t newCapacity);$/;"	p	class:WTF::Vector	access:public	signature:(size_t newCapacity)
WTF::Vector::reserveCapacity	.\Vector.h	/^    void Vector<T, inlineCapacity>::reserveCapacity(size_t newCapacity)$/;"	f	class:WTF::Vector	signature:(size_t newCapacity)
WTF::Vector::reserveInitialCapacity	.\Vector.h	/^        void reserveInitialCapacity(size_t initialCapacity);$/;"	p	class:WTF::Vector	access:public	signature:(size_t initialCapacity)
WTF::Vector::reserveInitialCapacity	.\Vector.h	/^    inline void Vector<T, inlineCapacity>::reserveInitialCapacity(size_t initialCapacity)$/;"	f	class:WTF::Vector	signature:(size_t initialCapacity)
WTF::Vector::resize	.\Vector.h	/^        void resize(size_t size);$/;"	p	class:WTF::Vector	access:public	signature:(size_t size)
WTF::Vector::resize	.\Vector.h	/^    inline void Vector<T, inlineCapacity>::resize(size_t size)$/;"	f	class:WTF::Vector	signature:(size_t size)
WTF::Vector::reverse	.\Vector.h	/^        void reverse();$/;"	p	class:WTF::Vector	access:public	signature:()
WTF::Vector::reverse	.\Vector.h	/^    inline void Vector<T, inlineCapacity>::reverse()$/;"	f	class:WTF::Vector	signature:()
WTF::Vector::reverseFind	.\Vector.h	/^        template<typename U> size_t reverseFind(const U&) const;$/;"	p	class:WTF::Vector	access:public	signature:(const U&) const
WTF::Vector::reverseFind	.\Vector.h	/^    size_t Vector<T, inlineCapacity>::reverseFind(const U& value) const$/;"	f	class:WTF::Vector	signature:(const U& value) const
WTF::Vector::reverse_iterator	.\Vector.h	/^        typedef std::reverse_iterator<iterator> reverse_iterator;$/;"	t	class:WTF::Vector	access:public
WTF::Vector::reversed	.\Vector.h	/^        VectorReverseProxy& reversed() { return static_cast<VectorReverseProxy&>(*this); }$/;"	f	class:WTF::Vector	access:public	signature:()
WTF::Vector::reversed	.\Vector.h	/^        const VectorReverseProxy& reversed() const { return static_cast<const VectorReverseProxy&>(*this); }$/;"	f	class:WTF::Vector	access:public	signature:() const
WTF::Vector::shrink	.\Vector.h	/^        void shrink(size_t size);$/;"	p	class:WTF::Vector	access:public	signature:(size_t size)
WTF::Vector::shrink	.\Vector.h	/^    void Vector<T, inlineCapacity>::shrink(size_t size)$/;"	f	class:WTF::Vector	signature:(size_t size)
WTF::Vector::shrinkCapacity	.\Vector.h	/^        void shrinkCapacity(size_t newCapacity);$/;"	p	class:WTF::Vector	access:public	signature:(size_t newCapacity)
WTF::Vector::shrinkCapacity	.\Vector.h	/^    void Vector<T, inlineCapacity>::shrinkCapacity(size_t newCapacity)$/;"	f	class:WTF::Vector	signature:(size_t newCapacity)
WTF::Vector::shrinkToFit	.\Vector.h	/^        void shrinkToFit() { shrinkCapacity(size()); }$/;"	f	class:WTF::Vector	access:public	signature:()
WTF::Vector::size	.\Vector.h	/^        size_t size() const { return m_size; }$/;"	f	class:WTF::Vector	access:public	signature:() const
WTF::Vector::swap	.\Vector.h	/^        void swap(Vector<T, inlineCapacity>& other)$/;"	f	class:WTF::Vector	access:public	signature:(Vector<T, inlineCapacity>& other)
WTF::Vector::tryAppend	.\Vector.h	/^        template<typename U> bool tryAppend(const U*, size_t);$/;"	p	class:WTF::Vector	access:public	signature:(const U*, size_t)
WTF::Vector::tryAppend	.\Vector.h	/^    bool Vector<T, inlineCapacity>::tryAppend(const U* data, size_t dataSize)$/;"	f	class:WTF::Vector	signature:(const U* data, size_t dataSize)
WTF::Vector::tryExpandCapacity	.\Vector.h	/^        bool tryExpandCapacity(size_t newMinCapacity);$/;"	p	class:WTF::Vector	access:private	signature:(size_t newMinCapacity)
WTF::Vector::tryExpandCapacity	.\Vector.h	/^        const T* tryExpandCapacity(size_t newMinCapacity, const T*);$/;"	p	class:WTF::Vector	access:private	signature:(size_t newMinCapacity, const T*)
WTF::Vector::tryExpandCapacity	.\Vector.h	/^    bool Vector<T, inlineCapacity>::tryExpandCapacity(size_t newMinCapacity)$/;"	f	class:WTF::Vector	signature:(size_t newMinCapacity)
WTF::Vector::tryExpandCapacity	.\Vector.h	/^    const T* Vector<T, inlineCapacity>::tryExpandCapacity(size_t newMinCapacity, const T* ptr)$/;"	f	class:WTF::Vector	signature:(size_t newMinCapacity, const T* ptr)
WTF::Vector::tryReserveCapacity	.\Vector.h	/^        bool tryReserveCapacity(size_t newCapacity);$/;"	p	class:WTF::Vector	access:public	signature:(size_t newCapacity)
WTF::Vector::tryReserveCapacity	.\Vector.h	/^    bool Vector<T, inlineCapacity>::tryReserveCapacity(size_t newCapacity)$/;"	f	class:WTF::Vector	signature:(size_t newCapacity)
WTF::Vector::uncheckedAppend	.\Vector.h	/^        template<typename U> void uncheckedAppend(const U& val);$/;"	p	class:WTF::Vector	access:public	signature:(const U& val)
WTF::Vector::uncheckedAppend	.\Vector.h	/^    inline void Vector<T, inlineCapacity>::uncheckedAppend(const U& val)$/;"	f	class:WTF::Vector	signature:(const U& val)
WTF::Vector::~Vector	.\Vector.h	/^        ~Vector()$/;"	f	class:WTF::Vector	access:public	signature:()
WTF::VectorBuffer	.\Vector.h	/^    class VectorBuffer : private VectorBufferBase<T> {$/;"	c	namespace:WTF	inherits:VectorBufferBase
WTF::VectorBuffer	.\Vector.h	/^    class VectorBuffer<T, 0> : private VectorBufferBase<T> {$/;"	c	namespace:WTF	inherits:VectorBufferBase
WTF::VectorBuffer::Base	.\Vector.h	/^        typedef VectorBufferBase<T> Base;$/;"	t	class:WTF::VectorBuffer	access:private
WTF::VectorBuffer::VectorBuffer	.\Vector.h	/^        VectorBuffer()$/;"	f	class:WTF::VectorBuffer	access:public	signature:()
WTF::VectorBuffer::VectorBuffer	.\Vector.h	/^        VectorBuffer(size_t capacity)$/;"	f	class:WTF::VectorBuffer	access:public	signature:(size_t capacity)
WTF::VectorBuffer::WTF_MAKE_NONCOPYABLE	.\Vector.h	/^        WTF_MAKE_NONCOPYABLE(VectorBuffer);$/;"	p	class:WTF::VectorBuffer	access:private	signature:(VectorBuffer)
WTF::VectorBuffer::allocateBuffer	.\Vector.h	/^        void allocateBuffer(size_t newCapacity)$/;"	f	class:WTF::VectorBuffer	access:public	signature:(size_t newCapacity)
WTF::VectorBuffer::deallocateBuffer	.\Vector.h	/^        void deallocateBuffer(T* bufferToDeallocate)$/;"	f	class:WTF::VectorBuffer	access:public	signature:(T* bufferToDeallocate)
WTF::VectorBuffer::inlineBuffer	.\Vector.h	/^        T* inlineBuffer() { return reinterpret_cast_ptr<T*>(m_inlineBuffer.buffer); }$/;"	f	class:WTF::VectorBuffer	access:private	signature:()
WTF::VectorBuffer::m_inlineBuffer	.\Vector.h	/^        AlignedBuffer<m_inlineBufferSize, WTF_ALIGN_OF(T)> m_inlineBuffer;$/;"	m	class:WTF::VectorBuffer	access:private
WTF::VectorBuffer::m_inlineBufferSize	.\Vector.h	/^        static const size_t m_inlineBufferSize = inlineCapacity * sizeof(T);$/;"	m	class:WTF::VectorBuffer	access:private
WTF::VectorBuffer::releaseBuffer	.\Vector.h	/^        T* releaseBuffer()$/;"	f	class:WTF::VectorBuffer	access:public	signature:()
WTF::VectorBuffer::restoreInlineBufferIfNeeded	.\Vector.h	/^        void restoreInlineBufferIfNeeded() { }$/;"	f	class:WTF::VectorBuffer	access:public	signature:()
WTF::VectorBuffer::restoreInlineBufferIfNeeded	.\Vector.h	/^        void restoreInlineBufferIfNeeded()$/;"	f	class:WTF::VectorBuffer	access:public	signature:()
WTF::VectorBuffer::swap	.\Vector.h	/^        void swap(VectorBuffer<T, 0>& other)$/;"	f	class:WTF::VectorBuffer	access:public	signature:(VectorBuffer<T, 0>& other)
WTF::VectorBuffer::swap	.\Vector.h	/^        void swap(VectorBuffer<T, inlineCapacity>& other)$/;"	f	class:WTF::VectorBuffer	access:public	signature:(VectorBuffer<T, inlineCapacity>& other)
WTF::VectorBuffer::tryAllocateBuffer	.\Vector.h	/^        bool tryAllocateBuffer(size_t newCapacity)$/;"	f	class:WTF::VectorBuffer	access:public	signature:(size_t newCapacity)
WTF::VectorBuffer::~VectorBuffer	.\Vector.h	/^        ~VectorBuffer()$/;"	f	class:WTF::VectorBuffer	access:public	signature:()
WTF::VectorBufferBase	.\Vector.h	/^    class VectorBufferBase {$/;"	c	namespace:WTF
WTF::VectorBufferBase::VectorBufferBase	.\Vector.h	/^        VectorBufferBase()$/;"	f	class:WTF::VectorBufferBase	access:protected	signature:()
WTF::VectorBufferBase::VectorBufferBase	.\Vector.h	/^        VectorBufferBase(T* buffer, size_t capacity)$/;"	f	class:WTF::VectorBufferBase	access:protected	signature:(T* buffer, size_t capacity)
WTF::VectorBufferBase::WTF_MAKE_NONCOPYABLE	.\Vector.h	/^        WTF_MAKE_NONCOPYABLE(VectorBufferBase);$/;"	p	class:WTF::VectorBufferBase	access:private	signature:(VectorBufferBase)
WTF::VectorBufferBase::allocateBuffer	.\Vector.h	/^        void allocateBuffer(size_t newCapacity)$/;"	f	class:WTF::VectorBufferBase	access:public	signature:(size_t newCapacity)
WTF::VectorBufferBase::buffer	.\Vector.h	/^        T* buffer() { return m_buffer; }$/;"	f	class:WTF::VectorBufferBase	access:public	signature:()
WTF::VectorBufferBase::buffer	.\Vector.h	/^        const T* buffer() const { return m_buffer; }$/;"	f	class:WTF::VectorBufferBase	access:public	signature:() const
WTF::VectorBufferBase::bufferSlot	.\Vector.h	/^        T** bufferSlot() { return &m_buffer; }$/;"	f	class:WTF::VectorBufferBase	access:public	signature:()
WTF::VectorBufferBase::capacity	.\Vector.h	/^        size_t capacity() const { return m_capacity; }$/;"	f	class:WTF::VectorBufferBase	access:public	signature:() const
WTF::VectorBufferBase::deallocateBuffer	.\Vector.h	/^        void deallocateBuffer(T* bufferToDeallocate)$/;"	f	class:WTF::VectorBufferBase	access:public	signature:(T* bufferToDeallocate)
WTF::VectorBufferBase::m_buffer	.\Vector.h	/^        T* m_buffer;$/;"	m	class:WTF::VectorBufferBase	access:protected
WTF::VectorBufferBase::m_capacity	.\Vector.h	/^        size_t m_capacity;$/;"	m	class:WTF::VectorBufferBase	access:protected
WTF::VectorBufferBase::releaseBuffer	.\Vector.h	/^        T* releaseBuffer()$/;"	f	class:WTF::VectorBufferBase	access:public	signature:()
WTF::VectorBufferBase::tryAllocateBuffer	.\Vector.h	/^        bool tryAllocateBuffer(size_t newCapacity)$/;"	f	class:WTF::VectorBufferBase	access:public	signature:(size_t newCapacity)
WTF::VectorBufferBase::~VectorBufferBase	.\Vector.h	/^        ~VectorBufferBase()$/;"	f	class:WTF::VectorBufferBase	access:protected	signature:()
WTF::VectorComparer	.\Vector.h	/^    struct VectorComparer<false, T>$/;"	s	namespace:WTF
WTF::VectorComparer	.\Vector.h	/^    struct VectorComparer<true, T>$/;"	s	namespace:WTF
WTF::VectorComparer::compare	.\Vector.h	/^        static bool compare(const T* a, const T* b, size_t size)$/;"	f	struct:WTF::VectorComparer	access:public	signature:(const T* a, const T* b, size_t size)
WTF::VectorCopier	.\Vector.h	/^    struct VectorCopier<false, T>$/;"	s	namespace:WTF
WTF::VectorCopier	.\Vector.h	/^    struct VectorCopier<true, T>$/;"	s	namespace:WTF
WTF::VectorCopier::uninitializedCopy	.\Vector.h	/^        static void uninitializedCopy(const T* src, const T* srcEnd, T* dst) $/;"	f	struct:WTF::VectorCopier	access:public	signature:(const T* src, const T* srcEnd, T* dst)
WTF::VectorDestructor	.\Vector.h	/^    struct VectorDestructor<false, T>$/;"	s	namespace:WTF
WTF::VectorDestructor	.\Vector.h	/^    struct VectorDestructor<true, T>$/;"	s	namespace:WTF
WTF::VectorDestructor::destruct	.\Vector.h	/^        static void destruct(T* begin, T* end) $/;"	f	struct:WTF::VectorDestructor	access:public	signature:(T* begin, T* end)
WTF::VectorDestructor::destruct	.\Vector.h	/^        static void destruct(T*, T*) {}$/;"	f	struct:WTF::VectorDestructor	access:public	signature:(T*, T*)
WTF::VectorFiller	.\Vector.h	/^    struct VectorFiller<false, T>$/;"	s	namespace:WTF
WTF::VectorFiller	.\Vector.h	/^    struct VectorFiller<true, T>$/;"	s	namespace:WTF
WTF::VectorFiller::uninitializedFill	.\Vector.h	/^        static void uninitializedFill(T* dst, T* dstEnd, const T& val) $/;"	f	struct:WTF::VectorFiller	access:public	signature:(T* dst, T* dstEnd, const T& val)
WTF::VectorInitializer	.\Vector.h	/^    struct VectorInitializer<false, ignore, T>$/;"	s	namespace:WTF
WTF::VectorInitializer	.\Vector.h	/^    struct VectorInitializer<true, false, T>$/;"	s	namespace:WTF
WTF::VectorInitializer	.\Vector.h	/^    struct VectorInitializer<true, true, T>$/;"	s	namespace:WTF
WTF::VectorInitializer::initialize	.\Vector.h	/^        static void initialize(T* begin, T* end) $/;"	f	struct:WTF::VectorInitializer	access:public	signature:(T* begin, T* end)
WTF::VectorInitializer::initialize	.\Vector.h	/^        static void initialize(T*, T*) {}$/;"	f	struct:WTF::VectorInitializer	access:public	signature:(T*, T*)
WTF::VectorMover	.\Vector.h	/^    struct VectorMover<false, T>$/;"	s	namespace:WTF
WTF::VectorMover	.\Vector.h	/^    struct VectorMover<true, T>$/;"	s	namespace:WTF
WTF::VectorMover::move	.\Vector.h	/^        static void move(const T* src, const T* srcEnd, T* dst) $/;"	f	struct:WTF::VectorMover	access:public	signature:(const T* src, const T* srcEnd, T* dst)
WTF::VectorMover::move	.\Vector.h	/^        static void move(const T* src, const T* srcEnd, T* dst)$/;"	f	struct:WTF::VectorMover	access:public	signature:(const T* src, const T* srcEnd, T* dst)
WTF::VectorMover::moveOverlapping	.\Vector.h	/^        static void moveOverlapping(const T* src, const T* srcEnd, T* dst) $/;"	f	struct:WTF::VectorMover	access:public	signature:(const T* src, const T* srcEnd, T* dst)
WTF::VectorMover::moveOverlapping	.\Vector.h	/^        static void moveOverlapping(const T* src, const T* srcEnd, T* dst)$/;"	f	struct:WTF::VectorMover	access:public	signature:(const T* src, const T* srcEnd, T* dst)
WTF::VectorTraits	.\VectorTraits.h	/^    struct VectorTraits : VectorTraitsBase<IsPod<T>::value, T> { };$/;"	s	namespace:WTF	inherits:VectorTraitsBase
WTF::VectorTraits	.\VectorTraits.h	/^    struct VectorTraits<OwnPtr<P> > : SimpleClassVectorTraits { };$/;"	s	namespace:WTF	inherits:SimpleClassVectorTraits
WTF::VectorTraits	.\VectorTraits.h	/^    struct VectorTraits<RefPtr<P> > : SimpleClassVectorTraits { };$/;"	s	namespace:WTF	inherits:SimpleClassVectorTraits
WTF::VectorTraits	.\VectorTraits.h	/^    struct VectorTraits<pair<First, Second> >$/;"	s	namespace:WTF
WTF::VectorTraits	.\text\WTFString.h	/^template <> struct VectorTraits<String> : SimpleClassVectorTraits { };$/;"	s	namespace:WTF	inherits:SimpleClassVectorTraits
WTF::VectorTraits::FirstTraits	.\VectorTraits.h	/^        typedef VectorTraits<First> FirstTraits;$/;"	t	struct:WTF::VectorTraits	access:public
WTF::VectorTraits::SecondTraits	.\VectorTraits.h	/^        typedef VectorTraits<Second> SecondTraits;$/;"	t	struct:WTF::VectorTraits	access:public
WTF::VectorTraits::canCompareWithMemcmp	.\VectorTraits.h	/^        static const bool canCompareWithMemcmp = FirstTraits::canCompareWithMemcmp && SecondTraits::canCompareWithMemcmp;$/;"	m	struct:WTF::VectorTraits	access:public
WTF::VectorTraits::canCopyWithMemcpy	.\VectorTraits.h	/^        static const bool canCopyWithMemcpy = FirstTraits::canCopyWithMemcpy && SecondTraits::canCopyWithMemcpy;$/;"	m	struct:WTF::VectorTraits	access:public
WTF::VectorTraits::canFillWithMemset	.\VectorTraits.h	/^        static const bool canFillWithMemset = false;$/;"	m	struct:WTF::VectorTraits	access:public
WTF::VectorTraits::canInitializeWithMemset	.\VectorTraits.h	/^        static const bool canInitializeWithMemset = FirstTraits::canInitializeWithMemset && SecondTraits::canInitializeWithMemset;$/;"	m	struct:WTF::VectorTraits	access:public
WTF::VectorTraits::canMoveWithMemcpy	.\VectorTraits.h	/^        static const bool canMoveWithMemcpy = FirstTraits::canMoveWithMemcpy && SecondTraits::canMoveWithMemcpy;$/;"	m	struct:WTF::VectorTraits	access:public
WTF::VectorTraits::needsDestruction	.\VectorTraits.h	/^        static const bool needsDestruction = FirstTraits::needsDestruction || SecondTraits::needsDestruction;$/;"	m	struct:WTF::VectorTraits	access:public
WTF::VectorTraits::needsInitialization	.\VectorTraits.h	/^        static const bool needsInitialization = FirstTraits::needsInitialization || SecondTraits::needsInitialization;$/;"	m	struct:WTF::VectorTraits	access:public
WTF::VectorTraitsBase	.\VectorTraits.h	/^    struct VectorTraitsBase<false, T>$/;"	s	namespace:WTF
WTF::VectorTraitsBase	.\VectorTraits.h	/^    struct VectorTraitsBase<true, T>$/;"	s	namespace:WTF
WTF::VectorTraitsBase::canCompareWithMemcmp	.\VectorTraits.h	/^        static const bool canCompareWithMemcmp = false;$/;"	m	struct:WTF::VectorTraitsBase	access:public
WTF::VectorTraitsBase::canCompareWithMemcmp	.\VectorTraits.h	/^        static const bool canCompareWithMemcmp = true;$/;"	m	struct:WTF::VectorTraitsBase	access:public
WTF::VectorTraitsBase::canCopyWithMemcpy	.\VectorTraits.h	/^        static const bool canCopyWithMemcpy = false;$/;"	m	struct:WTF::VectorTraitsBase	access:public
WTF::VectorTraitsBase::canCopyWithMemcpy	.\VectorTraits.h	/^        static const bool canCopyWithMemcpy = true;$/;"	m	struct:WTF::VectorTraitsBase	access:public
WTF::VectorTraitsBase::canFillWithMemset	.\VectorTraits.h	/^        static const bool canFillWithMemset = false;$/;"	m	struct:WTF::VectorTraitsBase	access:public
WTF::VectorTraitsBase::canFillWithMemset	.\VectorTraits.h	/^        static const bool canFillWithMemset = sizeof(T) == sizeof(char);$/;"	m	struct:WTF::VectorTraitsBase	access:public
WTF::VectorTraitsBase::canInitializeWithMemset	.\VectorTraits.h	/^        static const bool canInitializeWithMemset = false;$/;"	m	struct:WTF::VectorTraitsBase	access:public
WTF::VectorTraitsBase::canMoveWithMemcpy	.\VectorTraits.h	/^        static const bool canMoveWithMemcpy = false;$/;"	m	struct:WTF::VectorTraitsBase	access:public
WTF::VectorTraitsBase::canMoveWithMemcpy	.\VectorTraits.h	/^        static const bool canMoveWithMemcpy = true;$/;"	m	struct:WTF::VectorTraitsBase	access:public
WTF::VectorTraitsBase::needsDestruction	.\VectorTraits.h	/^        static const bool needsDestruction = false;$/;"	m	struct:WTF::VectorTraitsBase	access:public
WTF::VectorTraitsBase::needsDestruction	.\VectorTraits.h	/^        static const bool needsDestruction = true;$/;"	m	struct:WTF::VectorTraitsBase	access:public
WTF::VectorTraitsBase::needsInitialization	.\VectorTraits.h	/^        static const bool needsInitialization = false;$/;"	m	struct:WTF::VectorTraitsBase	access:public
WTF::VectorTraitsBase::needsInitialization	.\VectorTraits.h	/^        static const bool needsInitialization = true;$/;"	m	struct:WTF::VectorTraitsBase	access:public
WTF::VectorTypeOperations	.\Vector.h	/^    struct VectorTypeOperations$/;"	s	namespace:WTF
WTF::VectorTypeOperations::compare	.\Vector.h	/^        static bool compare(const T* a, const T* b, size_t size)$/;"	f	struct:WTF::VectorTypeOperations	access:public	signature:(const T* a, const T* b, size_t size)
WTF::VectorTypeOperations::destruct	.\Vector.h	/^        static void destruct(T* begin, T* end)$/;"	f	struct:WTF::VectorTypeOperations	access:public	signature:(T* begin, T* end)
WTF::VectorTypeOperations::initialize	.\Vector.h	/^        static void initialize(T* begin, T* end)$/;"	f	struct:WTF::VectorTypeOperations	access:public	signature:(T* begin, T* end)
WTF::VectorTypeOperations::move	.\Vector.h	/^        static void move(const T* src, const T* srcEnd, T* dst)$/;"	f	struct:WTF::VectorTypeOperations	access:public	signature:(const T* src, const T* srcEnd, T* dst)
WTF::VectorTypeOperations::moveOverlapping	.\Vector.h	/^        static void moveOverlapping(const T* src, const T* srcEnd, T* dst)$/;"	f	struct:WTF::VectorTypeOperations	access:public	signature:(const T* src, const T* srcEnd, T* dst)
WTF::VectorTypeOperations::uninitializedCopy	.\Vector.h	/^        static void uninitializedCopy(const T* src, const T* srcEnd, T* dst)$/;"	f	struct:WTF::VectorTypeOperations	access:public	signature:(const T* src, const T* srcEnd, T* dst)
WTF::VectorTypeOperations::uninitializedFill	.\Vector.h	/^        static void uninitializedFill(T* dst, T* dstEnd, const T& val)$/;"	f	struct:WTF::VectorTypeOperations	access:public	signature:(T* dst, T* dstEnd, const T& val)
WTF::Vector_should_stay_small	.\SizeLimits.cpp	/^COMPILE_ASSERT(sizeof(Vector<int>) == 3 * sizeof(int*), Vector_should_stay_small);$/;"	v
WTF::WTFThreadData	.\WTFThreadData.h	/^class WTFThreadData {$/;"	c	namespace:WTF
WTF::WTFThreadData::WTFThreadData	.\WTFThreadData.cpp	/^WTFThreadData::WTFThreadData()$/;"	f	class:WTF::WTFThreadData	signature:()
WTF::WTFThreadData::WTFThreadData	.\WTFThreadData.h	/^    WTF_EXPORT_PRIVATE WTFThreadData();$/;"	p	class:WTF::WTFThreadData	access:public	signature:()
WTF::WTFThreadData::WTF_MAKE_NONCOPYABLE	.\WTFThreadData.h	/^    WTF_MAKE_NONCOPYABLE(WTFThreadData);$/;"	p	class:WTF::WTFThreadData	access:private	signature:(WTFThreadData)
WTF::WTFThreadData::atomicStringTable	.\WTFThreadData.h	/^    AtomicStringTable* atomicStringTable()$/;"	f	class:WTF::WTFThreadData	access:public	signature:()
WTF::WTFThreadData::currentIdentifierTable	.\WTFThreadData.h	/^    JSC::IdentifierTable* currentIdentifierTable()$/;"	f	class:WTF::WTFThreadData	access:public	signature:()
WTF::WTFThreadData::m_atomicStringTable	.\WTFThreadData.h	/^    AtomicStringTable* m_atomicStringTable;$/;"	m	class:WTF::WTFThreadData	access:private
WTF::WTFThreadData::m_atomicStringTableDestructor	.\WTFThreadData.h	/^    AtomicStringTableDestructor m_atomicStringTableDestructor;$/;"	m	class:WTF::WTFThreadData	access:private
WTF::WTFThreadData::m_currentIdentifierTable	.\WTFThreadData.h	/^    JSC::IdentifierTable* m_currentIdentifierTable;$/;"	m	class:WTF::WTFThreadData	access:private
WTF::WTFThreadData::m_defaultIdentifierTable	.\WTFThreadData.h	/^    JSC::IdentifierTable* m_defaultIdentifierTable;$/;"	m	class:WTF::WTFThreadData	access:private
WTF::WTFThreadData::m_stackBounds	.\WTFThreadData.h	/^    StackBounds m_stackBounds;$/;"	m	class:WTF::WTFThreadData	access:private
WTF::WTFThreadData::resetCurrentIdentifierTable	.\WTFThreadData.h	/^    void resetCurrentIdentifierTable()$/;"	f	class:WTF::WTFThreadData	access:public	signature:()
WTF::WTFThreadData::setCurrentIdentifierTable	.\WTFThreadData.h	/^    JSC::IdentifierTable* setCurrentIdentifierTable(JSC::IdentifierTable* identifierTable)$/;"	f	class:WTF::WTFThreadData	access:public	signature:(JSC::IdentifierTable* identifierTable)
WTF::WTFThreadData::stack	.\WTFThreadData.h	/^    const StackBounds& stack() const$/;"	f	class:WTF::WTFThreadData	access:public	signature:() const
WTF::WTFThreadData::staticData	.\WTFThreadData.cpp	/^ThreadSpecific<WTFThreadData>* WTFThreadData::staticData;$/;"	m	class:WTF::WTFThreadData	file:
WTF::WTFThreadData::staticData	.\WTFThreadData.h	/^    static WTF_EXPORTDATA ThreadSpecific<WTFThreadData>* staticData;$/;"	m	class:WTF::WTFThreadData	access:private
WTF::WTFThreadData::wtfThreadData	.\WTFThreadData.h	/^    friend WTFThreadData& wtfThreadData();$/;"	p	class:WTF::WTFThreadData	access:friend	signature:()
WTF::WTFThreadData::~WTFThreadData	.\WTFThreadData.cpp	/^WTFThreadData::~WTFThreadData()$/;"	f	class:WTF::WTFThreadData	signature:()
WTF::WTFThreadData::~WTFThreadData	.\WTFThreadData.h	/^    WTF_EXPORT_PRIVATE ~WTFThreadData();$/;"	p	class:WTF::WTFThreadData	access:public	signature:()
WTF::_GVariant	.\gobject\GRefPtr.cpp	/^typedef struct _GVariant {$/;"	s	namespace:WTF	file:
WTF::_GVariant::fake	.\gobject\GRefPtr.cpp	/^    bool fake;$/;"	m	struct:WTF::_GVariant	file:	access:public
WTF::__anon3::ARC4RandomNumberGenerator	.\CryptographicallyRandomNumber.cpp	/^class ARC4RandomNumberGenerator {$/;"	c	namespace:WTF::__anon3	file:
WTF::__anon3::ARC4RandomNumberGenerator::ARC4RandomNumberGenerator	.\CryptographicallyRandomNumber.cpp	/^    ARC4RandomNumberGenerator();$/;"	p	class:WTF::__anon3::ARC4RandomNumberGenerator	file:	access:public	signature:()
WTF::__anon3::ARC4RandomNumberGenerator::ARC4RandomNumberGenerator	.\CryptographicallyRandomNumber.cpp	/^ARC4RandomNumberGenerator::ARC4RandomNumberGenerator()$/;"	f	class:WTF::__anon3::ARC4RandomNumberGenerator	signature:()
WTF::__anon3::ARC4RandomNumberGenerator::addRandomData	.\CryptographicallyRandomNumber.cpp	/^    inline void addRandomData(unsigned char *data, int length);$/;"	p	class:WTF::__anon3::ARC4RandomNumberGenerator	file:	access:private	signature:(unsigned char *data, int length)
WTF::__anon3::ARC4RandomNumberGenerator::addRandomData	.\CryptographicallyRandomNumber.cpp	/^void ARC4RandomNumberGenerator::addRandomData(unsigned char* data, int length)$/;"	f	class:WTF::__anon3::ARC4RandomNumberGenerator	signature:(unsigned char* data, int length)
WTF::__anon3::ARC4RandomNumberGenerator::getByte	.\CryptographicallyRandomNumber.cpp	/^    inline uint8_t getByte();$/;"	p	class:WTF::__anon3::ARC4RandomNumberGenerator	file:	access:private	signature:()
WTF::__anon3::ARC4RandomNumberGenerator::getByte	.\CryptographicallyRandomNumber.cpp	/^uint8_t ARC4RandomNumberGenerator::getByte()$/;"	f	class:WTF::__anon3::ARC4RandomNumberGenerator	signature:()
WTF::__anon3::ARC4RandomNumberGenerator::getWord	.\CryptographicallyRandomNumber.cpp	/^    inline uint32_t getWord();$/;"	p	class:WTF::__anon3::ARC4RandomNumberGenerator	file:	access:private	signature:()
WTF::__anon3::ARC4RandomNumberGenerator::getWord	.\CryptographicallyRandomNumber.cpp	/^uint32_t ARC4RandomNumberGenerator::getWord()$/;"	f	class:WTF::__anon3::ARC4RandomNumberGenerator	signature:()
WTF::__anon3::ARC4RandomNumberGenerator::m_count	.\CryptographicallyRandomNumber.cpp	/^    int m_count;$/;"	m	class:WTF::__anon3::ARC4RandomNumberGenerator	file:	access:private
WTF::__anon3::ARC4RandomNumberGenerator::m_mutex	.\CryptographicallyRandomNumber.cpp	/^    Mutex m_mutex;$/;"	m	class:WTF::__anon3::ARC4RandomNumberGenerator	file:	access:private
WTF::__anon3::ARC4RandomNumberGenerator::m_stream	.\CryptographicallyRandomNumber.cpp	/^    ARC4Stream m_stream;$/;"	m	class:WTF::__anon3::ARC4RandomNumberGenerator	file:	access:private
WTF::__anon3::ARC4RandomNumberGenerator::randomNumber	.\CryptographicallyRandomNumber.cpp	/^    uint32_t randomNumber();$/;"	p	class:WTF::__anon3::ARC4RandomNumberGenerator	file:	access:public	signature:()
WTF::__anon3::ARC4RandomNumberGenerator::randomNumber	.\CryptographicallyRandomNumber.cpp	/^uint32_t ARC4RandomNumberGenerator::randomNumber()$/;"	f	class:WTF::__anon3::ARC4RandomNumberGenerator	signature:()
WTF::__anon3::ARC4RandomNumberGenerator::randomValues	.\CryptographicallyRandomNumber.cpp	/^    void randomValues(void* buffer, size_t length);$/;"	p	class:WTF::__anon3::ARC4RandomNumberGenerator	file:	access:public	signature:(void* buffer, size_t length)
WTF::__anon3::ARC4RandomNumberGenerator::randomValues	.\CryptographicallyRandomNumber.cpp	/^void ARC4RandomNumberGenerator::randomValues(void* buffer, size_t length)$/;"	f	class:WTF::__anon3::ARC4RandomNumberGenerator	signature:(void* buffer, size_t length)
WTF::__anon3::ARC4RandomNumberGenerator::stir	.\CryptographicallyRandomNumber.cpp	/^    void stir();$/;"	p	class:WTF::__anon3::ARC4RandomNumberGenerator	file:	access:private	signature:()
WTF::__anon3::ARC4RandomNumberGenerator::stir	.\CryptographicallyRandomNumber.cpp	/^void ARC4RandomNumberGenerator::stir()$/;"	f	class:WTF::__anon3::ARC4RandomNumberGenerator	signature:()
WTF::__anon3::ARC4RandomNumberGenerator::stirIfNeeded	.\CryptographicallyRandomNumber.cpp	/^    void stirIfNeeded();$/;"	p	class:WTF::__anon3::ARC4RandomNumberGenerator	file:	access:private	signature:()
WTF::__anon3::ARC4RandomNumberGenerator::stirIfNeeded	.\CryptographicallyRandomNumber.cpp	/^void ARC4RandomNumberGenerator::stirIfNeeded()$/;"	f	class:WTF::__anon3::ARC4RandomNumberGenerator	signature:()
WTF::__anon3::ARC4Stream	.\CryptographicallyRandomNumber.cpp	/^class ARC4Stream {$/;"	c	namespace:WTF::__anon3	file:
WTF::__anon3::ARC4Stream::ARC4Stream	.\CryptographicallyRandomNumber.cpp	/^    ARC4Stream();$/;"	p	class:WTF::__anon3::ARC4Stream	file:	access:public	signature:()
WTF::__anon3::ARC4Stream::ARC4Stream	.\CryptographicallyRandomNumber.cpp	/^ARC4Stream::ARC4Stream()$/;"	f	class:WTF::__anon3::ARC4Stream	signature:()
WTF::__anon3::ARC4Stream::i	.\CryptographicallyRandomNumber.cpp	/^    uint8_t i;$/;"	m	class:WTF::__anon3::ARC4Stream	file:	access:public
WTF::__anon3::ARC4Stream::j	.\CryptographicallyRandomNumber.cpp	/^    uint8_t j;$/;"	m	class:WTF::__anon3::ARC4Stream	file:	access:public
WTF::__anon3::ARC4Stream::s	.\CryptographicallyRandomNumber.cpp	/^    uint8_t s[256];$/;"	m	class:WTF::__anon3::ARC4Stream	file:	access:public
WTF::__anon3::sharedRandomNumberGenerator	.\CryptographicallyRandomNumber.cpp	/^ARC4RandomNumberGenerator& sharedRandomNumberGenerator()$/;"	f	namespace:WTF::__anon3	signature:()
WTF::__anon4::L	.\dtoa.cpp	/^    uint32_t L[2];$/;"	m	union:WTF::__anon4	file:	access:public
WTF::__anon4::d	.\dtoa.cpp	/^    double d;$/;"	m	union:WTF::__anon4	file:	access:public
WTF::__anon5::m_memory	.\FastMalloc.cpp	/^    void* m_memory;$/;"	m	union:WTF::__anon5	file:	access:public
WTF::__anon5::m_pageHeap	.\FastMalloc.cpp	/^    TCMalloc_PageHeap* m_pageHeap;$/;"	m	union:WTF::__anon5	file:	access:public
WTF::__anon6::LockInverter	.\FastMalloc.cpp	/^class LockInverter {$/;"	c	namespace:WTF::__anon6	file:
WTF::__anon6::LockInverter::LockInverter	.\FastMalloc.cpp	/^  inline explicit LockInverter(SpinLock* held, SpinLock *temp)$/;"	f	class:WTF::__anon6::LockInverter	access:public	signature:(SpinLock* held, SpinLock *temp)
WTF::__anon6::LockInverter::held_	.\FastMalloc.cpp	/^  SpinLock *held_, *temp_;$/;"	m	class:WTF::__anon6::LockInverter	file:	access:private
WTF::__anon6::LockInverter::temp_	.\FastMalloc.cpp	/^  SpinLock *held_, *temp_;$/;"	m	class:WTF::__anon6::LockInverter	file:	access:private
WTF::__anon6::LockInverter::~LockInverter	.\FastMalloc.cpp	/^  inline ~LockInverter() { temp_->Unlock(); held_->Lock();  }$/;"	f	class:WTF::__anon6::LockInverter	access:public	signature:()
WTF::__libc_calloc	.\FastMalloc.cpp	/^  void* __libc_calloc(size_t n, size_t size)    { return calloc(n, size);    }$/;"	f	signature:(size_t n, size_t size)
WTF::__libc_cfree	.\FastMalloc.cpp	/^  void  __libc_cfree(void* ptr)                 { cfree(ptr);                }$/;"	f	signature:(void* ptr)
WTF::__libc_free	.\FastMalloc.cpp	/^  void  __libc_free(void* ptr)                  { free(ptr);                 }$/;"	f	signature:(void* ptr)
WTF::__libc_malloc	.\FastMalloc.cpp	/^  void* __libc_malloc(size_t size)              { return malloc(size);       }$/;"	f	signature:(size_t size)
WTF::__libc_memalign	.\FastMalloc.cpp	/^  void* __libc_memalign(size_t align, size_t s) { return memalign(align, s); }$/;"	f	signature:(size_t align, size_t s)
WTF::__libc_pvalloc	.\FastMalloc.cpp	/^  void* __libc_pvalloc(size_t size)             { return pvalloc(size);      }$/;"	f	signature:(size_t size)
WTF::__libc_realloc	.\FastMalloc.cpp	/^  void* __libc_realloc(void* ptr, size_t size)  { return realloc(ptr, size); }$/;"	f	signature:(void* ptr, size_t size)
WTF::__libc_valloc	.\FastMalloc.cpp	/^  void* __libc_valloc(size_t size)              { return valloc(size);       }$/;"	f	signature:(size_t size)
WTF::__memalign_hook	.\FastMalloc.cpp	/^void *(*__memalign_hook)(size_t, size_t, const void *) = MemalignOverride;$/;"	v
WTF::__posix_memalign	.\FastMalloc.cpp	/^  int __posix_memalign(void** r, size_t a, size_t s) {$/;"	f	signature:(void** r, size_t a, size_t s)
WTF::absoluteTimeToWaitTimeoutInterval	.\ThreadingPrimitives.h	/^DWORD absoluteTimeToWaitTimeoutInterval(double absoluteTime);$/;"	p	namespace:WTF	signature:(double absoluteTime)
WTF::absoluteTimeToWaitTimeoutInterval	.\ThreadingWin.cpp	/^DWORD absoluteTimeToWaitTimeoutInterval(double absoluteTime)$/;"	f	namespace:WTF	signature:(double absoluteTime)
WTF::addIterator	.\HashTable.h	/^    inline void addIterator(const HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>*,$/;"	f	namespace:WTF	signature:(const HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>*, HashTableConstIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>*)
WTF::addIterator	.\HashTable.h	/^    void addIterator(const HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>* table,$/;"	f	namespace:WTF	signature:(const HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>* table, HashTableConstIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>* it)
WTF::addIterator	.\HashTable.h	/^    void addIterator(const HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>*,$/;"	p	namespace:WTF	signature:(const HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>*, HashTableConstIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>*)
WTF::addToStringTable	.\text\AtomicString.cpp	/^static inline PassRefPtr<StringImpl> addToStringTable(const T& value)$/;"	f	namespace:WTF	file:	signature:(const T& value)
WTF::add_amount	.\FastMalloc.cpp	/^static const int add_amount[2] = { 7, 127 + (120 << 7) };$/;"	v	file:
WTF::adoptArrayPtr	.\OwnArrayPtr.h	/^template<typename T> PassOwnArrayPtr<T> adoptArrayPtr(T*);$/;"	p	namespace:WTF	signature:(T*)
WTF::adoptArrayPtr	.\PassOwnArrayPtr.h	/^template<typename T> PassOwnArrayPtr<T> adoptArrayPtr(T*);$/;"	p	namespace:WTF	signature:(T*)
WTF::adoptArrayPtr	.\PassOwnArrayPtr.h	/^template<typename T> inline PassOwnArrayPtr<T> adoptArrayPtr(T* ptr)$/;"	f	namespace:WTF	signature:(T* ptr)
WTF::adoptCF	.\RetainPtr.h	/^    template<typename T> inline RetainPtr<T> adoptCF(T o)$/;"	f	namespace:WTF	signature:(T o)
WTF::adoptGRef	.\gobject\GRefPtr.h	/^template <typename T> GRefPtr<T> adoptGRef(T* p)$/;"	f	namespace:WTF	signature:(T* p)
WTF::adoptGRef	.\gobject\GRefPtr.h	/^template <typename T> GRefPtr<T> adoptGRef(T*);$/;"	p	namespace:WTF	signature:(T*)
WTF::adoptNS	.\RetainPtr.h	/^    template<typename T> inline RetainPtr<T> adoptNS(T o)$/;"	f	namespace:WTF	signature:(T o)
WTF::adoptNSReference	.\RetainPtr.h	/^    inline void adoptNSReference(id ptr)$/;"	f	namespace:WTF	signature:(id ptr)
WTF::adoptPtr	.\OwnPtr.h	/^    template<typename T> PassOwnPtr<T> adoptPtr(T*);$/;"	p	namespace:WTF	signature:(T*)
WTF::adoptPtr	.\PassOwnPtr.h	/^    template<typename T> PassOwnPtr<T> adoptPtr(T*);$/;"	p	namespace:WTF	signature:(T*)
WTF::adoptPtr	.\PassOwnPtr.h	/^    template<typename T> inline PassOwnPtr<T> adoptPtr(T* ptr)$/;"	f	namespace:WTF	signature:(T* ptr)
WTF::adoptRef	.\PassRefPtr.h	/^    template<typename T> PassRefPtr<T> adoptRef(T*);$/;"	p	namespace:WTF	signature:(T*)
WTF::adoptRef	.\PassRefPtr.h	/^    template<typename T> inline PassRefPtr<T> adoptRef(T* p)$/;"	f	namespace:WTF	signature:(T* p)
WTF::adopted	.\PassRefPtr.h	/^    inline void adopted(const void*) { }$/;"	f	namespace:WTF	signature:(const void*)
WTF::adopted	.\RefCounted.h	/^inline void adopted(RefCountedBase* object)$/;"	f	namespace:WTF	signature:(RefCountedBase* object)
WTF::alignToMachineWord	.\text\ASCIIFastPath.h	/^template<typename T> inline T* alignToMachineWord(T* pointer)$/;"	f	namespace:WTF	signature:(T* pointer)
WTF::append	.\text\WTFString.h	/^inline void append(Vector<UChar>& vector, const String& string)$/;"	f	namespace:WTF	signature:(Vector<UChar>& vector, const String& string)
WTF::appendByteAsHex	.\HexNumber.h	/^inline void appendByteAsHex(unsigned char byte, T& destination, HexConversionMode mode = Uppercase)$/;"	f	namespace:WTF	signature:(unsigned char byte, T& destination, HexConversionMode mode = Uppercase)
WTF::appendNumber	.\text\WTFString.h	/^inline void appendNumber(Vector<UChar>& vector, unsigned char number)$/;"	f	namespace:WTF	signature:(Vector<UChar>& vector, unsigned char number)
WTF::appendURLEscapedCharacter	.\url\src\URLEscape.h	/^inline void appendURLEscapedCharacter(InChar ch, URLBuffer<OutChar>& buffer)$/;"	f	namespace:WTF	signature:(InChar ch, URLBuffer<OutChar>& buffer)
WTF::appendUnsignedAsHex	.\HexNumber.h	/^inline void appendUnsignedAsHex(unsigned number, T& destination, HexConversionMode mode = Uppercase)$/;"	f	namespace:WTF	signature:(unsigned number, T& destination, HexConversionMode mode = Uppercase)
WTF::appendUnsignedAsHexFixedSize	.\HexNumber.h	/^inline void appendUnsignedAsHexFixedSize(unsigned number, T& destination, unsigned desiredDigits, HexConversionMode mode = Uppercase)$/;"	f	namespace:WTF	signature:(unsigned number, T& destination, unsigned desiredDigits, HexConversionMode mode = Uppercase)
WTF::atomicDecrement	.\Atomics.h	/^inline int atomicDecrement(int* addend) { return InterlockedDecrement(reinterpret_cast<long*>(addend)); }$/;"	f	namespace:WTF	signature:(int* addend)
WTF::atomicIncrement	.\Atomics.h	/^inline int atomicIncrement(int* addend) { return InterlockedIncrement(reinterpret_cast<long*>(addend)); }$/;"	f	namespace:WTF	signature:(int* addend)
WTF::atomicallyInitializedStaticMutex	.\ThreadingPthreads.cpp	/^static Mutex* atomicallyInitializedStaticMutex;$/;"	v	file:
WTF::atomicallyInitializedStaticMutex	.\ThreadingWin.cpp	/^static Mutex* atomicallyInitializedStaticMutex;$/;"	v	file:
WTF::bigtens	.\dtoa.cpp	/^static const double bigtens[] = { 1e16, 1e32, 1e64, 1e128, 1e256 };$/;"	v	file:
WTF::binarySearch	.\StdLibExtras.h	/^inline ArrayElementType* binarySearch(ArrayElementType* array, size_t size, KeyType key, BinarySearchMode mode = KeyMustBePresentInArray)$/;"	f	namespace:WTF	signature:(ArrayElementType* array, size_t size, KeyType key, BinarySearchMode mode = KeyMustBePresentInArray)
WTF::binarySearchWithFunctor	.\StdLibExtras.h	/^inline ArrayElementType* binarySearchWithFunctor(ArrayElementType* array, size_t size, KeyType key, BinarySearchMode mode = KeyMustBePresentInArray, const ExtractKey& extractKey = ExtractKey())$/;"	f	namespace:WTF	signature:(ArrayElementType* array, size_t size, KeyType key, BinarySearchMode mode = KeyMustBePresentInArray, const ExtractKey& extractKey = ExtractKey())
WTF::bind	.\Functional.h	/^Function<typename FunctionWrapper<FunctionType>::ResultType ()> bind(FunctionType function)$/;"	f	namespace:WTF	signature:(FunctionType function)
WTF::bind	.\Functional.h	/^Function<typename FunctionWrapper<FunctionType>::ResultType ()> bind(FunctionType function, const A1& a1)$/;"	f	namespace:WTF	signature:(FunctionType function, const A1& a1)
WTF::bind	.\Functional.h	/^Function<typename FunctionWrapper<FunctionType>::ResultType ()> bind(FunctionType function, const A1& a1, const A2& a2)$/;"	f	namespace:WTF	signature:(FunctionType function, const A1& a1, const A2& a2)
WTF::bind	.\Functional.h	/^Function<typename FunctionWrapper<FunctionType>::ResultType ()> bind(FunctionType function, const A1& a1, const A2& a2, const A3& a3)$/;"	f	namespace:WTF	signature:(FunctionType function, const A1& a1, const A2& a2, const A3& a3)
WTF::bind	.\Functional.h	/^Function<typename FunctionWrapper<FunctionType>::ResultType ()> bind(FunctionType function, const A1& a1, const A2& a2, const A3& a3, const A4& a4)$/;"	f	namespace:WTF	signature:(FunctionType function, const A1& a1, const A2& a2, const A3& a3, const A4& a4)
WTF::bind	.\Functional.h	/^Function<typename FunctionWrapper<FunctionType>::ResultType ()> bind(FunctionType function, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5)$/;"	f	namespace:WTF	signature:(FunctionType function, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5)
WTF::bind	.\Functional.h	/^Function<typename FunctionWrapper<FunctionType>::ResultType ()> bind(FunctionType function, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6)$/;"	f	namespace:WTF	signature:(FunctionType function, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6)
WTF::bitCount	.\StdLibExtras.h	/^inline size_t bitCount(unsigned bits)$/;"	f	namespace:WTF	signature:(unsigned bits)
WTF::bitwise_cast	.\StdLibExtras.h	/^inline TO bitwise_cast(FROM from)$/;"	f	namespace:WTF	signature:(FROM from)
WTF::cachedCollator	.\unicode\icu\CollatorICU.cpp	/^static UCollator* cachedCollator;$/;"	v	file:
WTF::cachedCollatorMutex	.\unicode\icu\CollatorICU.cpp	/^static Mutex& cachedCollatorMutex()$/;"	f	namespace:WTF	file:	signature:()
WTF::calculateDSTOffset	.\DateMath.cpp	/^double calculateDSTOffset(double ms, double utcOffset)$/;"	f	namespace:WTF	signature:(double ms, double utcOffset)
WTF::calculateDSTOffset	.\DateMath.h	/^WTF_EXPORT_PRIVATE double calculateDSTOffset(double ms, double utcOffset);$/;"	p	namespace:WTF	signature:(double ms, double utcOffset)
WTF::calculateDSTOffsetSimple	.\DateMath.cpp	/^static double calculateDSTOffsetSimple(double localTimeSeconds, double utcOffset)$/;"	f	namespace:WTF	file:	signature:(double localTimeSeconds, double utcOffset)
WTF::calculateUTCOffset	.\DateMath.cpp	/^int32_t calculateUTCOffset()$/;"	f	namespace:WTF	signature:()
WTF::calculateUTCOffset	.\DateMath.h	/^WTF_EXPORT_PRIVATE int32_t calculateUTCOffset();$/;"	p	namespace:WTF	signature:()
WTF::callFunctionObject	.\MainThread.cpp	/^static void callFunctionObject(void* context)$/;"	f	namespace:WTF	file:	signature:(void* context)
WTF::callOnMainThread	.\MainThread.cpp	/^void callOnMainThread(MainThreadFunction* function, void* context)$/;"	f	namespace:WTF	signature:(MainThreadFunction* function, void* context)
WTF::callOnMainThread	.\MainThread.cpp	/^void callOnMainThread(const Function<void ()>& function)$/;"	f	namespace:WTF	signature:(const Function<void ()>& function)
WTF::callOnMainThread	.\MainThread.h	/^WTF_EXPORT_PRIVATE void callOnMainThread(MainThreadFunction*, void* context);$/;"	p	namespace:WTF	signature:(MainThreadFunction*, void* context)
WTF::callOnMainThread	.\MainThread.h	/^WTF_EXPORT_PRIVATE void callOnMainThread(const Function<void ()>&);$/;"	p	namespace:WTF	signature:(const Function<void ()>&)
WTF::callOnMainThread	.\chromium\MainThreadChromium.cpp	/^void callOnMainThread(MainThreadFunction* function, void* context)$/;"	f	namespace:WTF	signature:(MainThreadFunction* function, void* context)
WTF::callOnMainThreadAndWait	.\MainThread.cpp	/^void callOnMainThreadAndWait(MainThreadFunction* function, void* context)$/;"	f	namespace:WTF	signature:(MainThreadFunction* function, void* context)
WTF::callOnMainThreadAndWait	.\MainThread.h	/^WTF_EXPORT_PRIVATE void callOnMainThreadAndWait(MainThreadFunction*, void* context);$/;"	p	namespace:WTF	signature:(MainThreadFunction*, void* context)
WTF::callOnMainThreadAndWait	.\chromium\MainThreadChromium.cpp	/^void callOnMainThreadAndWait(MainThreadFunction*, void*)$/;"	f	namespace:WTF	signature:(MainThreadFunction*, void*)
WTF::callbacksPaused	.\MainThread.cpp	/^static bool callbacksPaused; \/\/ This global variable is only accessed from main thread.$/;"	v	file:
WTF::calloc	.\FastMalloc.cpp	/^ALWAYS_INLINE void* calloc(size_t, size_t);$/;"	p	namespace:WTF	file:	signature:(size_t, size_t)
WTF::calloc	.\FastMalloc.cpp	/^void* calloc(size_t n, size_t elem_size) {$/;"	f	namespace:WTF	signature:(size_t n, size_t elem_size)
WTF::cancelCallOnMainThread	.\MainThread.cpp	/^void cancelCallOnMainThread(MainThreadFunction* function, void* context)$/;"	f	namespace:WTF	signature:(MainThreadFunction* function, void* context)
WTF::cancelCallOnMainThread	.\MainThread.h	/^WTF_EXPORT_PRIVATE void cancelCallOnMainThread(MainThreadFunction*, void* context);$/;"	p	namespace:WTF	signature:(MainThreadFunction*, void* context)
WTF::central_cache	.\FastMalloc.cpp	/^static TCMalloc_Central_FreeListPadded central_cache[kNumClasses];$/;"	v	file:
WTF::cfree	.\FastMalloc.cpp	/^void cfree(void* ptr) {$/;"	f	namespace:WTF	signature:(void* ptr)
WTF::charactersAreAllASCII	.\text\ASCIIFastPath.h	/^inline bool charactersAreAllASCII(const CharacterType* characters, size_t length)$/;"	f	namespace:WTF	signature:(const CharacterType* characters, size_t length)
WTF::charactersToDouble	.\text\WTFString.cpp	/^double charactersToDouble(const LChar* data, size_t length, bool* ok, bool* didReadNumber)$/;"	f	namespace:WTF	signature:(const LChar* data, size_t length, bool* ok, bool* didReadNumber)
WTF::charactersToDouble	.\text\WTFString.cpp	/^double charactersToDouble(const UChar* data, size_t length, bool* ok, bool* didReadNumber)$/;"	f	namespace:WTF	signature:(const UChar* data, size_t length, bool* ok, bool* didReadNumber)
WTF::charactersToDouble	.\text\WTFString.h	/^WTF_EXPORT_PRIVATE double charactersToDouble(const LChar*, size_t, bool* ok = 0, bool* didReadNumber = 0);$/;"	p	namespace:WTF	signature:(const LChar*, size_t, bool* ok = 0, bool* didReadNumber = 0)
WTF::charactersToDouble	.\text\WTFString.h	/^WTF_EXPORT_PRIVATE double charactersToDouble(const UChar*, size_t, bool* ok = 0, bool* didReadNumber = 0);$/;"	p	namespace:WTF	signature:(const UChar*, size_t, bool* ok = 0, bool* didReadNumber = 0)
WTF::charactersToFloat	.\text\WTFString.cpp	/^float charactersToFloat(const LChar* data, size_t length, bool* ok, bool* didReadNumber)$/;"	f	namespace:WTF	signature:(const LChar* data, size_t length, bool* ok, bool* didReadNumber)
WTF::charactersToFloat	.\text\WTFString.cpp	/^float charactersToFloat(const UChar* data, size_t length, bool* ok, bool* didReadNumber)$/;"	f	namespace:WTF	signature:(const UChar* data, size_t length, bool* ok, bool* didReadNumber)
WTF::charactersToFloat	.\text\WTFString.h	/^WTF_EXPORT_PRIVATE float charactersToFloat(const UChar*, size_t, bool* ok = 0, bool* didReadNumber = 0);$/;"	p	namespace:WTF	signature:(const UChar*, size_t, bool* ok = 0, bool* didReadNumber = 0)
WTF::charactersToFloat	.\text\WTFString.h	/^float charactersToFloat(const LChar*, size_t, bool* ok = 0, bool* didReadNumber = 0);$/;"	p	namespace:WTF	signature:(const LChar*, size_t, bool* ok = 0, bool* didReadNumber = 0)
WTF::charactersToFloatIgnoringJunk	.\text\WTFString.cpp	/^float charactersToFloatIgnoringJunk(const LChar* data, size_t length, bool* ok, bool* didReadNumber)$/;"	f	namespace:WTF	signature:(const LChar* data, size_t length, bool* ok, bool* didReadNumber)
WTF::charactersToFloatIgnoringJunk	.\text\WTFString.cpp	/^float charactersToFloatIgnoringJunk(const UChar* data, size_t length, bool* ok, bool* didReadNumber)$/;"	f	namespace:WTF	signature:(const UChar* data, size_t length, bool* ok, bool* didReadNumber)
WTF::charactersToFloatIgnoringJunk	.\text\WTFString.h	/^WTF_EXPORT_PRIVATE float charactersToFloatIgnoringJunk(const LChar*, size_t, bool* ok = 0, bool* didReadNumber = 0);$/;"	p	namespace:WTF	signature:(const LChar*, size_t, bool* ok = 0, bool* didReadNumber = 0)
WTF::charactersToFloatIgnoringJunk	.\text\WTFString.h	/^WTF_EXPORT_PRIVATE float charactersToFloatIgnoringJunk(const UChar*, size_t, bool* ok = 0, bool* didReadNumber = 0);$/;"	p	namespace:WTF	signature:(const UChar*, size_t, bool* ok = 0, bool* didReadNumber = 0)
WTF::charactersToInt	.\text\WTFString.cpp	/^int charactersToInt(const LChar* data, size_t length, bool* ok)$/;"	f	namespace:WTF	signature:(const LChar* data, size_t length, bool* ok)
WTF::charactersToInt	.\text\WTFString.cpp	/^int charactersToInt(const UChar* data, size_t length, bool* ok)$/;"	f	namespace:WTF	signature:(const UChar* data, size_t length, bool* ok)
WTF::charactersToInt	.\text\WTFString.h	/^WTF_EXPORT_PRIVATE int charactersToInt(const UChar*, size_t, bool* ok = 0); \/\/ ignores trailing garbage$/;"	p	namespace:WTF	signature:(const UChar*, size_t, bool* ok = 0)
WTF::charactersToInt	.\text\WTFString.h	/^int charactersToInt(const LChar*, size_t, bool* ok = 0); \/\/ ignores trailing garbage$/;"	p	namespace:WTF	signature:(const LChar*, size_t, bool* ok = 0)
WTF::charactersToInt64	.\text\WTFString.cpp	/^int64_t charactersToInt64(const LChar* data, size_t length, bool* ok)$/;"	f	namespace:WTF	signature:(const LChar* data, size_t length, bool* ok)
WTF::charactersToInt64	.\text\WTFString.cpp	/^int64_t charactersToInt64(const UChar* data, size_t length, bool* ok)$/;"	f	namespace:WTF	signature:(const UChar* data, size_t length, bool* ok)
WTF::charactersToInt64	.\text\WTFString.h	/^int64_t charactersToInt64(const LChar*, size_t, bool* ok = 0); \/\/ ignores trailing garbage$/;"	p	namespace:WTF	signature:(const LChar*, size_t, bool* ok = 0)
WTF::charactersToInt64	.\text\WTFString.h	/^int64_t charactersToInt64(const UChar*, size_t, bool* ok = 0); \/\/ ignores trailing garbage$/;"	p	namespace:WTF	signature:(const UChar*, size_t, bool* ok = 0)
WTF::charactersToInt64Strict	.\text\WTFString.cpp	/^int64_t charactersToInt64Strict(const LChar* data, size_t length, bool* ok, int base)$/;"	f	namespace:WTF	signature:(const LChar* data, size_t length, bool* ok, int base)
WTF::charactersToInt64Strict	.\text\WTFString.cpp	/^int64_t charactersToInt64Strict(const UChar* data, size_t length, bool* ok, int base)$/;"	f	namespace:WTF	signature:(const UChar* data, size_t length, bool* ok, int base)
WTF::charactersToInt64Strict	.\text\WTFString.h	/^int64_t charactersToInt64Strict(const LChar*, size_t, bool* ok = 0, int base = 10);$/;"	p	namespace:WTF	signature:(const LChar*, size_t, bool* ok = 0, int base = 10)
WTF::charactersToInt64Strict	.\text\WTFString.h	/^int64_t charactersToInt64Strict(const UChar*, size_t, bool* ok = 0, int base = 10);$/;"	p	namespace:WTF	signature:(const UChar*, size_t, bool* ok = 0, int base = 10)
WTF::charactersToIntPtr	.\text\WTFString.cpp	/^intptr_t charactersToIntPtr(const LChar* data, size_t length, bool* ok)$/;"	f	namespace:WTF	signature:(const LChar* data, size_t length, bool* ok)
WTF::charactersToIntPtr	.\text\WTFString.cpp	/^intptr_t charactersToIntPtr(const UChar* data, size_t length, bool* ok)$/;"	f	namespace:WTF	signature:(const UChar* data, size_t length, bool* ok)
WTF::charactersToIntPtr	.\text\WTFString.h	/^intptr_t charactersToIntPtr(const LChar*, size_t, bool* ok = 0); \/\/ ignores trailing garbage$/;"	p	namespace:WTF	signature:(const LChar*, size_t, bool* ok = 0)
WTF::charactersToIntPtr	.\text\WTFString.h	/^intptr_t charactersToIntPtr(const UChar*, size_t, bool* ok = 0); \/\/ ignores trailing garbage$/;"	p	namespace:WTF	signature:(const UChar*, size_t, bool* ok = 0)
WTF::charactersToIntPtrStrict	.\text\WTFString.cpp	/^intptr_t charactersToIntPtrStrict(const LChar* data, size_t length, bool* ok, int base)$/;"	f	namespace:WTF	signature:(const LChar* data, size_t length, bool* ok, int base)
WTF::charactersToIntPtrStrict	.\text\WTFString.cpp	/^intptr_t charactersToIntPtrStrict(const UChar* data, size_t length, bool* ok, int base)$/;"	f	namespace:WTF	signature:(const UChar* data, size_t length, bool* ok, int base)
WTF::charactersToIntPtrStrict	.\text\WTFString.h	/^intptr_t charactersToIntPtrStrict(const LChar*, size_t, bool* ok = 0, int base = 10);$/;"	p	namespace:WTF	signature:(const LChar*, size_t, bool* ok = 0, int base = 10)
WTF::charactersToIntPtrStrict	.\text\WTFString.h	/^intptr_t charactersToIntPtrStrict(const UChar*, size_t, bool* ok = 0, int base = 10);$/;"	p	namespace:WTF	signature:(const UChar*, size_t, bool* ok = 0, int base = 10)
WTF::charactersToIntStrict	.\text\WTFString.cpp	/^int charactersToIntStrict(const LChar* data, size_t length, bool* ok, int base)$/;"	f	namespace:WTF	signature:(const LChar* data, size_t length, bool* ok, int base)
WTF::charactersToIntStrict	.\text\WTFString.cpp	/^int charactersToIntStrict(const UChar* data, size_t length, bool* ok, int base)$/;"	f	namespace:WTF	signature:(const UChar* data, size_t length, bool* ok, int base)
WTF::charactersToIntStrict	.\text\WTFString.h	/^WTF_EXPORT_PRIVATE int charactersToIntStrict(const UChar*, size_t, bool* ok = 0, int base = 10);$/;"	p	namespace:WTF	signature:(const UChar*, size_t, bool* ok = 0, int base = 10)
WTF::charactersToIntStrict	.\text\WTFString.h	/^int charactersToIntStrict(const LChar*, size_t, bool* ok = 0, int base = 10);$/;"	p	namespace:WTF	signature:(const LChar*, size_t, bool* ok = 0, int base = 10)
WTF::charactersToUInt	.\text\WTFString.cpp	/^unsigned charactersToUInt(const LChar* data, size_t length, bool* ok)$/;"	f	namespace:WTF	signature:(const LChar* data, size_t length, bool* ok)
WTF::charactersToUInt	.\text\WTFString.cpp	/^unsigned charactersToUInt(const UChar* data, size_t length, bool* ok)$/;"	f	namespace:WTF	signature:(const UChar* data, size_t length, bool* ok)
WTF::charactersToUInt	.\text\WTFString.h	/^unsigned charactersToUInt(const LChar*, size_t, bool* ok = 0); \/\/ ignores trailing garbage$/;"	p	namespace:WTF	signature:(const LChar*, size_t, bool* ok = 0)
WTF::charactersToUInt	.\text\WTFString.h	/^unsigned charactersToUInt(const UChar*, size_t, bool* ok = 0); \/\/ ignores trailing garbage$/;"	p	namespace:WTF	signature:(const UChar*, size_t, bool* ok = 0)
WTF::charactersToUInt64	.\text\WTFString.cpp	/^uint64_t charactersToUInt64(const LChar* data, size_t length, bool* ok)$/;"	f	namespace:WTF	signature:(const LChar* data, size_t length, bool* ok)
WTF::charactersToUInt64	.\text\WTFString.cpp	/^uint64_t charactersToUInt64(const UChar* data, size_t length, bool* ok)$/;"	f	namespace:WTF	signature:(const UChar* data, size_t length, bool* ok)
WTF::charactersToUInt64	.\text\WTFString.h	/^uint64_t charactersToUInt64(const LChar*, size_t, bool* ok = 0); \/\/ ignores trailing garbage$/;"	p	namespace:WTF	signature:(const LChar*, size_t, bool* ok = 0)
WTF::charactersToUInt64	.\text\WTFString.h	/^uint64_t charactersToUInt64(const UChar*, size_t, bool* ok = 0); \/\/ ignores trailing garbage$/;"	p	namespace:WTF	signature:(const UChar*, size_t, bool* ok = 0)
WTF::charactersToUInt64Strict	.\text\WTFString.cpp	/^uint64_t charactersToUInt64Strict(const LChar* data, size_t length, bool* ok, int base)$/;"	f	namespace:WTF	signature:(const LChar* data, size_t length, bool* ok, int base)
WTF::charactersToUInt64Strict	.\text\WTFString.cpp	/^uint64_t charactersToUInt64Strict(const UChar* data, size_t length, bool* ok, int base)$/;"	f	namespace:WTF	signature:(const UChar* data, size_t length, bool* ok, int base)
WTF::charactersToUInt64Strict	.\text\WTFString.h	/^uint64_t charactersToUInt64Strict(const LChar*, size_t, bool* ok = 0, int base = 10);$/;"	p	namespace:WTF	signature:(const LChar*, size_t, bool* ok = 0, int base = 10)
WTF::charactersToUInt64Strict	.\text\WTFString.h	/^uint64_t charactersToUInt64Strict(const UChar*, size_t, bool* ok = 0, int base = 10);$/;"	p	namespace:WTF	signature:(const UChar*, size_t, bool* ok = 0, int base = 10)
WTF::charactersToUIntStrict	.\text\WTFString.cpp	/^unsigned charactersToUIntStrict(const LChar* data, size_t length, bool* ok, int base)$/;"	f	namespace:WTF	signature:(const LChar* data, size_t length, bool* ok, int base)
WTF::charactersToUIntStrict	.\text\WTFString.cpp	/^unsigned charactersToUIntStrict(const UChar* data, size_t length, bool* ok, int base)$/;"	f	namespace:WTF	signature:(const UChar* data, size_t length, bool* ok, int base)
WTF::charactersToUIntStrict	.\text\WTFString.h	/^WTF_EXPORT_PRIVATE unsigned charactersToUIntStrict(const UChar*, size_t, bool* ok = 0, int base = 10);$/;"	p	namespace:WTF	signature:(const UChar*, size_t, bool* ok = 0, int base = 10)
WTF::charactersToUIntStrict	.\text\WTFString.h	/^unsigned charactersToUIntStrict(const LChar*, size_t, bool* ok = 0, int base = 10);$/;"	p	namespace:WTF	signature:(const LChar*, size_t, bool* ok = 0, int base = 10)
WTF::checkMonth	.\DateMath.cpp	/^static inline bool checkMonth(int dayInYear, int& startDayOfThisMonth, int& startDayOfNextMonth, int daysInThisMonth)$/;"	f	namespace:WTF	file:	signature:(int dayInYear, int& startDayOfThisMonth, int& startDayOfNextMonth, int daysInThisMonth)
WTF::class_array	.\FastMalloc.cpp	/^static unsigned char class_array[377];$/;"	v	file:
WTF::class_to_pages	.\FastMalloc.cpp	/^static size_t class_to_pages[kNumClasses];$/;"	v	file:
WTF::class_to_size	.\FastMalloc.cpp	/^static size_t class_to_size[kNumClasses];$/;"	v	file:
WTF::clearPthreadHandleForIdentifier	.\ThreadIdentifierDataPthreads.cpp	/^void clearPthreadHandleForIdentifier(ThreadIdentifier);$/;"	p	namespace:WTF	file:	signature:(ThreadIdentifier)
WTF::clearPthreadHandleForIdentifier	.\ThreadingPthreads.cpp	/^void clearPthreadHandleForIdentifier(ThreadIdentifier id)$/;"	f	namespace:WTF	signature:(ThreadIdentifier id)
WTF::clearPthreadHandleForIdentifier	.\ThreadingPthreads.cpp	/^void clearPthreadHandleForIdentifier(ThreadIdentifier);$/;"	p	namespace:WTF	file:	signature:(ThreadIdentifier)
WTF::clearThreadHandleForIdentifier	.\ThreadingWin.cpp	/^static void clearThreadHandleForIdentifier(ThreadIdentifier id)$/;"	f	namespace:WTF	file:	signature:(ThreadIdentifier id)
WTF::cmp	.\dtoa.cpp	/^static int cmp(const BigInt& a, const BigInt& b)$/;"	f	namespace:WTF	file:	signature:(const BigInt& a, const BigInt& b)
WTF::codePointCompare	.\text\StringImpl.h	/^static inline int codePointCompare(const StringImpl* string1, const StringImpl* string2)$/;"	f	namespace:WTF	signature:(const StringImpl* string1, const StringImpl* string2)
WTF::codePointCompare	.\text\StringImpl.h	/^static inline int codePointCompare(unsigned l1, unsigned l2, const CharacterType1* c1, const CharacterType2* c2)$/;"	f	namespace:WTF	signature:(unsigned l1, unsigned l2, const CharacterType1* c1, const CharacterType2* c2)
WTF::codePointCompare	.\text\WTFString.cpp	/^int codePointCompare(const String& a, const String& b)$/;"	f	namespace:WTF	signature:(const String& a, const String& b)
WTF::codePointCompare	.\text\WTFString.h	/^WTF_EXPORT_PRIVATE int codePointCompare(const String&, const String&);$/;"	p	namespace:WTF	signature:(const String&, const String&)
WTF::codePointCompare16	.\text\StringImpl.h	/^static inline int codePointCompare16(const StringImpl* string1, const StringImpl* string2)$/;"	f	namespace:WTF	signature:(const StringImpl* string1, const StringImpl* string2)
WTF::codePointCompare8	.\text\StringImpl.h	/^static inline int codePointCompare8(const StringImpl* string1, const StringImpl* string2)$/;"	f	namespace:WTF	signature:(const StringImpl* string1, const StringImpl* string2)
WTF::codePointCompare8To16	.\text\StringImpl.h	/^static inline int codePointCompare8To16(const StringImpl* string1, const StringImpl* string2)$/;"	f	namespace:WTF	signature:(const StringImpl* string1, const StringImpl* string2)
WTF::codePointCompareLessThan	.\text\WTFString.h	/^inline bool codePointCompareLessThan(const String& a, const String& b)$/;"	f	namespace:WTF	signature:(const String& a, const String& b)
WTF::compatEntryPoint	.\Threading.cpp	/^static void compatEntryPoint(void* param)$/;"	f	namespace:WTF	file:	signature:(void* param)
WTF::complexFromMagnitudePhase	.\Complex.h	/^inline Complex complexFromMagnitudePhase(double magnitude, double phase)$/;"	f	namespace:WTF	signature:(double magnitude, double phase)
WTF::const_pointer_cast	.\PassOwnArrayPtr.h	/^template<typename T, typename U> inline PassOwnArrayPtr<T> const_pointer_cast(const PassOwnArrayPtr<U>& p) $/;"	f	namespace:WTF	signature:(const PassOwnArrayPtr<U>& p)
WTF::const_pointer_cast	.\PassOwnPtr.h	/^    template<typename T, typename U> inline PassOwnPtr<T> const_pointer_cast(const PassOwnPtr<U>& p) $/;"	f	namespace:WTF	signature:(const PassOwnPtr<U>& p)
WTF::const_pointer_cast	.\PassRefPtr.h	/^    template<typename T, typename U> inline PassRefPtr<T> const_pointer_cast(const PassRefPtr<U>& p) $/;"	f	namespace:WTF	signature:(const PassRefPtr<U>& p)
WTF::const_pointer_cast	.\RefPtr.h	/^    template<typename T, typename U> inline RefPtr<T> const_pointer_cast(const RefPtr<U>& p)$/;"	f	namespace:WTF	signature:(const RefPtr<U>& p)
WTF::const_pointer_cast	.\gobject\GRefPtr.h	/^template <typename T, typename U> inline GRefPtr<T> const_pointer_cast(const GRefPtr<U>& p)$/;"	f	namespace:WTF	signature:(const GRefPtr<U>& p)
WTF::copyKeysToVector	.\HashMap.h	/^    inline void copyKeysToVector(const HashMap<T, U, V, W, X>& collection, Y& vector)$/;"	f	namespace:WTF	signature:(const HashMap<T, U, V, W, X>& collection, Y& vector)
WTF::copyToVector	.\HashCountedSet.h	/^    inline void copyToVector(const HashCountedSet<Value, HashFunctions, Traits>& collection, Vector<Value>& vector)$/;"	f	namespace:WTF	signature:(const HashCountedSet<Value, HashFunctions, Traits>& collection, Vector<Value>& vector)
WTF::copyToVector	.\HashCountedSet.h	/^    inline void copyToVector(const HashCountedSet<Value, HashFunctions, Traits>& collection, VectorType& vector)$/;"	f	namespace:WTF	signature:(const HashCountedSet<Value, HashFunctions, Traits>& collection, VectorType& vector)
WTF::copyToVector	.\HashSet.h	/^    inline void copyToVector(const HashSet<T, U, V>& collection, W& vector)$/;"	f	namespace:WTF	signature:(const HashSet<T, U, V>& collection, W& vector)
WTF::copyValuesToVector	.\HashMap.h	/^    inline void copyValuesToVector(const HashMap<T, U, V, W, X>& collection, Y& vector)$/;"	f	namespace:WTF	signature:(const HashMap<T, U, V, W, X>& collection, Y& vector)
WTF::cpp_alloc	.\FastMalloc.cpp	/^static inline void* cpp_alloc(size_t size, bool nothrow) {$/;"	f	namespace:WTF	file:	signature:(size_t size, bool nothrow)
WTF::createThread	.\Threading.cpp	/^ThreadIdentifier createThread(ThreadFunction entryPoint, void* data, const char* name)$/;"	f	namespace:WTF	signature:(ThreadFunction entryPoint, void* data, const char* name)
WTF::createThread	.\Threading.cpp	/^ThreadIdentifier createThread(ThreadFunctionWithReturnValue entryPoint, void* data)$/;"	f	namespace:WTF	signature:(ThreadFunctionWithReturnValue entryPoint, void* data)
WTF::createThread	.\Threading.cpp	/^ThreadIdentifier createThread(ThreadFunctionWithReturnValue entryPoint, void* data, const char* name)$/;"	f	namespace:WTF	signature:(ThreadFunctionWithReturnValue entryPoint, void* data, const char* name)
WTF::createThread	.\Threading.cpp	/^WTF_EXPORT_PRIVATE ThreadIdentifier createThread(ThreadFunctionWithReturnValue entryPoint, void* data);$/;"	p	namespace:WTF	file:	signature:(ThreadFunctionWithReturnValue entryPoint, void* data)
WTF::createThread	.\Threading.cpp	/^WTF_EXPORT_PRIVATE ThreadIdentifier createThread(ThreadFunctionWithReturnValue entryPoint, void* data, const char* name);$/;"	p	namespace:WTF	file:	signature:(ThreadFunctionWithReturnValue entryPoint, void* data, const char* name)
WTF::createThread	.\Threading.h	/^WTF_EXPORT_PRIVATE ThreadIdentifier createThread(ThreadFunction, void*, const char* threadName);$/;"	p	namespace:WTF	signature:(ThreadFunction, void*, const char* threadName)
WTF::createThreadInternal	.\Threading.h	/^ThreadIdentifier createThreadInternal(ThreadFunction, void*, const char* threadName);$/;"	p	namespace:WTF	signature:(ThreadFunction, void*, const char* threadName)
WTF::createThreadInternal	.\ThreadingPthreads.cpp	/^ThreadIdentifier createThreadInternal(ThreadFunction entryPoint, void* data, const char* threadName)$/;"	f	namespace:WTF	signature:(ThreadFunction entryPoint, void* data, const char* threadName)
WTF::createThreadInternal	.\ThreadingPthreads.cpp	/^ThreadIdentifier createThreadInternal(ThreadFunction entryPoint, void* data, const char*)$/;"	f	namespace:WTF	signature:(ThreadFunction entryPoint, void* data, const char*)
WTF::createThreadInternal	.\ThreadingWin.cpp	/^ThreadIdentifier createThreadInternal(ThreadFunction entryPoint, void* data, const char* threadName)$/;"	f	namespace:WTF	signature:(ThreadFunction entryPoint, void* data, const char* threadName)
WTF::cryptographicallyRandomNumber	.\CryptographicallyRandomNumber.cpp	/^uint32_t cryptographicallyRandomNumber()$/;"	f	namespace:WTF	signature:()
WTF::cryptographicallyRandomNumber	.\CryptographicallyRandomNumber.h	/^WTF_EXPORT_PRIVATE uint32_t cryptographicallyRandomNumber();$/;"	p	namespace:WTF	signature:()
WTF::cryptographicallyRandomValues	.\CryptographicallyRandomNumber.cpp	/^void cryptographicallyRandomValues(void* buffer, size_t length)$/;"	f	namespace:WTF	signature:(void* buffer, size_t length)
WTF::cryptographicallyRandomValues	.\CryptographicallyRandomNumber.h	/^WTF_EXPORT_PRIVATE void cryptographicallyRandomValues(void* buffer, size_t length);$/;"	p	namespace:WTF	signature:(void* buffer, size_t length)
WTF::cryptographicallyRandomValuesFromOS	.\OSRandomSource.cpp	/^void cryptographicallyRandomValuesFromOS(unsigned char* buffer, size_t length)$/;"	f	namespace:WTF	signature:(unsigned char* buffer, size_t length)
WTF::cryptographicallyRandomValuesFromOS	.\OSRandomSource.h	/^void cryptographicallyRandomValuesFromOS(unsigned char* buffer, size_t length);$/;"	p	namespace:WTF	signature:(unsigned char* buffer, size_t length)
WTF::currentSystemTime	.\CurrentTime.cpp	/^static double currentSystemTime()$/;"	f	namespace:WTF	file:	signature:()
WTF::currentThread	.\Threading.h	/^WTF_EXPORT_PRIVATE ThreadIdentifier currentThread();$/;"	p	namespace:WTF	signature:()
WTF::currentThread	.\ThreadingPthreads.cpp	/^ThreadIdentifier currentThread()$/;"	f	namespace:WTF	signature:()
WTF::currentThread	.\ThreadingWin.cpp	/^ThreadIdentifier currentThread()$/;"	f	namespace:WTF	signature:()
WTF::currentTime	.\CurrentTime.cpp	/^double currentTime()$/;"	f	namespace:WTF	signature:()
WTF::currentTime	.\CurrentTime.h	/^WTF_EXPORT_PRIVATE double currentTime();$/;"	p	namespace:WTF	signature:()
WTF::currentTimeMS	.\CurrentTime.h	/^inline double currentTimeMS()$/;"	f	namespace:WTF	signature:()
WTF::d2b	.\dtoa.cpp	/^static ALWAYS_INLINE void d2b(BigInt& b, U* d, int* e, int* bits)$/;"	f	namespace:WTF	file:	signature:(BigInt& b, U* d, int* e, int* bits)
WTF::dataFile	.\DataLog.cpp	/^FILE* dataFile()$/;"	f	namespace:WTF	signature:()
WTF::dataFile	.\DataLog.h	/^FILE* dataFile();$/;"	p	namespace:WTF	signature:()
WTF::dataLog	.\DataLog.cpp	/^void dataLog(const char* format, ...)$/;"	f	namespace:WTF	signature:(const char* format, ...)
WTF::dataLogV	.\DataLog.cpp	/^void dataLogV(const char* format, va_list argList)$/;"	f	namespace:WTF	signature:(const char* format, va_list argList)
WTF::dateToDaysFrom1970	.\DateMath.cpp	/^double dateToDaysFrom1970(int year, int month, int day)$/;"	f	namespace:WTF	signature:(int year, int month, int day)
WTF::dateToDaysFrom1970	.\DateMath.h	/^WTF_EXPORT_PRIVATE double dateToDaysFrom1970(int year, int month, int day);$/;"	p	namespace:WTF	signature:(int year, int month, int day)
WTF::dayInMonthFromDayInYear	.\DateMath.cpp	/^int dayInMonthFromDayInYear(int dayInYear, bool leapYear)$/;"	f	namespace:WTF	signature:(int dayInYear, bool leapYear)
WTF::dayInMonthFromDayInYear	.\DateMath.h	/^WTF_EXPORT_PRIVATE int dayInMonthFromDayInYear(int dayInYear, bool leapYear);$/;"	p	namespace:WTF	signature:(int dayInYear, bool leapYear)
WTF::dayInYear	.\DateMath.cpp	/^int dayInYear(double ms, int year)$/;"	f	namespace:WTF	signature:(double ms, int year)
WTF::dayInYear	.\DateMath.h	/^WTF_EXPORT_PRIVATE int dayInYear(double ms, int year);$/;"	p	namespace:WTF	signature:(double ms, int year)
WTF::daysFrom1970ToYear	.\DateMath.cpp	/^static inline double daysFrom1970ToYear(int year)$/;"	f	namespace:WTF	file:	signature:(int year)
WTF::daysInYear	.\DateMath.cpp	/^static inline int daysInYear(int year)$/;"	f	namespace:WTF	file:	signature:(int year)
WTF::deleteAllKeys	.\HashMap.h	/^    inline void deleteAllKeys(const HashMap<T, U, V, W, X>& collection)$/;"	f	namespace:WTF	signature:(const HashMap<T, U, V, W, X>& collection)
WTF::deleteAllPairFirsts	.\HashMap.h	/^    void deleteAllPairFirsts(HashTableType& collection)$/;"	f	namespace:WTF	signature:(HashTableType& collection)
WTF::deleteAllPairSeconds	.\HashMap.h	/^    void deleteAllPairSeconds(HashTableType& collection)$/;"	f	namespace:WTF	signature:(HashTableType& collection)
WTF::deleteAllValues	.\Deque.h	/^    void deleteAllValues(const Deque<T, inlineCapacity>& collection)$/;"	f	namespace:WTF	signature:(const Deque<T, inlineCapacity>& collection)
WTF::deleteAllValues	.\HashMap.h	/^    inline void deleteAllValues(const HashMap<T, U, V, W, X>& collection)$/;"	f	namespace:WTF	signature:(const HashMap<T, U, V, W, X>& collection)
WTF::deleteAllValues	.\HashSet.h	/^    inline void deleteAllValues(const HashSet<T, U, V>& collection)$/;"	f	namespace:WTF	signature:(const HashSet<T, U, V>& collection)
WTF::deleteAllValues	.\HashSet.h	/^    void deleteAllValues(HashTableType& collection)$/;"	f	namespace:WTF	signature:(HashTableType& collection)
WTF::deleteAllValues	.\HashSet.h	/^    void deleteAllValues(const HashSet<Value, HashFunctions, Traits>&);$/;"	p	namespace:WTF	signature:(const HashSet<Value, HashFunctions, Traits>&)
WTF::deleteAllValues	.\ListHashSet.h	/^    inline void deleteAllValues(const ListHashSet<T, inlineCapacity, U>& collection)$/;"	f	namespace:WTF	signature:(const ListHashSet<T, inlineCapacity, U>& collection)
WTF::deleteAllValues	.\ListHashSet.h	/^    void deleteAllValues(HashTableType& collection)$/;"	f	namespace:WTF	signature:(HashTableType& collection)
WTF::deleteAllValues	.\ListHashSet.h	/^    void deleteAllValues(const ListHashSet<Value, inlineCapacity, HashFunctions>&);$/;"	p	namespace:WTF	signature:(const ListHashSet<Value, inlineCapacity, HashFunctions>&)
WTF::deleteAllValues	.\Vector.h	/^    void deleteAllValues(const Vector<T, inlineCapacity>& collection)$/;"	f	namespace:WTF	signature:(const Vector<T, inlineCapacity>& collection)
WTF::deleteOwnedArrayPtr	.\PassOwnArrayPtr.h	/^template<typename T> inline void deleteOwnedArrayPtr(T* ptr)$/;"	f	namespace:WTF	signature:(T* ptr)
WTF::deleteOwnedArrayPtr	.\PassOwnArrayPtr.h	/^template<typename T> void deleteOwnedArrayPtr(T* ptr);$/;"	p	namespace:WTF	signature:(T* ptr)
WTF::deleteOwnedPtr	.\OwnPtrCommon.h	/^    template <typename T> inline void deleteOwnedPtr(T* ptr)$/;"	f	namespace:WTF	signature:(T* ptr)
WTF::deleteOwnedPtr	.\OwnPtrCommon.h	/^    void deleteOwnedPtr(Ecore_Evas*);$/;"	p	namespace:WTF	signature:(Ecore_Evas*)
WTF::deleteOwnedPtr	.\OwnPtrCommon.h	/^    void deleteOwnedPtr(Ecore_Pipe*);$/;"	p	namespace:WTF	signature:(Ecore_Pipe*)
WTF::deleteOwnedPtr	.\OwnPtrCommon.h	/^    void deleteOwnedPtr(Ecore_Timer*);$/;"	p	namespace:WTF	signature:(Ecore_Timer*)
WTF::deleteOwnedPtr	.\OwnPtrCommon.h	/^    void deleteOwnedPtr(Eina_Module*);$/;"	p	namespace:WTF	signature:(Eina_Module*)
WTF::deleteOwnedPtr	.\OwnPtrCommon.h	/^    void deleteOwnedPtr(Evas_Object*);$/;"	p	namespace:WTF	signature:(Evas_Object*)
WTF::deleteOwnedPtr	.\OwnPtrCommon.h	/^    void deleteOwnedPtr(HBITMAP);$/;"	p	namespace:WTF	signature:(HBITMAP)
WTF::deleteOwnedPtr	.\OwnPtrCommon.h	/^    void deleteOwnedPtr(HBRUSH);$/;"	p	namespace:WTF	signature:(HBRUSH)
WTF::deleteOwnedPtr	.\OwnPtrCommon.h	/^    void deleteOwnedPtr(HDC);$/;"	p	namespace:WTF	signature:(HDC)
WTF::deleteOwnedPtr	.\OwnPtrCommon.h	/^    void deleteOwnedPtr(HFONT);$/;"	p	namespace:WTF	signature:(HFONT)
WTF::deleteOwnedPtr	.\OwnPtrCommon.h	/^    void deleteOwnedPtr(HPALETTE);$/;"	p	namespace:WTF	signature:(HPALETTE)
WTF::deleteOwnedPtr	.\OwnPtrCommon.h	/^    void deleteOwnedPtr(HPEN);$/;"	p	namespace:WTF	signature:(HPEN)
WTF::deleteOwnedPtr	.\OwnPtrCommon.h	/^    void deleteOwnedPtr(HRGN);$/;"	p	namespace:WTF	signature:(HRGN)
WTF::deleteOwnedPtr	.\efl\OwnPtrEfl.cpp	/^void deleteOwnedPtr(Ecore_Evas* ptr)$/;"	f	namespace:WTF	signature:(Ecore_Evas* ptr)
WTF::deleteOwnedPtr	.\efl\OwnPtrEfl.cpp	/^void deleteOwnedPtr(Ecore_Pipe* ptr)$/;"	f	namespace:WTF	signature:(Ecore_Pipe* ptr)
WTF::deleteOwnedPtr	.\efl\OwnPtrEfl.cpp	/^void deleteOwnedPtr(Ecore_Timer* ptr)$/;"	f	namespace:WTF	signature:(Ecore_Timer* ptr)
WTF::deleteOwnedPtr	.\efl\OwnPtrEfl.cpp	/^void deleteOwnedPtr(Eina_Module* ptr)$/;"	f	namespace:WTF	signature:(Eina_Module* ptr)
WTF::deleteOwnedPtr	.\efl\OwnPtrEfl.cpp	/^void deleteOwnedPtr(Evas_Object* ptr)$/;"	f	namespace:WTF	signature:(Evas_Object* ptr)
WTF::deleteOwnedPtr	.\win\OwnPtrWin.cpp	/^void deleteOwnedPtr(HBITMAP ptr)$/;"	f	namespace:WTF	signature:(HBITMAP ptr)
WTF::deleteOwnedPtr	.\win\OwnPtrWin.cpp	/^void deleteOwnedPtr(HBRUSH ptr)$/;"	f	namespace:WTF	signature:(HBRUSH ptr)
WTF::deleteOwnedPtr	.\win\OwnPtrWin.cpp	/^void deleteOwnedPtr(HDC ptr)$/;"	f	namespace:WTF	signature:(HDC ptr)
WTF::deleteOwnedPtr	.\win\OwnPtrWin.cpp	/^void deleteOwnedPtr(HFONT ptr)$/;"	f	namespace:WTF	signature:(HFONT ptr)
WTF::deleteOwnedPtr	.\win\OwnPtrWin.cpp	/^void deleteOwnedPtr(HPALETTE ptr)$/;"	f	namespace:WTF	signature:(HPALETTE ptr)
WTF::deleteOwnedPtr	.\win\OwnPtrWin.cpp	/^void deleteOwnedPtr(HPEN ptr)$/;"	f	namespace:WTF	signature:(HPEN ptr)
WTF::deleteOwnedPtr	.\win\OwnPtrWin.cpp	/^void deleteOwnedPtr(HRGN ptr)$/;"	f	namespace:WTF	signature:(HRGN ptr)
WTF::derefGPtr	.\gobject\GRefPtr.cpp	/^template <> void derefGPtr(GHashTable* ptr)$/;"	f	namespace:WTF	signature:(GHashTable* ptr)
WTF::derefGPtr	.\gobject\GRefPtr.cpp	/^template <> void derefGPtr(GMainContext* ptr)$/;"	f	namespace:WTF	signature:(GMainContext* ptr)
WTF::derefGPtr	.\gobject\GRefPtr.cpp	/^template <> void derefGPtr(GMainLoop* ptr)$/;"	f	namespace:WTF	signature:(GMainLoop* ptr)
WTF::derefGPtr	.\gobject\GRefPtr.cpp	/^template <> void derefGPtr(GSource* ptr)$/;"	f	namespace:WTF	signature:(GSource* ptr)
WTF::derefGPtr	.\gobject\GRefPtr.cpp	/^template <> void derefGPtr(GVariant* ptr)$/;"	f	namespace:WTF	signature:(GVariant* ptr)
WTF::derefGPtr	.\gobject\GRefPtr.h	/^template <> void derefGPtr(GHashTable* ptr);$/;"	p	namespace:WTF	signature:(GHashTable* ptr)
WTF::derefGPtr	.\gobject\GRefPtr.h	/^template <> void derefGPtr(GMainContext* ptr);$/;"	p	namespace:WTF	signature:(GMainContext* ptr)
WTF::derefGPtr	.\gobject\GRefPtr.h	/^template <> void derefGPtr(GMainLoop* ptr);$/;"	p	namespace:WTF	signature:(GMainLoop* ptr)
WTF::derefGPtr	.\gobject\GRefPtr.h	/^template <> void derefGPtr(GSource* ptr);$/;"	p	namespace:WTF	signature:(GSource* ptr)
WTF::derefGPtr	.\gobject\GRefPtr.h	/^template <> void derefGPtr(GVariant* ptr);$/;"	p	namespace:WTF	signature:(GVariant* ptr)
WTF::derefGPtr	.\gobject\GRefPtr.h	/^template <typename T> inline void derefGPtr(T* ptr)$/;"	f	namespace:WTF	signature:(T* ptr)
WTF::derefGPtr	.\gobject\GRefPtr.h	/^template <typename T> inline void derefGPtr(T*);$/;"	p	namespace:WTF	signature:(T*)
WTF::derefIfNotNull	.\PassRefPtr.h	/^    template<typename T> REF_DEREF_INLINE void derefIfNotNull(T* ptr)$/;"	f	namespace:WTF	signature:(T* ptr)
WTF::detachThread	.\Threading.h	/^WTF_EXPORT_PRIVATE void detachThread(ThreadIdentifier);$/;"	p	namespace:WTF	signature:(ThreadIdentifier)
WTF::detachThread	.\ThreadingPthreads.cpp	/^void detachThread(ThreadIdentifier threadID)$/;"	f	namespace:WTF	signature:(ThreadIdentifier threadID)
WTF::detachThread	.\ThreadingWin.cpp	/^void detachThread(ThreadIdentifier threadID)$/;"	f	namespace:WTF	signature:(ThreadIdentifier threadID)
WTF::detectGrowingDownward	.\StackBounds.cpp	/^static bool detectGrowingDownward(void* previousFrame)$/;"	f	namespace:WTF	file:	signature:(void* previousFrame)
WTF::diff	.\dtoa.cpp	/^static ALWAYS_INLINE void diff(BigInt& c, const BigInt& aRef, const BigInt& bRef)$/;"	f	namespace:WTF	file:	signature:(BigInt& c, const BigInt& aRef, const BigInt& bRef)
WTF::dispatchFunctionsFromMainThread	.\MainThread.cpp	/^void dispatchFunctionsFromMainThread()$/;"	f	namespace:WTF	signature:()
WTF::dispatchFunctionsFromMainThread	.\MainThread.h	/^void dispatchFunctionsFromMainThread();$/;"	p	namespace:WTF	signature:()
WTF::do_free	.\FastMalloc.cpp	/^static ALWAYS_INLINE void do_free(void* ptr) {$/;"	f	namespace:WTF	file:	signature:(void* ptr)
WTF::do_mallinfo	.\FastMalloc.cpp	/^static inline struct mallinfo do_mallinfo() {$/;"	f	namespace:WTF	file:	signature:()
WTF::do_malloc	.\FastMalloc.cpp	/^static ALWAYS_INLINE void* do_malloc(size_t size) {$/;"	f	namespace:WTF	file:	signature:(size_t size)
WTF::do_malloc_stats	.\FastMalloc.cpp	/^static inline void do_malloc_stats() {$/;"	f	namespace:WTF	file:	signature:()
WTF::do_mallopt	.\FastMalloc.cpp	/^static inline int do_mallopt(int, int) {$/;"	f	namespace:WTF	file:	signature:(int, int)
WTF::do_memalign	.\FastMalloc.cpp	/^static void* do_memalign(size_t align, size_t size) {$/;"	f	namespace:WTF	file:	signature:(size_t align, size_t size)
WTF::doubleHash	.\HashTable.h	/^    inline unsigned doubleHash(unsigned key)$/;"	f	namespace:WTF	signature:(unsigned key)
WTF::double_conversion	.\dtoa\bignum-dtoa.cc	/^namespace double_conversion {$/;"	n	namespace:WTF	file:
WTF::double_conversion	.\dtoa\bignum-dtoa.h	/^namespace double_conversion {$/;"	n	namespace:WTF
WTF::double_conversion	.\dtoa\bignum.cc	/^namespace double_conversion {$/;"	n	namespace:WTF	file:
WTF::double_conversion	.\dtoa\bignum.h	/^namespace double_conversion {$/;"	n	namespace:WTF
WTF::double_conversion	.\dtoa\cached-powers.cc	/^namespace double_conversion {$/;"	n	namespace:WTF	file:
WTF::double_conversion	.\dtoa\cached-powers.h	/^namespace double_conversion {$/;"	n	namespace:WTF
WTF::double_conversion	.\dtoa\diy-fp.cc	/^namespace double_conversion {$/;"	n	namespace:WTF	file:
WTF::double_conversion	.\dtoa\diy-fp.h	/^namespace double_conversion {$/;"	n	namespace:WTF
WTF::double_conversion	.\dtoa\double-conversion.cc	/^namespace double_conversion {$/;"	n	namespace:WTF	file:
WTF::double_conversion	.\dtoa\double-conversion.h	/^namespace double_conversion {$/;"	n	namespace:WTF
WTF::double_conversion	.\dtoa\double.h	/^namespace double_conversion {$/;"	n	namespace:WTF
WTF::double_conversion	.\dtoa\fast-dtoa.cc	/^namespace double_conversion {$/;"	n	namespace:WTF	file:
WTF::double_conversion	.\dtoa\fast-dtoa.h	/^namespace double_conversion {$/;"	n	namespace:WTF
WTF::double_conversion	.\dtoa\fixed-dtoa.cc	/^namespace double_conversion {$/;"	n	namespace:WTF	file:
WTF::double_conversion	.\dtoa\fixed-dtoa.h	/^namespace double_conversion {$/;"	n	namespace:WTF
WTF::double_conversion	.\dtoa\strtod.cc	/^namespace double_conversion {$/;"	n	namespace:WTF	file:
WTF::double_conversion	.\dtoa\strtod.h	/^namespace double_conversion {$/;"	n	namespace:WTF
WTF::double_conversion	.\dtoa\utils.h	/^namespace double_conversion {$/;"	n	namespace:WTF
WTF::double_conversion::AdjustmentPowerOfTen	.\dtoa\strtod.cc	/^    static DiyFp AdjustmentPowerOfTen(int exponent) {$/;"	f	namespace:WTF::double_conversion	file:	signature:(int exponent)
WTF::double_conversion::AdvanceToNonspace	.\dtoa\double-conversion.cc	/^    static inline bool AdvanceToNonspace(const char** current, const char* end) {$/;"	f	namespace:WTF::double_conversion	file:	signature:(const char** current, const char* end)
WTF::double_conversion::BIGNUM_DTOA_FIXED	.\dtoa\bignum-dtoa.h	/^        BIGNUM_DTOA_FIXED,$/;"	e	enum:WTF::double_conversion::BignumDtoaMode
WTF::double_conversion::BIGNUM_DTOA_PRECISION	.\dtoa\bignum-dtoa.h	/^        BIGNUM_DTOA_PRECISION$/;"	e	enum:WTF::double_conversion::BignumDtoaMode
WTF::double_conversion::BIGNUM_DTOA_SHORTEST	.\dtoa\bignum-dtoa.h	/^        BIGNUM_DTOA_SHORTEST,$/;"	e	enum:WTF::double_conversion::BignumDtoaMode
WTF::double_conversion::BiggestPowerTen	.\dtoa\fast-dtoa.cc	/^    static void BiggestPowerTen(uint32_t number,$/;"	f	namespace:WTF::double_conversion	file:	signature:(uint32_t number, int number_bits, uint32_t* power, int* exponent)
WTF::double_conversion::Bignum	.\dtoa\bignum.h	/^    class Bignum {$/;"	c	namespace:WTF::double_conversion
WTF::double_conversion::Bignum::AddBignum	.\dtoa\bignum.cc	/^    void Bignum::AddBignum(const Bignum& other) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(const Bignum& other)
WTF::double_conversion::Bignum::AddBignum	.\dtoa\bignum.h	/^        void AddBignum(const Bignum& other);$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(const Bignum& other)
WTF::double_conversion::Bignum::AddUInt16	.\dtoa\bignum.h	/^        void AddUInt16(uint16_t operand);$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(uint16_t operand)
WTF::double_conversion::Bignum::AddUInt64	.\dtoa\bignum.cc	/^    void Bignum::AddUInt64(uint64_t operand) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(uint64_t operand)
WTF::double_conversion::Bignum::AddUInt64	.\dtoa\bignum.h	/^        void AddUInt64(uint64_t operand);$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(uint64_t operand)
WTF::double_conversion::Bignum::Align	.\dtoa\bignum.cc	/^    void Bignum::Align(const Bignum& other) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(const Bignum& other)
WTF::double_conversion::Bignum::Align	.\dtoa\bignum.h	/^        void Align(const Bignum& other);$/;"	p	class:WTF::double_conversion::Bignum	access:private	signature:(const Bignum& other)
WTF::double_conversion::Bignum::AssignBignum	.\dtoa\bignum.cc	/^    void Bignum::AssignBignum(const Bignum& other) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(const Bignum& other)
WTF::double_conversion::Bignum::AssignBignum	.\dtoa\bignum.h	/^        void AssignBignum(const Bignum& other);$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(const Bignum& other)
WTF::double_conversion::Bignum::AssignDecimalString	.\dtoa\bignum.cc	/^    void Bignum::AssignDecimalString(Vector<const char> value) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(Vector<const char> value)
WTF::double_conversion::Bignum::AssignDecimalString	.\dtoa\bignum.h	/^        void AssignDecimalString(Vector<const char> value);$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(Vector<const char> value)
WTF::double_conversion::Bignum::AssignHexString	.\dtoa\bignum.cc	/^    void Bignum::AssignHexString(Vector<const char> value) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(Vector<const char> value)
WTF::double_conversion::Bignum::AssignHexString	.\dtoa\bignum.h	/^        void AssignHexString(Vector<const char> value);$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(Vector<const char> value)
WTF::double_conversion::Bignum::AssignPowerUInt16	.\dtoa\bignum.cc	/^    void Bignum::AssignPowerUInt16(uint16_t base, int power_exponent) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(uint16_t base, int power_exponent)
WTF::double_conversion::Bignum::AssignPowerUInt16	.\dtoa\bignum.h	/^        void AssignPowerUInt16(uint16_t base, int exponent);$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(uint16_t base, int exponent)
WTF::double_conversion::Bignum::AssignUInt16	.\dtoa\bignum.cc	/^    void Bignum::AssignUInt16(uint16_t value) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(uint16_t value)
WTF::double_conversion::Bignum::AssignUInt16	.\dtoa\bignum.h	/^        void AssignUInt16(uint16_t value);$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(uint16_t value)
WTF::double_conversion::Bignum::AssignUInt64	.\dtoa\bignum.cc	/^    void Bignum::AssignUInt64(uint64_t value) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(uint64_t value)
WTF::double_conversion::Bignum::AssignUInt64	.\dtoa\bignum.h	/^        void AssignUInt64(uint64_t value);$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(uint64_t value)
WTF::double_conversion::Bignum::BigitAt	.\dtoa\bignum.cc	/^    Bignum::Chunk Bignum::BigitAt(int index) const {$/;"	f	class:WTF::double_conversion::Bignum	signature:(int index) const
WTF::double_conversion::Bignum::BigitAt	.\dtoa\bignum.h	/^        Chunk BigitAt(int index) const;$/;"	p	class:WTF::double_conversion::Bignum	access:private	signature:(int index) const
WTF::double_conversion::Bignum::BigitLength	.\dtoa\bignum.h	/^        int BigitLength() const { return used_digits_ + exponent_; }$/;"	f	class:WTF::double_conversion::Bignum	access:private	signature:() const
WTF::double_conversion::Bignum::BigitsShiftLeft	.\dtoa\bignum.cc	/^    void Bignum::BigitsShiftLeft(int shift_amount) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(int shift_amount)
WTF::double_conversion::Bignum::BigitsShiftLeft	.\dtoa\bignum.h	/^        void BigitsShiftLeft(int shift_amount);$/;"	p	class:WTF::double_conversion::Bignum	access:private	signature:(int shift_amount)
WTF::double_conversion::Bignum::Bignum	.\dtoa\bignum.cc	/^    Bignum::Bignum()$/;"	f	class:WTF::double_conversion::Bignum	signature:()
WTF::double_conversion::Bignum::Bignum	.\dtoa\bignum.h	/^        Bignum();$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:()
WTF::double_conversion::Bignum::Chunk	.\dtoa\bignum.h	/^        typedef uint32_t Chunk;$/;"	t	class:WTF::double_conversion::Bignum	access:private
WTF::double_conversion::Bignum::Clamp	.\dtoa\bignum.cc	/^    void Bignum::Clamp() {$/;"	f	class:WTF::double_conversion::Bignum	signature:()
WTF::double_conversion::Bignum::Clamp	.\dtoa\bignum.h	/^        void Clamp();$/;"	p	class:WTF::double_conversion::Bignum	access:private	signature:()
WTF::double_conversion::Bignum::Compare	.\dtoa\bignum.cc	/^    int Bignum::Compare(const Bignum& a, const Bignum& b) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(const Bignum& a, const Bignum& b)
WTF::double_conversion::Bignum::Compare	.\dtoa\bignum.h	/^        static int Compare(const Bignum& a, const Bignum& b);$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(const Bignum& a, const Bignum& b)
WTF::double_conversion::Bignum::DISALLOW_COPY_AND_ASSIGN	.\dtoa\bignum.h	/^        DISALLOW_COPY_AND_ASSIGN(Bignum);$/;"	p	class:WTF::double_conversion::Bignum	access:private	signature:(Bignum)
WTF::double_conversion::Bignum::DivideModuloIntBignum	.\dtoa\bignum.cc	/^    uint16_t Bignum::DivideModuloIntBignum(const Bignum& other) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(const Bignum& other)
WTF::double_conversion::Bignum::DivideModuloIntBignum	.\dtoa\bignum.h	/^        uint16_t DivideModuloIntBignum(const Bignum& other);$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(const Bignum& other)
WTF::double_conversion::Bignum::DoubleChunk	.\dtoa\bignum.h	/^        typedef uint64_t DoubleChunk;$/;"	t	class:WTF::double_conversion::Bignum	access:private
WTF::double_conversion::Bignum::EnsureCapacity	.\dtoa\bignum.h	/^        void EnsureCapacity(int size) {$/;"	f	class:WTF::double_conversion::Bignum	access:private	signature:(int size)
WTF::double_conversion::Bignum::Equal	.\dtoa\bignum.h	/^        static bool Equal(const Bignum& a, const Bignum& b) {$/;"	f	class:WTF::double_conversion::Bignum	access:public	signature:(const Bignum& a, const Bignum& b)
WTF::double_conversion::Bignum::IsClamped	.\dtoa\bignum.cc	/^    bool Bignum::IsClamped() const {$/;"	f	class:WTF::double_conversion::Bignum	signature:() const
WTF::double_conversion::Bignum::IsClamped	.\dtoa\bignum.h	/^        bool IsClamped() const;$/;"	p	class:WTF::double_conversion::Bignum	access:private	signature:() const
WTF::double_conversion::Bignum::Less	.\dtoa\bignum.h	/^        static bool Less(const Bignum& a, const Bignum& b) {$/;"	f	class:WTF::double_conversion::Bignum	access:public	signature:(const Bignum& a, const Bignum& b)
WTF::double_conversion::Bignum::LessEqual	.\dtoa\bignum.h	/^        static bool LessEqual(const Bignum& a, const Bignum& b) {$/;"	f	class:WTF::double_conversion::Bignum	access:public	signature:(const Bignum& a, const Bignum& b)
WTF::double_conversion::Bignum::MultiplyByPowerOfTen	.\dtoa\bignum.cc	/^    void Bignum::MultiplyByPowerOfTen(int exponent) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(int exponent)
WTF::double_conversion::Bignum::MultiplyByPowerOfTen	.\dtoa\bignum.h	/^        void MultiplyByPowerOfTen(int exponent);$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(int exponent)
WTF::double_conversion::Bignum::MultiplyByUInt32	.\dtoa\bignum.cc	/^    void Bignum::MultiplyByUInt32(uint32_t factor) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(uint32_t factor)
WTF::double_conversion::Bignum::MultiplyByUInt32	.\dtoa\bignum.h	/^        void MultiplyByUInt32(uint32_t factor);$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(uint32_t factor)
WTF::double_conversion::Bignum::MultiplyByUInt64	.\dtoa\bignum.cc	/^    void Bignum::MultiplyByUInt64(uint64_t factor) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(uint64_t factor)
WTF::double_conversion::Bignum::MultiplyByUInt64	.\dtoa\bignum.h	/^        void MultiplyByUInt64(uint64_t factor);$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(uint64_t factor)
WTF::double_conversion::Bignum::PlusCompare	.\dtoa\bignum.cc	/^    int Bignum::PlusCompare(const Bignum& a, const Bignum& b, const Bignum& c) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(const Bignum& a, const Bignum& b, const Bignum& c)
WTF::double_conversion::Bignum::PlusCompare	.\dtoa\bignum.h	/^        static int PlusCompare(const Bignum& a, const Bignum& b, const Bignum& c);$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(const Bignum& a, const Bignum& b, const Bignum& c)
WTF::double_conversion::Bignum::PlusEqual	.\dtoa\bignum.h	/^        static bool PlusEqual(const Bignum& a, const Bignum& b, const Bignum& c) {$/;"	f	class:WTF::double_conversion::Bignum	access:public	signature:(const Bignum& a, const Bignum& b, const Bignum& c)
WTF::double_conversion::Bignum::PlusLess	.\dtoa\bignum.h	/^        static bool PlusLess(const Bignum& a, const Bignum& b, const Bignum& c) {$/;"	f	class:WTF::double_conversion::Bignum	access:public	signature:(const Bignum& a, const Bignum& b, const Bignum& c)
WTF::double_conversion::Bignum::PlusLessEqual	.\dtoa\bignum.h	/^        static bool PlusLessEqual(const Bignum& a, const Bignum& b, const Bignum& c) {$/;"	f	class:WTF::double_conversion::Bignum	access:public	signature:(const Bignum& a, const Bignum& b, const Bignum& c)
WTF::double_conversion::Bignum::ShiftLeft	.\dtoa\bignum.cc	/^    void Bignum::ShiftLeft(int shift_amount) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(int shift_amount)
WTF::double_conversion::Bignum::ShiftLeft	.\dtoa\bignum.h	/^        void ShiftLeft(int shift_amount);$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(int shift_amount)
WTF::double_conversion::Bignum::Square	.\dtoa\bignum.cc	/^    void Bignum::Square() {$/;"	f	class:WTF::double_conversion::Bignum	signature:()
WTF::double_conversion::Bignum::Square	.\dtoa\bignum.h	/^        void Square();$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:()
WTF::double_conversion::Bignum::SubtractBignum	.\dtoa\bignum.cc	/^    void Bignum::SubtractBignum(const Bignum& other) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(const Bignum& other)
WTF::double_conversion::Bignum::SubtractBignum	.\dtoa\bignum.h	/^        void SubtractBignum(const Bignum& other);$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(const Bignum& other)
WTF::double_conversion::Bignum::SubtractTimes	.\dtoa\bignum.cc	/^    void Bignum::SubtractTimes(const Bignum& other, int factor) {$/;"	f	class:WTF::double_conversion::Bignum	signature:(const Bignum& other, int factor)
WTF::double_conversion::Bignum::SubtractTimes	.\dtoa\bignum.h	/^        void SubtractTimes(const Bignum& other, int factor);$/;"	p	class:WTF::double_conversion::Bignum	access:private	signature:(const Bignum& other, int factor)
WTF::double_conversion::Bignum::Times10	.\dtoa\bignum.h	/^        void Times10() { return MultiplyByUInt32(10); }$/;"	f	class:WTF::double_conversion::Bignum	access:public	signature:()
WTF::double_conversion::Bignum::ToHexString	.\dtoa\bignum.cc	/^    bool Bignum::ToHexString(char* buffer, int buffer_size) const {$/;"	f	class:WTF::double_conversion::Bignum	signature:(char* buffer, int buffer_size) const
WTF::double_conversion::Bignum::ToHexString	.\dtoa\bignum.h	/^        bool ToHexString(char* buffer, int buffer_size) const;$/;"	p	class:WTF::double_conversion::Bignum	access:public	signature:(char* buffer, int buffer_size) const
WTF::double_conversion::Bignum::Zero	.\dtoa\bignum.cc	/^    void Bignum::Zero() {$/;"	f	class:WTF::double_conversion::Bignum	signature:()
WTF::double_conversion::Bignum::Zero	.\dtoa\bignum.h	/^        void Zero();$/;"	p	class:WTF::double_conversion::Bignum	access:private	signature:()
WTF::double_conversion::Bignum::bigits_	.\dtoa\bignum.h	/^        Vector<Chunk> bigits_;$/;"	m	class:WTF::double_conversion::Bignum	access:private
WTF::double_conversion::Bignum::bigits_buffer_	.\dtoa\bignum.h	/^        Chunk bigits_buffer_[kBigitCapacity];$/;"	m	class:WTF::double_conversion::Bignum	access:private
WTF::double_conversion::Bignum::exponent_	.\dtoa\bignum.h	/^        int exponent_;$/;"	m	class:WTF::double_conversion::Bignum	access:private
WTF::double_conversion::Bignum::kBigitCapacity	.\dtoa\bignum.h	/^        static const int kBigitCapacity = kMaxSignificantBits \/ kBigitSize;$/;"	m	class:WTF::double_conversion::Bignum	access:private
WTF::double_conversion::Bignum::kBigitMask	.\dtoa\bignum.h	/^        static const Chunk kBigitMask = (1 << kBigitSize) - 1;$/;"	m	class:WTF::double_conversion::Bignum	access:private
WTF::double_conversion::Bignum::kBigitSize	.\dtoa\bignum.h	/^        static const int kBigitSize = 28;$/;"	m	class:WTF::double_conversion::Bignum	access:private
WTF::double_conversion::Bignum::kChunkSize	.\dtoa\bignum.h	/^        static const int kChunkSize = sizeof(Chunk) * 8;$/;"	m	class:WTF::double_conversion::Bignum	access:private
WTF::double_conversion::Bignum::kDoubleChunkSize	.\dtoa\bignum.h	/^        static const int kDoubleChunkSize = sizeof(DoubleChunk) * 8;$/;"	m	class:WTF::double_conversion::Bignum	access:private
WTF::double_conversion::Bignum::kMaxSignificantBits	.\dtoa\bignum.h	/^        static const int kMaxSignificantBits = 3584;$/;"	m	class:WTF::double_conversion::Bignum	access:public
WTF::double_conversion::Bignum::used_digits_	.\dtoa\bignum.h	/^        int used_digits_;$/;"	m	class:WTF::double_conversion::Bignum	access:private
WTF::double_conversion::BignumDtoa	.\dtoa\bignum-dtoa.cc	/^    void BignumDtoa(double v, BignumDtoaMode mode, int requested_digits,$/;"	f	namespace:WTF::double_conversion	signature:(double v, BignumDtoaMode mode, int requested_digits, Vector<char> buffer, int* length, int* decimal_point)
WTF::double_conversion::BignumDtoa	.\dtoa\bignum-dtoa.h	/^    void BignumDtoa(double v, BignumDtoaMode mode, int requested_digits,$/;"	p	namespace:WTF::double_conversion	signature:(double v, BignumDtoaMode mode, int requested_digits, Vector<char> buffer, int* length, int* point)
WTF::double_conversion::BignumDtoaMode	.\dtoa\bignum-dtoa.h	/^    enum BignumDtoaMode {$/;"	g	namespace:WTF::double_conversion
WTF::double_conversion::BignumStrtod	.\dtoa\strtod.cc	/^    static double BignumStrtod(Vector<const char> buffer,$/;"	f	namespace:WTF::double_conversion	file:	signature:(Vector<const char> buffer, int exponent, double guess)
WTF::double_conversion::BignumToFixed	.\dtoa\bignum-dtoa.cc	/^    static void BignumToFixed(int requested_digits, int* decimal_point,$/;"	f	namespace:WTF::double_conversion	file:	signature:(int requested_digits, int* decimal_point, Bignum* numerator, Bignum* denominator, Vector<char>(buffer), int* length)
WTF::double_conversion::BignumToFixed	.\dtoa\bignum-dtoa.cc	/^    static void BignumToFixed(int requested_digits, int* decimal_point,$/;"	p	namespace:WTF::double_conversion	file:	signature:(int requested_digits, int* decimal_point, Bignum* numerator, Bignum* denominator, Vector<char>(buffer), int* length)
WTF::double_conversion::BitCast	.\dtoa\utils.h	/^    inline Dest BitCast(Source* source) {$/;"	f	namespace:WTF::double_conversion	signature:(Source* source)
WTF::double_conversion::BitCast	.\dtoa\utils.h	/^    inline Dest BitCast(const Source& source) {$/;"	f	namespace:WTF::double_conversion	signature:(const Source& source)
WTF::double_conversion::BitSize	.\dtoa\bignum.cc	/^    static int BitSize(S value) {$/;"	f	namespace:WTF::double_conversion	file:	signature:(S value)
WTF::double_conversion::CachedPower	.\dtoa\cached-powers.cc	/^    struct CachedPower {$/;"	s	namespace:WTF::double_conversion	file:
WTF::double_conversion::CachedPower::binary_exponent	.\dtoa\cached-powers.cc	/^        int16_t binary_exponent;$/;"	m	struct:WTF::double_conversion::CachedPower	file:	access:public
WTF::double_conversion::CachedPower::decimal_exponent	.\dtoa\cached-powers.cc	/^        int16_t decimal_exponent;$/;"	m	struct:WTF::double_conversion::CachedPower	file:	access:public
WTF::double_conversion::CachedPower::significand	.\dtoa\cached-powers.cc	/^        uint64_t significand;$/;"	m	struct:WTF::double_conversion::CachedPower	file:	access:public
WTF::double_conversion::ConsumeSubString	.\dtoa\double-conversion.cc	/^    static bool ConsumeSubString(const char** current,$/;"	f	namespace:WTF::double_conversion	file:	signature:(const char** current, const char* end, const char* substring)
WTF::double_conversion::DigitGen	.\dtoa\fast-dtoa.cc	/^    static bool DigitGen(DiyFp low,$/;"	f	namespace:WTF::double_conversion	file:	signature:(DiyFp low, DiyFp w, DiyFp high, Vector<char> buffer, int* length, int* kappa)
WTF::double_conversion::DigitGenCounted	.\dtoa\fast-dtoa.cc	/^    static bool DigitGenCounted(DiyFp w,$/;"	f	namespace:WTF::double_conversion	file:	signature:(DiyFp w, int requested_digits, Vector<char> buffer, int* length, int* kappa)
WTF::double_conversion::DiyFp	.\dtoa\diy-fp.h	/^    class DiyFp {$/;"	c	namespace:WTF::double_conversion
WTF::double_conversion::DiyFp::DiyFp	.\dtoa\diy-fp.h	/^        DiyFp() : f_(0), e_(0) {}$/;"	f	class:WTF::double_conversion::DiyFp	access:public	signature:()
WTF::double_conversion::DiyFp::DiyFp	.\dtoa\diy-fp.h	/^        DiyFp(uint64_t f, int e) : f_(f), e_(e) {}$/;"	f	class:WTF::double_conversion::DiyFp	access:public	signature:(uint64_t f, int e)
WTF::double_conversion::DiyFp::Minus	.\dtoa\diy-fp.h	/^        static DiyFp Minus(const DiyFp& a, const DiyFp& b) {$/;"	f	class:WTF::double_conversion::DiyFp	access:public	signature:(const DiyFp& a, const DiyFp& b)
WTF::double_conversion::DiyFp::Multiply	.\dtoa\diy-fp.cc	/^    void DiyFp::Multiply(const DiyFp& other) {$/;"	f	class:WTF::double_conversion::DiyFp	signature:(const DiyFp& other)
WTF::double_conversion::DiyFp::Multiply	.\dtoa\diy-fp.h	/^        void Multiply(const DiyFp& other);$/;"	p	class:WTF::double_conversion::DiyFp	access:public	signature:(const DiyFp& other)
WTF::double_conversion::DiyFp::Normalize	.\dtoa\diy-fp.h	/^        static DiyFp Normalize(const DiyFp& a) {$/;"	f	class:WTF::double_conversion::DiyFp	access:public	signature:(const DiyFp& a)
WTF::double_conversion::DiyFp::Normalize	.\dtoa\diy-fp.h	/^        void Normalize() {$/;"	f	class:WTF::double_conversion::DiyFp	access:public	signature:()
WTF::double_conversion::DiyFp::Subtract	.\dtoa\diy-fp.h	/^        void Subtract(const DiyFp& other) {$/;"	f	class:WTF::double_conversion::DiyFp	access:public	signature:(const DiyFp& other)
WTF::double_conversion::DiyFp::Times	.\dtoa\diy-fp.h	/^        static DiyFp Times(const DiyFp& a, const DiyFp& b) {$/;"	f	class:WTF::double_conversion::DiyFp	access:public	signature:(const DiyFp& a, const DiyFp& b)
WTF::double_conversion::DiyFp::e	.\dtoa\diy-fp.h	/^        int e() const { return e_; }$/;"	f	class:WTF::double_conversion::DiyFp	access:public	signature:() const
WTF::double_conversion::DiyFp::e_	.\dtoa\diy-fp.h	/^        int e_;$/;"	m	class:WTF::double_conversion::DiyFp	access:private
WTF::double_conversion::DiyFp::f	.\dtoa\diy-fp.h	/^        uint64_t f() const { return f_; }$/;"	f	class:WTF::double_conversion::DiyFp	access:public	signature:() const
WTF::double_conversion::DiyFp::f_	.\dtoa\diy-fp.h	/^        uint64_t f_;$/;"	m	class:WTF::double_conversion::DiyFp	access:private
WTF::double_conversion::DiyFp::kSignificandSize	.\dtoa\diy-fp.h	/^        static const int kSignificandSize = 64;$/;"	m	class:WTF::double_conversion::DiyFp	access:public
WTF::double_conversion::DiyFp::kUint64MSB	.\dtoa\diy-fp.h	/^        static const uint64_t kUint64MSB = UINT64_2PART_C(0x80000000, 00000000);$/;"	m	class:WTF::double_conversion::DiyFp	access:private
WTF::double_conversion::DiyFp::set_e	.\dtoa\diy-fp.h	/^        void set_e(int new_value) { e_ = new_value; }$/;"	f	class:WTF::double_conversion::DiyFp	access:public	signature:(int new_value)
WTF::double_conversion::DiyFp::set_f	.\dtoa\diy-fp.h	/^        void set_f(uint64_t new_value) { f_ = new_value; }$/;"	f	class:WTF::double_conversion::DiyFp	access:public	signature:(uint64_t new_value)
WTF::double_conversion::DiyFpStrtod	.\dtoa\strtod.cc	/^    static bool DiyFpStrtod(Vector<const char> buffer,$/;"	f	namespace:WTF::double_conversion	file:	signature:(Vector<const char> buffer, int exponent, double* result)
WTF::double_conversion::Double	.\dtoa\double.h	/^    class Double {$/;"	c	namespace:WTF::double_conversion
WTF::double_conversion::Double::AsDiyFp	.\dtoa\double.h	/^        DiyFp AsDiyFp() const {$/;"	f	class:WTF::double_conversion::Double	access:public	signature:() const
WTF::double_conversion::Double::AsNormalizedDiyFp	.\dtoa\double.h	/^        DiyFp AsNormalizedDiyFp() const {$/;"	f	class:WTF::double_conversion::Double	access:public	signature:() const
WTF::double_conversion::Double::AsUint64	.\dtoa\double.h	/^        uint64_t AsUint64() const {$/;"	f	class:WTF::double_conversion::Double	access:public	signature:() const
WTF::double_conversion::Double::DiyFpToUint64	.\dtoa\double.h	/^        static uint64_t DiyFpToUint64(DiyFp diy_fp) {$/;"	f	class:WTF::double_conversion::Double	access:private	signature:(DiyFp diy_fp)
WTF::double_conversion::Double::Double	.\dtoa\double.h	/^        Double() : d64_(0) {}$/;"	f	class:WTF::double_conversion::Double	access:public	signature:()
WTF::double_conversion::Double::Double	.\dtoa\double.h	/^        explicit Double(DiyFp diy_fp)$/;"	f	class:WTF::double_conversion::Double	access:public	signature:(DiyFp diy_fp)
WTF::double_conversion::Double::Double	.\dtoa\double.h	/^        explicit Double(double d) : d64_(double_to_uint64(d)) {}$/;"	f	class:WTF::double_conversion::Double	access:public	signature:(double d)
WTF::double_conversion::Double::Double	.\dtoa\double.h	/^        explicit Double(uint64_t d64) : d64_(d64) {}$/;"	f	class:WTF::double_conversion::Double	access:public	signature:(uint64_t d64)
WTF::double_conversion::Double::Exponent	.\dtoa\double.h	/^        int Exponent() const {$/;"	f	class:WTF::double_conversion::Double	access:public	signature:() const
WTF::double_conversion::Double::Infinity	.\dtoa\double.h	/^        static double Infinity() {$/;"	f	class:WTF::double_conversion::Double	access:public	signature:()
WTF::double_conversion::Double::IsDenormal	.\dtoa\double.h	/^        bool IsDenormal() const {$/;"	f	class:WTF::double_conversion::Double	access:public	signature:() const
WTF::double_conversion::Double::IsInfinite	.\dtoa\double.h	/^        bool IsInfinite() const {$/;"	f	class:WTF::double_conversion::Double	access:public	signature:() const
WTF::double_conversion::Double::IsNan	.\dtoa\double.h	/^        bool IsNan() const {$/;"	f	class:WTF::double_conversion::Double	access:public	signature:() const
WTF::double_conversion::Double::IsSpecial	.\dtoa\double.h	/^        bool IsSpecial() const {$/;"	f	class:WTF::double_conversion::Double	access:public	signature:() const
WTF::double_conversion::Double::NaN	.\dtoa\double.h	/^        static double NaN() {$/;"	f	class:WTF::double_conversion::Double	access:public	signature:()
WTF::double_conversion::Double::NextDouble	.\dtoa\double.h	/^        double NextDouble() const {$/;"	f	class:WTF::double_conversion::Double	access:public	signature:() const
WTF::double_conversion::Double::NormalizedBoundaries	.\dtoa\double.h	/^        void NormalizedBoundaries(DiyFp* out_m_minus, DiyFp* out_m_plus) const {$/;"	f	class:WTF::double_conversion::Double	access:public	signature:(DiyFp* out_m_minus, DiyFp* out_m_plus) const
WTF::double_conversion::Double::Sign	.\dtoa\double.h	/^        int Sign() const {$/;"	f	class:WTF::double_conversion::Double	access:public	signature:() const
WTF::double_conversion::Double::Significand	.\dtoa\double.h	/^        uint64_t Significand() const {$/;"	f	class:WTF::double_conversion::Double	access:public	signature:() const
WTF::double_conversion::Double::SignificandSizeForOrderOfMagnitude	.\dtoa\double.h	/^        static int SignificandSizeForOrderOfMagnitude(int order) {$/;"	f	class:WTF::double_conversion::Double	access:public	signature:(int order)
WTF::double_conversion::Double::UpperBoundary	.\dtoa\double.h	/^        DiyFp UpperBoundary() const {$/;"	f	class:WTF::double_conversion::Double	access:public	signature:() const
WTF::double_conversion::Double::d64_	.\dtoa\double.h	/^        const uint64_t d64_;$/;"	m	class:WTF::double_conversion::Double	access:private
WTF::double_conversion::Double::kDenormalExponent	.\dtoa\double.h	/^        static const int kDenormalExponent = -kExponentBias + 1;$/;"	m	class:WTF::double_conversion::Double	access:private
WTF::double_conversion::Double::kExponentBias	.\dtoa\double.h	/^        static const int kExponentBias = 0x3FF + kPhysicalSignificandSize;$/;"	m	class:WTF::double_conversion::Double	access:private
WTF::double_conversion::Double::kExponentMask	.\dtoa\double.h	/^        static const uint64_t kExponentMask = UINT64_2PART_C(0x7FF00000, 00000000);$/;"	m	class:WTF::double_conversion::Double	access:public
WTF::double_conversion::Double::kHiddenBit	.\dtoa\double.h	/^        static const uint64_t kHiddenBit = UINT64_2PART_C(0x00100000, 00000000);$/;"	m	class:WTF::double_conversion::Double	access:public
WTF::double_conversion::Double::kInfinity	.\dtoa\double.h	/^        static const uint64_t kInfinity = UINT64_2PART_C(0x7FF00000, 00000000);$/;"	m	class:WTF::double_conversion::Double	access:private
WTF::double_conversion::Double::kMaxExponent	.\dtoa\double.h	/^        static const int kMaxExponent = 0x7FF - kExponentBias;$/;"	m	class:WTF::double_conversion::Double	access:private
WTF::double_conversion::Double::kNaN	.\dtoa\double.h	/^        static const uint64_t kNaN = UINT64_2PART_C(0x7FF80000, 00000000);$/;"	m	class:WTF::double_conversion::Double	access:private
WTF::double_conversion::Double::kPhysicalSignificandSize	.\dtoa\double.h	/^        static const int kPhysicalSignificandSize = 52;  \/\/ Excludes the hidden bit.$/;"	m	class:WTF::double_conversion::Double	access:public
WTF::double_conversion::Double::kSignMask	.\dtoa\double.h	/^        static const uint64_t kSignMask = UINT64_2PART_C(0x80000000, 00000000);$/;"	m	class:WTF::double_conversion::Double	access:public
WTF::double_conversion::Double::kSignificandMask	.\dtoa\double.h	/^        static const uint64_t kSignificandMask = UINT64_2PART_C(0x000FFFFF, FFFFFFFF);$/;"	m	class:WTF::double_conversion::Double	access:public
WTF::double_conversion::Double::kSignificandSize	.\dtoa\double.h	/^        static const int kSignificandSize = 53;$/;"	m	class:WTF::double_conversion::Double	access:public
WTF::double_conversion::Double::value	.\dtoa\double.h	/^        double value() const { return uint64_to_double(d64_); }$/;"	f	class:WTF::double_conversion::Double	access:public	signature:() const
WTF::double_conversion::DoubleStrtod	.\dtoa\strtod.cc	/^    static bool DoubleStrtod(Vector<const char> trimmed,$/;"	f	namespace:WTF::double_conversion	file:	signature:(Vector<const char> trimmed, int exponent, double* result)
WTF::double_conversion::DoubleToStringConverter	.\dtoa\double-conversion.h	/^    class DoubleToStringConverter {$/;"	c	namespace:WTF::double_conversion
WTF::double_conversion::DoubleToStringConverter::CreateDecimalRepresentation	.\dtoa\double-conversion.cc	/^    void DoubleToStringConverter::CreateDecimalRepresentation($/;"	f	class:WTF::double_conversion::DoubleToStringConverter	signature:( const char* decimal_digits, int length, int decimal_point, int digits_after_point, StringBuilder* result_builder) const
WTF::double_conversion::DoubleToStringConverter::CreateDecimalRepresentation	.\dtoa\double-conversion.h	/^        void CreateDecimalRepresentation(const char* decimal_digits,$/;"	p	class:WTF::double_conversion::DoubleToStringConverter	access:private	signature:(const char* decimal_digits, int length, int decimal_point, int digits_after_point, StringBuilder* result_builder) const
WTF::double_conversion::DoubleToStringConverter::CreateExponentialRepresentation	.\dtoa\double-conversion.cc	/^    void DoubleToStringConverter::CreateExponentialRepresentation($/;"	f	class:WTF::double_conversion::DoubleToStringConverter	signature:( const char* decimal_digits, int length, int exponent, StringBuilder* result_builder) const
WTF::double_conversion::DoubleToStringConverter::CreateExponentialRepresentation	.\dtoa\double-conversion.h	/^        void CreateExponentialRepresentation(const char* decimal_digits,$/;"	p	class:WTF::double_conversion::DoubleToStringConverter	access:private	signature:(const char* decimal_digits, int length, int exponent, StringBuilder* result_builder) const
WTF::double_conversion::DoubleToStringConverter::DISALLOW_IMPLICIT_CONSTRUCTORS	.\dtoa\double-conversion.h	/^        DISALLOW_IMPLICIT_CONSTRUCTORS(DoubleToStringConverter);$/;"	p	class:WTF::double_conversion::DoubleToStringConverter	access:private	signature:(DoubleToStringConverter)
WTF::double_conversion::DoubleToStringConverter::DoubleToAscii	.\dtoa\double-conversion.cc	/^    void DoubleToStringConverter::DoubleToAscii(double v,$/;"	f	class:WTF::double_conversion::DoubleToStringConverter	signature:(double v, DtoaMode mode, int requested_digits, char* buffer, int buffer_length, bool* sign, int* length, int* point)
WTF::double_conversion::DoubleToStringConverter::DoubleToAscii	.\dtoa\double-conversion.h	/^        static void DoubleToAscii(double v,$/;"	p	class:WTF::double_conversion::DoubleToStringConverter	access:public	signature:(double v, DtoaMode mode, int requested_digits, char* buffer, int buffer_length, bool* sign, int* length, int* point)
WTF::double_conversion::DoubleToStringConverter::DoubleToStringConverter	.\dtoa\double-conversion.h	/^        DoubleToStringConverter(int flags,$/;"	f	class:WTF::double_conversion::DoubleToStringConverter	access:public	signature:(int flags, const char* infinity_symbol, const char* nan_symbol, char exponent_character, int decimal_in_shortest_low, int decimal_in_shortest_high, int max_leading_padding_zeroes_in_precision_mode, int max_trailing_padding_zeroes_in_precision_mode)
WTF::double_conversion::DoubleToStringConverter::DtoaMode	.\dtoa\double-conversion.h	/^        enum DtoaMode {$/;"	g	class:WTF::double_conversion::DoubleToStringConverter	access:public
WTF::double_conversion::DoubleToStringConverter::EMIT_POSITIVE_EXPONENT_SIGN	.\dtoa\double-conversion.h	/^            EMIT_POSITIVE_EXPONENT_SIGN = 1,$/;"	e	enum:WTF::double_conversion::DoubleToStringConverter::Flags
WTF::double_conversion::DoubleToStringConverter::EMIT_TRAILING_DECIMAL_POINT	.\dtoa\double-conversion.h	/^            EMIT_TRAILING_DECIMAL_POINT = 2,$/;"	e	enum:WTF::double_conversion::DoubleToStringConverter::Flags
WTF::double_conversion::DoubleToStringConverter::EMIT_TRAILING_ZERO_AFTER_POINT	.\dtoa\double-conversion.h	/^            EMIT_TRAILING_ZERO_AFTER_POINT = 4,$/;"	e	enum:WTF::double_conversion::DoubleToStringConverter::Flags
WTF::double_conversion::DoubleToStringConverter::EcmaScriptConverter	.\dtoa\double-conversion.cc	/^    const DoubleToStringConverter& DoubleToStringConverter::EcmaScriptConverter() {$/;"	f	class:WTF::double_conversion::DoubleToStringConverter	signature:()
WTF::double_conversion::DoubleToStringConverter::EcmaScriptConverter	.\dtoa\double-conversion.h	/^        static const DoubleToStringConverter& EcmaScriptConverter();$/;"	p	class:WTF::double_conversion::DoubleToStringConverter	access:public	signature:()
WTF::double_conversion::DoubleToStringConverter::FIXED	.\dtoa\double-conversion.h	/^            FIXED,$/;"	e	enum:WTF::double_conversion::DoubleToStringConverter::DtoaMode
WTF::double_conversion::DoubleToStringConverter::Flags	.\dtoa\double-conversion.h	/^        enum Flags {$/;"	g	class:WTF::double_conversion::DoubleToStringConverter	access:public
WTF::double_conversion::DoubleToStringConverter::HandleSpecialValues	.\dtoa\double-conversion.cc	/^    bool DoubleToStringConverter::HandleSpecialValues($/;"	f	class:WTF::double_conversion::DoubleToStringConverter	signature:( double value, StringBuilder* result_builder) const
WTF::double_conversion::DoubleToStringConverter::HandleSpecialValues	.\dtoa\double-conversion.h	/^        bool HandleSpecialValues(double value, StringBuilder* result_builder) const;$/;"	p	class:WTF::double_conversion::DoubleToStringConverter	access:private	signature:(double value, StringBuilder* result_builder) const
WTF::double_conversion::DoubleToStringConverter::NO_FLAGS	.\dtoa\double-conversion.h	/^            NO_FLAGS = 0,$/;"	e	enum:WTF::double_conversion::DoubleToStringConverter::Flags
WTF::double_conversion::DoubleToStringConverter::PRECISION	.\dtoa\double-conversion.h	/^            PRECISION$/;"	e	enum:WTF::double_conversion::DoubleToStringConverter::DtoaMode
WTF::double_conversion::DoubleToStringConverter::SHORTEST	.\dtoa\double-conversion.h	/^            SHORTEST,$/;"	e	enum:WTF::double_conversion::DoubleToStringConverter::DtoaMode
WTF::double_conversion::DoubleToStringConverter::ToExponential	.\dtoa\double-conversion.cc	/^    bool DoubleToStringConverter::ToExponential($/;"	f	class:WTF::double_conversion::DoubleToStringConverter	signature:( double value, int requested_digits, StringBuilder* result_builder) const
WTF::double_conversion::DoubleToStringConverter::ToExponential	.\dtoa\double-conversion.h	/^        bool ToExponential(double value,$/;"	p	class:WTF::double_conversion::DoubleToStringConverter	access:public	signature:(double value, int requested_digits, StringBuilder* result_builder) const
WTF::double_conversion::DoubleToStringConverter::ToFixed	.\dtoa\double-conversion.cc	/^    bool DoubleToStringConverter::ToFixed(double value,$/;"	f	class:WTF::double_conversion::DoubleToStringConverter	signature:(double value, int requested_digits, StringBuilder* result_builder) const
WTF::double_conversion::DoubleToStringConverter::ToFixed	.\dtoa\double-conversion.h	/^        bool ToFixed(double value,$/;"	p	class:WTF::double_conversion::DoubleToStringConverter	access:public	signature:(double value, int requested_digits, StringBuilder* result_builder) const
WTF::double_conversion::DoubleToStringConverter::ToPrecision	.\dtoa\double-conversion.cc	/^    bool DoubleToStringConverter::ToPrecision(double value,$/;"	f	class:WTF::double_conversion::DoubleToStringConverter	signature:(double value, int precision, StringBuilder* result_builder) const
WTF::double_conversion::DoubleToStringConverter::ToPrecision	.\dtoa\double-conversion.h	/^        bool ToPrecision(double value,$/;"	p	class:WTF::double_conversion::DoubleToStringConverter	access:public	signature:(double value, int precision, StringBuilder* result_builder) const
WTF::double_conversion::DoubleToStringConverter::ToShortest	.\dtoa\double-conversion.cc	/^    bool DoubleToStringConverter::ToShortest(double value,$/;"	f	class:WTF::double_conversion::DoubleToStringConverter	signature:(double value, StringBuilder* result_builder) const
WTF::double_conversion::DoubleToStringConverter::ToShortest	.\dtoa\double-conversion.h	/^        bool ToShortest(double value, StringBuilder* result_builder) const;$/;"	p	class:WTF::double_conversion::DoubleToStringConverter	access:public	signature:(double value, StringBuilder* result_builder) const
WTF::double_conversion::DoubleToStringConverter::UNIQUE_ZERO	.\dtoa\double-conversion.h	/^            UNIQUE_ZERO = 8$/;"	e	enum:WTF::double_conversion::DoubleToStringConverter::Flags
WTF::double_conversion::DoubleToStringConverter::decimal_in_shortest_high_	.\dtoa\double-conversion.h	/^        const int decimal_in_shortest_high_;$/;"	m	class:WTF::double_conversion::DoubleToStringConverter	access:private
WTF::double_conversion::DoubleToStringConverter::decimal_in_shortest_low_	.\dtoa\double-conversion.h	/^        const int decimal_in_shortest_low_;$/;"	m	class:WTF::double_conversion::DoubleToStringConverter	access:private
WTF::double_conversion::DoubleToStringConverter::exponent_character_	.\dtoa\double-conversion.h	/^        const char exponent_character_;$/;"	m	class:WTF::double_conversion::DoubleToStringConverter	access:private
WTF::double_conversion::DoubleToStringConverter::flags_	.\dtoa\double-conversion.h	/^        const int flags_;$/;"	m	class:WTF::double_conversion::DoubleToStringConverter	access:private
WTF::double_conversion::DoubleToStringConverter::infinity_symbol_	.\dtoa\double-conversion.h	/^        const char* const infinity_symbol_;$/;"	m	class:WTF::double_conversion::DoubleToStringConverter	access:private
WTF::double_conversion::DoubleToStringConverter::kBase10MaximalLength	.\dtoa\double-conversion.h	/^        static const int kBase10MaximalLength = 17;$/;"	m	class:WTF::double_conversion::DoubleToStringConverter	access:public
WTF::double_conversion::DoubleToStringConverter::kMaxExponentialDigits	.\dtoa\double-conversion.h	/^        static const int kMaxExponentialDigits = 120;$/;"	m	class:WTF::double_conversion::DoubleToStringConverter	access:public
WTF::double_conversion::DoubleToStringConverter::kMaxFixedDigitsAfterPoint	.\dtoa\double-conversion.h	/^        static const int kMaxFixedDigitsAfterPoint = 60;$/;"	m	class:WTF::double_conversion::DoubleToStringConverter	access:public
WTF::double_conversion::DoubleToStringConverter::kMaxFixedDigitsBeforePoint	.\dtoa\double-conversion.h	/^        static const int kMaxFixedDigitsBeforePoint = 60;$/;"	m	class:WTF::double_conversion::DoubleToStringConverter	access:public
WTF::double_conversion::DoubleToStringConverter::kMaxPrecisionDigits	.\dtoa\double-conversion.h	/^        static const int kMaxPrecisionDigits = 120;$/;"	m	class:WTF::double_conversion::DoubleToStringConverter	access:public
WTF::double_conversion::DoubleToStringConverter::kMinPrecisionDigits	.\dtoa\double-conversion.h	/^        static const int kMinPrecisionDigits = 1;$/;"	m	class:WTF::double_conversion::DoubleToStringConverter	access:public
WTF::double_conversion::DoubleToStringConverter::max_leading_padding_zeroes_in_precision_mode_	.\dtoa\double-conversion.h	/^        const int max_leading_padding_zeroes_in_precision_mode_;$/;"	m	class:WTF::double_conversion::DoubleToStringConverter	access:private
WTF::double_conversion::DoubleToStringConverter::max_trailing_padding_zeroes_in_precision_mode_	.\dtoa\double-conversion.h	/^        const int max_trailing_padding_zeroes_in_precision_mode_;$/;"	m	class:WTF::double_conversion::DoubleToStringConverter	access:private
WTF::double_conversion::DoubleToStringConverter::nan_symbol_	.\dtoa\double-conversion.h	/^        const char* const nan_symbol_;$/;"	m	class:WTF::double_conversion::DoubleToStringConverter	access:private
WTF::double_conversion::DtoaToBignumDtoaMode	.\dtoa\double-conversion.cc	/^    static BignumDtoaMode DtoaToBignumDtoaMode($/;"	f	namespace:WTF::double_conversion	file:	signature:( DoubleToStringConverter::DtoaMode dtoa_mode)
WTF::double_conversion::EstimatePower	.\dtoa\bignum-dtoa.cc	/^    static int EstimatePower(int exponent) {$/;"	f	namespace:WTF::double_conversion	file:	signature:(int exponent)
WTF::double_conversion::EstimatePower	.\dtoa\bignum-dtoa.cc	/^    static int EstimatePower(int exponent);$/;"	p	namespace:WTF::double_conversion	file:	signature:(int exponent)
WTF::double_conversion::FAST_DTOA_PRECISION	.\dtoa\fast-dtoa.h	/^        FAST_DTOA_PRECISION$/;"	e	enum:WTF::double_conversion::FastDtoaMode
WTF::double_conversion::FAST_DTOA_SHORTEST	.\dtoa\fast-dtoa.h	/^        FAST_DTOA_SHORTEST,$/;"	e	enum:WTF::double_conversion::FastDtoaMode
WTF::double_conversion::FastDtoa	.\dtoa\fast-dtoa.cc	/^    bool FastDtoa(double v,$/;"	f	namespace:WTF::double_conversion	signature:(double v, FastDtoaMode mode, int requested_digits, Vector<char> buffer, int* length, int* decimal_point)
WTF::double_conversion::FastDtoa	.\dtoa\fast-dtoa.h	/^    bool FastDtoa(double d,$/;"	p	namespace:WTF::double_conversion	signature:(double d, FastDtoaMode mode, int requested_digits, Vector<char> buffer, int* length, int* decimal_point)
WTF::double_conversion::FastDtoaMode	.\dtoa\fast-dtoa.h	/^    enum FastDtoaMode {$/;"	g	namespace:WTF::double_conversion
WTF::double_conversion::FastFixedDtoa	.\dtoa\fixed-dtoa.cc	/^    bool FastFixedDtoa(double v,$/;"	f	namespace:WTF::double_conversion	signature:(double v, int fractional_count, Vector<char> buffer, int* length, int* decimal_point)
WTF::double_conversion::FastFixedDtoa	.\dtoa\fixed-dtoa.h	/^    bool FastFixedDtoa(double v, int fractional_count,$/;"	p	namespace:WTF::double_conversion	signature:(double v, int fractional_count, Vector<char> buffer, int* length, int* decimal_point)
WTF::double_conversion::FillDigits32	.\dtoa\fixed-dtoa.cc	/^    static void FillDigits32(uint32_t number, Vector<char> buffer, int* length) {$/;"	f	namespace:WTF::double_conversion	file:	signature:(uint32_t number, Vector<char> buffer, int* length)
WTF::double_conversion::FillDigits32FixedLength	.\dtoa\fixed-dtoa.cc	/^    static void FillDigits32FixedLength(uint32_t number, int requested_length,$/;"	f	namespace:WTF::double_conversion	file:	signature:(uint32_t number, int requested_length, Vector<char> buffer, int* length)
WTF::double_conversion::FillDigits64	.\dtoa\fixed-dtoa.cc	/^    static void FillDigits64(uint64_t number, Vector<char> buffer, int* length) {$/;"	f	namespace:WTF::double_conversion	file:	signature:(uint64_t number, Vector<char> buffer, int* length)
WTF::double_conversion::FillDigits64FixedLength	.\dtoa\fixed-dtoa.cc	/^    static void FillDigits64FixedLength(uint64_t number, int requested_length,$/;"	f	namespace:WTF::double_conversion	file:	signature:(uint64_t number, int requested_length, Vector<char> buffer, int* length)
WTF::double_conversion::FillFractionals	.\dtoa\fixed-dtoa.cc	/^    static void FillFractionals(uint64_t fractionals, int exponent,$/;"	f	namespace:WTF::double_conversion	file:	signature:(uint64_t fractionals, int exponent, int fractional_count, Vector<char> buffer, int* length, int* decimal_point)
WTF::double_conversion::FixupMultiply10	.\dtoa\bignum-dtoa.cc	/^    static void FixupMultiply10(int estimated_power, bool is_even,$/;"	f	namespace:WTF::double_conversion	file:	signature:(int estimated_power, bool is_even, int* decimal_point, Bignum* numerator, Bignum* denominator, Bignum* delta_minus, Bignum* delta_plus)
WTF::double_conversion::FixupMultiply10	.\dtoa\bignum-dtoa.cc	/^    static void FixupMultiply10(int estimated_power, bool is_even,$/;"	p	namespace:WTF::double_conversion	file:	signature:(int estimated_power, bool is_even, int* decimal_point, Bignum* numerator, Bignum* denominator, Bignum* delta_minus, Bignum* delta_plus)
WTF::double_conversion::GenerateCountedDigits	.\dtoa\bignum-dtoa.cc	/^    static void GenerateCountedDigits(int count, int* decimal_point,$/;"	f	namespace:WTF::double_conversion	file:	signature:(int count, int* decimal_point, Bignum* numerator, Bignum* denominator, Vector<char>(buffer), int* length)
WTF::double_conversion::GenerateCountedDigits	.\dtoa\bignum-dtoa.cc	/^    static void GenerateCountedDigits(int count, int* decimal_point,$/;"	p	namespace:WTF::double_conversion	file:	signature:(int count, int* decimal_point, Bignum* numerator, Bignum* denominator, Vector<char>(buffer), int* length)
WTF::double_conversion::GenerateShortestDigits	.\dtoa\bignum-dtoa.cc	/^    static void GenerateShortestDigits(Bignum* numerator, Bignum* denominator,$/;"	f	namespace:WTF::double_conversion	file:	signature:(Bignum* numerator, Bignum* denominator, Bignum* delta_minus, Bignum* delta_plus, bool is_even, Vector<char> buffer, int* length)
WTF::double_conversion::GenerateShortestDigits	.\dtoa\bignum-dtoa.cc	/^    static void GenerateShortestDigits(Bignum* numerator, Bignum* denominator,$/;"	p	namespace:WTF::double_conversion	file:	signature:(Bignum* numerator, Bignum* denominator, Bignum* delta_minus, Bignum* delta_plus, bool is_even, Vector<char> buffer, int* length)
WTF::double_conversion::Grisu3	.\dtoa\fast-dtoa.cc	/^    static bool Grisu3(double v,$/;"	f	namespace:WTF::double_conversion	file:	signature:(double v, Vector<char> buffer, int* length, int* decimal_exponent)
WTF::double_conversion::Grisu3Counted	.\dtoa\fast-dtoa.cc	/^    static bool Grisu3Counted(double v,$/;"	f	namespace:WTF::double_conversion	file:	signature:(double v, int requested_digits, Vector<char> buffer, int* length, int* decimal_exponent)
WTF::double_conversion::HexCharOfValue	.\dtoa\bignum.cc	/^    static char HexCharOfValue(int value) {$/;"	f	namespace:WTF::double_conversion	file:	signature:(int value)
WTF::double_conversion::HexCharValue	.\dtoa\bignum.cc	/^    static int HexCharValue(char c) {$/;"	f	namespace:WTF::double_conversion	file:	signature:(char c)
WTF::double_conversion::InitialScaledStartValues	.\dtoa\bignum-dtoa.cc	/^    static void InitialScaledStartValues(double v,$/;"	f	namespace:WTF::double_conversion	file:	signature:(double v, int estimated_power, bool need_boundary_deltas, Bignum* numerator, Bignum* denominator, Bignum* delta_minus, Bignum* delta_plus)
WTF::double_conversion::InitialScaledStartValues	.\dtoa\bignum-dtoa.cc	/^    static void InitialScaledStartValues(double v,$/;"	p	namespace:WTF::double_conversion	file:	signature:(double v, int estimated_power, bool need_boundary_deltas, Bignum* numerator, Bignum* denominator, Bignum* delta_minus, Bignum* delta_plus)
WTF::double_conversion::InitialScaledStartValuesNegativeExponentNegativePower	.\dtoa\bignum-dtoa.cc	/^    static void InitialScaledStartValuesNegativeExponentNegativePower($/;"	f	namespace:WTF::double_conversion	file:	signature:( double v, int estimated_power, bool need_boundary_deltas, Bignum* numerator, Bignum* denominator, Bignum* delta_minus, Bignum* delta_plus)
WTF::double_conversion::InitialScaledStartValuesNegativeExponentPositivePower	.\dtoa\bignum-dtoa.cc	/^    static void InitialScaledStartValuesNegativeExponentPositivePower($/;"	f	namespace:WTF::double_conversion	file:	signature:( double v, int estimated_power, bool need_boundary_deltas, Bignum* numerator, Bignum* denominator, Bignum* delta_minus, Bignum* delta_plus)
WTF::double_conversion::InitialScaledStartValuesPositiveExponent	.\dtoa\bignum-dtoa.cc	/^    static void InitialScaledStartValuesPositiveExponent($/;"	f	namespace:WTF::double_conversion	file:	signature:( double v, int estimated_power, bool need_boundary_deltas, Bignum* numerator, Bignum* denominator, Bignum* delta_minus, Bignum* delta_plus)
WTF::double_conversion::Max	.\dtoa\utils.h	/^    static T Max(T a, T b) {$/;"	f	namespace:WTF::double_conversion	signature:(T a, T b)
WTF::double_conversion::Min	.\dtoa\utils.h	/^    static T Min(T a, T b) {$/;"	f	namespace:WTF::double_conversion	signature:(T a, T b)
WTF::double_conversion::NormalizedExponent	.\dtoa\bignum-dtoa.cc	/^    static int NormalizedExponent(uint64_t significand, int exponent) {$/;"	f	namespace:WTF::double_conversion	file:	signature:(uint64_t significand, int exponent)
WTF::double_conversion::PowersOfTenCache	.\dtoa\cached-powers.h	/^    class PowersOfTenCache {$/;"	c	namespace:WTF::double_conversion
WTF::double_conversion::PowersOfTenCache::GetCachedPowerForBinaryExponentRange	.\dtoa\cached-powers.cc	/^    void PowersOfTenCache::GetCachedPowerForBinaryExponentRange($/;"	f	class:WTF::double_conversion::PowersOfTenCache	signature:( int min_exponent, int max_exponent, DiyFp* power, int* decimal_exponent)
WTF::double_conversion::PowersOfTenCache::GetCachedPowerForBinaryExponentRange	.\dtoa\cached-powers.h	/^        static void GetCachedPowerForBinaryExponentRange(int min_exponent,$/;"	p	class:WTF::double_conversion::PowersOfTenCache	access:public	signature:(int min_exponent, int max_exponent, DiyFp* power, int* decimal_exponent)
WTF::double_conversion::PowersOfTenCache::GetCachedPowerForDecimalExponent	.\dtoa\cached-powers.cc	/^    void PowersOfTenCache::GetCachedPowerForDecimalExponent(int requested_exponent,$/;"	f	class:WTF::double_conversion::PowersOfTenCache	signature:(int requested_exponent, DiyFp* power, int* found_exponent)
WTF::double_conversion::PowersOfTenCache::GetCachedPowerForDecimalExponent	.\dtoa\cached-powers.h	/^        static void GetCachedPowerForDecimalExponent(int requested_exponent,$/;"	p	class:WTF::double_conversion::PowersOfTenCache	access:public	signature:(int requested_exponent, DiyFp* power, int* found_exponent)
WTF::double_conversion::PowersOfTenCache::kDecimalExponentDistance	.\dtoa\cached-powers.cc	/^    int PowersOfTenCache::kDecimalExponentDistance = 1;$/;"	m	class:WTF::double_conversion::PowersOfTenCache	file:
WTF::double_conversion::PowersOfTenCache::kDecimalExponentDistance	.\dtoa\cached-powers.h	/^        static int kDecimalExponentDistance;$/;"	m	class:WTF::double_conversion::PowersOfTenCache	access:public
WTF::double_conversion::PowersOfTenCache::kMaxDecimalExponent	.\dtoa\cached-powers.cc	/^    int PowersOfTenCache::kMaxDecimalExponent = 1;$/;"	m	class:WTF::double_conversion::PowersOfTenCache	file:
WTF::double_conversion::PowersOfTenCache::kMaxDecimalExponent	.\dtoa\cached-powers.h	/^        static int kMaxDecimalExponent;$/;"	m	class:WTF::double_conversion::PowersOfTenCache	access:public
WTF::double_conversion::PowersOfTenCache::kMinDecimalExponent	.\dtoa\cached-powers.cc	/^    int PowersOfTenCache::kMinDecimalExponent = 1;$/;"	m	class:WTF::double_conversion::PowersOfTenCache	file:
WTF::double_conversion::PowersOfTenCache::kMinDecimalExponent	.\dtoa\cached-powers.h	/^        static int kMinDecimalExponent;$/;"	m	class:WTF::double_conversion::PowersOfTenCache	access:public
WTF::double_conversion::RadixStringToDouble	.\dtoa\double-conversion.cc	/^    static double RadixStringToDouble(const char* current,$/;"	f	namespace:WTF::double_conversion	file:	signature:(const char* current, const char* end, bool sign, bool allow_trailing_junk, double junk_string_value, const char** trailing_pointer)
WTF::double_conversion::ReadDiyFp	.\dtoa\strtod.cc	/^    static void ReadDiyFp(Vector<const char> buffer,$/;"	f	namespace:WTF::double_conversion	file:	signature:(Vector<const char> buffer, DiyFp* result, int* remaining_decimals)
WTF::double_conversion::ReadUInt64	.\dtoa\bignum.cc	/^    static uint64_t ReadUInt64(Vector<const char> buffer,$/;"	f	namespace:WTF::double_conversion	file:	signature:(Vector<const char> buffer, int from, int digits_to_read)
WTF::double_conversion::ReadUint64	.\dtoa\strtod.cc	/^    static uint64_t ReadUint64(Vector<const char> buffer,$/;"	f	namespace:WTF::double_conversion	file:	signature:(Vector<const char> buffer, int* number_of_read_digits)
WTF::double_conversion::RoundUp	.\dtoa\fixed-dtoa.cc	/^    static void RoundUp(Vector<char> buffer, int* length, int* decimal_point) {$/;"	f	namespace:WTF::double_conversion	file:	signature:(Vector<char> buffer, int* length, int* decimal_point)
WTF::double_conversion::RoundWeed	.\dtoa\fast-dtoa.cc	/^    static bool RoundWeed(Vector<char> buffer,$/;"	f	namespace:WTF::double_conversion	file:	signature:(Vector<char> buffer, int length, uint64_t distance_too_high_w, uint64_t unsafe_interval, uint64_t rest, uint64_t ten_kappa, uint64_t unit)
WTF::double_conversion::RoundWeedCounted	.\dtoa\fast-dtoa.cc	/^    static bool RoundWeedCounted(Vector<char> buffer,$/;"	f	namespace:WTF::double_conversion	file:	signature:(Vector<char> buffer, int length, uint64_t rest, uint64_t ten_kappa, uint64_t unit, int* kappa)
WTF::double_conversion::SignedZero	.\dtoa\double-conversion.cc	/^    static double SignedZero(bool sign) {$/;"	f	namespace:WTF::double_conversion	file:	signature:(bool sign)
WTF::double_conversion::SizeInHexChars	.\dtoa\bignum.cc	/^    static int SizeInHexChars(S number) {$/;"	f	namespace:WTF::double_conversion	file:	signature:(S number)
WTF::double_conversion::StrLength	.\dtoa\utils.h	/^    inline int StrLength(const char* string) {$/;"	f	namespace:WTF::double_conversion	signature:(const char* string)
WTF::double_conversion::StringBuilder	.\dtoa\utils.h	/^    class StringBuilder {$/;"	c	namespace:WTF::double_conversion
WTF::double_conversion::StringBuilder::AddCharacter	.\dtoa\utils.h	/^        void AddCharacter(char c) {$/;"	f	class:WTF::double_conversion::StringBuilder	access:public	signature:(char c)
WTF::double_conversion::StringBuilder::AddPadding	.\dtoa\utils.h	/^        void AddPadding(char c, int count) {$/;"	f	class:WTF::double_conversion::StringBuilder	access:public	signature:(char c, int count)
WTF::double_conversion::StringBuilder::AddString	.\dtoa\utils.h	/^        void AddString(const char* s) {$/;"	f	class:WTF::double_conversion::StringBuilder	access:public	signature:(const char* s)
WTF::double_conversion::StringBuilder::AddSubstring	.\dtoa\utils.h	/^        void AddSubstring(const char* s, int n) {$/;"	f	class:WTF::double_conversion::StringBuilder	access:public	signature:(const char* s, int n)
WTF::double_conversion::StringBuilder::DISALLOW_IMPLICIT_CONSTRUCTORS	.\dtoa\utils.h	/^        DISALLOW_IMPLICIT_CONSTRUCTORS(StringBuilder);$/;"	p	class:WTF::double_conversion::StringBuilder	access:private	signature:(StringBuilder)
WTF::double_conversion::StringBuilder::Finalize	.\dtoa\utils.h	/^        char* Finalize() {$/;"	f	class:WTF::double_conversion::StringBuilder	access:public	signature:()
WTF::double_conversion::StringBuilder::Reset	.\dtoa\utils.h	/^        void Reset() { position_ = 0; }$/;"	f	class:WTF::double_conversion::StringBuilder	access:public	signature:()
WTF::double_conversion::StringBuilder::SetPosition	.\dtoa\utils.h	/^        void SetPosition(int position)$/;"	f	class:WTF::double_conversion::StringBuilder	access:public	signature:(int position)
WTF::double_conversion::StringBuilder::StringBuilder	.\dtoa\utils.h	/^        StringBuilder(char* buffer, int size)$/;"	f	class:WTF::double_conversion::StringBuilder	access:public	signature:(char* buffer, int size)
WTF::double_conversion::StringBuilder::buffer_	.\dtoa\utils.h	/^        Vector<char> buffer_;$/;"	m	class:WTF::double_conversion::StringBuilder	access:private
WTF::double_conversion::StringBuilder::is_finalized	.\dtoa\utils.h	/^        bool is_finalized() const { return position_ < 0; }$/;"	f	class:WTF::double_conversion::StringBuilder	access:private	signature:() const
WTF::double_conversion::StringBuilder::position	.\dtoa\utils.h	/^        int position() const {$/;"	f	class:WTF::double_conversion::StringBuilder	access:public	signature:() const
WTF::double_conversion::StringBuilder::position_	.\dtoa\utils.h	/^        int position_;$/;"	m	class:WTF::double_conversion::StringBuilder	access:private
WTF::double_conversion::StringBuilder::size	.\dtoa\utils.h	/^        int size() const { return buffer_.length(); }$/;"	f	class:WTF::double_conversion::StringBuilder	access:public	signature:() const
WTF::double_conversion::StringBuilder::~StringBuilder	.\dtoa\utils.h	/^        ~StringBuilder() { if (!is_finalized()) Finalize(); }$/;"	f	class:WTF::double_conversion::StringBuilder	access:public	signature:()
WTF::double_conversion::StringToDoubleConverter	.\dtoa\double-conversion.h	/^    class StringToDoubleConverter {$/;"	c	namespace:WTF::double_conversion
WTF::double_conversion::StringToDoubleConverter::ALLOW_HEX	.\dtoa\double-conversion.h	/^            ALLOW_HEX = 1,$/;"	e	enum:WTF::double_conversion::StringToDoubleConverter::Flags
WTF::double_conversion::StringToDoubleConverter::ALLOW_LEADING_SPACES	.\dtoa\double-conversion.h	/^            ALLOW_LEADING_SPACES = 8,$/;"	e	enum:WTF::double_conversion::StringToDoubleConverter::Flags
WTF::double_conversion::StringToDoubleConverter::ALLOW_OCTALS	.\dtoa\double-conversion.h	/^            ALLOW_OCTALS = 2,$/;"	e	enum:WTF::double_conversion::StringToDoubleConverter::Flags
WTF::double_conversion::StringToDoubleConverter::ALLOW_SPACES_AFTER_SIGN	.\dtoa\double-conversion.h	/^            ALLOW_SPACES_AFTER_SIGN = 32$/;"	e	enum:WTF::double_conversion::StringToDoubleConverter::Flags
WTF::double_conversion::StringToDoubleConverter::ALLOW_TRAILING_JUNK	.\dtoa\double-conversion.h	/^            ALLOW_TRAILING_JUNK = 4,$/;"	e	enum:WTF::double_conversion::StringToDoubleConverter::Flags
WTF::double_conversion::StringToDoubleConverter::ALLOW_TRAILING_SPACES	.\dtoa\double-conversion.h	/^            ALLOW_TRAILING_SPACES = 16,$/;"	e	enum:WTF::double_conversion::StringToDoubleConverter::Flags
WTF::double_conversion::StringToDoubleConverter::DISALLOW_IMPLICIT_CONSTRUCTORS	.\dtoa\double-conversion.h	/^        DISALLOW_IMPLICIT_CONSTRUCTORS(StringToDoubleConverter);$/;"	p	class:WTF::double_conversion::StringToDoubleConverter	access:private	signature:(StringToDoubleConverter)
WTF::double_conversion::StringToDoubleConverter::Flags	.\dtoa\double-conversion.h	/^        enum Flags {$/;"	g	class:WTF::double_conversion::StringToDoubleConverter	access:public
WTF::double_conversion::StringToDoubleConverter::NO_FLAGS	.\dtoa\double-conversion.h	/^            NO_FLAGS = 0,$/;"	e	enum:WTF::double_conversion::StringToDoubleConverter::Flags
WTF::double_conversion::StringToDoubleConverter::StringToDouble	.\dtoa\double-conversion.cc	/^    double StringToDoubleConverter::StringToDouble($/;"	f	class:WTF::double_conversion::StringToDoubleConverter	signature:( const char* input, int length, int* processed_characters_count)
WTF::double_conversion::StringToDoubleConverter::StringToDouble	.\dtoa\double-conversion.h	/^        double StringToDouble(const char* buffer,$/;"	p	class:WTF::double_conversion::StringToDoubleConverter	access:public	signature:(const char* buffer, int length, int* processed_characters_count)
WTF::double_conversion::StringToDoubleConverter::StringToDoubleConverter	.\dtoa\double-conversion.h	/^        StringToDoubleConverter(int flags,$/;"	f	class:WTF::double_conversion::StringToDoubleConverter	access:public	signature:(int flags, double empty_string_value, double junk_string_value, const char* infinity_symbol, const char* nan_symbol)
WTF::double_conversion::StringToDoubleConverter::empty_string_value_	.\dtoa\double-conversion.h	/^        const double empty_string_value_;$/;"	m	class:WTF::double_conversion::StringToDoubleConverter	access:private
WTF::double_conversion::StringToDoubleConverter::flags_	.\dtoa\double-conversion.h	/^        const int flags_;$/;"	m	class:WTF::double_conversion::StringToDoubleConverter	access:private
WTF::double_conversion::StringToDoubleConverter::infinity_symbol_	.\dtoa\double-conversion.h	/^        const char* const infinity_symbol_;$/;"	m	class:WTF::double_conversion::StringToDoubleConverter	access:private
WTF::double_conversion::StringToDoubleConverter::junk_string_value_	.\dtoa\double-conversion.h	/^        const double junk_string_value_;$/;"	m	class:WTF::double_conversion::StringToDoubleConverter	access:private
WTF::double_conversion::StringToDoubleConverter::nan_symbol_	.\dtoa\double-conversion.h	/^        const char* const nan_symbol_;$/;"	m	class:WTF::double_conversion::StringToDoubleConverter	access:private
WTF::double_conversion::Strtod	.\dtoa\strtod.cc	/^    double Strtod(Vector<const char> buffer, int exponent) {$/;"	f	namespace:WTF::double_conversion	signature:(Vector<const char> buffer, int exponent)
WTF::double_conversion::Strtod	.\dtoa\strtod.h	/^    double Strtod(Vector<const char> buffer, int exponent);$/;"	p	namespace:WTF::double_conversion	signature:(Vector<const char> buffer, int exponent)
WTF::double_conversion::TrimLeadingZeros	.\dtoa\strtod.cc	/^    static Vector<const char> TrimLeadingZeros(Vector<const char> buffer) {$/;"	f	namespace:WTF::double_conversion	file:	signature:(Vector<const char> buffer)
WTF::double_conversion::TrimToMaxSignificantDigits	.\dtoa\strtod.cc	/^    static void TrimToMaxSignificantDigits(Vector<const char> buffer,$/;"	f	namespace:WTF::double_conversion	file:	signature:(Vector<const char> buffer, int exponent, char* significant_buffer, int* significant_exponent)
WTF::double_conversion::TrimTrailingZeros	.\dtoa\strtod.cc	/^    static Vector<const char> TrimTrailingZeros(Vector<const char> buffer) {$/;"	f	namespace:WTF::double_conversion	file:	signature:(Vector<const char> buffer)
WTF::double_conversion::TrimZeros	.\dtoa\fixed-dtoa.cc	/^    static void TrimZeros(Vector<char> buffer, int* length, int* decimal_point) {$/;"	f	namespace:WTF::double_conversion	file:	signature:(Vector<char> buffer, int* length, int* decimal_point)
WTF::double_conversion::UInt128	.\dtoa\fixed-dtoa.cc	/^    class UInt128 {$/;"	c	namespace:WTF::double_conversion	file:
WTF::double_conversion::UInt128::BitAt	.\dtoa\fixed-dtoa.cc	/^        int BitAt(int position) {$/;"	f	class:WTF::double_conversion::UInt128	access:public	signature:(int position)
WTF::double_conversion::UInt128::DivModPowerOf2	.\dtoa\fixed-dtoa.cc	/^        int DivModPowerOf2(int power) {$/;"	f	class:WTF::double_conversion::UInt128	access:public	signature:(int power)
WTF::double_conversion::UInt128::IsZero	.\dtoa\fixed-dtoa.cc	/^        bool IsZero() const {$/;"	f	class:WTF::double_conversion::UInt128	access:public	signature:() const
WTF::double_conversion::UInt128::Multiply	.\dtoa\fixed-dtoa.cc	/^        void Multiply(uint32_t multiplicand) {$/;"	f	class:WTF::double_conversion::UInt128	access:public	signature:(uint32_t multiplicand)
WTF::double_conversion::UInt128::Shift	.\dtoa\fixed-dtoa.cc	/^        void Shift(int shift_amount) {$/;"	f	class:WTF::double_conversion::UInt128	access:public	signature:(int shift_amount)
WTF::double_conversion::UInt128::UInt128	.\dtoa\fixed-dtoa.cc	/^        UInt128() : high_bits_(0), low_bits_(0) { }$/;"	f	class:WTF::double_conversion::UInt128	access:public	signature:()
WTF::double_conversion::UInt128::UInt128	.\dtoa\fixed-dtoa.cc	/^        UInt128(uint64_t high, uint64_t low) : high_bits_(high), low_bits_(low) { }$/;"	f	class:WTF::double_conversion::UInt128	access:public	signature:(uint64_t high, uint64_t low)
WTF::double_conversion::UInt128::high_bits_	.\dtoa\fixed-dtoa.cc	/^        uint64_t high_bits_;$/;"	m	class:WTF::double_conversion::UInt128	file:	access:private
WTF::double_conversion::UInt128::kMask32	.\dtoa\fixed-dtoa.cc	/^        static const uint64_t kMask32 = 0xFFFFFFFF;$/;"	m	class:WTF::double_conversion::UInt128	file:	access:private
WTF::double_conversion::UInt128::low_bits_	.\dtoa\fixed-dtoa.cc	/^        uint64_t low_bits_;$/;"	m	class:WTF::double_conversion::UInt128	file:	access:private
WTF::double_conversion::Vector	.\dtoa\utils.h	/^    class Vector {$/;"	c	namespace:WTF::double_conversion
WTF::double_conversion::Vector::SubVector	.\dtoa\utils.h	/^        Vector<T> SubVector(int from, int to) {$/;"	f	class:WTF::double_conversion::Vector	access:public	signature:(int from, int to)
WTF::double_conversion::Vector::Vector	.\dtoa\utils.h	/^        Vector() : start_(NULL), length_(0) {}$/;"	f	class:WTF::double_conversion::Vector	access:public	signature:()
WTF::double_conversion::Vector::Vector	.\dtoa\utils.h	/^        Vector(T* data, int length) : start_(data), length_(length) {$/;"	f	class:WTF::double_conversion::Vector	access:public	signature:(T* data, int length)
WTF::double_conversion::Vector::first	.\dtoa\utils.h	/^        T& first() { return start_[0]; }$/;"	f	class:WTF::double_conversion::Vector	access:public	signature:()
WTF::double_conversion::Vector::is_empty	.\dtoa\utils.h	/^        bool is_empty() const { return length_ == 0; }$/;"	f	class:WTF::double_conversion::Vector	access:public	signature:() const
WTF::double_conversion::Vector::last	.\dtoa\utils.h	/^        T& last() { return start_[length_ - 1]; }$/;"	f	class:WTF::double_conversion::Vector	access:public	signature:()
WTF::double_conversion::Vector::length	.\dtoa\utils.h	/^        int length() const { return length_; }$/;"	f	class:WTF::double_conversion::Vector	access:public	signature:() const
WTF::double_conversion::Vector::length_	.\dtoa\utils.h	/^        int length_;$/;"	m	class:WTF::double_conversion::Vector	access:private
WTF::double_conversion::Vector::operator []	.\dtoa\utils.h	/^        T& operator[](int index) const {$/;"	f	class:WTF::double_conversion::Vector	access:public	signature:(int index) const
WTF::double_conversion::Vector::start	.\dtoa\utils.h	/^        T* start() const { return start_; }$/;"	f	class:WTF::double_conversion::Vector	access:public	signature:() const
WTF::double_conversion::Vector::start_	.\dtoa\utils.h	/^        T* start_;$/;"	m	class:WTF::double_conversion::Vector	access:private
WTF::double_conversion::double_to_uint64	.\dtoa\double.h	/^    static uint64_t double_to_uint64(double d) { return BitCast<uint64_t>(d); }$/;"	f	namespace:WTF::double_conversion	signature:(double d)
WTF::double_conversion::exact_powers_of_ten	.\dtoa\strtod.cc	/^    static const double exact_powers_of_ten[] = {$/;"	v	file:
WTF::double_conversion::initialize	.\dtoa\cached-powers.cc	/^    void initialize() {$/;"	f	namespace:WTF::double_conversion	signature:()
WTF::double_conversion::initialize	.\dtoa\cached-powers.h	/^    void initialize();$/;"	p	namespace:WTF::double_conversion	signature:()
WTF::double_conversion::isDigit	.\dtoa\double-conversion.cc	/^    static bool isDigit(int x, int radix) {$/;"	f	namespace:WTF::double_conversion	file:	signature:(int x, int radix)
WTF::double_conversion::kCachedPowers	.\dtoa\cached-powers.cc	/^    static CachedPower* kCachedPowers = 0;$/;"	v	file:
WTF::double_conversion::kCachedPowersLength	.\dtoa\cached-powers.cc	/^    static int kCachedPowersLength = 1;$/;"	v	file:
WTF::double_conversion::kCachedPowersOffset	.\dtoa\cached-powers.cc	/^    static int kCachedPowersOffset = 1;$/;"	v	file:
WTF::double_conversion::kCharSize	.\dtoa\utils.h	/^    static const int kCharSize = sizeof(char);$/;"	v
WTF::double_conversion::kD_1_LOG2_10	.\dtoa\cached-powers.cc	/^    static const double kD_1_LOG2_10 = 0.30102999566398114;  \/\/  1 \/ lg(10)$/;"	v	file:
WTF::double_conversion::kDoubleSignificandSize	.\dtoa\fixed-dtoa.cc	/^    static const int kDoubleSignificandSize = 53;  \/\/ Includes the hidden bit.$/;"	v	file:
WTF::double_conversion::kExactPowersOfTenSize	.\dtoa\strtod.cc	/^    static const int kExactPowersOfTenSize = ARRAY_SIZE(exact_powers_of_ten);$/;"	v	file:
WTF::double_conversion::kFastDtoaMaximalLength	.\dtoa\fast-dtoa.h	/^    static const int kFastDtoaMaximalLength = 17;$/;"	v
WTF::double_conversion::kMaxDecimalPower	.\dtoa\strtod.cc	/^    static const int kMaxDecimalPower = 309;$/;"	v	file:
WTF::double_conversion::kMaxExactDoubleIntegerDecimalDigits	.\dtoa\strtod.cc	/^    static const int kMaxExactDoubleIntegerDecimalDigits = 15;$/;"	v	file:
WTF::double_conversion::kMaxSignificantDecimalDigits	.\dtoa\strtod.cc	/^    static const int kMaxSignificantDecimalDigits = 780;$/;"	v	file:
WTF::double_conversion::kMaxSignificantDigits	.\dtoa\double-conversion.cc	/^    const int kMaxSignificantDigits = 772;$/;"	v
WTF::double_conversion::kMaxUint64	.\dtoa\strtod.cc	/^    static const uint64_t kMaxUint64 = UINT64_2PART_C(0xFFFFFFFF, FFFFFFFF);$/;"	v	file:
WTF::double_conversion::kMaxUint64DecimalDigits	.\dtoa\strtod.cc	/^    static const int kMaxUint64DecimalDigits = 19;$/;"	v	file:
WTF::double_conversion::kMaximalTargetExponent	.\dtoa\fast-dtoa.cc	/^    static const int kMaximalTargetExponent = -32;$/;"	v	file:
WTF::double_conversion::kMinDecimalPower	.\dtoa\strtod.cc	/^    static const int kMinDecimalPower = -324;$/;"	v	file:
WTF::double_conversion::kMinimalTargetExponent	.\dtoa\fast-dtoa.cc	/^    static const int kMinimalTargetExponent = -60;$/;"	v	file:
WTF::double_conversion::kTen4	.\dtoa\fast-dtoa.cc	/^    static const uint32_t kTen4 = 10000;$/;"	v	file:
WTF::double_conversion::kTen5	.\dtoa\fast-dtoa.cc	/^    static const uint32_t kTen5 = 100000;$/;"	v	file:
WTF::double_conversion::kTen6	.\dtoa\fast-dtoa.cc	/^    static const uint32_t kTen6 = 1000000;$/;"	v	file:
WTF::double_conversion::kTen7	.\dtoa\fast-dtoa.cc	/^    static const uint32_t kTen7 = 10000000;$/;"	v	file:
WTF::double_conversion::kTen8	.\dtoa\fast-dtoa.cc	/^    static const uint32_t kTen8 = 100000000;$/;"	v	file:
WTF::double_conversion::kTen9	.\dtoa\fast-dtoa.cc	/^    static const uint32_t kTen9 = 1000000000;$/;"	v	file:
WTF::double_conversion::uint64_to_double	.\dtoa\double.h	/^    static double uint64_to_double(uint64_t d64) { return BitCast<double>(d64); }$/;"	f	namespace:WTF::double_conversion	signature:(uint64_t d64)
WTF::dtoa	.\dtoa.cpp	/^void dtoa(DtoaBuffer result, double dd, bool& sign, int& exponent, unsigned& precision)$/;"	f	namespace:WTF	signature:(DtoaBuffer result, double dd, bool& sign, int& exponent, unsigned& precision)
WTF::dtoa	.\dtoa.cpp	/^void dtoa(DtoaBuffer result, double dd, int ndigits, bool& signOut, int& exponentOut, unsigned& precisionOut)$/;"	f	namespace:WTF	signature:(DtoaBuffer result, double dd, int ndigits, bool& signOut, int& exponentOut, unsigned& precisionOut)
WTF::dtoa	.\dtoa.h	/^WTF_EXPORT_PRIVATE void dtoa(DtoaBuffer result, double dd, bool& sign, int& exponent, unsigned& precision);$/;"	p	namespace:WTF	signature:(DtoaBuffer result, double dd, bool& sign, int& exponent, unsigned& precision)
WTF::dtoaRoundDP	.\dtoa.cpp	/^void dtoaRoundDP(DtoaBuffer result, double dd, int ndigits, bool& sign, int& exponent, unsigned& precision)$/;"	f	namespace:WTF	signature:(DtoaBuffer result, double dd, int ndigits, bool& sign, int& exponent, unsigned& precision)
WTF::dtoaRoundDP	.\dtoa.h	/^WTF_EXPORT_PRIVATE void dtoaRoundDP(DtoaBuffer result, double dd, int ndigits, bool& sign, int& exponent, unsigned& precision);$/;"	p	namespace:WTF	signature:(DtoaBuffer result, double dd, int ndigits, bool& sign, int& exponent, unsigned& precision)
WTF::dtoaRoundSF	.\dtoa.cpp	/^void dtoaRoundSF(DtoaBuffer result, double dd, int ndigits, bool& sign, int& exponent, unsigned& precision)$/;"	f	namespace:WTF	signature:(DtoaBuffer result, double dd, int ndigits, bool& sign, int& exponent, unsigned& precision)
WTF::dtoaRoundSF	.\dtoa.h	/^WTF_EXPORT_PRIVATE void dtoaRoundSF(DtoaBuffer result, double dd, int ndigits, bool& sign, int& exponent, unsigned& precision);$/;"	p	namespace:WTF	signature:(DtoaBuffer result, double dd, int ndigits, bool& sign, int& exponent, unsigned& precision)
WTF::emptyString	.\text\WTFString.cpp	/^const String& emptyString()$/;"	f	namespace:WTF	signature:()
WTF::emptyString	.\text\WTFString.h	/^WTF_EXPORT_PRIVATE const String& emptyString();$/;"	p	namespace:WTF	signature:()
WTF::equal	.\text\StringBuilder.h	/^bool equal(const StringBuilder& a, const StringType& b)$/;"	f	namespace:WTF	signature:(const StringBuilder& a, const StringType& b)
WTF::equal	.\text\StringBuilder.h	/^bool equal(const StringBuilder& s, const CharType* buffer, unsigned length)$/;"	f	namespace:WTF	signature:(const StringBuilder& s, const CharType* buffer, unsigned length)
WTF::equal	.\text\StringImpl.cpp	/^bool equal(const StringImpl* a, const LChar* b)$/;"	f	namespace:WTF	signature:(const StringImpl* a, const LChar* b)
WTF::equal	.\text\StringImpl.cpp	/^bool equal(const StringImpl* a, const LChar* b, unsigned length)$/;"	f	namespace:WTF	signature:(const StringImpl* a, const LChar* b, unsigned length)
WTF::equal	.\text\StringImpl.cpp	/^bool equal(const StringImpl* a, const StringImpl* b)$/;"	f	namespace:WTF	signature:(const StringImpl* a, const StringImpl* b)
WTF::equal	.\text\StringImpl.cpp	/^bool equal(const StringImpl* a, const UChar* b, unsigned length)$/;"	f	namespace:WTF	signature:(const StringImpl* a, const UChar* b, unsigned length)
WTF::equal	.\text\StringImpl.h	/^ALWAYS_INLINE bool equal(const LChar* a, const LChar* b, unsigned length)$/;"	f	namespace:WTF	signature:(const LChar* a, const LChar* b, unsigned length)
WTF::equal	.\text\StringImpl.h	/^ALWAYS_INLINE bool equal(const LChar* a, const UChar* b, unsigned length)$/;"	f	namespace:WTF	signature:(const LChar* a, const UChar* b, unsigned length)
WTF::equal	.\text\StringImpl.h	/^ALWAYS_INLINE bool equal(const UChar* a, const LChar* b, unsigned length)$/;"	f	namespace:WTF	signature:(const UChar* a, const LChar* b, unsigned length)
WTF::equal	.\text\StringImpl.h	/^ALWAYS_INLINE bool equal(const UChar* a, const UChar* b, unsigned length)$/;"	f	namespace:WTF	signature:(const UChar* a, const UChar* b, unsigned length)
WTF::equal	.\text\StringImpl.h	/^WTF_EXPORT_PRIVATE bool equal(const StringImpl*, const LChar*);$/;"	p	namespace:WTF	signature:(const StringImpl*, const LChar*)
WTF::equal	.\text\StringImpl.h	/^WTF_EXPORT_PRIVATE bool equal(const StringImpl*, const LChar*, unsigned);$/;"	p	namespace:WTF	signature:(const StringImpl*, const LChar*, unsigned)
WTF::equal	.\text\StringImpl.h	/^WTF_EXPORT_PRIVATE bool equal(const StringImpl*, const StringImpl*);$/;"	p	namespace:WTF	signature:(const StringImpl*, const StringImpl*)
WTF::equal	.\text\StringImpl.h	/^WTF_EXPORT_PRIVATE bool equal(const StringImpl*, const UChar*, unsigned);$/;"	p	namespace:WTF	signature:(const StringImpl*, const UChar*, unsigned)
WTF::equal	.\text\StringImpl.h	/^inline bool equal(const LChar* a, StringImpl* b) { return equal(b, a); }$/;"	f	namespace:WTF	signature:(const LChar* a, StringImpl* b)
WTF::equal	.\text\StringImpl.h	/^inline bool equal(const StringImpl* a, const char* b) { return equal(a, reinterpret_cast<const LChar*>(b)); }$/;"	f	namespace:WTF	signature:(const StringImpl* a, const char* b)
WTF::equal	.\text\StringImpl.h	/^inline bool equal(const StringImpl* a, const char* b, unsigned length) { return equal(a, reinterpret_cast<const LChar*>(b), length); }$/;"	f	namespace:WTF	signature:(const StringImpl* a, const char* b, unsigned length)
WTF::equal	.\text\StringImpl.h	/^inline bool equal(const char* a, StringImpl* b) { return equal(b, reinterpret_cast<const LChar*>(a)); }$/;"	f	namespace:WTF	signature:(const char* a, StringImpl* b)
WTF::equalIgnoringCase	.\text\AtomicString.h	/^inline bool equalIgnoringCase(const AtomicString& a, const AtomicString& b) { return equalIgnoringCase(a.impl(), b.impl()); }$/;"	f	namespace:WTF	signature:(const AtomicString& a, const AtomicString& b)
WTF::equalIgnoringCase	.\text\AtomicString.h	/^inline bool equalIgnoringCase(const AtomicString& a, const LChar* b) { return equalIgnoringCase(a.impl(), b); }$/;"	f	namespace:WTF	signature:(const AtomicString& a, const LChar* b)
WTF::equalIgnoringCase	.\text\AtomicString.h	/^inline bool equalIgnoringCase(const AtomicString& a, const String& b) { return equalIgnoringCase(a.impl(), b.impl()); }$/;"	f	namespace:WTF	signature:(const AtomicString& a, const String& b)
WTF::equalIgnoringCase	.\text\AtomicString.h	/^inline bool equalIgnoringCase(const AtomicString& a, const char* b) { return equalIgnoringCase(a.impl(), reinterpret_cast<const LChar*>(b)); }$/;"	f	namespace:WTF	signature:(const AtomicString& a, const char* b)
WTF::equalIgnoringCase	.\text\AtomicString.h	/^inline bool equalIgnoringCase(const LChar* a, const AtomicString& b) { return equalIgnoringCase(a, b.impl()); }$/;"	f	namespace:WTF	signature:(const LChar* a, const AtomicString& b)
WTF::equalIgnoringCase	.\text\AtomicString.h	/^inline bool equalIgnoringCase(const String& a, const AtomicString& b) { return equalIgnoringCase(a.impl(), b.impl()); }$/;"	f	namespace:WTF	signature:(const String& a, const AtomicString& b)
WTF::equalIgnoringCase	.\text\AtomicString.h	/^inline bool equalIgnoringCase(const char* a, const AtomicString& b) { return equalIgnoringCase(reinterpret_cast<const LChar*>(a), b.impl()); }$/;"	f	namespace:WTF	signature:(const char* a, const AtomicString& b)
WTF::equalIgnoringCase	.\text\StringImpl.cpp	/^bool equalIgnoringCase(StringImpl* a, StringImpl* b)$/;"	f	namespace:WTF	signature:(StringImpl* a, StringImpl* b)
WTF::equalIgnoringCase	.\text\StringImpl.cpp	/^bool equalIgnoringCase(StringImpl* a, const LChar* b)$/;"	f	namespace:WTF	signature:(StringImpl* a, const LChar* b)
WTF::equalIgnoringCase	.\text\StringImpl.cpp	/^bool equalIgnoringCase(const LChar* a, const LChar* b, unsigned length)$/;"	f	namespace:WTF	signature:(const LChar* a, const LChar* b, unsigned length)
WTF::equalIgnoringCase	.\text\StringImpl.cpp	/^bool equalIgnoringCase(const UChar* a, const LChar* b, unsigned length)$/;"	f	namespace:WTF	signature:(const UChar* a, const LChar* b, unsigned length)
WTF::equalIgnoringCase	.\text\StringImpl.cpp	/^static inline bool equalIgnoringCase(const UChar* a, const UChar* b, int length)$/;"	f	namespace:WTF	file:	signature:(const UChar* a, const UChar* b, int length)
WTF::equalIgnoringCase	.\text\StringImpl.h	/^WTF_EXPORT_PRIVATE bool equalIgnoringCase(StringImpl*, StringImpl*);$/;"	p	namespace:WTF	signature:(StringImpl*, StringImpl*)
WTF::equalIgnoringCase	.\text\StringImpl.h	/^WTF_EXPORT_PRIVATE bool equalIgnoringCase(StringImpl*, const LChar*);$/;"	p	namespace:WTF	signature:(StringImpl*, const LChar*)
WTF::equalIgnoringCase	.\text\StringImpl.h	/^WTF_EXPORT_PRIVATE bool equalIgnoringCase(const LChar*, const LChar*, unsigned);$/;"	p	namespace:WTF	signature:(const LChar*, const LChar*, unsigned)
WTF::equalIgnoringCase	.\text\StringImpl.h	/^WTF_EXPORT_PRIVATE bool equalIgnoringCase(const UChar*, const LChar*, unsigned);$/;"	p	namespace:WTF	signature:(const UChar*, const LChar*, unsigned)
WTF::equalIgnoringCase	.\text\StringImpl.h	/^inline bool equalIgnoringCase(const LChar* a, StringImpl* b) { return equalIgnoringCase(b, a); }$/;"	f	namespace:WTF	signature:(const LChar* a, StringImpl* b)
WTF::equalIgnoringCase	.\text\StringImpl.h	/^inline bool equalIgnoringCase(const LChar* a, const UChar* b, unsigned length) { return equalIgnoringCase(b, a, length); }$/;"	f	namespace:WTF	signature:(const LChar* a, const UChar* b, unsigned length)
WTF::equalIgnoringCase	.\text\StringImpl.h	/^inline bool equalIgnoringCase(const UChar* a, const char* b, unsigned length) { return equalIgnoringCase(a, reinterpret_cast<const LChar*>(b), length); }$/;"	f	namespace:WTF	signature:(const UChar* a, const char* b, unsigned length)
WTF::equalIgnoringCase	.\text\StringImpl.h	/^inline bool equalIgnoringCase(const char* a, const UChar* b, unsigned length) { return equalIgnoringCase(b, reinterpret_cast<const LChar*>(a), length); }$/;"	f	namespace:WTF	signature:(const char* a, const UChar* b, unsigned length)
WTF::equalIgnoringCase	.\text\WTFString.h	/^inline bool equalIgnoringCase(const LChar* a, const String& b) { return equalIgnoringCase(a, b.impl()); }$/;"	f	namespace:WTF	signature:(const LChar* a, const String& b)
WTF::equalIgnoringCase	.\text\WTFString.h	/^inline bool equalIgnoringCase(const String& a, const LChar* b) { return equalIgnoringCase(a.impl(), b); }$/;"	f	namespace:WTF	signature:(const String& a, const LChar* b)
WTF::equalIgnoringCase	.\text\WTFString.h	/^inline bool equalIgnoringCase(const String& a, const String& b) { return equalIgnoringCase(a.impl(), b.impl()); }$/;"	f	namespace:WTF	signature:(const String& a, const String& b)
WTF::equalIgnoringCase	.\text\WTFString.h	/^inline bool equalIgnoringCase(const String& a, const char* b) { return equalIgnoringCase(a.impl(), reinterpret_cast<const LChar*>(b)); }$/;"	f	namespace:WTF	signature:(const String& a, const char* b)
WTF::equalIgnoringCase	.\text\WTFString.h	/^inline bool equalIgnoringCase(const char* a, const String& b) { return equalIgnoringCase(reinterpret_cast<const LChar*>(a), b.impl()); }$/;"	f	namespace:WTF	signature:(const char* a, const String& b)
WTF::equalIgnoringNullity	.\text\StringImpl.cpp	/^bool equalIgnoringNullity(StringImpl* a, StringImpl* b)$/;"	f	namespace:WTF	signature:(StringImpl* a, StringImpl* b)
WTF::equalIgnoringNullity	.\text\StringImpl.h	/^WTF_EXPORT_PRIVATE bool equalIgnoringNullity(StringImpl*, StringImpl*);$/;"	p	namespace:WTF	signature:(StringImpl*, StringImpl*)
WTF::equalIgnoringNullity	.\text\StringImpl.h	/^bool equalIgnoringNullity(const Vector<UChar, inlineCapacity>& a, StringImpl* b)$/;"	f	namespace:WTF	signature:(const Vector<UChar, inlineCapacity>& a, StringImpl* b)
WTF::equalIgnoringNullity	.\text\WTFString.h	/^inline bool equalIgnoringNullity(const String& a, const String& b) { return equalIgnoringNullity(a.impl(), b.impl()); }$/;"	f	namespace:WTF	signature:(const String& a, const String& b)
WTF::equalIgnoringNullity	.\text\WTFString.h	/^inline bool equalIgnoringNullity(const Vector<UChar, inlineCapacity>& a, const String& b) { return equalIgnoringNullity(a, b.impl()); }$/;"	f	namespace:WTF	signature:(const Vector<UChar, inlineCapacity>& a, const String& b)
WTF::equalPossiblyIgnoringCase	.\text\WTFString.h	/^inline bool equalPossiblyIgnoringCase(const String& a, const String& b, bool ignoreCase) $/;"	f	namespace:WTF	signature:(const String& a, const String& b, bool ignoreCase)
WTF::equivalentYearForDST	.\DateMath.cpp	/^int equivalentYearForDST(int year)$/;"	f	namespace:WTF	signature:(int year)
WTF::equivalentYearForDST	.\DateMath.h	/^int equivalentYearForDST(int year);$/;"	p	namespace:WTF	signature:(int year)
WTF::establishIdentifierForPthreadHandle	.\ThreadingPthreads.cpp	/^static ThreadIdentifier establishIdentifierForPthreadHandle(const pthread_t& pthreadHandle)$/;"	f	namespace:WTF	file:	signature:(const pthread_t& pthreadHandle)
WTF::estimateStackBound	.\StackBounds.cpp	/^static void* estimateStackBound(void* origin)$/;"	f	namespace:WTF	file:	signature:(void* origin)
WTF::estimatedStackSize	.\StackBounds.cpp	/^static const ptrdiff_t estimatedStackSize = 128 * sizeof(void*) * 1024;$/;"	v	file:
WTF::f	.\SHA1.cpp	/^static inline uint32_t f(int t, uint32_t b, uint32_t c, uint32_t d)$/;"	f	namespace:WTF	file:	signature:(int t, uint32_t b, uint32_t c, uint32_t d)
WTF::false_type	.\TypeTraits.h	/^    typedef IntegralConstant<bool, false> false_type;$/;"	t	namespace:WTF
WTF::fastCalloc	.\FastMalloc.cpp	/^void* fastCalloc(size_t n, size_t elem_size)$/;"	f	namespace:WTF	signature:(size_t n, size_t elem_size)
WTF::fastCalloc	.\FastMalloc.cpp	/^void* fastCalloc(size_t n_elements, size_t element_size)$/;"	f	namespace:WTF	signature:(size_t n_elements, size_t element_size)
WTF::fastCalloc	.\FastMalloc.h	/^    WTF_EXPORT_PRIVATE void* fastCalloc(size_t numElements, size_t elementSize);$/;"	p	namespace:WTF	signature:(size_t numElements, size_t elementSize)
WTF::fastCalloc	.\wince\MemoryManager.cpp	/^void *fastCalloc(size_t n_elements, size_t element_size) { return MemoryManager::m_calloc(n_elements, element_size); }$/;"	f	namespace:WTF	signature:(size_t n_elements, size_t element_size)
WTF::fastCalloc	.\wince\MemoryManager.cpp	/^void *fastCalloc(size_t n_elements, size_t element_size) { return calloc(n_elements, element_size); }$/;"	f	namespace:WTF	signature:(size_t n_elements, size_t element_size)
WTF::fastDelete	.\FastAllocBase.h	/^    inline void fastDelete(T* p)$/;"	f	namespace:WTF	signature:(T* p)
WTF::fastDeleteAllValues	.\HashSet.h	/^    inline void fastDeleteAllValues(const HashSet<T, U, V>& collection)$/;"	f	namespace:WTF	signature:(const HashSet<T, U, V>& collection)
WTF::fastDeleteAllValues	.\HashSet.h	/^    void fastDeleteAllValues(HashTableType& collection)$/;"	f	namespace:WTF	signature:(HashTableType& collection)
WTF::fastDeleteAllValues	.\HashSet.h	/^    void fastDeleteAllValues(const HashSet<Value, HashFunctions, Traits>&);$/;"	p	namespace:WTF	signature:(const HashSet<Value, HashFunctions, Traits>&)
WTF::fastDeleteArray	.\FastAllocBase.h	/^    void fastDeleteArray(T* p)$/;"	f	namespace:WTF	signature:(T* p)
WTF::fastDeleteSkippingDestructor	.\FastAllocBase.h	/^    inline void fastDeleteSkippingDestructor(T* p)$/;"	f	namespace:WTF	signature:(T* p)
WTF::fastFree	.\FastMalloc.cpp	/^void fastFree(void* p)$/;"	f	namespace:WTF	signature:(void* p)
WTF::fastFree	.\FastMalloc.h	/^    WTF_EXPORT_PRIVATE void fastFree(void*);$/;"	p	namespace:WTF	signature:(void*)
WTF::fastFree	.\wince\MemoryManager.cpp	/^void fastFree(void* p) { return MemoryManager::m_free(p); }$/;"	f	namespace:WTF	signature:(void* p)
WTF::fastFree	.\wince\MemoryManager.cpp	/^void fastFree(void* p) { return free(p); }$/;"	f	namespace:WTF	signature:(void* p)
WTF::fastMalloc	.\FastMalloc.cpp	/^void* fastMalloc(size_t n) $/;"	f	namespace:WTF	signature:(size_t n)
WTF::fastMalloc	.\FastMalloc.cpp	/^void* fastMalloc(size_t size)$/;"	f	namespace:WTF	signature:(size_t size)
WTF::fastMalloc	.\FastMalloc.h	/^    WTF_EXPORT_PRIVATE void* fastMalloc(size_t);$/;"	p	namespace:WTF	signature:(size_t)
WTF::fastMalloc	.\wince\MemoryManager.cpp	/^void *fastMalloc(size_t n) { return MemoryManager::m_malloc(n); }$/;"	f	namespace:WTF	signature:(size_t n)
WTF::fastMalloc	.\wince\MemoryManager.cpp	/^void *fastMalloc(size_t n) { return malloc(n); }$/;"	f	namespace:WTF	signature:(size_t n)
WTF::fastMallocAllow	.\FastMalloc.cpp	/^void fastMallocAllow()$/;"	f	namespace:WTF	signature:()
WTF::fastMallocAllow	.\FastMalloc.h	/^    void fastMallocAllow();$/;"	p	namespace:WTF	signature:()
WTF::fastMallocAllow	.\wince\MemoryManager.cpp	/^void fastMallocAllow() {}$/;"	f	namespace:WTF	signature:()
WTF::fastMallocForbid	.\FastMalloc.cpp	/^void fastMallocForbid()$/;"	f	namespace:WTF	signature:()
WTF::fastMallocForbid	.\FastMalloc.h	/^    void fastMallocForbid();$/;"	p	namespace:WTF	signature:()
WTF::fastMallocForbid	.\wince\MemoryManager.cpp	/^void fastMallocForbid() {}$/;"	f	namespace:WTF	signature:()
WTF::fastMallocMatchValidateFree	.\FastMalloc.h	/^    inline void fastMallocMatchValidateFree(void* p, Internal::AllocType)$/;"	f	namespace:WTF	signature:(void* p, Internal::AllocType)
WTF::fastMallocMatchValidateFree	.\FastMalloc.h	/^    inline void fastMallocMatchValidateFree(void*, Internal::AllocType)$/;"	f	namespace:WTF	signature:(void*, Internal::AllocType)
WTF::fastMallocMatchValidateFree	.\wince\FastMallocWinCE.h	/^    inline void fastMallocMatchValidateFree(void* p, Internal::AllocType allocType)$/;"	f	namespace:WTF	signature:(void* p, Internal::AllocType allocType)
WTF::fastMallocMatchValidateFree	.\wince\FastMallocWinCE.h	/^    inline void fastMallocMatchValidateFree(void*, Internal::AllocType)$/;"	f	namespace:WTF	signature:(void*, Internal::AllocType)
WTF::fastMallocMatchValidateMalloc	.\FastMalloc.h	/^    inline void fastMallocMatchValidateMalloc(void* p, Internal::AllocType allocType)$/;"	f	namespace:WTF	signature:(void* p, Internal::AllocType allocType)
WTF::fastMallocMatchValidateMalloc	.\FastMalloc.h	/^    inline void fastMallocMatchValidateMalloc(void*, Internal::AllocType)$/;"	f	namespace:WTF	signature:(void*, Internal::AllocType)
WTF::fastMallocMatchValidateMalloc	.\wince\FastMallocWinCE.h	/^    inline void fastMallocMatchValidateMalloc(void* p, Internal::AllocType allocType)$/;"	f	namespace:WTF	signature:(void* p, Internal::AllocType allocType)
WTF::fastMallocMatchValidateMalloc	.\wince\FastMallocWinCE.h	/^    inline void fastMallocMatchValidateMalloc(void*, Internal::AllocType)$/;"	f	namespace:WTF	signature:(void*, Internal::AllocType)
WTF::fastMallocSize	.\FastMalloc.cpp	/^size_t fastMallocSize(const void* p)$/;"	f	namespace:WTF	signature:(const void* p)
WTF::fastMallocSize	.\FastMalloc.cpp	/^size_t fastMallocSize(const void* ptr)$/;"	f	namespace:WTF	signature:(const void* ptr)
WTF::fastMallocSize	.\FastMalloc.h	/^    WTF_EXPORT_PRIVATE size_t fastMallocSize(const void*);$/;"	p	namespace:WTF	signature:(const void*)
WTF::fastMallocStatistics	.\FastMalloc.cpp	/^FastMallocStatistics fastMallocStatistics()$/;"	f	namespace:WTF	signature:()
WTF::fastMallocStatistics	.\FastMalloc.h	/^    WTF_EXPORT_PRIVATE FastMallocStatistics fastMallocStatistics();$/;"	p	namespace:WTF	signature:()
WTF::fastMallocValidate	.\FastMalloc.h	/^    inline void fastMallocValidate(void* p)$/;"	f	namespace:WTF	signature:(void* p)
WTF::fastNew	.\FastAllocBase.h	/^    inline T* fastNew()$/;"	f	namespace:WTF	signature:()
WTF::fastNew	.\FastAllocBase.h	/^    inline T* fastNew(Arg1 arg1)$/;"	f	namespace:WTF	signature:(Arg1 arg1)
WTF::fastNew	.\FastAllocBase.h	/^    inline T* fastNew(Arg1 arg1, Arg2 arg2)$/;"	f	namespace:WTF	signature:(Arg1 arg1, Arg2 arg2)
WTF::fastNew	.\FastAllocBase.h	/^    inline T* fastNew(Arg1 arg1, Arg2 arg2, Arg3 arg3)$/;"	f	namespace:WTF	signature:(Arg1 arg1, Arg2 arg2, Arg3 arg3)
WTF::fastNew	.\FastAllocBase.h	/^    inline T* fastNew(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4)$/;"	f	namespace:WTF	signature:(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4)
WTF::fastNew	.\FastAllocBase.h	/^    inline T* fastNew(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5)$/;"	f	namespace:WTF	signature:(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5)
WTF::fastNewArray	.\FastAllocBase.h	/^    inline T* fastNewArray(size_t count)$/;"	f	namespace:WTF	signature:(size_t count)
WTF::fastNonNullDelete	.\FastAllocBase.h	/^    inline void fastNonNullDelete(T* p)$/;"	f	namespace:WTF	signature:(T* p)
WTF::fastNonNullDeleteArray	.\FastAllocBase.h	/^    void fastNonNullDeleteArray(T* p)$/;"	f	namespace:WTF	signature:(T* p)
WTF::fastRealloc	.\FastMalloc.cpp	/^void* fastRealloc(void* old_ptr, size_t new_size)$/;"	f	namespace:WTF	signature:(void* old_ptr, size_t new_size)
WTF::fastRealloc	.\FastMalloc.cpp	/^void* fastRealloc(void* p, size_t n)$/;"	f	namespace:WTF	signature:(void* p, size_t n)
WTF::fastRealloc	.\FastMalloc.h	/^    WTF_EXPORT_PRIVATE void* fastRealloc(void*, size_t);$/;"	p	namespace:WTF	signature:(void*, size_t)
WTF::fastRealloc	.\wince\MemoryManager.cpp	/^void *fastRealloc(void* p, size_t n) { return MemoryManager::m_realloc(p, n); }$/;"	f	namespace:WTF	signature:(void* p, size_t n)
WTF::fastRealloc	.\wince\MemoryManager.cpp	/^void *fastRealloc(void* p, size_t n) { return realloc(p, n); }$/;"	f	namespace:WTF	signature:(void* p, size_t n)
WTF::fastStrDup	.\FastMalloc.cpp	/^char* fastStrDup(const char* src)$/;"	f	namespace:WTF	signature:(const char* src)
WTF::fastStrDup	.\FastMalloc.h	/^    WTF_EXPORT_PRIVATE char* fastStrDup(const char*);$/;"	p	namespace:WTF	signature:(const char*)
WTF::fastStrDup	.\wince\MemoryManager.cpp	/^char* fastStrDup(const char* str)$/;"	f	namespace:WTF	signature:(const char* str)
WTF::fastZeroedMalloc	.\FastMalloc.cpp	/^void* fastZeroedMalloc(size_t n) $/;"	f	namespace:WTF	signature:(size_t n)
WTF::fastZeroedMalloc	.\FastMalloc.h	/^    WTF_EXPORT_PRIVATE void* fastZeroedMalloc(size_t);$/;"	p	namespace:WTF	signature:(size_t)
WTF::fastZeroedMalloc	.\wince\MemoryManager.cpp	/^void* fastZeroedMalloc(size_t n)$/;"	f	namespace:WTF	signature:(size_t n)
WTF::file	.\DataLog.cpp	/^static FILE* file;$/;"	v	file:
WTF::find	.\text\WTFString.h	/^inline size_t find(const LChar* characters, unsigned length, CharacterMatchFunctionPtr matchFunction, unsigned index = 0)$/;"	f	namespace:WTF	signature:(const LChar* characters, unsigned length, CharacterMatchFunctionPtr matchFunction, unsigned index = 0)
WTF::find	.\text\WTFString.h	/^inline size_t find(const LChar* characters, unsigned length, LChar matchCharacter, unsigned index = 0)$/;"	f	namespace:WTF	signature:(const LChar* characters, unsigned length, LChar matchCharacter, unsigned index = 0)
WTF::find	.\text\WTFString.h	/^inline size_t find(const UChar* characters, unsigned length, CharacterMatchFunctionPtr matchFunction, unsigned index = 0)$/;"	f	namespace:WTF	signature:(const UChar* characters, unsigned length, CharacterMatchFunctionPtr matchFunction, unsigned index = 0)
WTF::find	.\text\WTFString.h	/^inline size_t find(const UChar* characters, unsigned length, UChar matchCharacter, unsigned index = 0)$/;"	f	namespace:WTF	signature:(const UChar* characters, unsigned length, UChar matchCharacter, unsigned index = 0)
WTF::findInner	.\text\StringImpl.cpp	/^ALWAYS_INLINE static size_t findInner(const CharType* searchCharacters, const CharType* matchCharacters, unsigned index, unsigned searchLength, unsigned matchLength)$/;"	f	namespace:WTF	file:	signature:(const CharType* searchCharacters, const CharType* matchCharacters, unsigned index, unsigned searchLength, unsigned matchLength)
WTF::findMonth	.\DateMath.cpp	/^static int findMonth(const char* monthStr)$/;"	f	namespace:WTF	file:	signature:(const char* monthStr)
WTF::firstDayOfMonth	.\DateMath.cpp	/^static const int firstDayOfMonth[2][12] = {$/;"	v	file:
WTF::formatStringTruncatingTrailingZerosIfNeeded	.\dtoa.cpp	/^static inline const char* formatStringTruncatingTrailingZerosIfNeeded(NumberToStringBuffer buffer, double_conversion::StringBuilder& builder)$/;"	f	namespace:WTF	file:	signature:(NumberToStringBuffer buffer, double_conversion::StringBuilder& builder)
WTF::free	.\FastMalloc.cpp	/^void free(void* ptr) {$/;"	f	namespace:WTF	signature:(void* ptr)
WTF::freeOwnedGPtr	.\gobject\GOwnPtr.cpp	/^template <> void freeOwnedGPtr<GDir>(GDir* ptr)$/;"	f	namespace:WTF	signature:(GDir* ptr)
WTF::freeOwnedGPtr	.\gobject\GOwnPtr.cpp	/^template <> void freeOwnedGPtr<GError>(GError* ptr)$/;"	f	namespace:WTF	signature:(GError* ptr)
WTF::freeOwnedGPtr	.\gobject\GOwnPtr.cpp	/^template <> void freeOwnedGPtr<GKeyFile>(GKeyFile* ptr)$/;"	f	namespace:WTF	signature:(GKeyFile* ptr)
WTF::freeOwnedGPtr	.\gobject\GOwnPtr.cpp	/^template <> void freeOwnedGPtr<GList>(GList* ptr)$/;"	f	namespace:WTF	signature:(GList* ptr)
WTF::freeOwnedGPtr	.\gobject\GOwnPtr.cpp	/^template <> void freeOwnedGPtr<GPatternSpec>(GPatternSpec* ptr)$/;"	f	namespace:WTF	signature:(GPatternSpec* ptr)
WTF::freeOwnedGPtr	.\gobject\GOwnPtr.cpp	/^template <> void freeOwnedGPtr<GSList>(GSList* ptr)$/;"	f	namespace:WTF	signature:(GSList* ptr)
WTF::freeOwnedGPtr	.\gobject\GOwnPtr.cpp	/^template <> void freeOwnedGPtr<GTimer>(GTimer* ptr)$/;"	f	namespace:WTF	signature:(GTimer* ptr)
WTF::freeOwnedGPtr	.\gobject\GOwnPtr.h	/^template <typename T> inline void freeOwnedGPtr(T* ptr)$/;"	f	namespace:WTF	signature:(T* ptr)
WTF::freeOwnedGPtr	.\gobject\GOwnPtr.h	/^template <typename T> inline void freeOwnedGPtr(T* ptr);$/;"	p	namespace:WTF	signature:(T* ptr)
WTF::freeOwnedGPtr	.\gobject\GOwnPtr.h	/^template<> void freeOwnedGPtr<GDir>(GDir*);$/;"	p	namespace:WTF	signature:(GDir*)
WTF::freeOwnedGPtr	.\gobject\GOwnPtr.h	/^template<> void freeOwnedGPtr<GError>(GError*);$/;"	p	namespace:WTF	signature:(GError*)
WTF::freeOwnedGPtr	.\gobject\GOwnPtr.h	/^template<> void freeOwnedGPtr<GKeyFile>(GKeyFile*);$/;"	p	namespace:WTF	signature:(GKeyFile*)
WTF::freeOwnedGPtr	.\gobject\GOwnPtr.h	/^template<> void freeOwnedGPtr<GList>(GList*);$/;"	p	namespace:WTF	signature:(GList*)
WTF::freeOwnedGPtr	.\gobject\GOwnPtr.h	/^template<> void freeOwnedGPtr<GPatternSpec>(GPatternSpec*);$/;"	p	namespace:WTF	signature:(GPatternSpec*)
WTF::freeOwnedGPtr	.\gobject\GOwnPtr.h	/^template<> void freeOwnedGPtr<GSList>(GSList*);$/;"	p	namespace:WTF	signature:(GSList*)
WTF::freeOwnedGPtr	.\gobject\GOwnPtr.h	/^template<> void freeOwnedGPtr<GTimer>(GTimer*);$/;"	p	namespace:WTF	signature:(GTimer*)
WTF::functionQueue	.\MainThread.cpp	/^static FunctionQueue& functionQueue()$/;"	f	namespace:WTF	file:	signature:()
WTF::genericBinarySearch	.\StdLibExtras.h	/^inline ArrayElementType* genericBinarySearch(ArrayType& array, size_t size, KeyType key)$/;"	f	namespace:WTF	signature:(ArrayType& array, size_t size, KeyType key)
WTF::getLocalTime	.\CurrentTime.h	/^inline void getLocalTime(const time_t* localTime, struct tm* localTM)$/;"	f	namespace:WTF	signature:(const time_t* localTime, struct tm* localTM)
WTF::getLowerStackBound	.\StackBounds.cpp	/^static inline void* getLowerStackBound(char* currentPage, DWORD pageSize)$/;"	f	namespace:WTF	file:	signature:(char* currentPage, DWORD pageSize)
WTF::getPageHeap	.\FastMalloc.cpp	/^static inline TCMalloc_PageHeap* getPageHeap()$/;"	f	namespace:WTF	file:	signature:()
WTF::getPtr	.\GetPtr.h	/^    template <typename T> inline T* getPtr(T* p)$/;"	f	namespace:WTF	signature:(T* p)
WTF::getPtr	.\ListRefPtr.h	/^    template <typename T> inline T* getPtr(const ListRefPtr<T>& p)$/;"	f	namespace:WTF	signature:(const ListRefPtr<T>& p)
WTF::getPtr	.\OwnArrayPtr.h	/^template <typename T> inline T* getPtr(const OwnArrayPtr<T>& p)$/;"	f	namespace:WTF	signature:(const OwnArrayPtr<T>& p)
WTF::getPtr	.\OwnPtr.h	/^    template<typename T> inline typename OwnPtr<T>::PtrType getPtr(const OwnPtr<T>& p)$/;"	f	namespace:WTF	signature:(const OwnPtr<T>& p)
WTF::getPtr	.\PassOwnArrayPtr.h	/^template<typename T> inline T* getPtr(const PassOwnArrayPtr<T>& p)$/;"	f	namespace:WTF	signature:(const PassOwnArrayPtr<T>& p)
WTF::getPtr	.\PassOwnPtr.h	/^    template<typename T> inline T* getPtr(const PassOwnPtr<T>& p)$/;"	f	namespace:WTF	signature:(const PassOwnPtr<T>& p)
WTF::getPtr	.\PassRefPtr.h	/^    template<typename T> inline T* getPtr(const PassRefPtr<T>& p)$/;"	f	namespace:WTF	signature:(const PassRefPtr<T>& p)
WTF::getPtr	.\RefPtr.h	/^    template<typename T> inline T* getPtr(const RefPtr<T>& p)$/;"	f	namespace:WTF	signature:(const RefPtr<T>& p)
WTF::getPtr	.\gobject\GOwnPtr.h	/^template <typename T> inline typename GOwnPtr<T>::PtrType getPtr(const GOwnPtr<T>& p)$/;"	f	namespace:WTF	signature:(const GOwnPtr<T>& p)
WTF::getPtr	.\gobject\GRefPtr.h	/^template <typename T> inline T* getPtr(const GRefPtr<T>& p)$/;"	f	namespace:WTF	signature:(const GRefPtr<T>& p)
WTF::getUpperStackBound	.\StackBounds.cpp	/^static inline void* getUpperStackBound(char* currentPage, DWORD pageSize)$/;"	f	namespace:WTF	file:	signature:(char* currentPage, DWORD pageSize)
WTF::hashTableStatsMutex	.\HashTable.cpp	/^static Mutex& hashTableStatsMutex()$/;"	f	namespace:WTF	file:	signature:()
WTF::hashTableSwap	.\HashTable.h	/^    template<typename T, typename U> inline void hashTableSwap(pair<T, U>& a, pair<T, U>& b)$/;"	f	namespace:WTF	signature:(pair<T, U>& a, pair<T, U>& b)
WTF::hashTableSwap	.\HashTable.h	/^    template<typename T> inline void hashTableSwap(T& a, T& b)$/;"	f	namespace:WTF	signature:(T& a, T& b)
WTF::heapSort	.\NonCopyingSort.h	/^void heapSort(RandomAccessIterator start, RandomAccessIterator end, Predicate compareLess)$/;"	f	namespace:WTF	signature:(RandomAccessIterator start, RandomAccessIterator end, Predicate compareLess)
WTF::heap_key	.\FastMalloc.cpp	/^static const pthread_key_t heap_key = __PTK_FRAMEWORK_JAVASCRIPTCORE_KEY0;$/;"	v	file:
WTF::heap_key	.\FastMalloc.cpp	/^static pthread_key_t heap_key;$/;"	v	file:
WTF::heapify	.\NonCopyingSort.h	/^inline void heapify(RandomAccessIterator array, ptrdiff_t count, Predicate compareLess) $/;"	f	namespace:WTF	signature:(RandomAccessIterator array, ptrdiff_t count, Predicate compareLess)
WTF::hexCharacterTable	.\url\src\URLEscape.cpp	/^const char hexCharacterTable[16] = {$/;"	v
WTF::hi0bits	.\dtoa.cpp	/^static int hi0bits(uint32_t x)$/;"	f	namespace:WTF	file:	signature:(uint32_t x)
WTF::highResUpTime	.\CurrentTime.cpp	/^static double highResUpTime()$/;"	f	namespace:WTF	file:	signature:()
WTF::hoursPerDay	.\DateMath.h	/^const double hoursPerDay = 24.0;$/;"	v
WTF::i2b	.\dtoa.cpp	/^static void i2b(BigInt& b, int i)$/;"	f	namespace:WTF	file:	signature:(BigInt& b, int i)
WTF::identifierByPthreadHandle	.\ThreadingPthreads.cpp	/^static ThreadIdentifier identifierByPthreadHandle(const pthread_t& pthreadHandle)$/;"	f	namespace:WTF	file:	signature:(const pthread_t& pthreadHandle)
WTF::initializeCurrentThreadInternal	.\Threading.h	/^void initializeCurrentThreadInternal(const char* threadName);$/;"	p	namespace:WTF	signature:(const char* threadName)
WTF::initializeCurrentThreadInternal	.\ThreadingPthreads.cpp	/^void initializeCurrentThreadInternal(const char* threadName)$/;"	f	namespace:WTF	signature:(const char* threadName)
WTF::initializeCurrentThreadInternal	.\ThreadingWin.cpp	/^void initializeCurrentThreadInternal(const char* szThreadName)$/;"	f	namespace:WTF	signature:(const char* szThreadName)
WTF::initializeDates	.\DateMath.cpp	/^void initializeDates()$/;"	f	namespace:WTF	signature:()
WTF::initializeDates	.\DateMath.h	/^void initializeDates();$/;"	p	namespace:WTF	signature:()
WTF::initializeGCThreads	.\MainThread.cpp	/^void initializeGCThreads()$/;"	f	namespace:WTF	signature:()
WTF::initializeGCThreads	.\MainThread.h	/^void initializeGCThreads();$/;"	p	namespace:WTF	signature:()
WTF::initializeLogFile	.\DataLog.cpp	/^static void initializeLogFile()$/;"	f	namespace:WTF	file:	signature:()
WTF::initializeLogFileOnce	.\DataLog.cpp	/^static void initializeLogFileOnce()$/;"	f	namespace:WTF	file:	signature:()
WTF::initializeLogFileOnceKey	.\DataLog.cpp	/^static pthread_once_t initializeLogFileOnceKey = PTHREAD_ONCE_INIT;$/;"	v	file:
WTF::initializeMainThread	.\MainThread.cpp	/^void initializeMainThread()$/;"	f	namespace:WTF	signature:()
WTF::initializeMainThread	.\MainThread.h	/^WTF_EXPORT_PRIVATE void initializeMainThread();$/;"	p	namespace:WTF	signature:()
WTF::initializeMainThread	.\chromium\MainThreadChromium.cpp	/^void initializeMainThread()$/;"	f	namespace:WTF	signature:()
WTF::initializeMainThreadKeyOnce	.\MainThread.cpp	/^static pthread_once_t initializeMainThreadKeyOnce = PTHREAD_ONCE_INIT;$/;"	v	file:
WTF::initializeMainThreadOnce	.\MainThread.cpp	/^static void initializeMainThreadOnce()$/;"	f	namespace:WTF	file:	signature:()
WTF::initializeMainThreadPlatform	.\MainThread.h	/^void initializeMainThreadPlatform();$/;"	p	namespace:WTF	signature:()
WTF::initializeMainThreadPlatform	.\blackberry\MainThreadBlackBerry.cpp	/^void initializeMainThreadPlatform()$/;"	f	namespace:WTF	signature:()
WTF::initializeMainThreadPlatform	.\efl\MainThreadEfl.cpp	/^void initializeMainThreadPlatform()$/;"	f	namespace:WTF	signature:()
WTF::initializeMainThreadPlatform	.\gtk\MainThreadGtk.cpp	/^void initializeMainThreadPlatform()$/;"	f	namespace:WTF	signature:()
WTF::initializeMainThreadPlatform	.\qt\MainThreadQt.cpp	/^void initializeMainThreadPlatform()$/;"	f	namespace:WTF	signature:()
WTF::initializeMainThreadPlatform	.\win\MainThreadWin.cpp	/^void initializeMainThreadPlatform()$/;"	f	namespace:WTF	signature:()
WTF::initializeMainThreadPlatform	.\wx\MainThreadWx.cpp	/^void initializeMainThreadPlatform()$/;"	f	namespace:WTF	signature:()
WTF::initializeMainThreadToProcessMainThread	.\MainThread.cpp	/^void initializeMainThreadToProcessMainThread()$/;"	f	namespace:WTF	signature:()
WTF::initializeMainThreadToProcessMainThread	.\MainThread.h	/^WTF_EXPORT_PRIVATE void initializeMainThreadToProcessMainThread();$/;"	p	namespace:WTF	signature:()
WTF::initializeMainThreadToProcessMainThreadOnce	.\MainThread.cpp	/^static void initializeMainThreadToProcessMainThreadOnce()$/;"	f	namespace:WTF	file:	signature:()
WTF::initializeMainThreadToProcessMainThreadPlatform	.\MainThread.h	/^void initializeMainThreadToProcessMainThreadPlatform();$/;"	p	namespace:WTF	signature:()
WTF::initializeRandomNumberGenerator	.\RandomNumberSeed.h	/^inline void initializeRandomNumberGenerator()$/;"	f	namespace:WTF	signature:()
WTF::initializeThreading	.\Threading.h	/^WTF_EXPORT_PRIVATE void initializeThreading();$/;"	p	namespace:WTF	signature:()
WTF::initializeThreading	.\ThreadingPthreads.cpp	/^void initializeThreading()$/;"	f	namespace:WTF	signature:()
WTF::initializeThreading	.\ThreadingWin.cpp	/^void initializeThreading()$/;"	f	namespace:WTF	signature:()
WTF::intHash	.\HashFunctions.h	/^    inline unsigned intHash(uint16_t key16)$/;"	f	namespace:WTF	signature:(uint16_t key16)
WTF::intHash	.\HashFunctions.h	/^    inline unsigned intHash(uint32_t key) $/;"	f	namespace:WTF	signature:(uint32_t key)
WTF::intHash	.\HashFunctions.h	/^    inline unsigned intHash(uint64_t key)$/;"	f	namespace:WTF	signature:(uint64_t key)
WTF::intHash	.\HashFunctions.h	/^    inline unsigned intHash(uint8_t key8)$/;"	f	namespace:WTF	signature:(uint8_t key8)
WTF::is8ByteAligned	.\StdLibExtras.h	/^inline bool is8ByteAligned(void* p)$/;"	f	namespace:WTF	signature:(void* p)
WTF::isASCII	.\ASCIICType.h	/^template<typename CharType> inline bool isASCII(CharType c)$/;"	f	namespace:WTF	signature:(CharType c)
WTF::isASCIIAlpha	.\ASCIICType.h	/^template<typename CharType> inline bool isASCIIAlpha(CharType c)$/;"	f	namespace:WTF	signature:(CharType c)
WTF::isASCIIAlphaCaselessEqual	.\ASCIICType.h	/^template<typename CharType> inline bool isASCIIAlphaCaselessEqual(CharType cssCharacter, char character)$/;"	f	namespace:WTF	signature:(CharType cssCharacter, char character)
WTF::isASCIIAlphanumeric	.\ASCIICType.h	/^template<typename CharType> inline bool isASCIIAlphanumeric(CharType c)$/;"	f	namespace:WTF	signature:(CharType c)
WTF::isASCIIDigit	.\ASCIICType.h	/^template<typename CharType> inline bool isASCIIDigit(CharType c)$/;"	f	namespace:WTF	signature:(CharType c)
WTF::isASCIIHexDigit	.\ASCIICType.h	/^template<typename CharType> inline bool isASCIIHexDigit(CharType c)$/;"	f	namespace:WTF	signature:(CharType c)
WTF::isASCIILower	.\ASCIICType.h	/^template<typename CharType> inline bool isASCIILower(CharType c)$/;"	f	namespace:WTF	signature:(CharType c)
WTF::isASCIIOctalDigit	.\ASCIICType.h	/^template<typename CharType> inline bool isASCIIOctalDigit(CharType c)$/;"	f	namespace:WTF	signature:(CharType c)
WTF::isASCIIPrintable	.\ASCIICType.h	/^template<typename CharType> inline bool isASCIIPrintable(CharType c)$/;"	f	namespace:WTF	signature:(CharType c)
WTF::isASCIISpace	.\ASCIICType.h	/^template<typename CharType> inline bool isASCIISpace(CharType c)$/;"	f	namespace:WTF	signature:(CharType c)
WTF::isASCIIUpper	.\ASCIICType.h	/^template<typename CharType> inline bool isASCIIUpper(CharType c)$/;"	f	namespace:WTF	signature:(CharType c)
WTF::isAlignedToMachineWord	.\text\ASCIIFastPath.h	/^inline bool isAlignedToMachineWord(const void* pointer)$/;"	f	namespace:WTF	signature:(const void* pointer)
WTF::isAllASCII	.\text\ASCIIFastPath.h	/^inline bool isAllASCII(MachineWord word)$/;"	f	namespace:WTF	signature:(MachineWord word)
WTF::isAllSpecialCharacters	.\text\WTFString.h	/^template<bool isSpecialCharacter(UChar)> bool isAllSpecialCharacters(const UChar*, size_t);$/;"	p	namespace:WTF	signature:(const UChar*, size_t)
WTF::isAllSpecialCharacters	.\text\WTFString.h	/^template<bool isSpecialCharacter(UChar)> inline bool isAllSpecialCharacters(const UChar* characters, size_t length)$/;"	f	namespace:WTF	signature:(const UChar* characters, size_t length)
WTF::isCharacterAllowedInBase	.\text\WTFString.cpp	/^static bool isCharacterAllowedInBase(UChar c, int base)$/;"	f	namespace:WTF	file:	signature:(UChar c, int base)
WTF::isForbidden	.\FastMalloc.cpp	/^static bool isForbidden()$/;"	f	namespace:WTF	file:	signature:()
WTF::isForibiddenTlsIndex	.\FastMalloc.cpp	/^static DWORD isForibiddenTlsIndex = TLS_OUT_OF_INDEXES;$/;"	v	file:
WTF::isGCThread	.\MainThread.cpp	/^static ThreadSpecific<bool>* isGCThread;$/;"	v	file:
WTF::isInBounds	.\CheckedArithmetic.h	/^template <typename Target, typename Source> static inline bool isInBounds(Source value)$/;"	f	namespace:WTF	signature:(Source value)
WTF::isLeapYear	.\DateMath.cpp	/^bool isLeapYear(int year)$/;"	f	namespace:WTF	signature:(int year)
WTF::isLeapYear	.\DateMath.h	/^bool isLeapYear(int year);$/;"	p	namespace:WTF	signature:(int year)
WTF::isMainThread	.\MainThread.cpp	/^bool isMainThread()$/;"	f	namespace:WTF	signature:()
WTF::isMainThread	.\MainThread.h	/^WTF_EXPORT_PRIVATE bool isMainThread();$/;"	p	namespace:WTF	signature:()
WTF::isMainThread	.\chromium\MainThreadChromium.cpp	/^bool isMainThread()$/;"	f	namespace:WTF	signature:()
WTF::isMainThreadOrGCThread	.\MainThread.cpp	/^bool isMainThreadOrGCThread()$/;"	f	namespace:WTF	signature:()
WTF::isMainThreadOrGCThread	.\MainThread.h	/^WTF_EXPORT_PRIVATE bool isMainThreadOrGCThread();$/;"	p	namespace:WTF	signature:()
WTF::isMainThreadOrGCThread	.\MainThread.h	/^inline bool isMainThreadOrGCThread() { return isMainThread(); }$/;"	f	namespace:WTF	signature:()
WTF::isPageAligned	.\PageBlock.h	/^inline bool isPageAligned(size_t size) { return !(size & (pageSize() - 1)); }$/;"	f	namespace:WTF	signature:(size_t size)
WTF::isPageAligned	.\PageBlock.h	/^inline bool isPageAligned(void* address) { return !(reinterpret_cast<intptr_t>(address) & (pageSize() - 1)); }$/;"	f	namespace:WTF	signature:(void* address)
WTF::isPageWritable	.\StackBounds.cpp	/^static inline bool isPageWritable(void* page)$/;"	f	namespace:WTF	file:	signature:(void* page)
WTF::isPointerAligned	.\StdLibExtras.h	/^inline bool isPointerAligned(void* p)$/;"	f	namespace:WTF	signature:(void* p)
WTF::isPowerOfTwo	.\PageBlock.h	/^inline bool isPowerOfTwo(size_t size) { return !(size & (size - 1)); }$/;"	f	namespace:WTF	signature:(size_t size)
WTF::isSpaceOrNewline	.\text\StringImpl.h	/^static inline bool isSpaceOrNewline(UChar c)$/;"	f	namespace:WTF	signature:(UChar c)
WTF::jsCurrentTime	.\DateMath.h	/^inline double jsCurrentTime()$/;"	f	namespace:WTF	signature:()
WTF::jscore_fastmalloc_introspection	.\FastMalloc.cpp	/^malloc_introspection_t jscore_fastmalloc_introspection = { &FastMallocZone::enumerate, &FastMallocZone::goodSize, &FastMallocZone::check, &FastMallocZone::print,$/;"	v
WTF::k	.\SHA1.cpp	/^static inline uint32_t k(int t)$/;"	f	namespace:WTF	file:	signature:(int t)
WTF::kAlignShift	.\FastMalloc.cpp	/^static const size_t kAlignShift = 3;$/;"	v	file:
WTF::kAlignment	.\FastMalloc.cpp	/^static const size_t kAlignment  = 1 << kAlignShift;$/;"	v	file:
WTF::kBitsUnusedOn64Bit	.\FastMalloc.cpp	/^static const size_t kBitsUnusedOn64Bit = 0;$/;"	v	file:
WTF::kBitsUnusedOn64Bit	.\FastMalloc.cpp	/^static const size_t kBitsUnusedOn64Bit = 16;$/;"	v	file:
WTF::kDefaultOverallThreadCacheSize	.\FastMalloc.cpp	/^static const size_t kDefaultOverallThreadCacheSize = 16 << 20;$/;"	v	file:
WTF::kMaxFreeListLength	.\FastMalloc.cpp	/^static const int kMaxFreeListLength = 256;$/;"	v	file:
WTF::kMaxPages	.\FastMalloc.cpp	/^static const size_t kMaxPages = kMinSystemAlloc;$/;"	v	file:
WTF::kMaxSize	.\FastMalloc.cpp	/^static const size_t kMaxSize    = 8u * kPageSize;$/;"	v	file:
WTF::kMaxSmallSize	.\FastMalloc.cpp	/^static const size_t kMaxSmallSize = 1024;$/;"	v	file:
WTF::kMaxStackDepth	.\FastMalloc.cpp	/^static const int kMaxStackDepth = 31;$/;"	v	file:
WTF::kMaxThreadCacheSize	.\FastMalloc.cpp	/^static const size_t kMaxThreadCacheSize = 2 << 20;$/;"	v	file:
WTF::kMaxThreadCacheSize	.\FastMalloc.cpp	/^static const size_t kMaxThreadCacheSize = 512 * 1024;$/;"	v	file:
WTF::kMaxTlsKeySize	.\ThreadSpecific.h	/^const int kMaxTlsKeySize = 256;$/;"	v
WTF::kMaxValidPages	.\FastMalloc.cpp	/^static const Length kMaxValidPages = (~static_cast<Length>(0)) >> kPageShift;$/;"	v	file:
WTF::kMinSpanListsWithSpans	.\FastMalloc.cpp	/^static const int kMinSpanListsWithSpans = 32;$/;"	v	file:
WTF::kMinSystemAlloc	.\FastMalloc.cpp	/^static const size_t kMinSystemAlloc = 1 << (20 - kPageShift);$/;"	v	file:
WTF::kMinThreadCacheSize	.\FastMalloc.cpp	/^static const size_t kMinThreadCacheSize = kMaxSize * 2;$/;"	v	file:
WTF::kMinimumFreeCommittedPageCount	.\FastMalloc.cpp	/^static const size_t kMinimumFreeCommittedPageCount = kMinSpanListsWithSpans * ((1.0f+kMinSpanListsWithSpans) \/ 2.0f);$/;"	v	file:
WTF::kNumClasses	.\FastMalloc.cpp	/^static const size_t kNumClasses = 68;$/;"	v	file:
WTF::kNumTransferEntries	.\FastMalloc.cpp	/^static const int kNumTransferEntries = kNumClasses;$/;"	v	file:
WTF::kPageMapBigAllocationThreshold	.\FastMalloc.cpp	/^static const size_t kPageMapBigAllocationThreshold = 128 << 20;$/;"	v	file:
WTF::kPageShift	.\FastMalloc.cpp	/^static const size_t kPageShift  = 12;$/;"	v	file:
WTF::kPageSize	.\FastMalloc.cpp	/^static const size_t kPageSize   = 1 << kPageShift;$/;"	v	file:
WTF::kScavengeDelayInSeconds	.\FastMalloc.cpp	/^static const int kScavengeDelayInSeconds = 2;$/;"	v	file:
WTF::kScavengePercentage	.\FastMalloc.cpp	/^static const float kScavengePercentage = .5f;$/;"	v	file:
WTF::kThreadingWindowClassName	.\win\MainThreadWin.cpp	/^const LPCWSTR kThreadingWindowClassName = L"ThreadingWindowClass";$/;"	v
WTF::kTlsAllowValue	.\FastMalloc.cpp	/^static const LPVOID kTlsAllowValue = reinterpret_cast<LPVOID>(0); \/\/ Must be zero.$/;"	v	file:
WTF::kTlsForbiddenValue	.\FastMalloc.cpp	/^static const LPVOID kTlsForbiddenValue = reinterpret_cast<LPVOID>(1);$/;"	v	file:
WTF::kernel_supports_tls	.\FastMalloc.cpp	/^  static bool kernel_supports_tls = false;      \/\/ be conservative$/;"	v	file:
WTF::known_zones	.\DateMath.cpp	/^} known_zones[] = {$/;"	v	typeref:struct:WTF::KnownZone	file:
WTF::lengthOfCharactersAsInteger	.\text\WTFString.cpp	/^static unsigned lengthOfCharactersAsInteger(const CharType* data, size_t length)$/;"	f	namespace:WTF	file:	signature:(const CharType* data, size_t length)
WTF::lo0bits	.\dtoa.cpp	/^static int lo0bits(uint32_t* y)$/;"	f	namespace:WTF	file:	signature:(uint32_t* y)
WTF::lockAtomicallyInitializedStaticMutex	.\Threading.h	/^WTF_EXPORT_PRIVATE void lockAtomicallyInitializedStaticMutex();$/;"	p	namespace:WTF	signature:()
WTF::lockAtomicallyInitializedStaticMutex	.\ThreadingPthreads.cpp	/^void lockAtomicallyInitializedStaticMutex()$/;"	f	namespace:WTF	signature:()
WTF::lockAtomicallyInitializedStaticMutex	.\ThreadingWin.cpp	/^void lockAtomicallyInitializedStaticMutex()$/;"	f	namespace:WTF	signature:()
WTF::logger	.\HashTable.cpp	/^static HashTableStats logger;$/;"	v	file:
WTF::lowResUTCTime	.\CurrentTime.cpp	/^static double lowResUTCTime()$/;"	f	namespace:WTF	file:	signature:()
WTF::lowerNibbleToASCIIHexDigit	.\ASCIICType.h	/^inline char lowerNibbleToASCIIHexDigit(char c)$/;"	f	namespace:WTF	signature:(char c)
WTF::lshift	.\dtoa.cpp	/^static ALWAYS_INLINE void lshift(BigInt& b, int k)$/;"	f	namespace:WTF	file:	signature:(BigInt& b, int k)
WTF::machineWordAlignmentMask	.\text\ASCIIFastPath.h	/^const uintptr_t machineWordAlignmentMask = sizeof(MachineWord) - 1;$/;"	v
WTF::mainThreadFunctionQueueMutex	.\MainThread.cpp	/^static Mutex& mainThreadFunctionQueueMutex()$/;"	f	namespace:WTF	file:	signature:()
WTF::mainThreadIdentifier	.\MainThread.cpp	/^static ThreadIdentifier mainThreadIdentifier;$/;"	v	file:
WTF::mainThreadIdentifier	.\chromium\MainThreadChromium.cpp	/^static ThreadIdentifier mainThreadIdentifier;$/;"	v	file:
WTF::makeRFC2822DateString	.\DateMath.cpp	/^String makeRFC2822DateString(unsigned dayOfWeek, unsigned day, unsigned month, unsigned year, unsigned hours, unsigned minutes, unsigned seconds, int utcOffset)$/;"	f	namespace:WTF	signature:(unsigned dayOfWeek, unsigned day, unsigned month, unsigned year, unsigned hours, unsigned minutes, unsigned seconds, int utcOffset)
WTF::makeRFC2822DateString	.\DateMath.h	/^String makeRFC2822DateString(unsigned dayOfWeek, unsigned day, unsigned month, unsigned year, unsigned hours, unsigned minutes, unsigned seconds, int utcOffset);$/;"	p	namespace:WTF	signature:(unsigned dayOfWeek, unsigned day, unsigned month, unsigned year, unsigned hours, unsigned minutes, unsigned seconds, int utcOffset)
WTF::makeString	.\text\StringConcatenate.h	/^String makeString(StringType1 string1)$/;"	f	namespace:WTF	signature:(StringType1 string1)
WTF::makeString	.\text\StringConcatenate.h	/^String makeString(StringType1 string1, StringType2 string2)$/;"	f	namespace:WTF	signature:(StringType1 string1, StringType2 string2)
WTF::makeString	.\text\StringConcatenate.h	/^String makeString(StringType1 string1, StringType2 string2, StringType3 string3)$/;"	f	namespace:WTF	signature:(StringType1 string1, StringType2 string2, StringType3 string3)
WTF::makeString	.\text\StringConcatenate.h	/^String makeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4)$/;"	f	namespace:WTF	signature:(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4)
WTF::makeString	.\text\StringConcatenate.h	/^String makeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5)$/;"	f	namespace:WTF	signature:(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5)
WTF::makeString	.\text\StringConcatenate.h	/^String makeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6)$/;"	f	namespace:WTF	signature:(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6)
WTF::makeString	.\text\StringConcatenate.h	/^String makeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6, StringType7 string7)$/;"	f	namespace:WTF	signature:(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6, StringType7 string7)
WTF::makeString	.\text\StringConcatenate.h	/^String makeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6, StringType7 string7, StringType8 string8)$/;"	f	namespace:WTF	signature:(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6, StringType7 string7, StringType8 string8)
WTF::makeString	.\text\StringConcatenate.h	/^String makeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6, StringType7 string7, StringType8 string8, StringType9 string9)$/;"	f	namespace:WTF	signature:(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6, StringType7 string7, StringType8 string8, StringType9 string9)
WTF::mallinfo	.\FastMalloc.cpp	/^extern "C" struct mallinfo mallinfo(void) {$/;"	f	namespace:WTF	signature:(void)
WTF::malloc	.\FastMalloc.cpp	/^ALWAYS_INLINE void* malloc(size_t);$/;"	p	namespace:WTF	file:	signature:(size_t)
WTF::malloc	.\FastMalloc.cpp	/^void* malloc(size_t size) {$/;"	f	namespace:WTF	signature:(size_t size)
WTF::malloc_stats	.\FastMalloc.cpp	/^extern "C" void malloc_stats(void) {$/;"	f	namespace:WTF	signature:(void)
WTF::mallopt	.\FastMalloc.cpp	/^extern "C" int mallopt(int cmd, int value) {$/;"	f	namespace:WTF	signature:(int cmd, int value)
WTF::maxECMAScriptTime	.\DateMath.cpp	/^static const double maxECMAScriptTime = 8.64E15;$/;"	v	file:
WTF::maxRunLoopSuspensionTime	.\MainThread.cpp	/^static const double maxRunLoopSuspensionTime = 0.05;$/;"	v	file:
WTF::maxUnixTime	.\DateMath.cpp	/^static const double maxUnixTime = 2145859200.0; \/\/ 12\/31\/2037$/;"	v	file:
WTF::maximumYearForDST	.\DateMath.cpp	/^static inline int maximumYearForDST()$/;"	f	namespace:WTF	file:	signature:()
WTF::memoryManager	.\wince\MemoryManager.cpp	/^MemoryManager* memoryManager()$/;"	f	namespace:WTF	signature:()
WTF::memoryManager	.\wince\MemoryManager.h	/^    MemoryManager* memoryManager();$/;"	p	namespace:WTF	signature:()
WTF::mergeDecommittedStates	.\FastMalloc.cpp	/^static ALWAYS_INLINE void mergeDecommittedStates(Span* destination, Span* other)$/;"	f	namespace:WTF	file:	signature:(Span* destination, Span* other)
WTF::metadata_system_bytes	.\FastMalloc.cpp	/^static uint64_t metadata_system_bytes = 0;$/;"	v	file:
WTF::minimumCapacity	.\text\StringBuilder.cpp	/^static const unsigned minimumCapacity = 16;$/;"	v	file:
WTF::minimumYearForDST	.\DateMath.cpp	/^static inline int minimumYearForDST()$/;"	f	namespace:WTF	file:	signature:()
WTF::minutesPerDay	.\DateMath.cpp	/^static const double minutesPerDay = 24.0 * 60.0;$/;"	v	file:
WTF::minutesPerHour	.\DateMath.h	/^const double minutesPerHour = 60.0;$/;"	v
WTF::module_enter_exit_hook	.\FastMalloc.cpp	/^static TCMallocGuard module_enter_exit_hook;$/;"	v	file:
WTF::monitorDispatchFunctions	.\efl\MainThreadEfl.cpp	/^static void monitorDispatchFunctions(void*, void*, unsigned int)$/;"	f	namespace:WTF	file:	signature:(void*, void*, unsigned int)
WTF::monotonicallyIncreasingTime	.\CurrentTime.cpp	/^double monotonicallyIncreasingTime()$/;"	f	namespace:WTF	signature:()
WTF::monotonicallyIncreasingTime	.\CurrentTime.h	/^WTF_EXPORT_PRIVATE double monotonicallyIncreasingTime();$/;"	p	namespace:WTF	signature:()
WTF::monthFromDayInYear	.\DateMath.cpp	/^int monthFromDayInYear(int dayInYear, bool leapYear)$/;"	f	namespace:WTF	signature:(int dayInYear, bool leapYear)
WTF::monthFromDayInYear	.\DateMath.h	/^WTF_EXPORT_PRIVATE int monthFromDayInYear(int dayInYear, bool leapYear);$/;"	p	namespace:WTF	signature:(int dayInYear, bool leapYear)
WTF::monthName	.\DateMath.h	/^const char* const monthName[12] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };$/;"	v
WTF::monthToDayInYear	.\DateMath.cpp	/^static inline int monthToDayInYear(int month, bool isLeapYear)$/;"	f	namespace:WTF	file:	signature:(int month, bool isLeapYear)
WTF::msPerDay	.\DateMath.h	/^const double msPerDay = 24.0 * 60.0 * 60.0 * 1000.0;$/;"	v
WTF::msPerHour	.\DateMath.h	/^const double msPerHour = 60.0 * 60.0 * 1000.0;$/;"	v
WTF::msPerMinute	.\DateMath.h	/^const double msPerMinute = 60.0 * 1000.0;$/;"	v
WTF::msPerMonth	.\DateMath.h	/^const double msPerMonth = 2592000000.0;$/;"	v
WTF::msPerSecond	.\CurrentTime.cpp	/^const double msPerSecond = 1000.0;$/;"	v
WTF::msPerSecond	.\DateMath.h	/^const double msPerSecond = 1000.0;$/;"	v
WTF::msToDays	.\DateMath.cpp	/^double msToDays(double ms)$/;"	f	namespace:WTF	signature:(double ms)
WTF::msToDays	.\DateMath.h	/^double msToDays(double ms);$/;"	p	namespace:WTF	signature:(double ms)
WTF::msToHours	.\DateMath.cpp	/^int msToHours(double ms)$/;"	f	namespace:WTF	signature:(double ms)
WTF::msToHours	.\DateMath.h	/^int msToHours(double ms);$/;"	p	namespace:WTF	signature:(double ms)
WTF::msToMilliseconds	.\DateMath.cpp	/^static inline double msToMilliseconds(double ms)$/;"	f	namespace:WTF	file:	signature:(double ms)
WTF::msToMinutes	.\DateMath.cpp	/^int msToMinutes(double ms)$/;"	f	namespace:WTF	signature:(double ms)
WTF::msToMinutes	.\DateMath.h	/^int msToMinutes(double ms);$/;"	p	namespace:WTF	signature:(double ms)
WTF::msToYear	.\DateMath.cpp	/^int msToYear(double ms)$/;"	f	namespace:WTF	signature:(double ms)
WTF::msToYear	.\DateMath.h	/^WTF_EXPORT_PRIVATE int msToYear(double ms);$/;"	p	namespace:WTF	signature:(double ms)
WTF::mult	.\dtoa.cpp	/^static void mult(BigInt& aRef, const BigInt& bRef)$/;"	f	namespace:WTF	file:	signature:(BigInt& aRef, const BigInt& bRef)
WTF::multadd	.\dtoa.cpp	/^static void multadd(BigInt& b, int m, int a)    \/* multiply by m and add a *\/$/;"	f	namespace:WTF	file:	signature:(BigInt& b, int m, int a)
WTF::nonCopyingSort	.\NonCopyingSort.h	/^inline void nonCopyingSort(RandomAccessIterator start, RandomAccessIterator end, Predicate compareLess)$/;"	f	namespace:WTF	signature:(RandomAccessIterator start, RandomAccessIterator end, Predicate compareLess)
WTF::notFound	.\NotFound.h	/^    const size_t notFound = static_cast<size_t>(-1);$/;"	v
WTF::nsStringNilIfEmpty	.\text\WTFString.h	/^inline NSString* nsStringNilIfEmpty(const String& str) {  return str.isEmpty() ? nil : (NSString*)str; }$/;"	f	namespace:WTF	signature:(const String& str)
WTF::num_objects_to_move	.\FastMalloc.cpp	/^static int num_objects_to_move[kNumClasses];$/;"	v	file:
WTF::numberOfProcessorCores	.\NumberOfCores.cpp	/^int numberOfProcessorCores()$/;"	f	namespace:WTF	signature:()
WTF::numberOfProcessorCores	.\NumberOfCores.h	/^int numberOfProcessorCores();$/;"	p	namespace:WTF	signature:()
WTF::numberToFixedPrecisionString	.\dtoa.cpp	/^const char* numberToFixedPrecisionString(double d, unsigned significantFigures, NumberToStringBuffer buffer, bool truncateTrailingZeros)$/;"	f	namespace:WTF	signature:(double d, unsigned significantFigures, NumberToStringBuffer buffer, bool truncateTrailingZeros)
WTF::numberToFixedPrecisionString	.\dtoa.h	/^const char* numberToFixedPrecisionString(double, unsigned significantFigures, NumberToStringBuffer, bool truncateTrailingZeros = false);$/;"	p	namespace:WTF	signature:(double, unsigned significantFigures, NumberToStringBuffer, bool truncateTrailingZeros = false)
WTF::numberToFixedWidthString	.\dtoa.cpp	/^const char* numberToFixedWidthString(double d, unsigned decimalPlaces, NumberToStringBuffer buffer)$/;"	f	namespace:WTF	signature:(double d, unsigned decimalPlaces, NumberToStringBuffer buffer)
WTF::numberToFixedWidthString	.\dtoa.h	/^const char* numberToFixedWidthString(double, unsigned decimalPlaces, NumberToStringBuffer);$/;"	p	namespace:WTF	signature:(double, unsigned decimalPlaces, NumberToStringBuffer)
WTF::numberToString	.\dtoa.cpp	/^const char* numberToString(double d, NumberToStringBuffer buffer)$/;"	f	namespace:WTF	signature:(double d, NumberToStringBuffer buffer)
WTF::numberToString	.\dtoa.h	/^WTF_EXPORT_PRIVATE const char* numberToString(double, NumberToStringBuffer);$/;"	p	namespace:WTF	signature:(double, NumberToStringBuffer)
WTF::operator !	.\text\WTFString.h	/^inline bool operator!(const String& str) { return str.isNull(); }$/;"	f	namespace:WTF	signature:(const String& str)
WTF::operator !=	.\HashIterators.h	/^        inline bool operator!=(const HashTableConstKeysIterator<T, U, V>& a, const HashTableConstKeysIterator<T, U, V>& b)$/;"	f	namespace:WTF	signature:(const HashTableConstKeysIterator<T, U, V>& a, const HashTableConstKeysIterator<T, U, V>& b)
WTF::operator !=	.\HashIterators.h	/^        inline bool operator!=(const HashTableConstValuesIterator<T, U, V>& a, const HashTableConstValuesIterator<T, U, V>& b)$/;"	f	namespace:WTF	signature:(const HashTableConstValuesIterator<T, U, V>& a, const HashTableConstValuesIterator<T, U, V>& b)
WTF::operator !=	.\HashIterators.h	/^        inline bool operator!=(const HashTableKeysIterator<T, U, V>& a, const HashTableKeysIterator<T, U, V>& b)$/;"	f	namespace:WTF	signature:(const HashTableKeysIterator<T, U, V>& a, const HashTableKeysIterator<T, U, V>& b)
WTF::operator !=	.\HashIterators.h	/^        inline bool operator!=(const HashTableValuesIterator<T, U, V>& a, const HashTableValuesIterator<T, U, V>& b)$/;"	f	namespace:WTF	signature:(const HashTableValuesIterator<T, U, V>& a, const HashTableValuesIterator<T, U, V>& b)
WTF::operator !=	.\HashMap.h	/^    inline bool operator!=(const HashMap<T, U, V, W, X>& a, const HashMap<T, U, V, W, X>& b)$/;"	f	namespace:WTF	signature:(const HashMap<T, U, V, W, X>& a, const HashMap<T, U, V, W, X>& b)
WTF::operator !=	.\HashTable.h	/^    inline bool operator!=(const HashTableConstIteratorAdapter<T, U>& a, const HashTableConstIteratorAdapter<T, U>& b)$/;"	f	namespace:WTF	signature:(const HashTableConstIteratorAdapter<T, U>& a, const HashTableConstIteratorAdapter<T, U>& b)
WTF::operator !=	.\HashTable.h	/^    inline bool operator!=(const HashTableConstIteratorAdapter<T, U>& a, const HashTableIteratorAdapter<T, U>& b)$/;"	f	namespace:WTF	signature:(const HashTableConstIteratorAdapter<T, U>& a, const HashTableIteratorAdapter<T, U>& b)
WTF::operator !=	.\HashTable.h	/^    inline bool operator!=(const HashTableIteratorAdapter<T, U>& a, const HashTableConstIteratorAdapter<T, U>& b)$/;"	f	namespace:WTF	signature:(const HashTableIteratorAdapter<T, U>& a, const HashTableConstIteratorAdapter<T, U>& b)
WTF::operator !=	.\HashTable.h	/^    inline bool operator!=(const HashTableIteratorAdapter<T, U>& a, const HashTableIteratorAdapter<T, U>& b)$/;"	f	namespace:WTF	signature:(const HashTableIteratorAdapter<T, U>& a, const HashTableIteratorAdapter<T, U>& b)
WTF::operator !=	.\OwnArrayPtr.h	/^template<typename T, typename U> inline bool operator!=(T* a, const OwnArrayPtr<U>& b)$/;"	f	namespace:WTF	signature:(T* a, const OwnArrayPtr<U>& b)
WTF::operator !=	.\OwnArrayPtr.h	/^template<typename T, typename U> inline bool operator!=(const OwnArrayPtr<T>& a, U* b)$/;"	f	namespace:WTF	signature:(const OwnArrayPtr<T>& a, U* b)
WTF::operator !=	.\OwnPtr.h	/^    template<typename T, typename U> inline bool operator!=(T* a, const OwnPtr<U>& b)$/;"	f	namespace:WTF	signature:(T* a, const OwnPtr<U>& b)
WTF::operator !=	.\OwnPtr.h	/^    template<typename T, typename U> inline bool operator!=(const OwnPtr<T>& a, U* b)$/;"	f	namespace:WTF	signature:(const OwnPtr<T>& a, U* b)
WTF::operator !=	.\PassOwnArrayPtr.h	/^template<typename T, typename U> inline bool operator!=(T* a, const PassOwnArrayPtr<U>& b) $/;"	f	namespace:WTF	signature:(T* a, const PassOwnArrayPtr<U>& b)
WTF::operator !=	.\PassOwnArrayPtr.h	/^template<typename T, typename U> inline bool operator!=(const OwnArrayPtr<T>& a, const PassOwnArrayPtr<U>& b) $/;"	f	namespace:WTF	signature:(const OwnArrayPtr<T>& a, const PassOwnArrayPtr<U>& b)
WTF::operator !=	.\PassOwnArrayPtr.h	/^template<typename T, typename U> inline bool operator!=(const PassOwnArrayPtr<T>& a, U* b)$/;"	f	namespace:WTF	signature:(const PassOwnArrayPtr<T>& a, U* b)
WTF::operator !=	.\PassOwnArrayPtr.h	/^template<typename T, typename U> inline bool operator!=(const PassOwnArrayPtr<T>& a, const OwnArrayPtr<U>& b) $/;"	f	namespace:WTF	signature:(const PassOwnArrayPtr<T>& a, const OwnArrayPtr<U>& b)
WTF::operator !=	.\PassOwnArrayPtr.h	/^template<typename T, typename U> inline bool operator!=(const PassOwnArrayPtr<T>& a, const PassOwnArrayPtr<U>& b) $/;"	f	namespace:WTF	signature:(const PassOwnArrayPtr<T>& a, const PassOwnArrayPtr<U>& b)
WTF::operator !=	.\PassOwnPtr.h	/^    template<typename T, typename U> inline bool operator!=(T* a, const PassOwnPtr<U>& b) $/;"	f	namespace:WTF	signature:(T* a, const PassOwnPtr<U>& b)
WTF::operator !=	.\PassOwnPtr.h	/^    template<typename T, typename U> inline bool operator!=(const OwnPtr<T>& a, const PassOwnPtr<U>& b) $/;"	f	namespace:WTF	signature:(const OwnPtr<T>& a, const PassOwnPtr<U>& b)
WTF::operator !=	.\PassOwnPtr.h	/^    template<typename T, typename U> inline bool operator!=(const PassOwnPtr<T>& a, U* b)$/;"	f	namespace:WTF	signature:(const PassOwnPtr<T>& a, U* b)
WTF::operator !=	.\PassOwnPtr.h	/^    template<typename T, typename U> inline bool operator!=(const PassOwnPtr<T>& a, const OwnPtr<U>& b) $/;"	f	namespace:WTF	signature:(const PassOwnPtr<T>& a, const OwnPtr<U>& b)
WTF::operator !=	.\PassOwnPtr.h	/^    template<typename T, typename U> inline bool operator!=(const PassOwnPtr<T>& a, const PassOwnPtr<U>& b) $/;"	f	namespace:WTF	signature:(const PassOwnPtr<T>& a, const PassOwnPtr<U>& b)
WTF::operator !=	.\PassRefPtr.h	/^    template<typename T, typename U> inline bool operator!=(T* a, const PassRefPtr<U>& b) $/;"	f	namespace:WTF	signature:(T* a, const PassRefPtr<U>& b)
WTF::operator !=	.\PassRefPtr.h	/^    template<typename T, typename U> inline bool operator!=(const PassRefPtr<T>& a, U* b)$/;"	f	namespace:WTF	signature:(const PassRefPtr<T>& a, U* b)
WTF::operator !=	.\PassRefPtr.h	/^    template<typename T, typename U> inline bool operator!=(const PassRefPtr<T>& a, const PassRefPtr<U>& b) $/;"	f	namespace:WTF	signature:(const PassRefPtr<T>& a, const PassRefPtr<U>& b)
WTF::operator !=	.\PassRefPtr.h	/^    template<typename T, typename U> inline bool operator!=(const PassRefPtr<T>& a, const RefPtr<U>& b) $/;"	f	namespace:WTF	signature:(const PassRefPtr<T>& a, const RefPtr<U>& b)
WTF::operator !=	.\PassRefPtr.h	/^    template<typename T, typename U> inline bool operator!=(const RefPtr<T>& a, const PassRefPtr<U>& b) $/;"	f	namespace:WTF	signature:(const RefPtr<T>& a, const PassRefPtr<U>& b)
WTF::operator !=	.\RefPtr.h	/^    template<typename T, typename U> inline bool operator!=(T* a, const RefPtr<U>& b)$/;"	f	namespace:WTF	signature:(T* a, const RefPtr<U>& b)
WTF::operator !=	.\RefPtr.h	/^    template<typename T, typename U> inline bool operator!=(const RefPtr<T>& a, U* b)$/;"	f	namespace:WTF	signature:(const RefPtr<T>& a, U* b)
WTF::operator !=	.\RefPtr.h	/^    template<typename T, typename U> inline bool operator!=(const RefPtr<T>& a, const RefPtr<U>& b)$/;"	f	namespace:WTF	signature:(const RefPtr<T>& a, const RefPtr<U>& b)
WTF::operator !=	.\RetainPtr.h	/^    template<typename T, typename U> inline bool operator!=(T* a, const RetainPtr<U>& b)$/;"	f	namespace:WTF	signature:(T* a, const RetainPtr<U>& b)
WTF::operator !=	.\RetainPtr.h	/^    template<typename T, typename U> inline bool operator!=(const RetainPtr<T>& a, U* b)$/;"	f	namespace:WTF	signature:(const RetainPtr<T>& a, U* b)
WTF::operator !=	.\RetainPtr.h	/^    template<typename T, typename U> inline bool operator!=(const RetainPtr<T>& a, const RetainPtr<U>& b)$/;"	f	namespace:WTF	signature:(const RetainPtr<T>& a, const RetainPtr<U>& b)
WTF::operator !=	.\Vector.h	/^    inline bool operator!=(const Vector<T, inlineCapacity>& a, const Vector<T, inlineCapacity>& b)$/;"	f	namespace:WTF	signature:(const Vector<T, inlineCapacity>& a, const Vector<T, inlineCapacity>& b)
WTF::operator !=	.\gobject\GOwnPtr.h	/^template <typename T, typename U> inline bool operator!=(T* a, const GOwnPtr<U>& b)$/;"	f	namespace:WTF	signature:(T* a, const GOwnPtr<U>& b)
WTF::operator !=	.\gobject\GOwnPtr.h	/^template <typename T, typename U> inline bool operator!=(const GOwnPtr<T>& a, U* b)$/;"	f	namespace:WTF	signature:(const GOwnPtr<T>& a, U* b)
WTF::operator !=	.\gobject\GRefPtr.h	/^template <typename T, typename U> inline bool operator!=(T* a, const GRefPtr<U>& b)$/;"	f	namespace:WTF	signature:(T* a, const GRefPtr<U>& b)
WTF::operator !=	.\gobject\GRefPtr.h	/^template <typename T, typename U> inline bool operator!=(const GRefPtr<T>& a, U* b)$/;"	f	namespace:WTF	signature:(const GRefPtr<T>& a, U* b)
WTF::operator !=	.\gobject\GRefPtr.h	/^template <typename T, typename U> inline bool operator!=(const GRefPtr<T>& a, const GRefPtr<U>& b)$/;"	f	namespace:WTF	signature:(const GRefPtr<T>& a, const GRefPtr<U>& b)
WTF::operator !=	.\text\AtomicString.h	/^inline bool operator!=(const AtomicString& a, const AtomicString& b) { return a.impl() != b.impl(); }$/;"	f	namespace:WTF	signature:(const AtomicString& a, const AtomicString& b)
WTF::operator !=	.\text\AtomicString.h	/^inline bool operator!=(const AtomicString& a, const LChar* b) { return !(a == b); }$/;"	f	namespace:WTF	signature:(const AtomicString& a, const LChar* b)
WTF::operator !=	.\text\AtomicString.h	/^inline bool operator!=(const AtomicString& a, const String& b) { return !equal(a.impl(), b.impl()); }$/;"	f	namespace:WTF	signature:(const AtomicString& a, const String& b)
WTF::operator !=	.\text\AtomicString.h	/^inline bool operator!=(const AtomicString& a, const Vector<UChar>& b) { return !(a == b); }$/;"	f	namespace:WTF	signature:(const AtomicString& a, const Vector<UChar>& b)
WTF::operator !=	.\text\AtomicString.h	/^inline bool operator!=(const AtomicString& a, const char* b) { return !(a == b); }$/;"	f	namespace:WTF	signature:(const AtomicString& a, const char* b)
WTF::operator !=	.\text\AtomicString.h	/^inline bool operator!=(const LChar* a, const AtomicString& b) { return !(b == a); }$/;"	f	namespace:WTF	signature:(const LChar* a, const AtomicString& b)
WTF::operator !=	.\text\AtomicString.h	/^inline bool operator!=(const String& a, const AtomicString& b) { return !equal(a.impl(), b.impl()); }$/;"	f	namespace:WTF	signature:(const String& a, const AtomicString& b)
WTF::operator !=	.\text\AtomicString.h	/^inline bool operator!=(const Vector<UChar>& a, const AtomicString& b) { return !(a == b); }$/;"	f	namespace:WTF	signature:(const Vector<UChar>& a, const AtomicString& b)
WTF::operator !=	.\text\CString.h	/^inline bool operator!=(const CString& a, const CString& b) { return !(a == b); }$/;"	f	namespace:WTF	signature:(const CString& a, const CString& b)
WTF::operator !=	.\text\StringBuilder.h	/^inline bool operator!=(const String& a, const StringBuilder& b) { return !equal(b, a); }$/;"	f	namespace:WTF	signature:(const String& a, const StringBuilder& b)
WTF::operator !=	.\text\StringBuilder.h	/^inline bool operator!=(const StringBuilder& a, const String& b) { return !equal(a, b); }$/;"	f	namespace:WTF	signature:(const StringBuilder& a, const String& b)
WTF::operator !=	.\text\StringBuilder.h	/^inline bool operator!=(const StringBuilder& a, const StringBuilder& b) { return !equal(a, b); }$/;"	f	namespace:WTF	signature:(const StringBuilder& a, const StringBuilder& b)
WTF::operator !=	.\text\WTFString.h	/^inline bool operator!=(const LChar* a, const String& b) { return !equal(a, b.impl()); }$/;"	f	namespace:WTF	signature:(const LChar* a, const String& b)
WTF::operator !=	.\text\WTFString.h	/^inline bool operator!=(const String& a, const LChar* b) { return !equal(a.impl(), b); }$/;"	f	namespace:WTF	signature:(const String& a, const LChar* b)
WTF::operator !=	.\text\WTFString.h	/^inline bool operator!=(const String& a, const String& b) { return !equal(a.impl(), b.impl()); }$/;"	f	namespace:WTF	signature:(const String& a, const String& b)
WTF::operator !=	.\text\WTFString.h	/^inline bool operator!=(const String& a, const Vector<char, inlineCapacity>& b) { return b != a; }$/;"	f	namespace:WTF	signature:(const String& a, const Vector<char, inlineCapacity>& b)
WTF::operator !=	.\text\WTFString.h	/^inline bool operator!=(const String& a, const char* b) { return !equal(a.impl(), reinterpret_cast<const LChar*>(b)); }$/;"	f	namespace:WTF	signature:(const String& a, const char* b)
WTF::operator !=	.\text\WTFString.h	/^inline bool operator!=(const Vector<char, inlineCapacity>& a, const String& b) { return !(a == b); }$/;"	f	namespace:WTF	signature:(const Vector<char, inlineCapacity>& a, const String& b)
WTF::operator !=	.\text\WTFString.h	/^inline bool operator!=(const char* a, const String& b) { return !equal(reinterpret_cast<const LChar*>(a), b.impl()); }$/;"	f	namespace:WTF	signature:(const char* a, const String& b)
WTF::operator *	.\CheckedArithmetic.h	/^template <typename U, typename V, typename OverflowHandler> static inline Checked<typename Result<U, V>::ResultType, OverflowHandler> operator*(Checked<U, OverflowHandler> lhs, Checked<V, OverflowHandler> rhs)$/;"	f	namespace:WTF	signature:(Checked<U, OverflowHandler> lhs, Checked<V, OverflowHandler> rhs)
WTF::operator *	.\CheckedArithmetic.h	/^template <typename U, typename V, typename OverflowHandler> static inline Checked<typename Result<U, V>::ResultType, OverflowHandler> operator*(Checked<U, OverflowHandler> lhs, V rhs)$/;"	f	namespace:WTF	signature:(Checked<U, OverflowHandler> lhs, V rhs)
WTF::operator *	.\CheckedArithmetic.h	/^template <typename U, typename V, typename OverflowHandler> static inline Checked<typename Result<U, V>::ResultType, OverflowHandler> operator*(U lhs, Checked<V, OverflowHandler> rhs)$/;"	f	namespace:WTF	signature:(U lhs, Checked<V, OverflowHandler> rhs)
WTF::operator +	.\CheckedArithmetic.h	/^template <typename U, typename V, typename OverflowHandler> static inline Checked<typename Result<U, V>::ResultType, OverflowHandler> operator+(Checked<U, OverflowHandler> lhs, Checked<V, OverflowHandler> rhs)$/;"	f	namespace:WTF	signature:(Checked<U, OverflowHandler> lhs, Checked<V, OverflowHandler> rhs)
WTF::operator +	.\CheckedArithmetic.h	/^template <typename U, typename V, typename OverflowHandler> static inline Checked<typename Result<U, V>::ResultType, OverflowHandler> operator+(Checked<U, OverflowHandler> lhs, V rhs)$/;"	f	namespace:WTF	signature:(Checked<U, OverflowHandler> lhs, V rhs)
WTF::operator +	.\CheckedArithmetic.h	/^template <typename U, typename V, typename OverflowHandler> static inline Checked<typename Result<U, V>::ResultType, OverflowHandler> operator+(U lhs, Checked<V, OverflowHandler> rhs)$/;"	f	namespace:WTF	signature:(U lhs, Checked<V, OverflowHandler> rhs)
WTF::operator +	.\text\StringOperators.h	/^StringAppend<String, T> operator+(const String& string1, T string2)$/;"	f	namespace:WTF	signature:(const String& string1, T string2)
WTF::operator +	.\text\StringOperators.h	/^StringAppend<StringAppend<U, V>, W> operator+(const StringAppend<U, V>& string1, W string2)$/;"	f	namespace:WTF	signature:(const StringAppend<U, V>& string1, W string2)
WTF::operator +	.\text\StringOperators.h	/^StringAppend<const UChar*, StringAppend<U, V> > operator+(const UChar* string1, const StringAppend<U, V>& string2)$/;"	f	namespace:WTF	signature:(const UChar* string1, const StringAppend<U, V>& string2)
WTF::operator +	.\text\StringOperators.h	/^StringAppend<const char*, StringAppend<U, V> > operator+(const char* string1, const StringAppend<U, V>& string2)$/;"	f	namespace:WTF	signature:(const char* string1, const StringAppend<U, V>& string2)
WTF::operator +	.\text\StringOperators.h	/^inline StringAppend<const UChar*, AtomicString> operator+(const UChar* string1, const AtomicString& string2)$/;"	f	namespace:WTF	signature:(const UChar* string1, const AtomicString& string2)
WTF::operator +	.\text\StringOperators.h	/^inline StringAppend<const UChar*, String> operator+(const UChar* string1, const String& string2)$/;"	f	namespace:WTF	signature:(const UChar* string1, const String& string2)
WTF::operator +	.\text\StringOperators.h	/^inline StringAppend<const char*, AtomicString> operator+(const char* string1, const AtomicString& string2)$/;"	f	namespace:WTF	signature:(const char* string1, const AtomicString& string2)
WTF::operator +	.\text\StringOperators.h	/^inline StringAppend<const char*, String> operator+(const char* string1, const String& string2)$/;"	f	namespace:WTF	signature:(const char* string1, const String& string2)
WTF::operator +=	.\text\WTFString.h	/^inline String& operator+=(String& a, const String& b) { a.append(b); return a; }$/;"	f	namespace:WTF	signature:(String& a, const String& b)
WTF::operator -	.\CheckedArithmetic.h	/^template <typename U, typename V, typename OverflowHandler> static inline Checked<typename Result<U, V>::ResultType, OverflowHandler> operator-(Checked<U, OverflowHandler> lhs, Checked<V, OverflowHandler> rhs)$/;"	f	namespace:WTF	signature:(Checked<U, OverflowHandler> lhs, Checked<V, OverflowHandler> rhs)
WTF::operator -	.\CheckedArithmetic.h	/^template <typename U, typename V, typename OverflowHandler> static inline Checked<typename Result<U, V>::ResultType, OverflowHandler> operator-(Checked<U, OverflowHandler> lhs, V rhs)$/;"	f	namespace:WTF	signature:(Checked<U, OverflowHandler> lhs, V rhs)
WTF::operator -	.\CheckedArithmetic.h	/^template <typename U, typename V, typename OverflowHandler> static inline Checked<typename Result<U, V>::ResultType, OverflowHandler> operator-(U lhs, Checked<V, OverflowHandler> rhs)$/;"	f	namespace:WTF	signature:(U lhs, Checked<V, OverflowHandler> rhs)
WTF::operator <<	.\Vector.h	/^    QDataStream& operator<<(QDataStream& stream, const Vector<T>& data)$/;"	f	namespace:WTF	signature:(QDataStream& stream, const Vector<T>& data)
WTF::operator <<	.\qt\StringQt.cpp	/^QDataStream& operator<<(QDataStream& stream, const String& str)$/;"	f	namespace:WTF	signature:(QDataStream& stream, const String& str)
WTF::operator <<	.\text\WTFString.h	/^QDataStream& operator<<(QDataStream& stream, const String& str);$/;"	p	namespace:WTF	signature:(QDataStream& stream, const String& str)
WTF::operator ==	.\HashIterators.h	/^        inline bool operator==(const HashTableConstKeysIterator<T, U, V>& a, const HashTableConstKeysIterator<T, U, V>& b)$/;"	f	namespace:WTF	signature:(const HashTableConstKeysIterator<T, U, V>& a, const HashTableConstKeysIterator<T, U, V>& b)
WTF::operator ==	.\HashIterators.h	/^        inline bool operator==(const HashTableConstValuesIterator<T, U, V>& a, const HashTableConstValuesIterator<T, U, V>& b)$/;"	f	namespace:WTF	signature:(const HashTableConstValuesIterator<T, U, V>& a, const HashTableConstValuesIterator<T, U, V>& b)
WTF::operator ==	.\HashIterators.h	/^        inline bool operator==(const HashTableKeysIterator<T, U, V>& a, const HashTableKeysIterator<T, U, V>& b)$/;"	f	namespace:WTF	signature:(const HashTableKeysIterator<T, U, V>& a, const HashTableKeysIterator<T, U, V>& b)
WTF::operator ==	.\HashIterators.h	/^        inline bool operator==(const HashTableValuesIterator<T, U, V>& a, const HashTableValuesIterator<T, U, V>& b)$/;"	f	namespace:WTF	signature:(const HashTableValuesIterator<T, U, V>& a, const HashTableValuesIterator<T, U, V>& b)
WTF::operator ==	.\HashMap.h	/^    bool operator==(const HashMap<T, U, V, W, X>& a, const HashMap<T, U, V, W, X>& b)$/;"	f	namespace:WTF	signature:(const HashMap<T, U, V, W, X>& a, const HashMap<T, U, V, W, X>& b)
WTF::operator ==	.\HashTable.h	/^    inline bool operator==(const HashTableConstIteratorAdapter<T, U>& a, const HashTableConstIteratorAdapter<T, U>& b)$/;"	f	namespace:WTF	signature:(const HashTableConstIteratorAdapter<T, U>& a, const HashTableConstIteratorAdapter<T, U>& b)
WTF::operator ==	.\HashTable.h	/^    inline bool operator==(const HashTableConstIteratorAdapter<T, U>& a, const HashTableIteratorAdapter<T, U>& b)$/;"	f	namespace:WTF	signature:(const HashTableConstIteratorAdapter<T, U>& a, const HashTableIteratorAdapter<T, U>& b)
WTF::operator ==	.\HashTable.h	/^    inline bool operator==(const HashTableIteratorAdapter<T, U>& a, const HashTableConstIteratorAdapter<T, U>& b)$/;"	f	namespace:WTF	signature:(const HashTableIteratorAdapter<T, U>& a, const HashTableConstIteratorAdapter<T, U>& b)
WTF::operator ==	.\HashTable.h	/^    inline bool operator==(const HashTableIteratorAdapter<T, U>& a, const HashTableIteratorAdapter<T, U>& b)$/;"	f	namespace:WTF	signature:(const HashTableIteratorAdapter<T, U>& a, const HashTableIteratorAdapter<T, U>& b)
WTF::operator ==	.\OwnArrayPtr.h	/^template<typename T, typename U> inline bool operator==(T* a, const OwnArrayPtr<U>& b) $/;"	f	namespace:WTF	signature:(T* a, const OwnArrayPtr<U>& b)
WTF::operator ==	.\OwnArrayPtr.h	/^template<typename T, typename U> inline bool operator==(const OwnArrayPtr<T>& a, U* b)$/;"	f	namespace:WTF	signature:(const OwnArrayPtr<T>& a, U* b)
WTF::operator ==	.\OwnPtr.h	/^    template<typename T, typename U> inline bool operator==(T* a, const OwnPtr<U>& b) $/;"	f	namespace:WTF	signature:(T* a, const OwnPtr<U>& b)
WTF::operator ==	.\OwnPtr.h	/^    template<typename T, typename U> inline bool operator==(const OwnPtr<T>& a, U* b)$/;"	f	namespace:WTF	signature:(const OwnPtr<T>& a, U* b)
WTF::operator ==	.\PassOwnArrayPtr.h	/^template<typename T, typename U> inline bool operator==(T* a, const PassOwnArrayPtr<U>& b) $/;"	f	namespace:WTF	signature:(T* a, const PassOwnArrayPtr<U>& b)
WTF::operator ==	.\PassOwnArrayPtr.h	/^template<typename T, typename U> inline bool operator==(const OwnArrayPtr<T>& a, const PassOwnArrayPtr<U>& b) $/;"	f	namespace:WTF	signature:(const OwnArrayPtr<T>& a, const PassOwnArrayPtr<U>& b)
WTF::operator ==	.\PassOwnArrayPtr.h	/^template<typename T, typename U> inline bool operator==(const PassOwnArrayPtr<T>& a, U* b) $/;"	f	namespace:WTF	signature:(const PassOwnArrayPtr<T>& a, U* b)
WTF::operator ==	.\PassOwnArrayPtr.h	/^template<typename T, typename U> inline bool operator==(const PassOwnArrayPtr<T>& a, const OwnArrayPtr<U>& b) $/;"	f	namespace:WTF	signature:(const PassOwnArrayPtr<T>& a, const OwnArrayPtr<U>& b)
WTF::operator ==	.\PassOwnArrayPtr.h	/^template<typename T, typename U> inline bool operator==(const PassOwnArrayPtr<T>& a, const PassOwnArrayPtr<U>& b) $/;"	f	namespace:WTF	signature:(const PassOwnArrayPtr<T>& a, const PassOwnArrayPtr<U>& b)
WTF::operator ==	.\PassOwnPtr.h	/^    template<typename T, typename U> inline bool operator==(T* a, const PassOwnPtr<U>& b) $/;"	f	namespace:WTF	signature:(T* a, const PassOwnPtr<U>& b)
WTF::operator ==	.\PassOwnPtr.h	/^    template<typename T, typename U> inline bool operator==(const OwnPtr<T>& a, const PassOwnPtr<U>& b) $/;"	f	namespace:WTF	signature:(const OwnPtr<T>& a, const PassOwnPtr<U>& b)
WTF::operator ==	.\PassOwnPtr.h	/^    template<typename T, typename U> inline bool operator==(const PassOwnPtr<T>& a, U* b) $/;"	f	namespace:WTF	signature:(const PassOwnPtr<T>& a, U* b)
WTF::operator ==	.\PassOwnPtr.h	/^    template<typename T, typename U> inline bool operator==(const PassOwnPtr<T>& a, const OwnPtr<U>& b) $/;"	f	namespace:WTF	signature:(const PassOwnPtr<T>& a, const OwnPtr<U>& b)
WTF::operator ==	.\PassOwnPtr.h	/^    template<typename T, typename U> inline bool operator==(const PassOwnPtr<T>& a, const PassOwnPtr<U>& b) $/;"	f	namespace:WTF	signature:(const PassOwnPtr<T>& a, const PassOwnPtr<U>& b)
WTF::operator ==	.\PassRefPtr.h	/^    template<typename T, typename U> inline bool operator==(T* a, const PassRefPtr<U>& b) $/;"	f	namespace:WTF	signature:(T* a, const PassRefPtr<U>& b)
WTF::operator ==	.\PassRefPtr.h	/^    template<typename T, typename U> inline bool operator==(const PassRefPtr<T>& a, U* b) $/;"	f	namespace:WTF	signature:(const PassRefPtr<T>& a, U* b)
WTF::operator ==	.\PassRefPtr.h	/^    template<typename T, typename U> inline bool operator==(const PassRefPtr<T>& a, const PassRefPtr<U>& b) $/;"	f	namespace:WTF	signature:(const PassRefPtr<T>& a, const PassRefPtr<U>& b)
WTF::operator ==	.\PassRefPtr.h	/^    template<typename T, typename U> inline bool operator==(const PassRefPtr<T>& a, const RefPtr<U>& b) $/;"	f	namespace:WTF	signature:(const PassRefPtr<T>& a, const RefPtr<U>& b)
WTF::operator ==	.\PassRefPtr.h	/^    template<typename T, typename U> inline bool operator==(const RefPtr<T>& a, const PassRefPtr<U>& b) $/;"	f	namespace:WTF	signature:(const RefPtr<T>& a, const PassRefPtr<U>& b)
WTF::operator ==	.\RefPtr.h	/^    template<typename T, typename U> inline bool operator==(T* a, const RefPtr<U>& b) $/;"	f	namespace:WTF	signature:(T* a, const RefPtr<U>& b)
WTF::operator ==	.\RefPtr.h	/^    template<typename T, typename U> inline bool operator==(const RefPtr<T>& a, U* b)$/;"	f	namespace:WTF	signature:(const RefPtr<T>& a, U* b)
WTF::operator ==	.\RefPtr.h	/^    template<typename T, typename U> inline bool operator==(const RefPtr<T>& a, const RefPtr<U>& b)$/;"	f	namespace:WTF	signature:(const RefPtr<T>& a, const RefPtr<U>& b)
WTF::operator ==	.\RetainPtr.h	/^    template<typename T, typename U> inline bool operator==(T* a, const RetainPtr<U>& b) $/;"	f	namespace:WTF	signature:(T* a, const RetainPtr<U>& b)
WTF::operator ==	.\RetainPtr.h	/^    template<typename T, typename U> inline bool operator==(const RetainPtr<T>& a, U* b)$/;"	f	namespace:WTF	signature:(const RetainPtr<T>& a, U* b)
WTF::operator ==	.\RetainPtr.h	/^    template<typename T, typename U> inline bool operator==(const RetainPtr<T>& a, const RetainPtr<U>& b)$/;"	f	namespace:WTF	signature:(const RetainPtr<T>& a, const RetainPtr<U>& b)
WTF::operator ==	.\Vector.h	/^    bool operator==(const Vector<T, inlineCapacity>& a, const Vector<T, inlineCapacity>& b)$/;"	f	namespace:WTF	signature:(const Vector<T, inlineCapacity>& a, const Vector<T, inlineCapacity>& b)
WTF::operator ==	.\gobject\GOwnPtr.h	/^template <typename T, typename U> inline bool operator==(T* a, const GOwnPtr<U>& b) $/;"	f	namespace:WTF	signature:(T* a, const GOwnPtr<U>& b)
WTF::operator ==	.\gobject\GOwnPtr.h	/^template <typename T, typename U> inline bool operator==(const GOwnPtr<T>& a, U* b)$/;"	f	namespace:WTF	signature:(const GOwnPtr<T>& a, U* b)
WTF::operator ==	.\gobject\GRefPtr.h	/^template <typename T, typename U> inline bool operator==(T* a, const GRefPtr<U>& b)$/;"	f	namespace:WTF	signature:(T* a, const GRefPtr<U>& b)
WTF::operator ==	.\gobject\GRefPtr.h	/^template <typename T, typename U> inline bool operator==(const GRefPtr<T>& a, U* b)$/;"	f	namespace:WTF	signature:(const GRefPtr<T>& a, U* b)
WTF::operator ==	.\gobject\GRefPtr.h	/^template <typename T, typename U> inline bool operator==(const GRefPtr<T>& a, const GRefPtr<U>& b)$/;"	f	namespace:WTF	signature:(const GRefPtr<T>& a, const GRefPtr<U>& b)
WTF::operator ==	.\text\AtomicString.h	/^bool operator==(const AtomicString&, const LChar*);$/;"	p	namespace:WTF	signature:(const AtomicString&, const LChar*)
WTF::operator ==	.\text\AtomicString.h	/^inline bool operator==(const AtomicString& a, const AtomicString& b) { return a.impl() == b.impl(); }$/;"	f	namespace:WTF	signature:(const AtomicString& a, const AtomicString& b)
WTF::operator ==	.\text\AtomicString.h	/^inline bool operator==(const AtomicString& a, const String& b) { return equal(a.impl(), b.impl()); }$/;"	f	namespace:WTF	signature:(const AtomicString& a, const String& b)
WTF::operator ==	.\text\AtomicString.h	/^inline bool operator==(const AtomicString& a, const Vector<UChar>& b) { return a.impl() && equal(a.impl(), b.data(), b.size()); }    $/;"	f	namespace:WTF	signature:(const AtomicString& a, const Vector<UChar>& b)
WTF::operator ==	.\text\AtomicString.h	/^inline bool operator==(const AtomicString& a, const char* b) { return WTF::equal(a.impl(), reinterpret_cast<const LChar*>(b)); }$/;"	f	namespace:WTF	signature:(const AtomicString& a, const char* b)
WTF::operator ==	.\text\AtomicString.h	/^inline bool operator==(const LChar* a, const AtomicString& b) { return b == a; }$/;"	f	namespace:WTF	signature:(const LChar* a, const AtomicString& b)
WTF::operator ==	.\text\AtomicString.h	/^inline bool operator==(const String& a, const AtomicString& b) { return equal(a.impl(), b.impl()); }$/;"	f	namespace:WTF	signature:(const String& a, const AtomicString& b)
WTF::operator ==	.\text\AtomicString.h	/^inline bool operator==(const Vector<UChar>& a, const AtomicString& b) { return b == a; }$/;"	f	namespace:WTF	signature:(const Vector<UChar>& a, const AtomicString& b)
WTF::operator ==	.\text\CString.cpp	/^bool operator==(const CString& a, const CString& b)$/;"	f	namespace:WTF	signature:(const CString& a, const CString& b)
WTF::operator ==	.\text\CString.h	/^WTF_EXPORT_PRIVATE bool operator==(const CString& a, const CString& b);$/;"	p	namespace:WTF	signature:(const CString& a, const CString& b)
WTF::operator ==	.\text\StringBuilder.h	/^inline bool operator==(const String& a, const StringBuilder& b) { return equal(b, a); }$/;"	f	namespace:WTF	signature:(const String& a, const StringBuilder& b)
WTF::operator ==	.\text\StringBuilder.h	/^inline bool operator==(const StringBuilder& a, const String& b) { return equal(a, b); }$/;"	f	namespace:WTF	signature:(const StringBuilder& a, const String& b)
WTF::operator ==	.\text\StringBuilder.h	/^inline bool operator==(const StringBuilder& a, const StringBuilder& b) { return equal(a, b); }$/;"	f	namespace:WTF	signature:(const StringBuilder& a, const StringBuilder& b)
WTF::operator ==	.\text\WTFString.h	/^inline bool operator==(const LChar* a, const String& b) { return equal(a, b.impl()); }$/;"	f	namespace:WTF	signature:(const LChar* a, const String& b)
WTF::operator ==	.\text\WTFString.h	/^inline bool operator==(const String& a, const LChar* b) { return equal(a.impl(), b); }$/;"	f	namespace:WTF	signature:(const String& a, const LChar* b)
WTF::operator ==	.\text\WTFString.h	/^inline bool operator==(const String& a, const String& b) { return equal(a.impl(), b.impl()); }$/;"	f	namespace:WTF	signature:(const String& a, const String& b)
WTF::operator ==	.\text\WTFString.h	/^inline bool operator==(const String& a, const Vector<char, inlineCapacity>& b) { return b == a; }$/;"	f	namespace:WTF	signature:(const String& a, const Vector<char, inlineCapacity>& b)
WTF::operator ==	.\text\WTFString.h	/^inline bool operator==(const String& a, const char* b) { return equal(a.impl(), reinterpret_cast<const LChar*>(b)); }$/;"	f	namespace:WTF	signature:(const String& a, const char* b)
WTF::operator ==	.\text\WTFString.h	/^inline bool operator==(const Vector<char, inlineCapacity>& a, const String& b) { return equal(b.impl(), a.data(), a.size()); }$/;"	f	namespace:WTF	signature:(const Vector<char, inlineCapacity>& a, const String& b)
WTF::operator ==	.\text\WTFString.h	/^inline bool operator==(const char* a, const String& b) { return equal(reinterpret_cast<const LChar*>(a), b.impl()); }$/;"	f	namespace:WTF	signature:(const char* a, const String& b)
WTF::operator >>	.\Vector.h	/^    QDataStream& operator>>(QDataStream& stream, Vector<T>& data)$/;"	f	namespace:WTF	signature:(QDataStream& stream, Vector<T>& data)
WTF::operator >>	.\qt\StringQt.cpp	/^QDataStream& operator>>(QDataStream& stream, String& str)$/;"	f	namespace:WTF	signature:(QDataStream& stream, String& str)
WTF::operator >>	.\text\WTFString.h	/^QDataStream& operator>>(QDataStream& stream, String& str);$/;"	p	namespace:WTF	signature:(QDataStream& stream, String& str)
WTF::operator new	.\FastMalloc.cpp	/^void* operator new(size_t size) {$/;"	f	namespace:WTF	signature:(size_t size)
WTF::operator new[]	.\FastMalloc.cpp	/^void* operator new[](size_t size) {$/;"	f	namespace:WTF	signature:(size_t size)
WTF::overall_thread_cache_size	.\FastMalloc.cpp	/^static size_t overall_thread_cache_size = kDefaultOverallThreadCacheSize;$/;"	v	file:
WTF::p5s	.\dtoa.cpp	/^static P5Node* p5s;$/;"	v	file:
WTF::p5sCount	.\dtoa.cpp	/^static int p5sCount;$/;"	v	file:
WTF::pageMask	.\PageBlock.cpp	/^size_t pageMask()$/;"	f	namespace:WTF	signature:()
WTF::pageMask	.\PageBlock.h	/^WTF_EXPORT_PRIVATE size_t pageMask();$/;"	p	namespace:WTF	signature:()
WTF::pageSize	.\PageBlock.cpp	/^size_t pageSize()$/;"	f	namespace:WTF	signature:()
WTF::pageSize	.\PageBlock.h	/^WTF_EXPORT_PRIVATE size_t pageSize();$/;"	p	namespace:WTF	signature:()
WTF::pageheap_lock	.\FastMalloc.cpp	/^static SpinLock pageheap_lock = SPINLOCK_INITIALIZER;$/;"	v	file:
WTF::pageheap_memory	.\FastMalloc.cpp	/^static AllocAlignmentInteger pageheap_memory[(sizeof(TCMalloc_PageHeap) + sizeof(AllocAlignmentInteger) - 1) \/ sizeof(AllocAlignmentInteger)];$/;"	v	file:
WTF::pages	.\FastMalloc.cpp	/^static inline Length pages(size_t bytes) {$/;"	f	namespace:WTF	file:	signature:(size_t bytes)
WTF::pagesize	.\FastMalloc.cpp	/^static size_t pagesize = 0;$/;"	v	file:
WTF::parseDateFromNullTerminatedCharacters	.\DateMath.cpp	/^double parseDateFromNullTerminatedCharacters(const char* dateString)$/;"	f	namespace:WTF	signature:(const char* dateString)
WTF::parseDateFromNullTerminatedCharacters	.\DateMath.cpp	/^double parseDateFromNullTerminatedCharacters(const char* dateString, bool& haveTZ, int& offset)$/;"	f	namespace:WTF	signature:(const char* dateString, bool& haveTZ, int& offset)
WTF::parseDateFromNullTerminatedCharacters	.\DateMath.h	/^WTF_EXPORT_PRIVATE double parseDateFromNullTerminatedCharacters(const char* dateString);$/;"	p	namespace:WTF	signature:(const char* dateString)
WTF::parseDateFromNullTerminatedCharacters	.\DateMath.h	/^double parseDateFromNullTerminatedCharacters(const char* dateString, bool& haveTZ, int& offset);$/;"	p	namespace:WTF	signature:(const char* dateString, bool& haveTZ, int& offset)
WTF::parseES5DateFromNullTerminatedCharacters	.\DateMath.cpp	/^double parseES5DateFromNullTerminatedCharacters(const char* dateString)$/;"	f	namespace:WTF	signature:(const char* dateString)
WTF::parseES5DateFromNullTerminatedCharacters	.\DateMath.h	/^double parseES5DateFromNullTerminatedCharacters(const char* dateString);$/;"	p	namespace:WTF	signature:(const char* dateString)
WTF::parseES5DatePortion	.\DateMath.cpp	/^static char* parseES5DatePortion(const char* currentPosition, long& year, long& month, long& day)$/;"	f	namespace:WTF	file:	signature:(const char* currentPosition, long& year, long& month, long& day)
WTF::parseES5TimePortion	.\DateMath.cpp	/^static char* parseES5TimePortion(char* currentPosition, long& hours, long& minutes, double& seconds, long& timeZoneSeconds)$/;"	f	namespace:WTF	file:	signature:(char* currentPosition, long& hours, long& minutes, double& seconds, long& timeZoneSeconds)
WTF::parseLong	.\DateMath.cpp	/^static bool parseLong(const char* string, char** stopPosition, int base, long* result)$/;"	f	namespace:WTF	file:	signature:(const char* string, char** stopPosition, int base, long* result)
WTF::per_thread_cache_size	.\FastMalloc.cpp	/^static volatile size_t per_thread_cache_size = kMaxThreadCacheSize;$/;"	v	file:
WTF::phinited	.\FastMalloc.cpp	/^static bool phinited = false;$/;"	v	file:
WTF::pipeObject	.\efl\MainThreadEfl.cpp	/^static OwnPtr<Ecore_Pipe>& pipeObject()$/;"	f	namespace:WTF	file:	signature:()
WTF::placeByteAsHex	.\HexNumber.h	/^inline void placeByteAsHex(unsigned char byte, T& destination, HexConversionMode mode = Uppercase)$/;"	f	namespace:WTF	signature:(unsigned char byte, T& destination, HexConversionMode mode = Uppercase)
WTF::placeByteAsHexCompressIfPossible	.\HexNumber.h	/^inline void placeByteAsHexCompressIfPossible(unsigned char byte, T& destination, unsigned& index, HexConversionMode mode = Uppercase)$/;"	f	namespace:WTF	signature:(unsigned char byte, T& destination, unsigned& index, HexConversionMode mode = Uppercase)
WTF::pow5mult	.\dtoa.cpp	/^static ALWAYS_INLINE void pow5mult(BigInt& b, int k)$/;"	f	namespace:WTF	file:	signature:(BigInt& b, int k)
WTF::primes_list	.\FastMalloc.cpp	/^static int primes_list[] = {$/;"	v	file:
WTF::protection	.\OSAllocatorWin.cpp	/^static inline DWORD protection(bool writable, bool executable)$/;"	f	namespace:WTF	file:	signature:(bool writable, bool executable)
WTF::pthreadHandleForIdentifier	.\ThreadingPthreads.cpp	/^static pthread_t pthreadHandleForIdentifier(ThreadIdentifier id)$/;"	f	namespace:WTF	file:	signature:(ThreadIdentifier id)
WTF::putUTF8Triple	.\text\WTFString.cpp	/^static inline void putUTF8Triple(char*& buffer, UChar ch)$/;"	f	namespace:WTF	file:	signature:(char*& buffer, UChar ch)
WTF::qpcAvailable	.\CurrentTime.cpp	/^static bool qpcAvailable()$/;"	f	namespace:WTF	file:	signature:()
WTF::qpcFrequency	.\CurrentTime.cpp	/^static LARGE_INTEGER qpcFrequency;$/;"	v	file:
WTF::quorem	.\dtoa.cpp	/^static ALWAYS_INLINE int quorem(BigInt& b, BigInt& S)$/;"	f	namespace:WTF	file:	signature:(BigInt& b, BigInt& S)
WTF::randomNumber	.\RandomNumber.cpp	/^double randomNumber()$/;"	f	namespace:WTF	signature:()
WTF::randomNumber	.\RandomNumber.h	/^    WTF_EXPORT_PRIVATE double randomNumber();$/;"	p	namespace:WTF	signature:()
WTF::realloc	.\FastMalloc.cpp	/^ALWAYS_INLINE void* realloc(void*, size_t);$/;"	p	namespace:WTF	file:	signature:(void*, size_t)
WTF::realloc	.\FastMalloc.cpp	/^void* realloc(void* old_ptr, size_t new_size) {$/;"	f	namespace:WTF	signature:(void* old_ptr, size_t new_size)
WTF::refGPtr	.\gobject\GRefPtr.cpp	/^template <> GHashTable* refGPtr(GHashTable* ptr)$/;"	f	namespace:WTF	signature:(GHashTable* ptr)
WTF::refGPtr	.\gobject\GRefPtr.cpp	/^template <> GMainContext* refGPtr(GMainContext* ptr)$/;"	f	namespace:WTF	signature:(GMainContext* ptr)
WTF::refGPtr	.\gobject\GRefPtr.cpp	/^template <> GMainLoop* refGPtr(GMainLoop* ptr)$/;"	f	namespace:WTF	signature:(GMainLoop* ptr)
WTF::refGPtr	.\gobject\GRefPtr.cpp	/^template <> GSource* refGPtr(GSource* ptr)$/;"	f	namespace:WTF	signature:(GSource* ptr)
WTF::refGPtr	.\gobject\GRefPtr.cpp	/^template <> GVariant* refGPtr(GVariant* ptr)$/;"	f	namespace:WTF	signature:(GVariant* ptr)
WTF::refGPtr	.\gobject\GRefPtr.h	/^template <> GHashTable* refGPtr(GHashTable* ptr);$/;"	p	namespace:WTF	signature:(GHashTable* ptr)
WTF::refGPtr	.\gobject\GRefPtr.h	/^template <> GMainContext* refGPtr(GMainContext* ptr);$/;"	p	namespace:WTF	signature:(GMainContext* ptr)
WTF::refGPtr	.\gobject\GRefPtr.h	/^template <> GMainLoop* refGPtr(GMainLoop* ptr);$/;"	p	namespace:WTF	signature:(GMainLoop* ptr)
WTF::refGPtr	.\gobject\GRefPtr.h	/^template <> GSource* refGPtr(GSource* ptr);$/;"	p	namespace:WTF	signature:(GSource* ptr)
WTF::refGPtr	.\gobject\GRefPtr.h	/^template <> GVariant* refGPtr(GVariant* ptr);$/;"	p	namespace:WTF	signature:(GVariant* ptr)
WTF::refGPtr	.\gobject\GRefPtr.h	/^template <typename T> inline T* refGPtr(T* ptr)$/;"	f	namespace:WTF	signature:(T* ptr)
WTF::refGPtr	.\gobject\GRefPtr.h	/^template <typename T> inline T* refGPtr(T*);$/;"	p	namespace:WTF	signature:(T*)
WTF::refIfNotNull	.\PassRefPtr.h	/^    template<typename T> REF_DEREF_INLINE void refIfNotNull(T* ptr)$/;"	f	namespace:WTF	signature:(T* ptr)
WTF::registerGCThread	.\MainThread.cpp	/^void registerGCThread()$/;"	f	namespace:WTF	signature:()
WTF::registerGCThread	.\MainThread.h	/^void registerGCThread();$/;"	p	namespace:WTF	signature:()
WTF::releaseFastMallocFreeMemory	.\FastMalloc.cpp	/^void releaseFastMallocFreeMemory() { }$/;"	f	namespace:WTF	signature:()
WTF::releaseFastMallocFreeMemory	.\FastMalloc.cpp	/^void releaseFastMallocFreeMemory()$/;"	f	namespace:WTF	signature:()
WTF::releaseFastMallocFreeMemory	.\FastMalloc.h	/^    WTF_EXPORT_PRIVATE void releaseFastMallocFreeMemory();$/;"	p	namespace:WTF	signature:()
WTF::removeIterator	.\HashTable.h	/^    inline void removeIterator(HashTableConstIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>*) { }$/;"	f	namespace:WTF	signature:(HashTableConstIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>*)
WTF::removeIterator	.\HashTable.h	/^    void removeIterator(HashTableConstIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>* it)$/;"	f	namespace:WTF	signature:(HashTableConstIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>* it)
WTF::removeIterator	.\HashTable.h	/^    void removeIterator(HashTableConstIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>*);$/;"	p	namespace:WTF	signature:(HashTableConstIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>*)
WTF::retainPtr	.\RetainPtr.h	/^    template<typename T> inline RetainPtr<T> retainPtr(T o)$/;"	f	namespace:WTF	signature:(T o)
WTF::reverseBytes	.\MD5.cpp	/^static void reverseBytes(uint8_t* buf, unsigned longs)$/;"	f	namespace:WTF	file:	signature:(uint8_t* buf, unsigned longs)
WTF::reverseFind	.\text\WTFString.h	/^inline size_t reverseFind(const LChar* characters, unsigned length, LChar matchCharacter, unsigned index = UINT_MAX)$/;"	f	namespace:WTF	signature:(const LChar* characters, unsigned length, LChar matchCharacter, unsigned index = UINT_MAX)
WTF::reverseFind	.\text\WTFString.h	/^inline size_t reverseFind(const UChar* characters, unsigned length, UChar matchCharacter, unsigned index = UINT_MAX)$/;"	f	namespace:WTF	signature:(const UChar* characters, unsigned length, UChar matchCharacter, unsigned index = UINT_MAX)
WTF::reverseFindInner	.\text\StringImpl.cpp	/^ALWAYS_INLINE static size_t reverseFindInner(const CharType* searchCharacters, const CharType* matchCharacters, unsigned index, unsigned length, unsigned matchLength)$/;"	f	namespace:WTF	file:	signature:(const CharType* searchCharacters, const CharType* matchCharacters, unsigned index, unsigned length, unsigned matchLength)
WTF::rotateLeft	.\SHA1.cpp	/^static inline uint32_t rotateLeft(int n, uint32_t x)$/;"	f	namespace:WTF	file:	signature:(int n, uint32_t x)
WTF::roundUpToMultipleOf	.\StdLibExtras.h	/^inline size_t roundUpToMultipleOf(size_t divisor, size_t x)$/;"	f	namespace:WTF	signature:(size_t divisor, size_t x)
WTF::roundUpToMultipleOf	.\StdLibExtras.h	/^template<size_t divisor> inline size_t roundUpToMultipleOf(size_t x)$/;"	f	namespace:WTF	signature:(size_t x)
WTF::s_dtoaP5Mutex	.\dtoa.cpp	/^Mutex* s_dtoaP5Mutex;$/;"	v
WTF::s_mainThreadInvokerEventType	.\qt\MainThreadQt.cpp	/^static int s_mainThreadInvokerEventType;$/;"	v	file:
WTF::s_pageMask	.\PageBlock.cpp	/^static size_t s_pageMask;$/;"	v	file:
WTF::s_pageSize	.\PageBlock.cpp	/^static size_t s_pageSize;$/;"	v	file:
WTF::safeAdd	.\CheckedArithmetic.h	/^template <typename U, typename V, typename R> static inline bool safeAdd(U lhs, V rhs, R& result)$/;"	f	namespace:WTF	signature:(U lhs, V rhs, R& result)
WTF::safeCast	.\StdLibExtras.h	/^inline To safeCast(From value)$/;"	f	namespace:WTF	signature:(From value)
WTF::safeEquals	.\CheckedArithmetic.h	/^template <typename U, typename V> static inline bool safeEquals(U lhs, V rhs)$/;"	f	namespace:WTF	signature:(U lhs, V rhs)
WTF::safeMultiply	.\CheckedArithmetic.h	/^template <typename U, typename V, typename R> static inline bool safeMultiply(U lhs, V rhs, R& result)$/;"	f	namespace:WTF	signature:(U lhs, V rhs, R& result)
WTF::safeSub	.\CheckedArithmetic.h	/^template <typename U, typename V, typename R> static inline bool safeSub(U lhs, V rhs, R& result)$/;"	f	namespace:WTF	signature:(U lhs, V rhs, R& result)
WTF::sameSize	.\CheckedArithmetic.h	/^template <typename U, typename V, bool uIsBigger = (sizeof(U) > sizeof(V)), bool sameSize = (sizeof(U) == sizeof(V))> struct ResultBase;$/;"	v
WTF::sample_period	.\FastMalloc.cpp	/^static size_t sample_period = 0;$/;"	v	file:
WTF::sample_period	.\FastMalloc.cpp	/^static size_t sample_period = 262147;$/;"	v	file:
WTF::sample_period_lock	.\FastMalloc.cpp	/^static SpinLock sample_period_lock = SPINLOCK_INITIALIZER;$/;"	v	file:
WTF::sampled_objects	.\FastMalloc.cpp	/^static Span sampled_objects;$/;"	v	file:
WTF::scheduleDispatchFunctionsOnMainThread	.\MainThread.h	/^void scheduleDispatchFunctionsOnMainThread();$/;"	p	namespace:WTF	signature:()
WTF::scheduleDispatchFunctionsOnMainThread	.\blackberry\MainThreadBlackBerry.cpp	/^void scheduleDispatchFunctionsOnMainThread()$/;"	f	namespace:WTF	signature:()
WTF::scheduleDispatchFunctionsOnMainThread	.\efl\MainThreadEfl.cpp	/^void scheduleDispatchFunctionsOnMainThread()$/;"	f	namespace:WTF	signature:()
WTF::scheduleDispatchFunctionsOnMainThread	.\gtk\MainThreadGtk.cpp	/^void scheduleDispatchFunctionsOnMainThread()$/;"	f	namespace:WTF	signature:()
WTF::scheduleDispatchFunctionsOnMainThread	.\qt\MainThreadQt.cpp	/^void scheduleDispatchFunctionsOnMainThread()$/;"	f	namespace:WTF	signature:()
WTF::scheduleDispatchFunctionsOnMainThread	.\win\MainThreadWin.cpp	/^void scheduleDispatchFunctionsOnMainThread()$/;"	f	namespace:WTF	signature:()
WTF::scheduleDispatchFunctionsOnMainThread	.\wx\MainThreadWx.cpp	/^void scheduleDispatchFunctionsOnMainThread()$/;"	f	namespace:WTF	signature:()
WTF::secondsPerDay	.\DateMath.cpp	/^static const double secondsPerDay = 24.0 * 60.0 * 60.0;$/;"	v	file:
WTF::secondsPerHour	.\DateMath.h	/^const double secondsPerHour = 60.0 * 60.0;$/;"	v
WTF::secondsPerMinute	.\DateMath.h	/^const double secondsPerMinute = 60.0;$/;"	v
WTF::secondsPerYear	.\DateMath.cpp	/^static const double secondsPerYear = 24.0 * 60.0 * 60.0 * 365.0;$/;"	v	file:
WTF::setMainThreadCallbacksPaused	.\MainThread.cpp	/^void setMainThreadCallbacksPaused(bool paused)$/;"	f	namespace:WTF	signature:(bool paused)
WTF::setMainThreadCallbacksPaused	.\MainThread.h	/^WTF_EXPORT_PRIVATE void setMainThreadCallbacksPaused(bool paused);$/;"	p	namespace:WTF	signature:(bool paused)
WTF::setMainThreadCallbacksPaused	.\chromium\MainThreadChromium.cpp	/^void setMainThreadCallbacksPaused(bool)$/;"	f	namespace:WTF	signature:(bool)
WTF::setThreadHeap	.\FastMalloc.cpp	/^static ALWAYS_INLINE void setThreadHeap(TCMalloc_ThreadCache* heap)$/;"	f	namespace:WTF	file:	signature:(TCMalloc_ThreadCache* heap)
WTF::set_new_handler_lock	.\FastMalloc.cpp	/^static SpinLock set_new_handler_lock = SPINLOCK_INITIALIZER;$/;"	v	file:
WTF::shift_amount	.\FastMalloc.cpp	/^static const int shift_amount[2] = { 3, 7 };  \/\/ For divides by 8 or 128$/;"	v	file:
WTF::siftDown	.\NonCopyingSort.h	/^inline void siftDown(RandomAccessIterator array, ptrdiff_t start, ptrdiff_t end, Predicate compareLess) $/;"	f	namespace:WTF	signature:(RandomAccessIterator array, ptrdiff_t start, ptrdiff_t end, Predicate compareLess)
WTF::sizeof	.\SizeLimits.cpp	/^COMPILE_ASSERT(sizeof(OwnPtr<int>) == sizeof(int*), OwnPtr_should_stay_small);$/;"	v
WTF::sizeof	.\SizeLimits.cpp	/^COMPILE_ASSERT(sizeof(PassRefPtr<RefCounted<int> >) == sizeof(int*), PassRefPtr_should_stay_small);$/;"	v
WTF::sizeof	.\SizeLimits.cpp	/^COMPILE_ASSERT(sizeof(RefCounted<int>) == sizeof(SameSizeAsRefCounted), RefCounted_should_stay_small);$/;"	v
WTF::sizeof	.\SizeLimits.cpp	/^COMPILE_ASSERT(sizeof(RefCountedCustomAllocated<int>) == sizeof(SameSizeAsRefCounted), RefCountedCustomAllocated_should_stay_small);$/;"	v
WTF::sizeof	.\SizeLimits.cpp	/^COMPILE_ASSERT(sizeof(RefPtr<RefCounted<int> >) == sizeof(int*), RefPtr_should_stay_small);$/;"	v
WTF::sizeof	.\SizeLimits.cpp	/^COMPILE_ASSERT(sizeof(Vector<int>) == 3 * sizeof(int*), Vector_should_stay_small);$/;"	v
WTF::skipSpacesAndComments	.\DateMath.cpp	/^inline static void skipSpacesAndComments(const char*& s)$/;"	f	namespace:WTF	file:	signature:(const char*& s)
WTF::span_allocator	.\FastMalloc.cpp	/^static PageHeapAllocator<Span> span_allocator;$/;"	v	file:
WTF::stacktrace_allocator	.\FastMalloc.cpp	/^static PageHeapAllocator<StackTrace> stacktrace_allocator;$/;"	v	file:
WTF::static_pointer_cast	.\PassOwnArrayPtr.h	/^template<typename T, typename U> inline PassOwnArrayPtr<T> static_pointer_cast(const PassOwnArrayPtr<U>& p) $/;"	f	namespace:WTF	signature:(const PassOwnArrayPtr<U>& p)
WTF::static_pointer_cast	.\PassOwnPtr.h	/^    template<typename T, typename U> inline PassOwnPtr<T> static_pointer_cast(const PassOwnPtr<U>& p) $/;"	f	namespace:WTF	signature:(const PassOwnPtr<U>& p)
WTF::static_pointer_cast	.\PassRefPtr.h	/^    template<typename T, typename U> inline PassRefPtr<T> static_pointer_cast(const PassRefPtr<U>& p) $/;"	f	namespace:WTF	signature:(const PassRefPtr<U>& p)
WTF::static_pointer_cast	.\RefPtr.h	/^    template<typename T, typename U> inline RefPtr<T> static_pointer_cast(const RefPtr<U>& p)$/;"	f	namespace:WTF	signature:(const RefPtr<U>& p)
WTF::static_pointer_cast	.\gobject\GRefPtr.h	/^template <typename T, typename U> inline GRefPtr<T> static_pointer_cast(const GRefPtr<U>& p)$/;"	f	namespace:WTF	signature:(const GRefPtr<U>& p)
WTF::storeInc	.\dtoa.cpp	/^static ALWAYS_INLINE uint32_t* storeInc(uint32_t* p, uint16_t high, uint16_t low)$/;"	f	namespace:WTF	file:	signature:(uint32_t* p, uint16_t high, uint16_t low)
WTF::storeThreadHandleByIdentifier	.\ThreadingWin.cpp	/^static void storeThreadHandleByIdentifier(DWORD threadID, HANDLE threadHandle)$/;"	f	namespace:WTF	file:	signature:(DWORD threadID, HANDLE threadHandle)
WTF::stringHashingStartValue	.\StringHasher.h	/^static const unsigned stringHashingStartValue = 0x9e3779b9U;$/;"	v
WTF::stringTable	.\text\AtomicString.cpp	/^static inline HashSet<StringImpl*>& stringTable()$/;"	f	namespace:WTF	file:	signature:()
WTF::strtod	.\dtoa.cpp	/^double strtod(const char* s00, char** se)$/;"	f	namespace:WTF	signature:(const char* s00, char** se)
WTF::strtod	.\dtoa.cpp	/^template double strtod<AllowTrailingJunk, AllowTrailingSpaces>(const char*, char**);$/;"	p	namespace:WTF	file:	signature:(const char*, char**)
WTF::strtod	.\dtoa.cpp	/^template double strtod<AllowTrailingJunk, DisallowTrailingSpaces>(const char*, char**);$/;"	p	namespace:WTF	file:	signature:(const char*, char**)
WTF::strtod	.\dtoa.cpp	/^template double strtod<DisallowTrailingJunk, AllowTrailingSpaces>(const char*, char**);$/;"	p	namespace:WTF	file:	signature:(const char*, char**)
WTF::strtod	.\dtoa.cpp	/^template double strtod<DisallowTrailingJunk, DisallowTrailingSpaces>(const char*, char**);$/;"	p	namespace:WTF	file:	signature:(const char*, char**)
WTF::strtod	.\dtoa.h	/^double strtod(const char* s00, char** se);$/;"	p	namespace:WTF	signature:(const char* s00, char** se)
WTF::sumWithOverflow	.\text\StringConcatenate.h	/^inline void sumWithOverflow(unsigned& total, unsigned addend, bool& overflow)$/;"	f	namespace:WTF	signature:(unsigned& total, unsigned addend, bool& overflow)
WTF::swap	.\Alignment.h	/^    void swap(AlignedBuffer<size, alignment>& a, AlignedBuffer<size, alignment>& b)$/;"	f	namespace:WTF	signature:(AlignedBuffer<size, alignment>& a, AlignedBuffer<size, alignment>& b)
WTF::swap	.\OwnArrayPtr.h	/^template <typename T> inline void swap(OwnArrayPtr<T>& a, OwnArrayPtr<T>& b)$/;"	f	namespace:WTF	signature:(OwnArrayPtr<T>& a, OwnArrayPtr<T>& b)
WTF::swap	.\OwnPtr.h	/^    template<typename T> inline void swap(OwnPtr<T>& a, OwnPtr<T>& b)$/;"	f	namespace:WTF	signature:(OwnPtr<T>& a, OwnPtr<T>& b)
WTF::swap	.\RefPtr.h	/^    template<class T> inline void swap(RefPtr<T>& a, RefPtr<T>& b)$/;"	f	namespace:WTF	signature:(RefPtr<T>& a, RefPtr<T>& b)
WTF::swap	.\RetainPtr.h	/^    template<typename T> inline void swap(RetainPtr<T>& a, RetainPtr<T>& b)$/;"	f	namespace:WTF	signature:(RetainPtr<T>& a, RetainPtr<T>& b)
WTF::swap	.\Vector.h	/^    inline void swap(Vector<T, inlineCapacity>& a, Vector<T, inlineCapacity>& b)$/;"	f	namespace:WTF	signature:(Vector<T, inlineCapacity>& a, Vector<T, inlineCapacity>& b)
WTF::swap	.\gobject\GOwnPtr.h	/^template <typename T> inline void swap(GOwnPtr<T>& a, GOwnPtr<T>& b)$/;"	f	namespace:WTF	signature:(GOwnPtr<T>& a, GOwnPtr<T>& b)
WTF::swap	.\gobject\GRefPtr.h	/^template <class T> inline void swap(GRefPtr<T>& a, GRefPtr<T>& b)$/;"	f	namespace:WTF	signature:(GRefPtr<T>& a, GRefPtr<T>& b)
WTF::swap	.\text\WTFString.h	/^inline void swap(String& a, String& b) { a.swap(b); }$/;"	f	namespace:WTF	signature:(String& a, String& b)
WTF::syncedTime	.\CurrentTime.cpp	/^static bool syncedTime;$/;"	v	file:
WTF::systemPageSize	.\PageBlock.cpp	/^inline size_t systemPageSize()$/;"	f	namespace:WTF	signature:()
WTF::tagTHREADNAME_INFO	.\ThreadingWin.cpp	/^typedef struct tagTHREADNAME_INFO {$/;"	s	namespace:WTF	file:
WTF::tagTHREADNAME_INFO::dwFlags	.\ThreadingWin.cpp	/^    DWORD dwFlags; \/\/ reserved for future use, must be zero$/;"	m	struct:WTF::tagTHREADNAME_INFO	file:	access:public
WTF::tagTHREADNAME_INFO::dwThreadID	.\ThreadingWin.cpp	/^    DWORD dwThreadID; \/\/ thread ID (-1=caller thread)$/;"	m	struct:WTF::tagTHREADNAME_INFO	file:	access:public
WTF::tagTHREADNAME_INFO::dwType	.\ThreadingWin.cpp	/^    DWORD dwType; \/\/ must be 0x1000$/;"	m	struct:WTF::tagTHREADNAME_INFO	file:	access:public
WTF::tagTHREADNAME_INFO::szName	.\ThreadingWin.cpp	/^    LPCSTR szName; \/\/ pointer to name (in user addr space)$/;"	m	struct:WTF::tagTHREADNAME_INFO	file:	access:public
WTF::tens	.\dtoa.cpp	/^static const double tens[] = {$/;"	v	file:
WTF::testMD5	.\MD5.cpp	/^static inline void testMD5() { }$/;"	f	namespace:WTF	file:	signature:()
WTF::testSHA1	.\SHA1.cpp	/^static inline void testSHA1() { }$/;"	f	namespace:WTF	file:	signature:()
WTF::threadEntryPoint	.\Threading.cpp	/^static void threadEntryPoint(void* contextData)$/;"	f	namespace:WTF	file:	signature:(void* contextData)
WTF::threadHandleForIdentifier	.\ThreadingWin.cpp	/^static HANDLE threadHandleForIdentifier(ThreadIdentifier id)$/;"	f	namespace:WTF	file:	signature:(ThreadIdentifier id)
WTF::threadMap	.\ThreadingPthreads.cpp	/^static ThreadMap& threadMap()$/;"	f	namespace:WTF	file:	signature:()
WTF::threadMap	.\ThreadingWin.cpp	/^static HashMap<DWORD, HANDLE>& threadMap()$/;"	f	namespace:WTF	file:	signature:()
WTF::threadMapMutex	.\ThreadingPthreads.cpp	/^static Mutex& threadMapMutex()$/;"	f	namespace:WTF	file:	signature:()
WTF::threadMapMutex	.\ThreadingWin.cpp	/^static Mutex& threadMapMutex()$/;"	f	namespace:WTF	file:	signature:()
WTF::thread_heap_count	.\FastMalloc.cpp	/^static int thread_heap_count = 0;$/;"	v	file:
WTF::thread_heaps	.\FastMalloc.cpp	/^static TCMalloc_ThreadCache* thread_heaps = NULL;$/;"	v	file:
WTF::threadheap_allocator	.\FastMalloc.cpp	/^static PageHeapAllocator<TCMalloc_ThreadCache> threadheap_allocator;$/;"	v	file:
WTF::threadingFiredMessage	.\win\MainThreadWin.cpp	/^static UINT threadingFiredMessage;$/;"	v	file:
WTF::threadingWindowHandle	.\win\MainThreadWin.cpp	/^static HWND threadingWindowHandle;$/;"	v	file:
WTF::threadlocal_heap	.\FastMalloc.cpp	/^static __thread TCMalloc_ThreadCache *threadlocal_heap;$/;"	v	file:
WTF::timeClip	.\DateMath.cpp	/^double timeClip(double t)$/;"	f	namespace:WTF	signature:(double t)
WTF::timeClip	.\DateMath.h	/^double timeClip(double);$/;"	p	namespace:WTF	signature:(double)
WTF::timeoutFired	.\gtk\MainThreadGtk.cpp	/^static gboolean timeoutFired(gpointer)$/;"	f	namespace:WTF	file:	signature:(gpointer)
WTF::tinytens	.\dtoa.cpp	/^static const double tinytens[] = { 1e-16, 1e-32, 1e-64, 1e-128,$/;"	v	file:
WTF::tlsIndex	.\FastMalloc.cpp	/^DWORD tlsIndex = TLS_OUT_OF_INDEXES;$/;"	v
WTF::tlsKeyCount	.\ThreadSpecific.h	/^long& tlsKeyCount();$/;"	p	namespace:WTF	signature:()
WTF::tlsKeyCount	.\ThreadSpecificWin.cpp	/^long& tlsKeyCount()$/;"	f	namespace:WTF	signature:()
WTF::tlsKeys	.\ThreadSpecific.h	/^DWORD* tlsKeys();$/;"	p	namespace:WTF	signature:()
WTF::tlsKeys	.\ThreadSpecificWin.cpp	/^DWORD* tlsKeys()$/;"	f	namespace:WTF	signature:()
WTF::toASCIIHexValue	.\ASCIICType.h	/^template<typename CharType> inline int toASCIIHexValue(CharType c)$/;"	f	namespace:WTF	signature:(CharType c)
WTF::toASCIIHexValue	.\ASCIICType.h	/^template<typename CharType> inline int toASCIIHexValue(CharType upperValue, CharType lowerValue)$/;"	f	namespace:WTF	signature:(CharType upperValue, CharType lowerValue)
WTF::toASCIILower	.\ASCIICType.h	/^template<typename CharType> inline CharType toASCIILower(CharType c)$/;"	f	namespace:WTF	signature:(CharType c)
WTF::toASCIILowerUnchecked	.\ASCIICType.h	/^template<typename CharType> inline CharType toASCIILowerUnchecked(CharType character)$/;"	f	namespace:WTF	signature:(CharType character)
WTF::toASCIIUpper	.\ASCIICType.h	/^template<typename CharType> inline CharType toASCIIUpper(CharType c)$/;"	f	namespace:WTF	signature:(CharType c)
WTF::toDoubleType	.\text\WTFString.cpp	/^static inline double toDoubleType(const CharType* data, size_t length, bool* ok, bool* didReadNumber)$/;"	f	namespace:WTF	file:	signature:(const CharType* data, size_t length, bool* ok, bool* didReadNumber)
WTF::toIntegralType	.\text\WTFString.cpp	/^static inline IntegralType toIntegralType(const CharType* data, size_t length, bool* ok, int base)$/;"	f	namespace:WTF	file:	signature:(const CharType* data, size_t length, bool* ok, int base)
WTF::true_type	.\TypeTraits.h	/^    typedef IntegralConstant<bool, true>  true_type;$/;"	t	namespace:WTF
WTF::tryFastCalloc	.\FastMalloc.cpp	/^TryMallocReturnValue tryFastCalloc(size_t n, size_t elem_size)$/;"	f	namespace:WTF	signature:(size_t n, size_t elem_size)
WTF::tryFastCalloc	.\FastMalloc.cpp	/^TryMallocReturnValue tryFastCalloc(size_t n_elements, size_t element_size)$/;"	f	namespace:WTF	signature:(size_t n_elements, size_t element_size)
WTF::tryFastCalloc	.\FastMalloc.h	/^    WTF_EXPORT_PRIVATE TryMallocReturnValue tryFastCalloc(size_t n_elements, size_t element_size);$/;"	p	namespace:WTF	signature:(size_t n_elements, size_t element_size)
WTF::tryFastCalloc	.\wince\MemoryManager.cpp	/^TryMallocReturnValue tryFastCalloc(size_t n_elements, size_t element_size)$/;"	f	namespace:WTF	signature:(size_t n_elements, size_t element_size)
WTF::tryFastMalloc	.\FastMalloc.cpp	/^TryMallocReturnValue tryFastMalloc(size_t n) $/;"	f	namespace:WTF	signature:(size_t n)
WTF::tryFastMalloc	.\FastMalloc.cpp	/^TryMallocReturnValue tryFastMalloc(size_t size)$/;"	f	namespace:WTF	signature:(size_t size)
WTF::tryFastMalloc	.\FastMalloc.h	/^    WTF_EXPORT_PRIVATE TryMallocReturnValue tryFastMalloc(size_t n);$/;"	p	namespace:WTF	signature:(size_t n)
WTF::tryFastMalloc	.\wince\MemoryManager.cpp	/^TryMallocReturnValue tryFastMalloc(size_t n)$/;"	f	namespace:WTF	signature:(size_t n)
WTF::tryFastRealloc	.\FastMalloc.cpp	/^TryMallocReturnValue tryFastRealloc(void* old_ptr, size_t new_size)$/;"	f	namespace:WTF	signature:(void* old_ptr, size_t new_size)
WTF::tryFastRealloc	.\FastMalloc.cpp	/^TryMallocReturnValue tryFastRealloc(void* p, size_t n)$/;"	f	namespace:WTF	signature:(void* p, size_t n)
WTF::tryFastRealloc	.\FastMalloc.h	/^    WTF_EXPORT_PRIVATE TryMallocReturnValue tryFastRealloc(void* p, size_t n);$/;"	p	namespace:WTF	signature:(void* p, size_t n)
WTF::tryFastRealloc	.\wince\MemoryManager.cpp	/^TryMallocReturnValue tryFastRealloc(void* p, size_t n)$/;"	f	namespace:WTF	signature:(void* p, size_t n)
WTF::tryFastZeroedMalloc	.\FastMalloc.cpp	/^TryMallocReturnValue tryFastZeroedMalloc(size_t n) $/;"	f	namespace:WTF	signature:(size_t n)
WTF::tryFastZeroedMalloc	.\FastMalloc.h	/^    TryMallocReturnValue tryFastZeroedMalloc(size_t n);$/;"	p	namespace:WTF	signature:(size_t n)
WTF::tryFastZeroedMalloc	.\wince\MemoryManager.cpp	/^TryMallocReturnValue tryFastZeroedMalloc(size_t n)$/;"	f	namespace:WTF	signature:(size_t n)
WTF::tryMakeString	.\text\StringConcatenate.h	/^PassRefPtr<StringImpl> tryMakeString(StringType1 string1, StringType2 string2)$/;"	f	namespace:WTF	signature:(StringType1 string1, StringType2 string2)
WTF::tryMakeString	.\text\StringConcatenate.h	/^PassRefPtr<StringImpl> tryMakeString(StringType1 string1, StringType2 string2, StringType3 string3)$/;"	f	namespace:WTF	signature:(StringType1 string1, StringType2 string2, StringType3 string3)
WTF::tryMakeString	.\text\StringConcatenate.h	/^PassRefPtr<StringImpl> tryMakeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4)$/;"	f	namespace:WTF	signature:(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4)
WTF::tryMakeString	.\text\StringConcatenate.h	/^PassRefPtr<StringImpl> tryMakeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5)$/;"	f	namespace:WTF	signature:(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5)
WTF::tryMakeString	.\text\StringConcatenate.h	/^PassRefPtr<StringImpl> tryMakeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6)$/;"	f	namespace:WTF	signature:(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6)
WTF::tryMakeString	.\text\StringConcatenate.h	/^PassRefPtr<StringImpl> tryMakeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6, StringType7 string7)$/;"	f	namespace:WTF	signature:(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6, StringType7 string7)
WTF::tryMakeString	.\text\StringConcatenate.h	/^PassRefPtr<StringImpl> tryMakeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6, StringType7 string7, StringType8 string8)$/;"	f	namespace:WTF	signature:(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6, StringType7 string7, StringType8 string8)
WTF::tryMakeString	.\text\StringConcatenate.h	/^PassRefPtr<StringImpl> tryMakeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6, StringType7 string7, StringType8 string8, StringType9 string9)$/;"	f	namespace:WTF	signature:(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6, StringType7 string7, StringType8 string8, StringType9 string9)
WTF::tsd_inited	.\FastMalloc.cpp	/^static bool tsd_inited = false;$/;"	v	file:
WTF::twoDigitStringFromNumber	.\DateMath.cpp	/^static String twoDigitStringFromNumber(int number)$/;"	f	namespace:WTF	file:	signature:(int number)
WTF::typelessPointersAreEqual	.\Vector.h	/^    inline bool typelessPointersAreEqual(const void* a, const void* b) { return a == b; }$/;"	f	namespace:WTF	signature:(const void* a, const void* b)
WTF::unlockAtomicallyInitializedStaticMutex	.\Threading.h	/^WTF_EXPORT_PRIVATE void unlockAtomicallyInitializedStaticMutex();$/;"	p	namespace:WTF	signature:()
WTF::unlockAtomicallyInitializedStaticMutex	.\ThreadingPthreads.cpp	/^void unlockAtomicallyInitializedStaticMutex()$/;"	f	namespace:WTF	signature:()
WTF::unlockAtomicallyInitializedStaticMutex	.\ThreadingWin.cpp	/^void unlockAtomicallyInitializedStaticMutex()$/;"	f	namespace:WTF	signature:()
WTF::upperNibbleToASCIIHexDigit	.\ASCIICType.h	/^inline char upperNibbleToASCIIHexDigit(char c)$/;"	f	namespace:WTF	signature:(char c)
WTF::usecPerSec	.\DateMath.cpp	/^static const double usecPerSec = 1000000.0;$/;"	v	file:
WTF::waitForThreadCompletion	.\Threading.cpp	/^WTF_EXPORT_PRIVATE int waitForThreadCompletion(ThreadIdentifier, void**);$/;"	p	namespace:WTF	file:	signature:(ThreadIdentifier, void**)
WTF::waitForThreadCompletion	.\Threading.cpp	/^int waitForThreadCompletion(ThreadIdentifier threadID, void**)$/;"	f	namespace:WTF	signature:(ThreadIdentifier threadID, void**)
WTF::waitForThreadCompletion	.\Threading.h	/^WTF_EXPORT_PRIVATE int waitForThreadCompletion(ThreadIdentifier);$/;"	p	namespace:WTF	signature:(ThreadIdentifier)
WTF::waitForThreadCompletion	.\ThreadingPthreads.cpp	/^int waitForThreadCompletion(ThreadIdentifier threadID)$/;"	f	namespace:WTF	signature:(ThreadIdentifier threadID)
WTF::waitForThreadCompletion	.\ThreadingWin.cpp	/^int waitForThreadCompletion(ThreadIdentifier threadID)$/;"	f	namespace:WTF	signature:(ThreadIdentifier threadID)
WTF::weakCompareAndSwap	.\Atomics.h	/^inline bool weakCompareAndSwap(void*volatile* location, void* expected, void* newValue)$/;"	f	namespace:WTF	signature:(void*volatile* location, void* expected, void* newValue)
WTF::weakCompareAndSwap	.\Atomics.h	/^inline bool weakCompareAndSwap(volatile unsigned* location, unsigned expected, unsigned newValue) $/;"	f	namespace:WTF	signature:(volatile unsigned* location, unsigned expected, unsigned newValue)
WTF::weakCompareAndSwapUIntPtr	.\Atomics.h	/^inline bool weakCompareAndSwapUIntPtr(volatile uintptr_t* location, uintptr_t expected, uintptr_t newValue)$/;"	f	namespace:WTF	signature:(volatile uintptr_t* location, uintptr_t expected, uintptr_t newValue)
WTF::weekdayName	.\DateMath.h	/^const char* const weekdayName[7] = { "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun" };$/;"	v
WTF::workAroundClangBug	.\CheckedArithmetic.h	/^static inline bool workAroundClangBug() { return true; }$/;"	f	namespace:WTF	signature:()
WTF::wtfThreadData	.\WTFThreadData.h	/^inline WTFThreadData& wtfThreadData()$/;"	f	namespace:WTF	signature:()
WTF::wtfThreadEntryPoint	.\ThreadingPthreads.cpp	/^static void* wtfThreadEntryPoint(void* param)$/;"	f	namespace:WTF	file:	signature:(void* param)
WTF::wtfThreadEntryPoint	.\ThreadingWin.cpp	/^static unsigned __stdcall wtfThreadEntryPoint(void* param)$/;"	f	namespace:WTF	file:	signature:(void* param)
WTF::yield	.\Threading.h	/^WTF_EXPORT_PRIVATE void yield();$/;"	p	namespace:WTF	signature:()
WTF::yield	.\ThreadingPthreads.cpp	/^void yield()$/;"	f	namespace:WTF	signature:()
WTF::yield	.\ThreadingWin.cpp	/^void yield()$/;"	f	namespace:WTF	signature:()
WTF::ymdhmsToSeconds	.\DateMath.cpp	/^static inline double ymdhmsToSeconds(long year, int mon, int day, int hour, int minute, double second)$/;"	f	namespace:WTF	file:	signature:(long year, int mon, int day, int hour, int minute, double second)
WTFAnnotateBenignRaceSized	.\DynamicAnnotations.cpp	/^void WTFAnnotateBenignRaceSized(const char*, int, const volatile void*, long, const char*)$/;"	f	signature:(const char*, int, const volatile void*, long, const char*)
WTFAnnotateBenignRaceSized	.\DynamicAnnotations.h	/^void WTFAnnotateBenignRaceSized(const char* file, int line, const volatile void* memory, long size, const char* description);$/;"	p	signature:(const char* file, int line, const volatile void* memory, long size, const char* description)
WTFAnnotateHappensAfter	.\DynamicAnnotations.cpp	/^void WTFAnnotateHappensAfter(const char*, int, const volatile void*)$/;"	f	signature:(const char*, int, const volatile void*)
WTFAnnotateHappensAfter	.\DynamicAnnotations.h	/^void WTFAnnotateHappensAfter(const char* file, int line, const volatile void* address);$/;"	p	signature:(const char* file, int line, const volatile void* address)
WTFAnnotateHappensBefore	.\DynamicAnnotations.cpp	/^void WTFAnnotateHappensBefore(const char*, int, const volatile void*)$/;"	f	signature:(const char*, int, const volatile void*)
WTFAnnotateHappensBefore	.\DynamicAnnotations.h	/^void WTFAnnotateHappensBefore(const char* file, int line, const volatile void* address);$/;"	p	signature:(const char* file, int line, const volatile void* address)
WTFCrashHookFunction	.\Assertions.h	/^typedef void (*WTFCrashHookFunction)();$/;"	t
WTFGetBacktrace	.\Assertions.cpp	/^void WTFGetBacktrace(void** stack, int* size)$/;"	f	signature:(void** stack, int* size)
WTFGetBacktrace	.\Assertions.h	/^WTF_EXPORT_PRIVATE void WTFGetBacktrace(void** stack, int* size);$/;"	p	signature:(void** stack, int* size)
WTFInvokeCrashHook	.\Assertions.cpp	/^void WTFInvokeCrashHook()$/;"	f	signature:()
WTFInvokeCrashHook	.\Assertions.h	/^WTF_EXPORT_PRIVATE void WTFInvokeCrashHook();$/;"	p	signature:()
WTFLog	.\Assertions.cpp	/^void WTFLog(WTFLogChannel* channel, const char* format, ...)$/;"	f	signature:(WTFLogChannel* channel, const char* format, ...)
WTFLogChannel	.\Assertions.h	/^} WTFLogChannel;$/;"	t	typeref:struct:__anon2
WTFLogChannelOff	.\Assertions.h	/^typedef enum { WTFLogChannelOff, WTFLogChannelOn } WTFLogChannelState;$/;"	e	enum:__anon1
WTFLogChannelOn	.\Assertions.h	/^typedef enum { WTFLogChannelOff, WTFLogChannelOn } WTFLogChannelState;$/;"	e	enum:__anon1
WTFLogChannelState	.\Assertions.h	/^typedef enum { WTFLogChannelOff, WTFLogChannelOn } WTFLogChannelState;$/;"	t	typeref:enum:__anon1
WTFLogLocker	.\Assertions.cpp	/^    WTFLogLocker(BlackBerry::Platform::MessageLogLevel logLevel)$/;"	f	struct:WTFLogLocker	access:public	signature:(BlackBerry::Platform::MessageLogLevel logLevel)
WTFLogLocker	.\Assertions.cpp	/^struct WTFLogLocker {$/;"	s	file:
WTFLogLocker::WTFLogLocker	.\Assertions.cpp	/^    WTFLogLocker(BlackBerry::Platform::MessageLogLevel logLevel)$/;"	f	struct:WTFLogLocker	access:public	signature:(BlackBerry::Platform::MessageLogLevel logLevel)
WTFLogLocker::~WTFLogLocker	.\Assertions.cpp	/^    ~WTFLogLocker()$/;"	f	struct:WTFLogLocker	access:public	signature:()
WTFLogVerbose	.\Assertions.cpp	/^void WTFLogVerbose(const char* file, int line, const char* function, WTFLogChannel* channel, const char* format, ...)$/;"	f	signature:(const char* file, int line, const char* function, WTFLogChannel* channel, const char* format, ...)
WTFPrintBacktrace	.\Assertions.cpp	/^void WTFPrintBacktrace(void** stack, int size)$/;"	f	signature:(void** stack, int size)
WTFPrintBacktrace	.\Assertions.h	/^WTF_EXPORT_PRIVATE void WTFPrintBacktrace(void** stack, int size);$/;"	p	signature:(void** stack, int size)
WTFReportArgumentAssertionFailure	.\Assertions.cpp	/^void WTFReportArgumentAssertionFailure(const char* file, int line, const char* function, const char* argName, const char* assertion)$/;"	f	signature:(const char* file, int line, const char* function, const char* argName, const char* assertion)
WTFReportArgumentAssertionFailure	.\Assertions.h	/^WTF_EXPORT_PRIVATE void WTFReportArgumentAssertionFailure(const char* file, int line, const char* function, const char* argName, const char* assertion);$/;"	p	signature:(const char* file, int line, const char* function, const char* argName, const char* assertion)
WTFReportAssertionFailure	.\Assertions.cpp	/^void WTFReportAssertionFailure(const char* file, int line, const char* function, const char* assertion)$/;"	f	signature:(const char* file, int line, const char* function, const char* assertion)
WTFReportAssertionFailure	.\Assertions.h	/^WTF_EXPORT_PRIVATE void WTFReportAssertionFailure(const char* file, int line, const char* function, const char* assertion);$/;"	p	signature:(const char* file, int line, const char* function, const char* assertion)
WTFReportAssertionFailureWithMessage	.\Assertions.cpp	/^void WTFReportAssertionFailureWithMessage(const char* file, int line, const char* function, const char* assertion, const char* format, ...)$/;"	f	signature:(const char* file, int line, const char* function, const char* assertion, const char* format, ...)
WTFReportBacktrace	.\Assertions.cpp	/^void WTFReportBacktrace()$/;"	f	signature:()
WTFReportBacktrace	.\Assertions.h	/^WTF_EXPORT_PRIVATE void WTFReportBacktrace();$/;"	p	signature:()
WTFReportError	.\Assertions.cpp	/^void WTFReportError(const char* file, int line, const char* function, const char* format, ...)$/;"	f	signature:(const char* file, int line, const char* function, const char* format, ...)
WTFReportFatalError	.\Assertions.cpp	/^void WTFReportFatalError(const char* file, int line, const char* function, const char* format, ...)$/;"	f	signature:(const char* file, int line, const char* function, const char* format, ...)
WTFSetCrashHook	.\Assertions.cpp	/^void WTFSetCrashHook(WTFCrashHookFunction function)$/;"	f	signature:(WTFCrashHookFunction function)
WTFSetCrashHook	.\Assertions.h	/^WTF_EXPORT_PRIVATE void WTFSetCrashHook(WTFCrashHookFunction);$/;"	p	signature:(WTFCrashHookFunction)
WTFString_h	.\text\WTFString.h	23;"	d
WTFThreadData	.\WTFThreadData.cpp	/^WTFThreadData::WTFThreadData()$/;"	f	class:WTF::WTFThreadData	signature:()
WTFThreadData	.\WTFThreadData.h	/^    WTF_EXPORT_PRIVATE WTFThreadData();$/;"	p	class:WTF::WTFThreadData	access:public	signature:()
WTFThreadData	.\WTFThreadData.h	/^class WTFThreadData {$/;"	c	namespace:WTF
WTFThreadData_h	.\WTFThreadData.h	28;"	d
WTF_ALIGNED	.\Alignment.h	/^    template<size_t size> struct AlignedBuffer<size, 16> { WTF_ALIGNED(AlignedBufferChar, buffer[size], 16); };$/;"	p	struct:WTF::AlignedBuffer	access:public	signature:(AlignedBufferChar, buffer[size], 16)
WTF_ALIGNED	.\Alignment.h	/^    template<size_t size> struct AlignedBuffer<size, 2> { WTF_ALIGNED(AlignedBufferChar, buffer[size], 2);  };$/;"	p	struct:WTF::AlignedBuffer	access:public	signature:(AlignedBufferChar, buffer[size], 2)
WTF_ALIGNED	.\Alignment.h	/^    template<size_t size> struct AlignedBuffer<size, 32> { WTF_ALIGNED(AlignedBufferChar, buffer[size], 32); };$/;"	p	struct:WTF::AlignedBuffer	access:public	signature:(AlignedBufferChar, buffer[size], 32)
WTF_ALIGNED	.\Alignment.h	/^    template<size_t size> struct AlignedBuffer<size, 4> { WTF_ALIGNED(AlignedBufferChar, buffer[size], 4);  };$/;"	p	struct:WTF::AlignedBuffer	access:public	signature:(AlignedBufferChar, buffer[size], 4)
WTF_ALIGNED	.\Alignment.h	/^    template<size_t size> struct AlignedBuffer<size, 64> { WTF_ALIGNED(AlignedBufferChar, buffer[size], 64); };$/;"	p	struct:WTF::AlignedBuffer	access:public	signature:(AlignedBufferChar, buffer[size], 64)
WTF_ALIGNED	.\Alignment.h	/^    template<size_t size> struct AlignedBuffer<size, 8> { WTF_ALIGNED(AlignedBufferChar, buffer[size], 8);  };$/;"	p	struct:WTF::AlignedBuffer	access:public	signature:(AlignedBufferChar, buffer[size], 8)
WTF_ALIGNED	.\Alignment.h	31;"	d
WTF_ALIGN_OF	.\Alignment.h	30;"	d
WTF_ANNOTATE_BENIGN_RACE	.\DynamicAnnotations.h	54;"	d
WTF_ANNOTATE_BENIGN_RACE	.\DynamicAnnotations.h	91;"	d
WTF_ANNOTATE_BENIGN_RACE_SIZED	.\DynamicAnnotations.h	53;"	d
WTF_ANNOTATE_BENIGN_RACE_SIZED	.\DynamicAnnotations.h	90;"	d
WTF_ANNOTATE_HAPPENS_AFTER	.\DynamicAnnotations.h	74;"	d
WTF_ANNOTATE_HAPPENS_AFTER	.\DynamicAnnotations.h	93;"	d
WTF_ANNOTATE_HAPPENS_BEFORE	.\DynamicAnnotations.h	73;"	d
WTF_ANNOTATE_HAPPENS_BEFORE	.\DynamicAnnotations.h	92;"	d
WTF_ARM_ARCH_AT_LEAST	.\Platform.h	184;"	d
WTF_ARM_ARCH_VERSION	.\Platform.h	191;"	d
WTF_ARM_ARCH_VERSION	.\Platform.h	196;"	d
WTF_ARM_ARCH_VERSION	.\Platform.h	201;"	d
WTF_ARM_ARCH_VERSION	.\Platform.h	212;"	d
WTF_ARM_ARCH_VERSION	.\Platform.h	216;"	d
WTF_ARM_ARCH_VERSION	.\Platform.h	220;"	d
WTF_ARM_ARCH_VERSION	.\Platform.h	230;"	d
WTF_ARRAY_LENGTH	.\StdLibExtras.h	154;"	d
WTF_ASCIICType_h	.\ASCIICType.h	30;"	d
WTF_ATTRIBUTE_PRINTF	.\Assertions.h	120;"	d
WTF_ATTRIBUTE_PRINTF	.\Assertions.h	122;"	d
WTF_Alignment_h	.\Alignment.h	22;"	d
WTF_Assertions_h	.\Assertions.h	27;"	d
WTF_BoundsCheckedPointer_h	.\BoundsCheckedPointer.h	30;"	d
WTF_COMPILER_CLANG	.\Compiler.h	39;"	d
WTF_COMPILER_GCC	.\Compiler.h	95;"	d
WTF_COMPILER_GCCE	.\Compiler.h	87;"	d
WTF_COMPILER_INTEL	.\Compiler.h	121;"	d
WTF_COMPILER_MINGW	.\Compiler.h	112;"	d
WTF_COMPILER_MINGW64	.\Compiler.h	115;"	d
WTF_COMPILER_MSVC	.\Compiler.h	61;"	d
WTF_COMPILER_MSVC7_OR_LOWER	.\Compiler.h	63;"	d
WTF_COMPILER_MSVC9_OR_LOWER	.\Compiler.h	65;"	d
WTF_COMPILER_RVCT	.\Compiler.h	78;"	d
WTF_COMPILER_SUNCC	.\Compiler.h	126;"	d
WTF_COMPILER_SUPPORTS_BLOCKS	.\Compiler.h	50;"	d
WTF_COMPILER_SUPPORTS_CXX_DELETED_FUNCTIONS	.\Compiler.h	48;"	d
WTF_COMPILER_SUPPORTS_CXX_NULLPTR	.\Compiler.h	101;"	d
WTF_COMPILER_SUPPORTS_CXX_NULLPTR	.\Compiler.h	49;"	d
WTF_COMPILER_SUPPORTS_CXX_NULLPTR	.\Compiler.h	70;"	d
WTF_COMPILER_SUPPORTS_CXX_RVALUE_REFERENCES	.\Compiler.h	47;"	d
WTF_COMPILER_SUPPORTS_CXX_VARIADIC_TEMPLATES	.\Compiler.h	46;"	d
WTF_COMPILER_SUPPORTS_C_STATIC_ASSERT	.\Compiler.h	51;"	d
WTF_COMPILER_SUPPORTS_HAS_TRIVIAL_DESTRUCTOR	.\Compiler.h	53;"	d
WTF_CPU_ALPHA	.\Platform.h	65;"	d
WTF_CPU_ARM	.\Platform.h	170;"	d
WTF_CPU_ARMV5_OR_LOWER	.\Platform.h	270;"	d
WTF_CPU_ARM_NEON	.\Platform.h	293;"	d
WTF_CPU_ARM_THUMB2	.\Platform.h	281;"	d
WTF_CPU_ARM_THUMB2	.\Platform.h	284;"	d
WTF_CPU_ARM_TRADITIONAL	.\Platform.h	280;"	d
WTF_CPU_ARM_TRADITIONAL	.\Platform.h	283;"	d
WTF_CPU_BIG_ENDIAN	.\Platform.h	106;"	d
WTF_CPU_BIG_ENDIAN	.\Platform.h	113;"	d
WTF_CPU_BIG_ENDIAN	.\Platform.h	124;"	d
WTF_CPU_BIG_ENDIAN	.\Platform.h	130;"	d
WTF_CPU_BIG_ENDIAN	.\Platform.h	141;"	d
WTF_CPU_BIG_ENDIAN	.\Platform.h	147;"	d
WTF_CPU_BIG_ENDIAN	.\Platform.h	173;"	d
WTF_CPU_BIG_ENDIAN	.\Platform.h	83;"	d
WTF_CPU_IA64	.\Platform.h	70;"	d
WTF_CPU_IA64_32	.\Platform.h	73;"	d
WTF_CPU_MIDDLE_ENDIAN	.\Platform.h	180;"	d
WTF_CPU_MIPS	.\Platform.h	81;"	d
WTF_CPU_NEEDS_ALIGNED_ACCESS	.\Platform.h	299;"	d
WTF_CPU_PPC	.\Platform.h	105;"	d
WTF_CPU_PPC64	.\Platform.h	112;"	d
WTF_CPU_S390	.\Platform.h	146;"	d
WTF_CPU_S390X	.\Platform.h	140;"	d
WTF_CPU_SH4	.\Platform.h	118;"	d
WTF_CPU_SPARC	.\Platform.h	135;"	d
WTF_CPU_SPARC32	.\Platform.h	123;"	d
WTF_CPU_SPARC64	.\Platform.h	129;"	d
WTF_CPU_X86	.\Platform.h	156;"	d
WTF_CPU_X86_64	.\Platform.h	162;"	d
WTF_Collator_h	.\unicode\Collator.h	30;"	d
WTF_Compiler_h	.\Compiler.h	27;"	d
WTF_Complex_h	.\Complex.h	30;"	d
WTF_CryptographicallyRandomNumber_h	.\CryptographicallyRandomNumber.h	27;"	d
WTF_Deque_h	.\Deque.h	31;"	d
WTF_DisallowCType_h	.\DisallowCType.h	30;"	d
WTF_DynamicAnnotations_h	.\DynamicAnnotations.h	28;"	d
WTF_EXPORT	.\ExportMacros.h	39;"	d
WTF_EXPORT	.\ExportMacros.h	43;"	d
WTF_EXPORT	.\ExportMacros.h	47;"	d
WTF_EXPORT	.\ExportMacros.h	74;"	d
WTF_EXPORTCLASS	.\ExportMacros.h	72;"	d
WTF_EXPORTDATA	.\ExportMacros.h	55;"	d
WTF_EXPORTDATA	.\ExportMacros.h	57;"	d
WTF_EXPORTDATA	.\ExportMacros.h	64;"	d
WTF_EXPORTDATA	.\ExportMacros.h	66;"	d
WTF_EXPORTDATA	.\ExportMacros.h	69;"	d
WTF_EXPORT_HIDDEN	.\ExportMacros.h	94;"	d
WTF_EXPORT_PRIVATE	.\ExportMacros.h	81;"	d
WTF_EXPORT_PRIVATE	.\ExportMacros.h	83;"	d
WTF_EXPORT_PRIVATE_RTTI	.\ExportMacros.h	89;"	d
WTF_EXPORT_PRIVATE_RTTI	.\ExportMacros.h	91;"	d
WTF_FastMallocWinCE_h	.\wince\FastMallocWinCE.h	23;"	d
WTF_FastMalloc_h	.\FastMalloc.h	22;"	d
WTF_Forward_h	.\Forward.h	22;"	d
WTF_Functional_h	.\Functional.h	27;"	d
WTF_GRefPtr_h	.\gobject\GRefPtr.h	24;"	d
WTF_GetPtr_h	.\GetPtr.h	22;"	d
WTF_HIDDEN	.\ExportMacros.h	41;"	d
WTF_HIDDEN	.\ExportMacros.h	45;"	d
WTF_HIDDEN	.\ExportMacros.h	49;"	d
WTF_HIDDEN	.\ExportMacros.h	76;"	d
WTF_HashCountedSet_h	.\HashCountedSet.h	22;"	d
WTF_HashFunctions_h	.\HashFunctions.h	22;"	d
WTF_HashIterators_h	.\HashIterators.h	27;"	d
WTF_HashMap_h	.\HashMap.h	22;"	d
WTF_HashSet_h	.\HashSet.h	22;"	d
WTF_HashTable_h	.\HashTable.h	23;"	d
WTF_HashTraits_h	.\HashTraits.h	22;"	d
WTF_IMPORT	.\ExportMacros.h	40;"	d
WTF_IMPORT	.\ExportMacros.h	44;"	d
WTF_IMPORT	.\ExportMacros.h	48;"	d
WTF_IMPORT	.\ExportMacros.h	75;"	d
WTF_ListHashSet_h	.\ListHashSet.h	23;"	d
WTF_ListRefPtr_h	.\ListRefPtr.h	22;"	d
WTF_MAKE_FAST_ALLOCATED	.\Deque.h	/^        WTF_MAKE_FAST_ALLOCATED;$/;"	m	class:WTF::Deque	access:private
WTF_MAKE_FAST_ALLOCATED	.\FastAllocBase.h	96;"	d
WTF_MAKE_FAST_ALLOCATED	.\HashCountedSet.h	/^        WTF_MAKE_FAST_ALLOCATED;$/;"	m	class:WTF::HashCountedSet	access:private
WTF_MAKE_FAST_ALLOCATED	.\HashMap.h	/^        WTF_MAKE_FAST_ALLOCATED;$/;"	m	class:WTF::HashMap	access:private
WTF_MAKE_FAST_ALLOCATED	.\HashSet.h	/^        WTF_MAKE_FAST_ALLOCATED;$/;"	m	class:WTF::HashSet	access:private
WTF_MAKE_FAST_ALLOCATED	.\ListHashSet.h	/^        WTF_MAKE_FAST_ALLOCATED;$/;"	m	class:WTF::ListHashSet	access:private
WTF_MAKE_FAST_ALLOCATED	.\ParallelJobs.h	/^    WTF_MAKE_FAST_ALLOCATED;$/;"	m	class:WTF::ParallelJobs	access:private
WTF_MAKE_FAST_ALLOCATED	.\ParallelJobsGeneric.h	/^    WTF_MAKE_FAST_ALLOCATED;$/;"	m	class:WTF::ParallelEnvironment	access:private
WTF_MAKE_FAST_ALLOCATED	.\ParallelJobsLibdispatch.h	/^    WTF_MAKE_FAST_ALLOCATED;$/;"	m	class:WTF::ParallelEnvironment	access:private
WTF_MAKE_FAST_ALLOCATED	.\RefCounted.h	/^    WTF_MAKE_NONCOPYABLE(RefCounted); WTF_MAKE_FAST_ALLOCATED;$/;"	m	class:WTF::RefCounted	access:private
WTF_MAKE_FAST_ALLOCATED	.\RefPtr.h	/^        WTF_MAKE_FAST_ALLOCATED;$/;"	m	class:WTF::RefPtr	access:private
WTF_MAKE_FAST_ALLOCATED	.\RefPtrHashMap.h	/^        WTF_MAKE_FAST_ALLOCATED;$/;"	m	class:WTF::HashMap	access:private
WTF_MAKE_FAST_ALLOCATED	.\ThreadSafeRefCounted.h	/^    WTF_MAKE_FAST_ALLOCATED;$/;"	m	class:WTF::ThreadSafeRefCountedBase	access:private
WTF_MAKE_FAST_ALLOCATED	.\Threading.cpp	/^    WTF_MAKE_FAST_ALLOCATED;$/;"	m	struct:WTF::NewThreadContext	file:	access:public
WTF_MAKE_FAST_ALLOCATED	.\ThreadingPrimitives.h	/^    WTF_MAKE_NONCOPYABLE(Mutex); WTF_MAKE_FAST_ALLOCATED;$/;"	m	class:WTF::Mutex	access:private
WTF_MAKE_FAST_ALLOCATED	.\Vector.h	/^        WTF_MAKE_FAST_ALLOCATED;$/;"	m	class:WTF::Vector	access:private
WTF_MAKE_FAST_ALLOCATED	.\WTFThreadData.h	/^    WTF_MAKE_FAST_ALLOCATED;$/;"	m	class:JSC::IdentifierTable	access:private
WTF_MAKE_FAST_ALLOCATED	.\dtoa.cpp	/^    WTF_MAKE_NONCOPYABLE(P5Node); WTF_MAKE_FAST_ALLOCATED;$/;"	m	struct:WTF::P5Node	file:	access:public
WTF_MAKE_FAST_ALLOCATED	.\text\StringImpl.h	/^    WTF_MAKE_NONCOPYABLE(StringImpl); WTF_MAKE_FAST_ALLOCATED;$/;"	m	class:WTF::StringImpl	access:private
WTF_MAKE_FAST_ALLOCATED	.\unicode\Collator.h	/^        WTF_MAKE_NONCOPYABLE(Collator); WTF_MAKE_FAST_ALLOCATED;$/;"	m	class:WTF::Collator	access:private
WTF_MAKE_NONCOPYABLE	.\ArrayBuffer.h	/^    WTF_MAKE_NONCOPYABLE(ArrayBufferContents);$/;"	p	class:WTF::ArrayBufferContents	access:private	signature:(ArrayBufferContents)
WTF_MAKE_NONCOPYABLE	.\Locker.h	/^    WTF_MAKE_NONCOPYABLE(Locker);$/;"	p	class:WTF::Locker	access:private	signature:(Locker)
WTF_MAKE_NONCOPYABLE	.\MessageQueue.h	/^        WTF_MAKE_NONCOPYABLE(MessageQueue);$/;"	p	class:WTF::MessageQueue	access:private	signature:(MessageQueue)
WTF_MAKE_NONCOPYABLE	.\MetaAllocator.h	/^    WTF_MAKE_NONCOPYABLE(MetaAllocator);$/;"	p	class:WTF::MetaAllocator	access:private	signature:(MetaAllocator)
WTF_MAKE_NONCOPYABLE	.\Noncopyable.h	27;"	d
WTF_MAKE_NONCOPYABLE	.\Noncopyable.h	36;"	d
WTF_MAKE_NONCOPYABLE	.\ParallelJobsOpenMP.h	/^    WTF_MAKE_NONCOPYABLE(ParallelEnvironment);$/;"	p	class:WTF::ParallelEnvironment	access:private	signature:(ParallelEnvironment)
WTF_MAKE_NONCOPYABLE	.\RedBlackTree.h	/^    WTF_MAKE_NONCOPYABLE(RedBlackTree);$/;"	p	class:WTF::RedBlackTree	access:private	signature:(RedBlackTree)
WTF_MAKE_NONCOPYABLE	.\RefCounted.h	/^    WTF_MAKE_NONCOPYABLE(RefCounted); WTF_MAKE_FAST_ALLOCATED;$/;"	p	class:WTF::RefCounted	access:private	signature:(RefCounted)
WTF_MAKE_NONCOPYABLE	.\RefCounted.h	/^    WTF_MAKE_NONCOPYABLE(RefCountedCustomAllocated);$/;"	p	class:WTF::RefCountedCustomAllocated	access:private	signature:(RefCountedCustomAllocated)
WTF_MAKE_NONCOPYABLE	.\TemporaryChange.h	/^    WTF_MAKE_NONCOPYABLE(TemporaryChange);$/;"	p	class:WTF::TemporaryChange	access:private	signature:(TemporaryChange)
WTF_MAKE_NONCOPYABLE	.\ThreadIdentifierDataPthreads.h	/^    WTF_MAKE_NONCOPYABLE(ThreadIdentifierData);$/;"	p	class:WTF::ThreadIdentifierData	access:private	signature:(ThreadIdentifierData)
WTF_MAKE_NONCOPYABLE	.\ThreadSafeRefCounted.h	/^    WTF_MAKE_NONCOPYABLE(ThreadSafeRefCountedBase);$/;"	p	class:WTF::ThreadSafeRefCountedBase	access:private	signature:(ThreadSafeRefCountedBase)
WTF_MAKE_NONCOPYABLE	.\ThreadSpecific.h	/^        WTF_MAKE_NONCOPYABLE(Data);$/;"	p	struct:WTF::ThreadSpecific::Data	access:public	signature:(Data)
WTF_MAKE_NONCOPYABLE	.\ThreadSpecific.h	/^    WTF_MAKE_NONCOPYABLE(ThreadSpecific);$/;"	p	class:WTF::ThreadSpecific	access:private	signature:(ThreadSpecific)
WTF_MAKE_NONCOPYABLE	.\ThreadingPrimitives.h	/^    WTF_MAKE_NONCOPYABLE(Mutex); WTF_MAKE_FAST_ALLOCATED;$/;"	p	class:WTF::Mutex	access:private	signature:(Mutex)
WTF_MAKE_NONCOPYABLE	.\ThreadingPrimitives.h	/^    WTF_MAKE_NONCOPYABLE(ReadWriteLock);$/;"	p	class:WTF::ReadWriteLock	access:private	signature:(ReadWriteLock)
WTF_MAKE_NONCOPYABLE	.\ThreadingPrimitives.h	/^    WTF_MAKE_NONCOPYABLE(ThreadCondition);$/;"	p	class:WTF::ThreadCondition	access:private	signature:(ThreadCondition)
WTF_MAKE_NONCOPYABLE	.\Vector.h	/^        WTF_MAKE_NONCOPYABLE(VectorBuffer);$/;"	p	class:WTF::VectorBuffer	access:private	signature:(VectorBuffer)
WTF_MAKE_NONCOPYABLE	.\Vector.h	/^        WTF_MAKE_NONCOPYABLE(VectorBufferBase);$/;"	p	class:WTF::VectorBufferBase	access:private	signature:(VectorBufferBase)
WTF_MAKE_NONCOPYABLE	.\WTFThreadData.h	/^    WTF_MAKE_NONCOPYABLE(WTFThreadData);$/;"	p	class:WTF::WTFThreadData	access:private	signature:(WTFThreadData)
WTF_MAKE_NONCOPYABLE	.\dtoa.cpp	/^    WTF_MAKE_NONCOPYABLE(P5Node); WTF_MAKE_FAST_ALLOCATED;$/;"	p	struct:WTF::P5Node	file:	access:public	signature:(P5Node)
WTF_MAKE_NONCOPYABLE	.\gobject\GOwnPtr.h	/^    WTF_MAKE_NONCOPYABLE(GOwnPtr);$/;"	p	class:WTF::GOwnPtr	access:private	signature:(GOwnPtr)
WTF_MAKE_NONCOPYABLE	.\text\StringBuffer.h	/^    WTF_MAKE_NONCOPYABLE(StringBuffer);$/;"	p	class:WTF::StringBuffer	access:private	signature:(StringBuffer)
WTF_MAKE_NONCOPYABLE	.\text\StringBuilder.h	/^    WTF_MAKE_NONCOPYABLE(StringBuilder);$/;"	p	class:WTF::StringBuilder	access:private	signature:(StringBuilder)
WTF_MAKE_NONCOPYABLE	.\text\StringImpl.h	/^    WTF_MAKE_NONCOPYABLE(StringImpl); WTF_MAKE_FAST_ALLOCATED;$/;"	p	class:WTF::StringImpl	access:private	signature:(StringImpl)
WTF_MAKE_NONCOPYABLE	.\threads\BinarySemaphore.h	/^    WTF_MAKE_NONCOPYABLE(BinarySemaphore);$/;"	p	class:WTF::BinarySemaphore	access:private	signature:(BinarySemaphore)
WTF_MAKE_NONCOPYABLE	.\unicode\Collator.h	/^        WTF_MAKE_NONCOPYABLE(Collator); WTF_MAKE_FAST_ALLOCATED;$/;"	p	class:WTF::Collator	access:private	signature:(Collator)
WTF_MD5_h	.\MD5.h	32;"	d
WTF_MIPS_ARCH	.\Platform.h	86;"	d
WTF_MIPS_ARCH_REV	.\Platform.h	89;"	d
WTF_MIPS_DOUBLE_FLOAT	.\Platform.h	91;"	d
WTF_MIPS_FP64	.\Platform.h	92;"	d
WTF_MIPS_ISA	.\Platform.h	87;"	d
WTF_MIPS_ISA_AT_LEAST	.\Platform.h	88;"	d
WTF_MIPS_ISA_REV	.\Platform.h	90;"	d
WTF_MIPS_PIC	.\Platform.h	85;"	d
WTF_MathExtras_h	.\MathExtras.h	27;"	d
WTF_MetaAllocatorHandle_h	.\MetaAllocatorHandle.h	30;"	d
WTF_MetaAllocator_h	.\MetaAllocator.h	30;"	d
WTF_NonCopyingSort_h	.\NonCopyingSort.h	28;"	d
WTF_Noncopyable_h	.\Noncopyable.h	22;"	d
WTF_OSRandomSource_h	.\OSRandomSource.h	27;"	d
WTF_OS_AIX	.\Platform.h	312;"	d
WTF_OS_ANDROID	.\Platform.h	307;"	d
WTF_OS_DARWIN	.\Platform.h	317;"	d
WTF_OS_FREEBSD	.\Platform.h	351;"	d
WTF_OS_HURD	.\Platform.h	356;"	d
WTF_OS_IOS	.\Platform.h	329;"	d
WTF_OS_LINUX	.\Platform.h	361;"	d
WTF_OS_MAC	.\Platform.h	395;"	d
WTF_OS_MAC_OS_X	.\Platform.h	331;"	d
WTF_OS_NETBSD	.\Platform.h	366;"	d
WTF_OS_OPENBSD	.\Platform.h	371;"	d
WTF_OS_QNX	.\Platform.h	376;"	d
WTF_OS_SOLARIS	.\Platform.h	381;"	d
WTF_OS_UNIX	.\Platform.h	411;"	d
WTF_OS_WIN	.\Platform.h	394;"	d
WTF_OS_WINCE	.\Platform.h	386;"	d
WTF_OS_WINDOWS	.\Platform.h	391;"	d
WTF_OwnArrayPtr_h	.\OwnArrayPtr.h	22;"	d
WTF_OwnPtrCommon_h	.\OwnPtrCommon.h	29;"	d
WTF_OwnPtr_h	.\OwnPtr.h	22;"	d
WTF_PLATFORM_BLACKBERRY	.\Platform.h	433;"	d
WTF_PLATFORM_CFNETWORK	.\Platform.h	1099;"	d
WTF_PLATFORM_CHROMIUM	.\Platform.h	425;"	d
WTF_PLATFORM_GTK	.\Platform.h	431;"	d
WTF_PLATFORM_IOS	.\Platform.h	443;"	d
WTF_PLATFORM_IOS	.\Platform.h	448;"	d
WTF_PLATFORM_IOS	.\Platform.h	455;"	d
WTF_PLATFORM_IOS_SIMULATOR	.\Platform.h	449;"	d
WTF_PLATFORM_IOS_SIMULATOR	.\Platform.h	451;"	d
WTF_PLATFORM_MAC	.\Platform.h	435;"	d
WTF_PLATFORM_QT	.\Platform.h	427;"	d
WTF_PLATFORM_WIN	.\Platform.h	437;"	d
WTF_PLATFORM_WX	.\Platform.h	429;"	d
WTF_PRETTY_FUNCTION	.\Assertions.h	111;"	d
WTF_PRETTY_FUNCTION	.\Assertions.h	113;"	d
WTF_PRIVATE_INLINE	.\FastMalloc.h	241;"	d
WTF_PassOwnArrayPtr_h	.\PassOwnArrayPtr.h	27;"	d
WTF_PassOwnPtr_h	.\PassOwnPtr.h	27;"	d
WTF_PassRefPtr_h	.\PassRefPtr.h	22;"	d
WTF_PassTraits_h	.\PassTraits.h	30;"	d
WTF_Platform_h	.\Platform.h	29;"	d
WTF_RandomNumberSeed_h	.\RandomNumberSeed.h	27;"	d
WTF_RandomNumber_h	.\RandomNumber.h	27;"	d
WTF_RefPtr_h	.\RefPtr.h	24;"	d
WTF_SHA1_h	.\SHA1.h	32;"	d
WTF_STRINGTYPEADAPTER_COPIED_WTF_STRING	.\text\StringConcatenate.h	36;"	d
WTF_ScriptCodesFromICU_h	.\unicode\ScriptCodesFromICU.h	7;"	d
WTF_StdLibExtras_h	.\StdLibExtras.h	27;"	d
WTF_StringExtras_h	.\StringExtras.h	27;"	d
WTF_StringHasher_h	.\StringHasher.h	22;"	d
WTF_THUMB_ARCH_VERSION	.\Platform.h	236;"	d
WTF_THUMB_ARCH_VERSION	.\Platform.h	241;"	d
WTF_THUMB_ARCH_VERSION	.\Platform.h	248;"	d
WTF_THUMB_ARCH_VERSION	.\Platform.h	255;"	d
WTF_THUMB_ARCH_VERSION	.\Platform.h	259;"	d
WTF_THUMB_ARCH_VERSION	.\Platform.h	262;"	d
WTF_ThreadSpecific_h	.\ThreadSpecific.h	42;"	d
WTF_UNICODE_H	.\unicode\Unicode.h	24;"	d
WTF_UNICODE_ICU_H	.\unicode\icu\UnicodeIcu.h	24;"	d
WTF_UNICODE_QT4_H	.\unicode\qt4\UnicodeQt4.h	24;"	d
WTF_USE_ACCELERATE	.\Platform.h	708;"	d
WTF_USE_ACCELERATED_COMPOSITING	.\Platform.h	1078;"	d
WTF_USE_ACCESSIBILITY_CONTEXT_MENUS	.\Platform.h	1111;"	d
WTF_USE_ARENA_ALLOC_ALIGNMENT_INTEGER	.\Platform.h	203;"	d
WTF_USE_ARENA_ALLOC_ALIGNMENT_INTEGER	.\Platform.h	226;"	d
WTF_USE_ARENA_ALLOC_ALIGNMENT_INTEGER	.\Platform.h	94;"	d
WTF_USE_ATSUI	.\Platform.h	1068;"	d
WTF_USE_ATSUI	.\Platform.h	1071;"	d
WTF_USE_ATSUI	.\Platform.h	476;"	d
WTF_USE_AVFOUNDATION	.\Platform.h	1162;"	d
WTF_USE_BACKTRACE_SYMBOLS	.\Assertions.cpp	296;"	d	file:
WTF_USE_BACKTRACE_SYMBOLS	.\Assertions.cpp	336;"	d	file:
WTF_USE_CA	.\Platform.h	465;"	d
WTF_USE_CAIRO	.\Platform.h	496;"	d
WTF_USE_CF	.\Platform.h	549;"	d
WTF_USE_CF	.\Platform.h	567;"	d
WTF_USE_CF	.\Platform.h	579;"	d
WTF_USE_CF	.\Platform.h	604;"	d
WTF_USE_CF	.\Platform.h	622;"	d
WTF_USE_CF	.\Platform.h	651;"	d
WTF_USE_CFNETWORK	.\Platform.h	605;"	d
WTF_USE_CFNETWORK	.\Platform.h	627;"	d
WTF_USE_CFURLCACHE	.\Platform.h	631;"	d
WTF_USE_CFURLSTORAGESESSIONS	.\Platform.h	632;"	d
WTF_USE_CG	.\Platform.h	462;"	d
WTF_USE_CG	.\Platform.h	474;"	d
WTF_USE_CHROMIUM_NET	.\Platform.h	484;"	d
WTF_USE_COREAUDIO	.\Platform.h	1182;"	d
WTF_USE_COREMEDIA	.\Platform.h	1166;"	d
WTF_USE_CORE_TEXT	.\Platform.h	1069;"	d
WTF_USE_CORE_TEXT	.\Platform.h	1072;"	d
WTF_USE_CORE_TEXT	.\Platform.h	477;"	d
WTF_USE_CORE_TEXT	.\Platform.h	652;"	d
WTF_USE_CROSS_PLATFORM_CONTEXT_MENUS	.\Platform.h	1107;"	d
WTF_USE_DLADDR	.\Assertions.cpp	299;"	d	file:
WTF_USE_DLADDR	.\Assertions.cpp	337;"	d	file:
WTF_USE_EXPORT_MACROS	.\Platform.h	1138;"	d
WTF_USE_EXPORT_MACROS	.\Platform.h	1140;"	d
WTF_USE_GLES2_RENDERING	.\Platform.h	481;"	d
WTF_USE_ICCJPEG	.\Platform.h	478;"	d
WTF_USE_ICU_UNICODE	.\Platform.h	531;"	d
WTF_USE_JSC	.\Platform.h	1196;"	d
WTF_USE_JSVALUE32_64	.\Platform.h	909;"	d
WTF_USE_JSVALUE64	.\Platform.h	907;"	d
WTF_USE_LOCKFREE_THREADSAFEREFCOUNTED	.\Atomics.h	85;"	d
WTF_USE_MERSENNE_TWISTER_19937	.\Platform.h	491;"	d
WTF_USE_MERSENNE_TWISTER_19937	.\Platform.h	502;"	d
WTF_USE_PLATFORM_STRATEGIES	.\Platform.h	1103;"	d
WTF_USE_PLUGIN_HOST_PROCESS	.\Platform.h	536;"	d
WTF_USE_PLUGIN_HOST_PROCESS	.\Platform.h	844;"	d
WTF_USE_PREEMPT_GEOLOCATION_PERMISSION	.\Platform.h	1115;"	d
WTF_USE_PROTECTION_SPACE_AUTH_CALLBACK	.\Platform.h	1087;"	d
WTF_USE_PTHREADS	.\Platform.h	550;"	d
WTF_USE_PTHREADS	.\Platform.h	568;"	d
WTF_USE_PTHREADS	.\Platform.h	606;"	d
WTF_USE_PTHREADS	.\Platform.h	623;"	d
WTF_USE_PTHREADS	.\Platform.h	659;"	d
WTF_USE_PTHREADS	.\Platform.h	663;"	d
WTF_USE_PTHREADS	.\Platform.h	749;"	d
WTF_USE_PTHREAD_GETSPECIFIC_DIRECT	.\FastMalloc.cpp	461;"	d	file:
WTF_USE_QT4_UNICODE	.\Platform.h	524;"	d
WTF_USE_QUERY_PERFORMANCE_COUNTER	.\Platform.h	507;"	d
WTF_USE_QXMLQUERY	.\Platform.h	1061;"	d
WTF_USE_QXMLSTREAM	.\Platform.h	1060;"	d
WTF_USE_REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR	.\Platform.h	1174;"	d
WTF_USE_REQUEST_ANIMATION_FRAME_TIMER	.\Platform.h	1170;"	d
WTF_USE_SCROLLBAR_PAINTER	.\Platform.h	541;"	d
WTF_USE_SKIA	.\Platform.h	472;"	d
WTF_USE_SKIA	.\Platform.h	480;"	d
WTF_USE_SKIA	.\Platform.h	483;"	d
WTF_USE_SKIA	.\Platform.h	492;"	d
WTF_USE_UI_SIDE_COMPOSITING	.\Platform.h	1083;"	d
WTF_USE_UNIX_DOMAIN_SOCKETS	.\Platform.h	1144;"	d
WTF_USE_V8	.\Platform.h	1187;"	d
WTF_USE_V8	.\Platform.h	1192;"	d
WTF_USE_WINCE_UNICODE	.\Platform.h	527;"	d
WTF_USE_WK_SCROLLBAR_PAINTER	.\Platform.h	571;"	d
WTF_USE_WTFURL	.\Platform.h	1203;"	d
WTF_USE_ZLIB	.\Platform.h	1207;"	d
WTF_UTF8_h	.\unicode\UTF8.h	27;"	d
WTF_UnicodeWinCE_h	.\unicode\wince\UnicodeWinCE.h	25;"	d
WTF_UnusedParam_h	.\UnusedParam.h	22;"	d
WTF_UtilsQt_h	.\qt\UtilsQt.h	21;"	d
WTF_VectorTraits_h	.\VectorTraits.h	22;"	d
WTF_Vector_h	.\Vector.h	22;"	d
WTF_dtoa_h	.\dtoa.h	22;"	d
WebKit	.\text\WTFString.h	/^namespace WebKit {$/;"	n	namespace:BlackBerry
WhiteSpaceNeutral	.\unicode\glib\UnicodeGLib.h	/^    WhiteSpaceNeutral,$/;"	e	enum:WTF::Unicode::Direction
WhiteSpaceNeutral	.\unicode\icu\UnicodeIcu.h	/^    WhiteSpaceNeutral = U_WHITE_SPACE_NEUTRAL,$/;"	e	enum:WTF::Unicode::Direction
WhiteSpaceNeutral	.\unicode\qt4\UnicodeQt4.h	/^    WhiteSpaceNeutral = QChar::DirWS,$/;"	e	enum:WTF::Unicode::Direction
WhiteSpaceNeutral	.\unicode\wince\UnicodeWinCE.h	/^    WhiteSpaceNeutral = UnicodeCE::U_WHITE_SPACE_NEUTRAL,$/;"	e	enum:WTF::Unicode::Direction
WordType	.\Bitmap.h	/^    typedef uint32_t WordType;$/;"	t	class:WTF::Bitmap	access:private
WorkerFunction	.\ParallelJobs.h	/^    typedef void (*WorkerFunction)(Type*);$/;"	t	class:WTF::ParallelJobs	access:public
YesType	.\Functional.h	/^    typedef char YesType;$/;"	t	class:WTF::HasRefAndDeref	access:private
YesType	.\TypeTraits.h	/^            typedef char YesType;$/;"	t	class:WTF::IsConvertibleToInteger::IsConvertibleToDouble	access:private
YesType	.\TypeTraits.h	/^        typedef char YesType;$/;"	t	class:WTF::IsSubclass	access:private
YesType	.\TypeTraits.h	/^        typedef char YesType;$/;"	t	class:WTF::IsSubclassOfTemplate	access:private
Zero	.\dtoa\bignum.cc	/^    void Bignum::Zero() {$/;"	f	class:WTF::double_conversion::Bignum	signature:()
Zero	.\dtoa\bignum.h	/^        void Zero();$/;"	p	class:WTF::double_conversion::Bignum	access:private	signature:()
_GVariant	.\gobject\GRefPtr.cpp	/^typedef struct _GVariant {$/;"	s	namespace:WTF	file:
_INC_ASSERT	.\Platform.h	517;"	d
__THROW	.\FastMalloc.cpp	600;"	d	file:
__anon2::defaultName	.\Assertions.h	/^    const char *defaultName;$/;"	m	struct:__anon2	access:public
__anon2::mask	.\Assertions.h	/^    unsigned mask;$/;"	m	struct:__anon2	access:public
__anon2::state	.\Assertions.h	/^    WTFLogChannelState state;$/;"	m	struct:__anon2	access:public
__has_extension	.\Compiler.h	42;"	d
__libc_calloc	.\FastMalloc.cpp	/^  void* __libc_calloc(size_t n, size_t size)    { return calloc(n, size);    }$/;"	f	signature:(size_t n, size_t size)
__libc_cfree	.\FastMalloc.cpp	/^  void  __libc_cfree(void* ptr)                 { cfree(ptr);                }$/;"	f	signature:(void* ptr)
__libc_free	.\FastMalloc.cpp	/^  void  __libc_free(void* ptr)                  { free(ptr);                 }$/;"	f	signature:(void* ptr)
__libc_malloc	.\FastMalloc.cpp	/^  void* __libc_malloc(size_t size)              { return malloc(size);       }$/;"	f	signature:(size_t size)
__libc_memalign	.\FastMalloc.cpp	/^  void* __libc_memalign(size_t align, size_t s) { return memalign(align, s); }$/;"	f	signature:(size_t align, size_t s)
__libc_pvalloc	.\FastMalloc.cpp	/^  void* __libc_pvalloc(size_t size)             { return pvalloc(size);      }$/;"	f	signature:(size_t size)
__libc_realloc	.\FastMalloc.cpp	/^  void* __libc_realloc(void* ptr, size_t size)  { return realloc(ptr, size); }$/;"	f	signature:(void* ptr, size_t size)
__libc_valloc	.\FastMalloc.cpp	/^  void* __libc_valloc(size_t size)              { return valloc(size);       }$/;"	f	signature:(size_t size)
__memalign_hook	.\FastMalloc.cpp	/^void *(*__memalign_hook)(size_t, size_t, const void *) = MemalignOverride;$/;"	v
__posix_memalign	.\FastMalloc.cpp	/^  int __posix_memalign(void** r, size_t a, size_t s) {$/;"	f	signature:(void** r, size_t a, size_t s)
__usp10__	.\Platform.h	515;"	d
_strdup	.\wince\MemoryManager.cpp	28;"	d	file:
a	.\SizeLimits.cpp	/^    int a;$/;"	m	struct:WTF::SameSizeAsRefCounted	file:	access:public
abs	.\AVLTree.h	/^    abs_plus_root abs;$/;"	m	class:WTF::AVLTree	access:protected
abs	.\MathExtras.h	/^inline long long abs(long long num) { return _abs64(num); }$/;"	f	signature:(long long num)
abs	.\MathExtras.h	/^inline long long abs(long num) { return labs(num); }$/;"	f	signature:(long num)
abs_plus_root	.\AVLTree.h	/^    struct abs_plus_root : public Abstractor {$/;"	s	class:WTF::AVLTree	inherits:Abstractor	access:protected
absoluteTimeToWaitTimeoutInterval	.\ThreadingPrimitives.h	/^DWORD absoluteTimeToWaitTimeoutInterval(double absoluteTime);$/;"	p	namespace:WTF	signature:(double absoluteTime)
absoluteTimeToWaitTimeoutInterval	.\ThreadingWin.cpp	/^DWORD absoluteTimeToWaitTimeoutInterval(double absoluteTime)$/;"	f	namespace:WTF	signature:(double absoluteTime)
abstractor	.\AVLTree.h	/^    Abstractor& abstractor() { return abs; }$/;"	f	class:WTF::AVLTree	access:public	signature:()
add	.\BloomFilter.h	/^    void add(const AtomicString& string) { add(string.impl()->existingHash()); }$/;"	f	class:WTF::BloomFilter	access:public	signature:(const AtomicString& string)
add	.\BloomFilter.h	/^    void add(const String& string) { add(string.impl()->hash()); }$/;"	f	class:WTF::BloomFilter	access:public	signature:(const String& string)
add	.\BloomFilter.h	/^    void add(unsigned hash);$/;"	p	class:WTF::BloomFilter	access:public	signature:(unsigned hash)
add	.\BloomFilter.h	/^inline void BloomFilter<keyBits>::add(unsigned hash)$/;"	f	class:WTF::BloomFilter	signature:(unsigned hash)
add	.\CheckedArithmetic.h	/^    static inline bool add(int64_t lhs, int64_t rhs, ResultType& result)$/;"	f	struct:WTF::ArithmeticOperations	access:public	signature:(int64_t lhs, int64_t rhs, ResultType& result)
add	.\HashCountedSet.h	/^        std::pair<iterator, bool> add(const ValueType&);$/;"	p	class:WTF::HashCountedSet	access:public	signature:(const ValueType&)
add	.\HashCountedSet.h	/^    inline std::pair<typename HashCountedSet<Value, HashFunctions, Traits>::iterator, bool> HashCountedSet<Value, HashFunctions, Traits>::add(const ValueType &value)$/;"	f	class:WTF::HashCountedSet	signature:(const ValueType &value)
add	.\HashMap.h	/^        pair<iterator, bool> add(const KeyType&, MappedPassInType); $/;"	p	class:WTF::HashMap	access:public	signature:(const KeyType&, MappedPassInType)
add	.\HashMap.h	/^        template<typename T, typename HashTranslator> pair<iterator, bool> add(const T&, MappedPassInType);$/;"	p	class:WTF::HashMap	access:public	signature:(const T&, MappedPassInType)
add	.\HashMap.h	/^    HashMap<T, U, V, W, X>::add(const KeyType& key, MappedPassInType mapped)$/;"	f	class:WTF::HashMap	signature:(const KeyType& key, MappedPassInType mapped)
add	.\HashMap.h	/^    HashMap<T, U, V, W, X>::add(const TYPE& key, MappedPassInType value)$/;"	f	class:WTF::HashMap	signature:(const TYPE& key, MappedPassInType value)
add	.\HashSet.h	/^        pair<iterator, bool> add(const ValueType&);$/;"	p	class:WTF::HashSet	access:public	signature:(const ValueType&)
add	.\HashSet.h	/^        template<typename T, typename HashTranslator> pair<iterator, bool> add(const T&);$/;"	p	class:WTF::HashSet	access:public	signature:(const T&)
add	.\HashSet.h	/^    HashSet<Value, HashFunctions, Traits>::add(const T& value)$/;"	f	class:WTF::HashSet	signature:(const T& value)
add	.\HashSet.h	/^    inline pair<typename HashSet<T, U, V>::iterator, bool> HashSet<T, U, V>::add(const ValueType& value)$/;"	f	class:WTF::HashSet	signature:(const ValueType& value)
add	.\HashTable.h	/^        pair<iterator, bool> add(const ValueType& value) { return add<IdentityTranslatorType>(Extractor::extract(value), value); }$/;"	f	class:WTF::HashTable	access:public	signature:(const ValueType& value)
add	.\HashTable.h	/^        template<typename HashTranslator, typename T, typename Extra> pair<iterator, bool> add(const T& key, const Extra&);$/;"	p	class:WTF::HashTable	access:public	signature:(const T& key, const Extra&)
add	.\HashTable.h	/^    inline pair<typename HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::iterator, bool> HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::add(const T& key, const Extra& extra)$/;"	f	class:WTF::HashTable	signature:(const T& key, const Extra& extra)
add	.\ListHashSet.h	/^        pair<iterator, bool> add(const ValueType&);$/;"	p	class:WTF::ListHashSet	access:public	signature:(const ValueType&)
add	.\ListHashSet.h	/^    pair<typename ListHashSet<T, inlineCapacity, U>::iterator, bool> ListHashSet<T, inlineCapacity, U>::add(const ValueType &value)$/;"	f	class:WTF::ListHashSet	signature:(const ValueType &value)
add	.\RefPtrHashMap.h	/^        pair<iterator, bool> add(RawKeyType, MappedPassInType); $/;"	p	class:WTF::HashMap	access:public	signature:(RawKeyType, MappedPassInType)
add	.\RefPtrHashMap.h	/^        pair<iterator, bool> add(const KeyType&, MappedPassInType); $/;"	p	class:WTF::HashMap	access:public	signature:(const KeyType&, MappedPassInType)
add	.\RefPtrHashMap.h	/^    HashMap<RefPtr<T>, U, V, W, X>::add(RawKeyType key, MappedPassInType mapped)$/;"	f	class:WTF::HashMap	signature:(RawKeyType key, MappedPassInType mapped)
add	.\RefPtrHashMap.h	/^    HashMap<RefPtr<T>, U, V, W, X>::add(const KeyType& key, MappedPassInType mapped)$/;"	f	class:WTF::HashMap	signature:(const KeyType& key, MappedPassInType mapped)
add	.\SimpleStats.h	/^    void add(double value)$/;"	f	class:WTF::SimpleStats	access:public	signature:(double value)
add	.\Spectrum.h	/^    void add(const T& key, unsigned long count = 1)$/;"	f	class:WTF::Spectrum	access:public	signature:(const T& key, unsigned long count = 1)
add	.\WTFThreadData.cpp	/^std::pair<HashSet<StringImpl*>::iterator, bool> IdentifierTable::add(StringImpl* value)$/;"	f	class:JSC::IdentifierTable	signature:(StringImpl* value)
add	.\WTFThreadData.h	/^    std::pair<HashSet<StringImpl*>::iterator, bool> add(StringImpl* value);$/;"	p	class:JSC::IdentifierTable	access:public	signature:(StringImpl* value)
add	.\WTFThreadData.h	/^    std::pair<HashSet<StringImpl*>::iterator, bool> add(U value);$/;"	p	class:JSC::IdentifierTable	access:public	signature:(U value)
add	.\text\AtomicString.cpp	/^PassRefPtr<StringImpl> AtomicString::add(StringImpl* baseString, unsigned start, unsigned length)$/;"	f	class:WTF::AtomicString	signature:(StringImpl* baseString, unsigned start, unsigned length)
add	.\text\AtomicString.cpp	/^PassRefPtr<StringImpl> AtomicString::add(const LChar* c)$/;"	f	class:WTF::AtomicString	signature:(const LChar* c)
add	.\text\AtomicString.cpp	/^PassRefPtr<StringImpl> AtomicString::add(const UChar* s)$/;"	f	class:WTF::AtomicString	signature:(const UChar* s)
add	.\text\AtomicString.cpp	/^PassRefPtr<StringImpl> AtomicString::add(const UChar* s, unsigned length)$/;"	f	class:WTF::AtomicString	signature:(const UChar* s, unsigned length)
add	.\text\AtomicString.cpp	/^PassRefPtr<StringImpl> AtomicString::add(const UChar* s, unsigned length, unsigned existingHash)$/;"	f	class:WTF::AtomicString	signature:(const UChar* s, unsigned length, unsigned existingHash)
add	.\text\AtomicString.h	/^    ALWAYS_INLINE static PassRefPtr<StringImpl> add(StringImpl* r)$/;"	f	class:WTF::AtomicString	access:private	signature:(StringImpl* r)
add	.\text\AtomicString.h	/^    ALWAYS_INLINE static PassRefPtr<StringImpl> add(const char* s) { return add(reinterpret_cast<const LChar*>(s)); };$/;"	f	class:WTF::AtomicString	access:private	signature:(const char* s)
add	.\text\AtomicString.h	/^    ALWAYS_INLINE static PassRefPtr<StringImpl> add(const char* s, unsigned length) { return add(reinterpret_cast<const char*>(s), length); };$/;"	f	class:WTF::AtomicString	access:private	signature:(const char* s, unsigned length)
add	.\text\AtomicString.h	/^    WTF_EXPORT_PRIVATE static PassRefPtr<StringImpl> add(StringImpl*, unsigned offset, unsigned length);$/;"	p	class:WTF::AtomicString	access:private	signature:(StringImpl*, unsigned offset, unsigned length)
add	.\text\AtomicString.h	/^    WTF_EXPORT_PRIVATE static PassRefPtr<StringImpl> add(const LChar*);$/;"	p	class:WTF::AtomicString	access:private	signature:(const LChar*)
add	.\text\AtomicString.h	/^    WTF_EXPORT_PRIVATE static PassRefPtr<StringImpl> add(const UChar*);$/;"	p	class:WTF::AtomicString	access:private	signature:(const UChar*)
add	.\text\AtomicString.h	/^    WTF_EXPORT_PRIVATE static PassRefPtr<StringImpl> add(const UChar*, unsigned length);$/;"	p	class:WTF::AtomicString	access:private	signature:(const UChar*, unsigned length)
add	.\text\AtomicString.h	/^    WTF_EXPORT_PRIVATE static PassRefPtr<StringImpl> add(const UChar*, unsigned length, unsigned existingHash);$/;"	p	class:WTF::AtomicString	access:private	signature:(const UChar*, unsigned length, unsigned existingHash)
addBytes	.\MD5.cpp	/^void MD5::addBytes(const uint8_t* input, size_t length)$/;"	f	class:WTF::MD5	signature:(const uint8_t* input, size_t length)
addBytes	.\MD5.h	/^    WTF_EXPORT_PRIVATE void addBytes(const uint8_t* input, size_t length);$/;"	p	class:WTF::MD5	access:public	signature:(const uint8_t* input, size_t length)
addBytes	.\MD5.h	/^    void addBytes(const Vector<uint8_t>& input)$/;"	f	class:WTF::MD5	access:public	signature:(const Vector<uint8_t>& input)
addBytes	.\SHA1.cpp	/^void SHA1::addBytes(const uint8_t* input, size_t length)$/;"	f	class:WTF::SHA1	signature:(const uint8_t* input, size_t length)
addBytes	.\SHA1.h	/^    WTF_EXPORT_PRIVATE void addBytes(const uint8_t* input, size_t length);$/;"	p	class:WTF::SHA1	access:public	signature:(const uint8_t* input, size_t length)
addBytes	.\SHA1.h	/^    void addBytes(const Vector<uint8_t>& input)$/;"	f	class:WTF::SHA1	access:public	signature:(const Vector<uint8_t>& input)
addCharacter	.\StringHasher.h	/^    inline void addCharacter(UChar ch)$/;"	f	class:WTF::StringHasher	access:public	signature:(UChar ch)
addCharacters	.\StringHasher.h	/^    inline void addCharacters(UChar a, UChar b)$/;"	f	class:WTF::StringHasher	access:public	signature:(UChar a, UChar b)
addCharactersToHash	.\StringHasher.h	/^    inline void addCharactersToHash(UChar a, UChar b)$/;"	f	class:WTF::StringHasher	access:private	signature:(UChar a, UChar b)
addFreeSpace	.\MetaAllocator.cpp	/^void MetaAllocator::addFreeSpace(void* start, size_t sizeInBytes)$/;"	f	class:WTF::MetaAllocator	signature:(void* start, size_t sizeInBytes)
addFreeSpace	.\MetaAllocator.h	/^    void addFreeSpace(void* start, size_t sizeInBytes);$/;"	p	class:WTF::MetaAllocator	access:private	signature:(void* start, size_t sizeInBytes)
addFreeSpaceFromReleasedHandle	.\MetaAllocator.cpp	/^void MetaAllocator::addFreeSpaceFromReleasedHandle(void* start, size_t sizeInBytes)$/;"	f	class:WTF::MetaAllocator	signature:(void* start, size_t sizeInBytes)
addFreeSpaceFromReleasedHandle	.\MetaAllocator.h	/^    void addFreeSpaceFromReleasedHandle(void* start, size_t sizeInBytes);$/;"	p	class:WTF::MetaAllocator	access:private	signature:(void* start, size_t sizeInBytes)
addFreshFreeSpace	.\MetaAllocator.cpp	/^void MetaAllocator::addFreshFreeSpace(void* start, size_t sizeInBytes)$/;"	f	class:WTF::MetaAllocator	signature:(void* start, size_t sizeInBytes)
addFreshFreeSpace	.\MetaAllocator.h	/^    WTF_EXPORT_PRIVATE void addFreshFreeSpace(void* start, size_t sizeInBytes);$/;"	p	class:WTF::MetaAllocator	access:public	signature:(void* start, size_t sizeInBytes)
addIterator	.\HashTable.h	/^    inline void addIterator(const HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>*,$/;"	f	namespace:WTF	signature:(const HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>*, HashTableConstIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>*)
addIterator	.\HashTable.h	/^    void addIterator(const HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>* table,$/;"	f	namespace:WTF	signature:(const HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>* table, HashTableConstIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>* it)
addIterator	.\HashTable.h	/^    void addIterator(const HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>*,$/;"	p	namespace:WTF	signature:(const HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>*, HashTableConstIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>*)
addPassingHashCode	.\HashTable.h	/^        template<typename HashTranslator, typename T, typename Extra> pair<iterator, bool> addPassingHashCode(const T& key, const Extra&);$/;"	p	class:WTF::HashTable	access:public	signature:(const T& key, const Extra&)
addPassingHashCode	.\HashTable.h	/^    inline pair<typename HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::iterator, bool> HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::addPassingHashCode(const T& key, const Extra& extra)$/;"	f	class:WTF::HashTable	signature:(const T& key, const Extra& extra)
addRandomData	.\CryptographicallyRandomNumber.cpp	/^    inline void addRandomData(unsigned char *data, int length);$/;"	p	class:WTF::__anon3::ARC4RandomNumberGenerator	file:	access:private	signature:(unsigned char *data, int length)
addRandomData	.\CryptographicallyRandomNumber.cpp	/^void ARC4RandomNumberGenerator::addRandomData(unsigned char* data, int length)$/;"	f	class:WTF::__anon3::ARC4RandomNumberGenerator	signature:(unsigned char* data, int length)
addSlowCase	.\text\AtomicString.cpp	/^PassRefPtr<StringImpl> AtomicString::addSlowCase(StringImpl* r)$/;"	f	class:WTF::AtomicString	signature:(StringImpl* r)
addSlowCase	.\text\AtomicString.h	/^    WTF_EXPORT_PRIVATE static PassRefPtr<StringImpl> addSlowCase(StringImpl*);$/;"	p	class:WTF::AtomicString	access:private	signature:(StringImpl*)
addToIteratorsList	.\Deque.h	/^        void addToIteratorsList();$/;"	p	class:WTF::DequeIteratorBase	access:private	signature:()
addToIteratorsList	.\Deque.h	/^    template<typename T, size_t inlineCapacity> inline void DequeIteratorBase<T, inlineCapacity>::addToIteratorsList() { }$/;"	f	class:WTF::DequeIteratorBase	signature:()
addToIteratorsList	.\Deque.h	/^    void DequeIteratorBase<T, inlineCapacity>::addToIteratorsList()$/;"	f	class:WTF::DequeIteratorBase	signature:()
addToStringTable	.\text\AtomicString.cpp	/^static inline PassRefPtr<StringImpl> addToStringTable(const T& value)$/;"	f	namespace:WTF	file:	signature:(const T& value)
addView	.\ArrayBuffer.cpp	/^void ArrayBuffer::addView(ArrayBufferView* view)$/;"	f	class:WTF::ArrayBuffer	signature:(ArrayBufferView* view)
addView	.\ArrayBuffer.h	/^    void addView(ArrayBufferView*);$/;"	p	class:WTF::ArrayBuffer	access:public	signature:(ArrayBufferView*)
add_amount	.\FastMalloc.cpp	/^static const int add_amount[2] = { 7, 127 + (120 << 7) };$/;"	v	file:
addressOfCount	.\RefCounted.h	/^    const int* addressOfCount() const$/;"	f	class:WTF::RefCountedBase	access:public	signature:() const
adopt	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::adopt(StringBuffer<LChar>& buffer)$/;"	f	class:WTF::StringImpl	signature:(StringBuffer<LChar>& buffer)
adopt	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::adopt(StringBuffer<UChar>& buffer)$/;"	f	class:WTF::StringImpl	signature:(StringBuffer<UChar>& buffer)
adopt	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE static PassRefPtr<StringImpl> adopt(StringBuffer<UChar>& buffer);$/;"	p	class:WTF::StringImpl	access:public	signature:(StringBuffer<UChar>& buffer)
adopt	.\text\StringImpl.h	/^    static PassRefPtr<StringImpl> adopt(StringBuffer<LChar>& buffer);$/;"	p	class:WTF::StringImpl	access:public	signature:(StringBuffer<LChar>& buffer)
adopt	.\text\StringImpl.h	/^    static PassRefPtr<StringImpl> adopt(Vector<CharType, inlineCapacity>& vector)$/;"	f	class:WTF::StringImpl	access:public	signature:(Vector<CharType, inlineCapacity>& vector)
adopt	.\text\WTFString.h	/^    static String adopt(StringBuffer<LChar>& buffer) { return StringImpl::adopt(buffer); }$/;"	f	class:WTF::String	access:public	signature:(StringBuffer<LChar>& buffer)
adopt	.\text\WTFString.h	/^    static String adopt(StringBuffer<UChar>& buffer) { return StringImpl::adopt(buffer); }$/;"	f	class:WTF::String	access:public	signature:(StringBuffer<UChar>& buffer)
adopt	.\text\WTFString.h	/^    static String adopt(Vector<UChar, inlineCapacity>& vector) { return StringImpl::adopt(vector); }$/;"	f	class:WTF::String	access:public	signature:(Vector<UChar, inlineCapacity>& vector)
adoptArrayPtr	.\OwnArrayPtr.h	/^template<typename T> PassOwnArrayPtr<T> adoptArrayPtr(T*);$/;"	p	namespace:WTF	signature:(T*)
adoptArrayPtr	.\PassOwnArrayPtr.h	/^    template<typename U> friend PassOwnArrayPtr<U> adoptArrayPtr(U*);$/;"	p	class:WTF::PassOwnArrayPtr	access:friend	signature:(U*)
adoptArrayPtr	.\PassOwnArrayPtr.h	/^template<typename T> PassOwnArrayPtr<T> adoptArrayPtr(T*);$/;"	p	namespace:WTF	signature:(T*)
adoptArrayPtr	.\PassOwnArrayPtr.h	/^template<typename T> inline PassOwnArrayPtr<T> adoptArrayPtr(T* ptr)$/;"	f	namespace:WTF	signature:(T* ptr)
adoptCF	.\RetainPtr.h	/^        void adoptCF(PtrType);$/;"	p	class:WTF::RetainPtr	access:public	signature:(PtrType)
adoptCF	.\RetainPtr.h	/^    template<typename T> inline RetainPtr<T> adoptCF(T o)$/;"	f	namespace:WTF	signature:(T o)
adoptCF	.\RetainPtr.h	/^    template<typename T> inline void RetainPtr<T>::adoptCF(PtrType optr)$/;"	f	class:WTF::RetainPtr	signature:(PtrType optr)
adoptGRef	.\gobject\GRefPtr.h	/^    friend GRefPtr adoptGRef<T>(T*);$/;"	p	class:WTF::GRefPtr	access:friend	signature:(T*)
adoptGRef	.\gobject\GRefPtr.h	/^template <typename T> GRefPtr<T> adoptGRef(T* p)$/;"	f	namespace:WTF	signature:(T* p)
adoptGRef	.\gobject\GRefPtr.h	/^template <typename T> GRefPtr<T> adoptGRef(T*);$/;"	p	namespace:WTF	signature:(T*)
adoptNS	.\RetainPtr.h	/^        void adoptNS(PtrType);$/;"	p	class:WTF::RetainPtr	access:public	signature:(PtrType)
adoptNS	.\RetainPtr.h	/^    template<typename T> inline RetainPtr<T> adoptNS(T o)$/;"	f	namespace:WTF	signature:(T o)
adoptNS	.\RetainPtr.h	/^    template<typename T> inline void RetainPtr<T>::adoptNS(PtrType optr)$/;"	f	class:WTF::RetainPtr	signature:(PtrType optr)
adoptNSReference	.\RetainPtr.h	/^    inline void adoptNSReference(id ptr)$/;"	f	namespace:WTF	signature:(id ptr)
adoptPtr	.\OwnPtr.h	/^    template<typename T> PassOwnPtr<T> adoptPtr(T*);$/;"	p	namespace:WTF	signature:(T*)
adoptPtr	.\PassOwnPtr.h	/^        template<typename U> friend PassOwnPtr<U> adoptPtr(U*);$/;"	p	class:WTF::PassOwnPtr	access:friend	signature:(U*)
adoptPtr	.\PassOwnPtr.h	/^    template<typename T> PassOwnPtr<T> adoptPtr(T*);$/;"	p	namespace:WTF	signature:(T*)
adoptPtr	.\PassOwnPtr.h	/^    template<typename T> inline PassOwnPtr<T> adoptPtr(T* ptr)$/;"	f	namespace:WTF	signature:(T* ptr)
adoptRef	.\PassRefPtr.h	/^        friend PassRefPtr adoptRef<T>(T*);$/;"	p	class:WTF::PassRefPtr	access:friend	signature:(T*)
adoptRef	.\PassRefPtr.h	/^    template<typename T> PassRefPtr<T> adoptRef(T*);$/;"	p	namespace:WTF	signature:(T*)
adoptRef	.\PassRefPtr.h	/^    template<typename T> inline PassRefPtr<T> adoptRef(T* p)$/;"	f	namespace:WTF	signature:(T* p)
adopted	.\PassRefPtr.h	/^    inline void adopted(const void*) { }$/;"	f	namespace:WTF	signature:(const void*)
adopted	.\RefCounted.h	/^    friend void adopted(RefCountedBase*);$/;"	p	class:WTF::RefCountedBase	access:friend	signature:(RefCountedBase*)
adopted	.\RefCounted.h	/^inline void adopted(RefCountedBase* object)$/;"	f	namespace:WTF	signature:(RefCountedBase* object)
aegeanWordSeparatorDot	.\unicode\CharacterNames.h	/^const UChar32 aegeanWordSeparatorDot = 0x10101;$/;"	v
aegeanWordSeparatorLine	.\unicode\CharacterNames.h	/^const UChar32 aegeanWordSeparatorLine = 0x10100;$/;"	v
after	.\Deque.h	/^        T* after() const;$/;"	p	class:WTF::DequeIteratorBase	access:protected	signature:() const
after	.\Deque.h	/^    inline T* DequeIteratorBase<T, inlineCapacity>::after() const$/;"	f	class:WTF::DequeIteratorBase	signature:() const
alignToMachineWord	.\text\ASCIIFastPath.h	/^template<typename T> inline T* alignToMachineWord(T* pointer)$/;"	f	namespace:WTF	signature:(T* pointer)
alloc	.\BumpPointerAllocator.h	/^    void* alloc(size_t size)$/;"	f	class:WTF::BumpPointerPool	access:public	signature:(size_t size)
alloc	.\SegmentedVector.h	/^        T& alloc()$/;"	f	class:WTF::SegmentedVector	access:public	signature:()
allocFreeSpaceNode	.\MetaAllocator.cpp	/^MetaAllocator::FreeSpaceNode* MetaAllocator::allocFreeSpaceNode()$/;"	f	class:WTF::MetaAllocator	signature:()
allocFreeSpaceNode	.\MetaAllocator.h	/^    FreeSpaceNode* allocFreeSpaceNode();$/;"	p	class:WTF::MetaAllocator	access:private	signature:()
allocate	.\ListHashSet.h	/^        Node* allocate()$/;"	f	struct:WTF::ListHashSetNodeAllocator	access:public	signature:()
allocate	.\MetaAllocator.cpp	/^PassRefPtr<MetaAllocatorHandle> MetaAllocator::allocate(size_t sizeInBytes, void* ownerUID)$/;"	f	class:WTF::MetaAllocator	signature:(size_t sizeInBytes, void* ownerUID)
allocate	.\MetaAllocator.h	/^    WTF_EXPORT_PRIVATE PassRefPtr<MetaAllocatorHandle> allocate(size_t sizeInBytes, void* ownerUID);$/;"	p	class:WTF::MetaAllocator	access:public	signature:(size_t sizeInBytes, void* ownerUID)
allocate	.\PageAllocation.h	/^    static PageAllocation allocate(size_t size, OSAllocator::Usage usage = OSAllocator::UnknownUsage, bool writable = true, bool executable = false)$/;"	f	class:WTF::PageAllocation	access:public	signature:(size_t size, OSAllocator::Usage usage = OSAllocator::UnknownUsage, bool writable = true, bool executable = false)
allocate	.\PageAllocationAligned.cpp	/^PageAllocationAligned PageAllocationAligned::allocate(size_t size, size_t alignment, OSAllocator::Usage usage, bool writable, bool executable)$/;"	f	class:WTF::PageAllocationAligned	signature:(size_t size, size_t alignment, OSAllocator::Usage usage, bool writable, bool executable)
allocate	.\PageAllocationAligned.h	/^    static PageAllocationAligned allocate(size_t size, size_t alignment, OSAllocator::Usage usage = OSAllocator::UnknownUsage, bool writable = true, bool executable = false);$/;"	p	class:WTF::PageAllocationAligned	access:public	signature:(size_t size, size_t alignment, OSAllocator::Usage usage = OSAllocator::UnknownUsage, bool writable = true, bool executable = false)
allocate64kBlock	.\wince\MemoryManager.cpp	/^void* MemoryManager::allocate64kBlock()$/;"	f	class:WTF::MemoryManager	signature:()
allocate64kBlock	.\wince\MemoryManager.h	/^        static void* allocate64kBlock();$/;"	p	class:WTF::MemoryManager	access:public	signature:()
allocateBuffer	.\Vector.h	/^        void allocateBuffer(size_t newCapacity)$/;"	f	class:WTF::VectorBuffer	access:public	signature:(size_t newCapacity)
allocateBuffer	.\Vector.h	/^        void allocateBuffer(size_t newCapacity)$/;"	f	class:WTF::VectorBufferBase	access:public	signature:(size_t newCapacity)
allocateBuffer	.\text\StringBuilder.cpp	/^void StringBuilder::allocateBuffer(const LChar* currentCharacters, unsigned requiredLength)$/;"	f	class:WTF::StringBuilder	signature:(const LChar* currentCharacters, unsigned requiredLength)
allocateBuffer	.\text\StringBuilder.cpp	/^void StringBuilder::allocateBuffer(const UChar* currentCharacters, unsigned requiredLength)$/;"	f	class:WTF::StringBuilder	signature:(const UChar* currentCharacters, unsigned requiredLength)
allocateBuffer	.\text\StringBuilder.h	/^    void allocateBuffer(const LChar* currentCharacters, unsigned requiredLength);$/;"	p	class:WTF::StringBuilder	access:private	signature:(const LChar* currentCharacters, unsigned requiredLength)
allocateBuffer	.\text\StringBuilder.h	/^    void allocateBuffer(const UChar* currentCharacters, unsigned requiredLength);$/;"	p	class:WTF::StringBuilder	access:private	signature:(const UChar* currentCharacters, unsigned requiredLength)
allocateBufferUpConvert	.\text\StringBuilder.cpp	/^void StringBuilder::allocateBufferUpConvert(const LChar* currentCharacters, unsigned requiredLength)$/;"	f	class:WTF::StringBuilder	signature:(const LChar* currentCharacters, unsigned requiredLength)
allocateBufferUpConvert	.\text\StringBuilder.h	/^    void allocateBufferUpConvert(const LChar* currentCharacters, unsigned requiredLength);$/;"	p	class:WTF::StringBuilder	access:private	signature:(const LChar* currentCharacters, unsigned requiredLength)
allocateNewSpace	.\MetaAllocator.h	/^    virtual void* allocateNewSpace(size_t& numPages) = 0;$/;"	p	class:WTF::MetaAllocator	access:protected	signature:(size_t& numPages)
allocateTable	.\HashTable.h	/^        static ValueType* allocateTable(int size);$/;"	p	class:WTF::HashTable	access:private	signature:(int size)
allocateTable	.\HashTable.h	/^    Value* HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::allocateTable(int size)$/;"	f	class:WTF::HashTable	signature:(int size)
allocated_regions_	.\FastMalloc.cpp	/^  void* allocated_regions_;$/;"	m	class:WTF::PageHeapAllocator	file:	access:private
allocationCanFail	.\wince\MemoryManager.h	/^        bool allocationCanFail() const { return m_allocationCanFail; }$/;"	f	class:WTF::MemoryManager	access:public	signature:() const
allocator	.\MetaAllocatorHandle.h	/^    MetaAllocator* allocator()$/;"	f	class:WTF::MetaAllocatorHandle	access:public	signature:()
allocator_	.\TCPageMap.h	/^  void* (*allocator_)(size_t);          \/\/ Memory allocator$/;"	m	class:TCMalloc_PageMap2	access:private
allocator_	.\TCPageMap.h	/^  void* (*allocator_)(size_t);          \/\/ Memory allocator$/;"	m	class:TCMalloc_PageMap3	access:private
alwaysTruePredicate	.\MessageQueue.h	/^        static bool alwaysTruePredicate(DataType*) { return true; }$/;"	f	class:WTF::MessageQueue	access:private	signature:(DataType*)
append	.\Deque.h	/^        template<typename U> void append(const U&);$/;"	p	class:WTF::Deque	access:public	signature:(const U&)
append	.\Deque.h	/^    inline void Deque<T, inlineCapacity>::append(const U& value)$/;"	f	class:WTF::Deque	signature:(const U& value)
append	.\DoublyLinkedList.h	/^    void append(T*);$/;"	p	class:WTF::DoublyLinkedList	access:public	signature:(T*)
append	.\DoublyLinkedList.h	/^template<typename T> inline void DoublyLinkedList<T>::append(T* node)$/;"	f	class:WTF::DoublyLinkedList	signature:(T* node)
append	.\MessageQueue.h	/^        void append(PassOwnPtr<DataType>);$/;"	p	class:WTF::MessageQueue	access:public	signature:(PassOwnPtr<DataType>)
append	.\MessageQueue.h	/^    inline void MessageQueue<DataType>::append(PassOwnPtr<DataType> message)$/;"	f	class:WTF::MessageQueue	signature:(PassOwnPtr<DataType> message)
append	.\SegmentedVector.h	/^        template <typename U> void append(const U& value)$/;"	f	class:WTF::SegmentedVector	access:public	signature:(const U& value)
append	.\Vector.h	/^        template<size_t otherCapacity> void append(const Vector<T, otherCapacity>&);$/;"	p	class:WTF::Vector	access:public	signature:(const Vector<T, otherCapacity>&)
append	.\Vector.h	/^        template<typename U> void append(const U&);$/;"	p	class:WTF::Vector	access:public	signature:(const U&)
append	.\Vector.h	/^        template<typename U> void append(const U*, size_t);$/;"	p	class:WTF::Vector	access:public	signature:(const U*, size_t)
append	.\Vector.h	/^    ALWAYS_INLINE void Vector<T, inlineCapacity>::append(const U& val)$/;"	f	class:WTF::Vector	signature:(const U& val)
append	.\Vector.h	/^    inline void Vector<T, inlineCapacity>::append(const Vector<T, otherCapacity>& val)$/;"	f	class:WTF::Vector	signature:(const Vector<T, otherCapacity>& val)
append	.\Vector.h	/^    void Vector<T, inlineCapacity>::append(const U* data, size_t dataSize)$/;"	f	class:WTF::Vector	signature:(const U* data, size_t dataSize)
append	.\dtoa.cpp	/^    void append(uint32_t w)$/;"	f	struct:WTF::BigInt	access:public	signature:(uint32_t w)
append	.\text\StringBuilder.cpp	/^void StringBuilder::append(const LChar* characters, unsigned length)$/;"	f	class:WTF::StringBuilder	signature:(const LChar* characters, unsigned length)
append	.\text\StringBuilder.cpp	/^void StringBuilder::append(const UChar* characters, unsigned length)$/;"	f	class:WTF::StringBuilder	signature:(const UChar* characters, unsigned length)
append	.\text\StringBuilder.h	/^    ALWAYS_INLINE void append(const char* characters, unsigned length) { append(reinterpret_cast<const LChar*>(characters), length); }$/;"	f	class:WTF::StringBuilder	access:public	signature:(const char* characters, unsigned length)
append	.\text\StringBuilder.h	/^    WTF_EXPORT_PRIVATE void append(const LChar*, unsigned);$/;"	p	class:WTF::StringBuilder	access:public	signature:(const LChar*, unsigned)
append	.\text\StringBuilder.h	/^    WTF_EXPORT_PRIVATE void append(const UChar*, unsigned);$/;"	p	class:WTF::StringBuilder	access:public	signature:(const UChar*, unsigned)
append	.\text\StringBuilder.h	/^    void append(LChar c)$/;"	f	class:WTF::StringBuilder	access:public	signature:(LChar c)
append	.\text\StringBuilder.h	/^    void append(UChar c)$/;"	f	class:WTF::StringBuilder	access:public	signature:(UChar c)
append	.\text\StringBuilder.h	/^    void append(char c)$/;"	f	class:WTF::StringBuilder	access:public	signature:(char c)
append	.\text\StringBuilder.h	/^    void append(const String& string)$/;"	f	class:WTF::StringBuilder	access:public	signature:(const String& string)
append	.\text\StringBuilder.h	/^    void append(const String& string, unsigned offset, unsigned length)$/;"	f	class:WTF::StringBuilder	access:public	signature:(const String& string, unsigned offset, unsigned length)
append	.\text\StringBuilder.h	/^    void append(const StringBuilder& other)$/;"	f	class:WTF::StringBuilder	access:public	signature:(const StringBuilder& other)
append	.\text\StringBuilder.h	/^    void append(const char* characters)$/;"	f	class:WTF::StringBuilder	access:public	signature:(const char* characters)
append	.\text\WTFString.cpp	/^void String::append(LChar c)$/;"	f	class:WTF::String	signature:(LChar c)
append	.\text\WTFString.cpp	/^void String::append(UChar c)$/;"	f	class:WTF::String	signature:(UChar c)
append	.\text\WTFString.cpp	/^void String::append(const String& str)$/;"	f	class:WTF::String	signature:(const String& str)
append	.\text\WTFString.cpp	/^void String::append(const UChar* charactersToAppend, unsigned lengthToAppend)$/;"	f	class:WTF::String	signature:(const UChar* charactersToAppend, unsigned lengthToAppend)
append	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE void append(LChar);$/;"	p	class:WTF::String	access:public	signature:(LChar)
append	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE void append(UChar);$/;"	p	class:WTF::String	access:public	signature:(UChar)
append	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE void append(const String&);$/;"	p	class:WTF::String	access:public	signature:(const String&)
append	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE void append(const UChar*, unsigned length);$/;"	p	class:WTF::String	access:public	signature:(const UChar*, unsigned length)
append	.\text\WTFString.h	/^    void append(char c) { append(static_cast<LChar>(c)); };$/;"	f	class:WTF::String	access:public	signature:(char c)
append	.\text\WTFString.h	/^inline void append(Vector<UChar>& vector, const String& string)$/;"	f	namespace:WTF	signature:(Vector<UChar>& vector, const String& string)
append	.\url\src\URLBuffer.h	/^    void append(CharacterType ch)$/;"	f	class:WTF::URLBuffer	access:public	signature:(CharacterType ch)
append	.\url\src\URLBuffer.h	/^    void append(const CharacterType* str, int strLength)$/;"	f	class:WTF::URLBuffer	access:public	signature:(const CharacterType* str, int strLength)
appendAndCheckEmpty	.\MessageQueue.h	/^        bool appendAndCheckEmpty(PassOwnPtr<DataType>);$/;"	p	class:WTF::MessageQueue	access:public	signature:(PassOwnPtr<DataType>)
appendAndCheckEmpty	.\MessageQueue.h	/^    inline bool MessageQueue<DataType>::appendAndCheckEmpty(PassOwnPtr<DataType> message)$/;"	f	class:WTF::MessageQueue	signature:(PassOwnPtr<DataType> message)
appendByteAsHex	.\HexNumber.h	/^inline void appendByteAsHex(unsigned char byte, T& destination, HexConversionMode mode = Uppercase)$/;"	f	namespace:WTF	signature:(unsigned char byte, T& destination, HexConversionMode mode = Uppercase)
appendNode	.\ListHashSet.h	/^        void appendNode(Node*);$/;"	p	class:WTF::ListHashSet	access:private	signature:(Node*)
appendNode	.\ListHashSet.h	/^    void ListHashSet<T, inlineCapacity, U>::appendNode(Node* node)$/;"	f	class:WTF::ListHashSet	signature:(Node* node)
appendNumber	.\text\WTFString.h	/^inline void appendNumber(Vector<UChar>& vector, unsigned char number)$/;"	f	namespace:WTF	signature:(Vector<UChar>& vector, unsigned char number)
appendRange	.\Vector.h	/^        template<typename Iterator> void appendRange(Iterator start, Iterator end);$/;"	p	class:WTF::Vector	access:public	signature:(Iterator start, Iterator end)
appendRange	.\Vector.h	/^    void Vector<T, inlineCapacity>::appendRange(Iterator start, Iterator end)$/;"	f	class:WTF::Vector	signature:(Iterator start, Iterator end)
appendRaw8BitQueryString	.\url\src\URLQueryCanonicalizer.h	/^    static void appendRaw8BitQueryString(const InChar* source, int length, URLBuffer<OutChar>* buffer)$/;"	f	class:WTF::URLQueryCanonicalizer	access:private	signature:(const InChar* source, int length, URLBuffer<OutChar>* buffer)
appendSlowCase	.\Vector.h	/^        template<typename U> void appendSlowCase(const U&);$/;"	p	class:WTF::Vector	access:private	signature:(const U&)
appendSlowCase	.\Vector.h	/^    void Vector<T, inlineCapacity>::appendSlowCase(const U& val)$/;"	f	class:WTF::Vector	signature:(const U& val)
appendURLEscapedCharacter	.\url\src\URLEscape.h	/^inline void appendURLEscapedCharacter(InChar ch, URLBuffer<OutChar>& buffer)$/;"	f	namespace:WTF	signature:(InChar ch, URLBuffer<OutChar>& buffer)
appendUninitialized	.\text\StringBuilder.cpp	/^ALWAYS_INLINE CharType* StringBuilder::appendUninitialized(unsigned length)$/;"	f	class:WTF::StringBuilder	signature:(unsigned length)
appendUninitialized	.\text\StringBuilder.h	/^    ALWAYS_INLINE CharType* appendUninitialized(unsigned length);$/;"	p	class:WTF::StringBuilder	access:private	signature:(unsigned length)
appendUninitializedSlow	.\text\StringBuilder.cpp	/^CharType* StringBuilder::appendUninitializedSlow(unsigned requiredLength)$/;"	f	class:WTF::StringBuilder	signature:(unsigned requiredLength)
appendUninitializedSlow	.\text\StringBuilder.h	/^    CharType* appendUninitializedSlow(unsigned length);$/;"	p	class:WTF::StringBuilder	access:private	signature:(unsigned length)
appendUnsignedAsHex	.\HexNumber.h	/^inline void appendUnsignedAsHex(unsigned number, T& destination, HexConversionMode mode = Uppercase)$/;"	f	namespace:WTF	signature:(unsigned number, T& destination, HexConversionMode mode = Uppercase)
appendUnsignedAsHexFixedSize	.\HexNumber.h	/^inline void appendUnsignedAsHexFixedSize(unsigned number, T& destination, unsigned desiredDigits, HexConversionMode mode = Uppercase)$/;"	f	namespace:WTF	signature:(unsigned number, T& destination, unsigned desiredDigits, HexConversionMode mode = Uppercase)
array_	.\TCPackedCache.h	/^  T array_[1 << kHashbits];$/;"	m	class:PackedCache	access:private
array_	.\TCPageMap.h	/^  void** array_;$/;"	m	class:TCMalloc_PageMap1	access:private
ascii	.\text\WTFString.cpp	/^CString String::ascii() const$/;"	f	class:WTF::String	signature:() const
ascii	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE CString ascii() const;$/;"	p	class:WTF::String	access:public	signature:() const
asciiDebug	.\text\WTFString.cpp	/^Vector<char> asciiDebug(String& string)$/;"	f	signature:(String& string)
asciiDebug	.\text\WTFString.cpp	/^Vector<char> asciiDebug(String& string);$/;"	p	file:	signature:(String& string)
asciiDebug	.\text\WTFString.cpp	/^Vector<char> asciiDebug(StringImpl* impl)$/;"	f	signature:(StringImpl* impl)
asciiDebug	.\text\WTFString.cpp	/^Vector<char> asciiDebug(StringImpl* impl);$/;"	p	file:	signature:(StringImpl* impl)
assert	.\Platform.h	518;"	d
assertUnused	.\Assertions.h	/^inline void assertUnused(T& x) { (void)x; }$/;"	f	signature:(T& x)
assertWithMessageUnused	.\Assertions.h	/^inline void assertWithMessageUnused(T& x) { (void)x; }$/;"	f	signature:(T& x)
assign	.\Deque.h	/^        void assign(const Base& other) { *this = other; }$/;"	f	class:WTF::DequeIteratorBase	access:protected	signature:(const Base& other)
at	.\RefCountedArray.h	/^    T& at(size_t i)$/;"	f	class:WTF::RefCountedArray	access:public	signature:(size_t i)
at	.\RefCountedArray.h	/^    const T& at(size_t i) const$/;"	f	class:WTF::RefCountedArray	access:public	signature:(size_t i) const
at	.\SegmentedVector.h	/^        T& at(size_t index)$/;"	f	class:WTF::SegmentedVector	access:public	signature:(size_t index)
at	.\Vector.h	/^        T& at(size_t i) $/;"	f	class:WTF::Vector	access:public	signature:(size_t i)
at	.\Vector.h	/^        const T& at(size_t i) const $/;"	f	class:WTF::Vector	access:public	signature:(size_t i) const
at	.\url\src\URLBuffer.h	/^    inline char at(int offset) const { return m_buffer[offset]; }$/;"	f	class:WTF::URLBuffer	access:public	signature:(int offset) const
atan2	.\MathExtras.h	206;"	d
atomicDecrement	.\Atomics.h	/^inline int atomicDecrement(int* addend) { return InterlockedDecrement(reinterpret_cast<long*>(addend)); }$/;"	f	namespace:WTF	signature:(int* addend)
atomicIncrement	.\Atomics.h	/^inline int atomicIncrement(int* addend) { return InterlockedIncrement(reinterpret_cast<long*>(addend)); }$/;"	f	namespace:WTF	signature:(int* addend)
atomicStringTable	.\WTFThreadData.h	/^    AtomicStringTable* atomicStringTable()$/;"	f	class:WTF::WTFThreadData	access:public	signature:()
atomicallyInitializedStaticMutex	.\ThreadingPthreads.cpp	/^static Mutex* atomicallyInitializedStaticMutex;$/;"	v	file:
atomicallyInitializedStaticMutex	.\ThreadingWin.cpp	/^static Mutex* atomicallyInitializedStaticMutex;$/;"	v	file:
avoidDeletedValue	.\text\StringHash.h	/^        static unsigned avoidDeletedValue(unsigned hash)$/;"	f	struct:WTF::AlreadyHashed	access:public	signature:(unsigned hash)
b	.\SizeLimits.cpp	/^    bool b;$/;"	m	struct:WTF::SameSizeAsRefCounted	file:	access:public
balance	.\AVLTree.h	/^    handle balance(handle bal_h)$/;"	f	class:WTF::AVLTree	access:private	signature:(handle bal_h)
base	.\PageBlock.h	/^    void* base() const { return m_base; }$/;"	f	class:WTF::PageBlock	access:public	signature:() const
baseAddress	.\ArrayBufferView.h	/^    void* baseAddress() const$/;"	f	class:WTF::ArrayBufferView	access:public	signature:() const
baseAsString	.\url\api\ParsedURL.cpp	/^String ParsedURL::baseAsString() const$/;"	f	class:WTF::ParsedURL	signature:() const
baseAsString	.\url\api\ParsedURL.h	/^    WTF_EXPORT_PRIVATE String baseAsString() const;$/;"	p	class:WTF::ParsedURL	access:public	signature:() const
baseString	.\text\AtomicString.cpp	/^    StringImpl* baseString;$/;"	m	struct:WTF::SubstringLocation	file:	access:public
before	.\Deque.h	/^        T* before() const;$/;"	p	class:WTF::DequeIteratorBase	access:protected	signature:() const
before	.\Deque.h	/^    inline T* DequeIteratorBase<T, inlineCapacity>::before() const$/;"	f	class:WTF::DequeIteratorBase	signature:() const
beforeFirst	.\text\TextPosition.h	/^    static OrdinalNumber beforeFirst() { return OrdinalNumber(-1); }$/;"	f	class:WTF::OrdinalNumber	access:public	signature:()
begin	.\Deque.h	/^        const_iterator begin() const { return const_iterator(this, m_start); }$/;"	f	class:WTF::Deque	access:public	signature:() const
begin	.\Deque.h	/^        iterator begin() { return iterator(this, m_start); }$/;"	f	class:WTF::Deque	access:public	signature:()
begin	.\HashCountedSet.h	/^        const_iterator begin() const;$/;"	p	class:WTF::HashCountedSet	access:public	signature:() const
begin	.\HashCountedSet.h	/^        iterator begin();$/;"	p	class:WTF::HashCountedSet	access:public	signature:()
begin	.\HashCountedSet.h	/^    inline typename HashCountedSet<Value, HashFunctions, Traits>::const_iterator HashCountedSet<Value, HashFunctions, Traits>::begin() const$/;"	f	class:WTF::HashCountedSet	signature:() const
begin	.\HashCountedSet.h	/^    inline typename HashCountedSet<Value, HashFunctions, Traits>::iterator HashCountedSet<Value, HashFunctions, Traits>::begin()$/;"	f	class:WTF::HashCountedSet	signature:()
begin	.\HashMap.h	/^            const_iterator begin() const$/;"	f	class:WTF::HashMap::HashMapKeysProxy	access:public	signature:() const
begin	.\HashMap.h	/^            const_iterator begin() const$/;"	f	class:WTF::HashMap::HashMapValuesProxy	access:public	signature:() const
begin	.\HashMap.h	/^            iterator begin()$/;"	f	class:WTF::HashMap::HashMapKeysProxy	access:public	signature:()
begin	.\HashMap.h	/^            iterator begin()$/;"	f	class:WTF::HashMap::HashMapValuesProxy	access:public	signature:()
begin	.\HashMap.h	/^        const_iterator begin() const;$/;"	p	class:WTF::HashMap	access:public	signature:() const
begin	.\HashMap.h	/^        iterator begin();$/;"	p	class:WTF::HashMap	access:public	signature:()
begin	.\HashMap.h	/^    inline typename HashMap<T, U, V, W, X>::const_iterator HashMap<T, U, V, W, X>::begin() const$/;"	f	class:WTF::HashMap	signature:() const
begin	.\HashMap.h	/^    inline typename HashMap<T, U, V, W, X>::iterator HashMap<T, U, V, W, X>::begin()$/;"	f	class:WTF::HashMap	signature:()
begin	.\HashSet.h	/^        iterator begin() const;$/;"	p	class:WTF::HashSet	access:public	signature:() const
begin	.\HashSet.h	/^    inline typename HashSet<T, U, V>::iterator HashSet<T, U, V>::begin() const$/;"	f	class:WTF::HashSet	signature:() const
begin	.\HashTable.h	/^        const_iterator begin() const { return makeConstIterator(m_table); }$/;"	f	class:WTF::HashTable	access:public	signature:() const
begin	.\HashTable.h	/^        iterator begin() { return makeIterator(m_table); }$/;"	f	class:WTF::HashTable	access:public	signature:()
begin	.\ListHashSet.h	/^        const_iterator begin() const;$/;"	p	class:WTF::ListHashSet	access:public	signature:() const
begin	.\ListHashSet.h	/^        iterator begin();$/;"	p	class:WTF::ListHashSet	access:public	signature:()
begin	.\ListHashSet.h	/^    inline typename ListHashSet<T, inlineCapacity, U>::const_iterator ListHashSet<T, inlineCapacity, U>::begin() const$/;"	f	class:WTF::ListHashSet	signature:() const
begin	.\ListHashSet.h	/^    inline typename ListHashSet<T, inlineCapacity, U>::iterator ListHashSet<T, inlineCapacity, U>::begin()$/;"	f	class:WTF::ListHashSet	signature:()
begin	.\RefCountedArray.h	/^    T* begin() { return m_data; }$/;"	f	class:WTF::RefCountedArray	access:public	signature:()
begin	.\RefCountedArray.h	/^    const T* begin() const { return m_data; }$/;"	f	class:WTF::RefCountedArray	access:public	signature:() const
begin	.\RefPtrHashMap.h	/^        const_iterator begin() const;$/;"	p	class:WTF::HashMap	access:public	signature:() const
begin	.\RefPtrHashMap.h	/^        iterator begin();$/;"	p	class:WTF::HashMap	access:public	signature:()
begin	.\RefPtrHashMap.h	/^    inline typename HashMap<RefPtr<T>, U, V, W, X>::const_iterator HashMap<RefPtr<T>, U, V, W, X>::begin() const$/;"	f	class:WTF::HashMap	signature:() const
begin	.\RefPtrHashMap.h	/^    inline typename HashMap<RefPtr<T>, U, V, W, X>::iterator HashMap<RefPtr<T>, U, V, W, X>::begin()$/;"	f	class:WTF::HashMap	signature:()
begin	.\SegmentedVector.h	/^        Iterator begin()$/;"	f	class:WTF::SegmentedVector	access:public	signature:()
begin	.\SentinelLinkedList.h	/^    iterator begin();$/;"	p	class:WTF::SentinelLinkedList	access:public	signature:()
begin	.\SentinelLinkedList.h	/^template <typename T, typename RawNode> inline typename SentinelLinkedList<T, RawNode>::iterator SentinelLinkedList<T, RawNode>::begin()$/;"	f	class:WTF::SentinelLinkedList	signature:()
begin	.\Spectrum.h	/^    const_iterator begin() const { return m_map.begin(); }$/;"	f	class:WTF::Spectrum	access:public	signature:() const
begin	.\Spectrum.h	/^    iterator begin() { return m_map.begin(); }$/;"	f	class:WTF::Spectrum	access:public	signature:()
begin	.\Vector.h	/^            const_iterator begin() const { return Vector::rbegin(); }$/;"	f	class:WTF::Vector::VectorReverseProxy	access:public	signature:() const
begin	.\Vector.h	/^            iterator begin() { return Vector::rbegin(); }$/;"	f	class:WTF::Vector::VectorReverseProxy	access:public	signature:()
begin	.\Vector.h	/^        const_iterator begin() const { return data(); }$/;"	f	class:WTF::Vector	access:public	signature:() const
begin	.\Vector.h	/^        iterator begin() { return data(); }$/;"	f	class:WTF::Vector	access:public	signature:()
begin	.\url\src\URLComponent.h	/^    int begin() const { return m_begin; }$/;"	f	class:WTF::URLComponent	access:public	signature:() const
belowRangePosition	.\text\TextPosition.h	/^    static TextPosition belowRangePosition() { return TextPosition(OrdinalNumber::beforeFirst(), OrdinalNumber::beforeFirst()); }$/;"	f	class:WTF::TextPosition	access:public	signature:()
bigits_	.\dtoa\bignum.h	/^        Vector<Chunk> bigits_;$/;"	m	class:WTF::double_conversion::Bignum	access:private
bigits_buffer_	.\dtoa\bignum.h	/^        Chunk bigits_buffer_[kBigitCapacity];$/;"	m	class:WTF::double_conversion::Bignum	access:private
bigtens	.\dtoa.cpp	/^static const double bigtens[] = { 1e16, 1e32, 1e64, 1e128, 1e256 };$/;"	v	file:
binarySearch	.\StdLibExtras.h	/^inline ArrayElementType* binarySearch(ArrayElementType* array, size_t size, KeyType key, BinarySearchMode mode = KeyMustBePresentInArray)$/;"	f	namespace:WTF	signature:(ArrayElementType* array, size_t size, KeyType key, BinarySearchMode mode = KeyMustBePresentInArray)
binarySearchWithFunctor	.\StdLibExtras.h	/^inline ArrayElementType* binarySearchWithFunctor(ArrayElementType* array, size_t size, KeyType key, BinarySearchMode mode = KeyMustBePresentInArray, const ExtractKey& extractKey = ExtractKey())$/;"	f	namespace:WTF	signature:(ArrayElementType* array, size_t size, KeyType key, BinarySearchMode mode = KeyMustBePresentInArray, const ExtractKey& extractKey = ExtractKey())
binary_exponent	.\dtoa\cached-powers.cc	/^        int16_t binary_exponent;$/;"	m	struct:WTF::double_conversion::CachedPower	file:	access:public
bind	.\Functional.h	/^Function<typename FunctionWrapper<FunctionType>::ResultType ()> bind(FunctionType function)$/;"	f	namespace:WTF	signature:(FunctionType function)
bind	.\Functional.h	/^Function<typename FunctionWrapper<FunctionType>::ResultType ()> bind(FunctionType function, const A1& a1)$/;"	f	namespace:WTF	signature:(FunctionType function, const A1& a1)
bind	.\Functional.h	/^Function<typename FunctionWrapper<FunctionType>::ResultType ()> bind(FunctionType function, const A1& a1, const A2& a2)$/;"	f	namespace:WTF	signature:(FunctionType function, const A1& a1, const A2& a2)
bind	.\Functional.h	/^Function<typename FunctionWrapper<FunctionType>::ResultType ()> bind(FunctionType function, const A1& a1, const A2& a2, const A3& a3)$/;"	f	namespace:WTF	signature:(FunctionType function, const A1& a1, const A2& a2, const A3& a3)
bind	.\Functional.h	/^Function<typename FunctionWrapper<FunctionType>::ResultType ()> bind(FunctionType function, const A1& a1, const A2& a2, const A3& a3, const A4& a4)$/;"	f	namespace:WTF	signature:(FunctionType function, const A1& a1, const A2& a2, const A3& a3, const A4& a4)
bind	.\Functional.h	/^Function<typename FunctionWrapper<FunctionType>::ResultType ()> bind(FunctionType function, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5)$/;"	f	namespace:WTF	signature:(FunctionType function, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5)
bind	.\Functional.h	/^Function<typename FunctionWrapper<FunctionType>::ResultType ()> bind(FunctionType function, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6)$/;"	f	namespace:WTF	signature:(FunctionType function, const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6)
bitCount	.\StdLibExtras.h	/^inline size_t bitCount(unsigned bits)$/;"	f	namespace:WTF	signature:(unsigned bits)
bits	.\BitVector.h	/^        const uintptr_t* bits() const { return bitwise_cast<const uintptr_t*>(this + 1); }$/;"	f	class:WTF::BitVector::OutOfLineBits	access:public	signature:() const
bits	.\BitVector.h	/^        uintptr_t* bits() { return bitwise_cast<uintptr_t*>(this + 1); }$/;"	f	class:WTF::BitVector::OutOfLineBits	access:public	signature:()
bits	.\BitVector.h	/^    const uintptr_t* bits() const$/;"	f	class:WTF::BitVector	access:private	signature:() const
bits	.\BitVector.h	/^    uintptr_t* bits()$/;"	f	class:WTF::BitVector	access:private	signature:()
bits	.\Bitmap.h	/^    FixedArray<WordType, words> bits;$/;"	m	class:WTF::Bitmap	access:private
bitsInPointer	.\BitVector.h	/^    static unsigned bitsInPointer()$/;"	f	class:WTF::BitVector	access:private	signature:()
bitwise_cast	.\StdLibExtras.h	/^inline TO bitwise_cast(FROM from)$/;"	f	namespace:WTF	signature:(FROM from)
blackCircle	.\unicode\CharacterNames.h	/^const UChar blackCircle = 0x25CF;$/;"	v
blackSquare	.\unicode\CharacterNames.h	/^const UChar blackSquare = 0x25A0;$/;"	v
blackUpPointingTriangle	.\unicode\CharacterNames.h	/^const UChar blackUpPointingTriangle = 0x25B2;$/;"	v
blockLength	.\BlockStack.h	/^    static const size_t blockLength = blockSize \/ sizeof(T);$/;"	m	class:WTF::BlockStack	access:public
blockSize	.\BlockStack.h	/^    static const size_t blockSize = 4096;$/;"	m	class:WTF::BlockStack	access:public
blocks	.\BlockStack.h	/^    const Vector<T*>& blocks();$/;"	p	class:WTF::BlockStack	access:public	signature:()
blocks	.\BlockStack.h	/^template <typename T> inline const Vector<T*>& BlockStack<T>::blocks()$/;"	f	class:WTF::BlockStack	signature:()
branch	.\AVLTree.h	/^        BSet branch;$/;"	m	class:WTF::AVLTree::Iterator	access:protected
broadcast	.\ThreadingPrimitives.h	/^    WTF_EXPORT_PRIVATE void broadcast();$/;"	p	class:WTF::ThreadCondition	access:public	signature:()
broadcast	.\ThreadingPthreads.cpp	/^void ThreadCondition::broadcast()$/;"	f	class:WTF::ThreadCondition	signature:()
broadcast	.\ThreadingWin.cpp	/^void ThreadCondition::broadcast()$/;"	f	class:WTF::ThreadCondition	signature:()
buffer	.\Alignment.h	/^    template<size_t size> struct AlignedBuffer<size, 1> { AlignedBufferChar buffer[size]; };$/;"	m	struct:WTF::AlignedBuffer	access:public
buffer	.\ArrayBufferView.h	/^    PassRefPtr<ArrayBuffer> buffer() const$/;"	f	class:WTF::ArrayBufferView	access:public	signature:() const
buffer	.\Vector.h	/^        T* buffer() { return m_buffer; }$/;"	f	class:WTF::VectorBufferBase	access:public	signature:()
buffer	.\Vector.h	/^        const T* buffer() const { return m_buffer; }$/;"	f	class:WTF::VectorBufferBase	access:public	signature:() const
buffer	.\text\CString.h	/^    CStringBuffer* buffer() const { return m_buffer.get(); }$/;"	f	class:WTF::CString	access:public	signature:() const
bufferLengthForStringDecimal	.\DecimalNumber.cpp	/^unsigned DecimalNumber::bufferLengthForStringDecimal() const$/;"	f	class:WTF::DecimalNumber	signature:() const
bufferLengthForStringDecimal	.\DecimalNumber.h	/^    WTF_EXPORT_PRIVATE unsigned bufferLengthForStringDecimal() const;$/;"	p	class:WTF::DecimalNumber	access:public	signature:() const
bufferLengthForStringExponential	.\DecimalNumber.cpp	/^unsigned DecimalNumber::bufferLengthForStringExponential() const$/;"	f	class:WTF::DecimalNumber	signature:() const
bufferLengthForStringExponential	.\DecimalNumber.h	/^    WTF_EXPORT_PRIVATE unsigned bufferLengthForStringExponential() const;$/;"	p	class:WTF::DecimalNumber	access:public	signature:() const
bufferOwnership	.\text\StringImpl.h	/^    BufferOwnership bufferOwnership() const { return static_cast<BufferOwnership>(m_hashAndFlags & s_hashMaskBufferOwnership); }$/;"	f	class:WTF::StringImpl	access:private	signature:() const
bufferSlot	.\Vector.h	/^        T** bufferSlot() { return &m_buffer; }$/;"	f	class:WTF::VectorBufferBase	access:public	signature:()
buffer_	.\dtoa\utils.h	/^        Vector<char> buffer_;$/;"	m	class:WTF::double_conversion::StringBuilder	access:private
build	.\AVLTree.h	/^    bool build(fwd_iter p, size num_nodes)$/;"	f	class:WTF::AVLTree	access:public	signature:(fwd_iter p, size num_nodes)
buildList	.\Spectrum.h	/^    Vector<KeyAndCount> buildList() const$/;"	f	class:WTF::Spectrum	access:public	signature:() const
bullet	.\unicode\CharacterNames.h	/^const UChar bullet = 0x2022;$/;"	v
bullseye	.\unicode\CharacterNames.h	/^const UChar bullseye = 0x25CE;$/;"	v
byteCount	.\BitVector.h	/^    static size_t byteCount(size_t bitCount)$/;"	f	class:WTF::BitVector	access:private	signature:(size_t bitCount)
byteLength	.\ArrayBuffer.h	/^    inline unsigned byteLength() const;$/;"	p	class:WTF::ArrayBuffer	access:public	signature:() const
byteLength	.\ArrayBuffer.h	/^unsigned ArrayBuffer::byteLength() const$/;"	f	class:WTF::ArrayBuffer	signature:() const
byteLength	.\ArrayBufferView.h	/^    virtual unsigned byteLength() const = 0;$/;"	p	class:WTF::ArrayBufferView	access:public	signature:() const
byteLength	.\TypedArrayBase.h	/^    virtual unsigned byteLength() const$/;"	f	class:WTF::TypedArrayBase	access:public	signature:() const
byteOffset	.\ArrayBufferView.h	/^    unsigned byteOffset() const$/;"	f	class:WTF::ArrayBufferView	access:public	signature:() const
bytesAllocated	.\MetaAllocator.h	/^        size_t bytesAllocated;$/;"	m	struct:WTF::MetaAllocator::Statistics	access:public
bytesAllocated	.\MetaAllocator.h	/^    size_t bytesAllocated() { return m_bytesAllocated; }$/;"	f	class:WTF::MetaAllocator	access:public	signature:()
bytesCommitted	.\MetaAllocator.h	/^        size_t bytesCommitted;$/;"	m	struct:WTF::MetaAllocator::Statistics	access:public
bytesCommitted	.\MetaAllocator.h	/^    size_t bytesCommitted() { return m_bytesCommitted; }$/;"	f	class:WTF::MetaAllocator	access:public	signature:()
bytesReserved	.\MetaAllocator.h	/^        size_t bytesReserved;$/;"	m	struct:WTF::MetaAllocator::Statistics	access:public
bytesReserved	.\MetaAllocator.h	/^    size_t bytesReserved() { return m_bytesReserved; }$/;"	f	class:WTF::MetaAllocator	access:public	signature:()
bytes_until_sample_	.\FastMalloc.cpp	/^  size_t        bytes_until_sample_;    \/\/ Bytes until we sample next$/;"	m	class:WTF::TCMalloc_ThreadCache	file:	access:private
c	.\SizeLimits.cpp	/^    bool c;$/;"	m	struct:WTF::SameSizeAsRefCounted	file:	access:public
cache_size_	.\FastMalloc.cpp	/^  int32_t cache_size_;$/;"	m	class:WTF::TCMalloc_Central_FreeList	file:	access:private
cachedCollator	.\unicode\icu\CollatorICU.cpp	/^static UCollator* cachedCollator;$/;"	v	file:
cachedCollatorMutex	.\unicode\icu\CollatorICU.cpp	/^static Mutex& cachedCollatorMutex()$/;"	f	namespace:WTF	file:	signature:()
cairo_rectangle_int_t	.\gobject\GTypedefs.h	/^typedef struct _cairo_rectangle_int cairo_rectangle_int_t;$/;"	t	typeref:struct:_cairo_rectangle_int
cairo_surface_t	.\gobject\GTypedefs.h	/^typedef struct _cairo_surface cairo_surface_t;$/;"	t	typeref:struct:_cairo_surface
calculateDSTOffset	.\DateMath.cpp	/^double calculateDSTOffset(double ms, double utcOffset)$/;"	f	namespace:WTF	signature:(double ms, double utcOffset)
calculateDSTOffset	.\DateMath.h	/^WTF_EXPORT_PRIVATE double calculateDSTOffset(double ms, double utcOffset);$/;"	p	namespace:WTF	signature:(double ms, double utcOffset)
calculateDSTOffsetSimple	.\DateMath.cpp	/^static double calculateDSTOffsetSimple(double localTimeSeconds, double utcOffset)$/;"	f	namespace:WTF	file:	signature:(double localTimeSeconds, double utcOffset)
calculateOffsetAndLength	.\ArrayBufferView.h	/^    static inline void calculateOffsetAndLength(int start, int end, unsigned arraySize,$/;"	p	class:WTF::ArrayBufferView	access:protected	signature:(int start, int end, unsigned arraySize, unsigned* offset, unsigned* length)
calculateOffsetAndLength	.\ArrayBufferView.h	/^void ArrayBufferView::calculateOffsetAndLength(int start, int end, unsigned arraySize,$/;"	f	class:WTF::ArrayBufferView	signature:(int start, int end, unsigned arraySize, unsigned* offset, unsigned* length)
calculateStringHashAndLengthFromUTF8	.\unicode\UTF8.cpp	/^unsigned calculateStringHashAndLengthFromUTF8(const char* data, const char* dataEnd, unsigned& dataLength, unsigned& utf16Length)$/;"	f	namespace:WTF::Unicode	signature:(const char* data, const char* dataEnd, unsigned& dataLength, unsigned& utf16Length)
calculateStringHashAndLengthFromUTF8	.\unicode\UTF8.h	/^    unsigned calculateStringHashAndLengthFromUTF8(const char* data, const char* dataEnd, unsigned& dataLength, unsigned& utf16Length);$/;"	p	namespace:WTF::Unicode	signature:(const char* data, const char* dataEnd, unsigned& dataLength, unsigned& utf16Length)
calculateUTCOffset	.\DateMath.cpp	/^int32_t calculateUTCOffset()$/;"	f	namespace:WTF	signature:()
calculateUTCOffset	.\DateMath.h	/^WTF_EXPORT_PRIVATE int32_t calculateUTCOffset();$/;"	p	namespace:WTF	signature:()
callFunctionObject	.\MainThread.cpp	/^static void callFunctionObject(void* context)$/;"	f	namespace:WTF	file:	signature:(void* context)
callOnMainThread	.\MainThread.cpp	/^void callOnMainThread(MainThreadFunction* function, void* context)$/;"	f	namespace:WTF	signature:(MainThreadFunction* function, void* context)
callOnMainThread	.\MainThread.cpp	/^void callOnMainThread(const Function<void ()>& function)$/;"	f	namespace:WTF	signature:(const Function<void ()>& function)
callOnMainThread	.\MainThread.h	/^WTF_EXPORT_PRIVATE void callOnMainThread(MainThreadFunction*, void* context);$/;"	p	namespace:WTF	signature:(MainThreadFunction*, void* context)
callOnMainThread	.\MainThread.h	/^WTF_EXPORT_PRIVATE void callOnMainThread(const Function<void ()>&);$/;"	p	namespace:WTF	signature:(const Function<void ()>&)
callOnMainThread	.\chromium\ChromiumThreading.h	/^    static void callOnMainThread(void (*func)(void*), void* context);$/;"	p	class:WTF::ChromiumThreading	access:public	signature:(void (*func)(void*), void* context)
callOnMainThread	.\chromium\MainThreadChromium.cpp	/^void callOnMainThread(MainThreadFunction* function, void* context)$/;"	f	namespace:WTF	signature:(MainThreadFunction* function, void* context)
callOnMainThreadAndWait	.\MainThread.cpp	/^void callOnMainThreadAndWait(MainThreadFunction* function, void* context)$/;"	f	namespace:WTF	signature:(MainThreadFunction* function, void* context)
callOnMainThreadAndWait	.\MainThread.h	/^WTF_EXPORT_PRIVATE void callOnMainThreadAndWait(MainThreadFunction*, void* context);$/;"	p	namespace:WTF	signature:(MainThreadFunction*, void* context)
callOnMainThreadAndWait	.\chromium\MainThreadChromium.cpp	/^void callOnMainThreadAndWait(MainThreadFunction*, void*)$/;"	f	namespace:WTF	signature:(MainThreadFunction*, void*)
callbacksPaused	.\MainThread.cpp	/^static bool callbacksPaused; \/\/ This global variable is only accessed from main thread.$/;"	v	file:
calloc	.\FastMalloc.cpp	/^ALWAYS_INLINE void* calloc(size_t, size_t);$/;"	p	namespace:WTF	file:	signature:(size_t, size_t)
calloc	.\FastMalloc.cpp	/^void* calloc(size_t n, size_t elem_size) {$/;"	f	namespace:WTF	signature:(size_t n, size_t elem_size)
calloc	.\FastMalloc.cpp	4660;"	d	file:
calloc	.\FastMalloc.cpp	499;"	d	file:
calloc	.\wince\FastMallocWinCE.h	53;"	d
calloc	.\wince\MemoryManager.cpp	24;"	d	file:
canCompareWithMemcmp	.\VectorTraits.h	/^        static const bool canCompareWithMemcmp = FirstTraits::canCompareWithMemcmp && SecondTraits::canCompareWithMemcmp;$/;"	m	struct:WTF::VectorTraits	access:public
canCompareWithMemcmp	.\VectorTraits.h	/^        static const bool canCompareWithMemcmp = false;$/;"	m	struct:WTF::VectorTraitsBase	access:public
canCompareWithMemcmp	.\VectorTraits.h	/^        static const bool canCompareWithMemcmp = true;$/;"	m	struct:WTF::SimpleClassVectorTraits	access:public
canCompareWithMemcmp	.\VectorTraits.h	/^        static const bool canCompareWithMemcmp = true;$/;"	m	struct:WTF::VectorTraitsBase	access:public
canCopyWithMemcpy	.\VectorTraits.h	/^        static const bool canCopyWithMemcpy = FirstTraits::canCopyWithMemcpy && SecondTraits::canCopyWithMemcpy;$/;"	m	struct:WTF::VectorTraits	access:public
canCopyWithMemcpy	.\VectorTraits.h	/^        static const bool canCopyWithMemcpy = false;$/;"	m	struct:WTF::VectorTraitsBase	access:public
canCopyWithMemcpy	.\VectorTraits.h	/^        static const bool canCopyWithMemcpy = true;$/;"	m	struct:WTF::VectorTraitsBase	access:public
canFillWithMemset	.\VectorTraits.h	/^        static const bool canFillWithMemset = false;$/;"	m	struct:WTF::VectorTraits	access:public
canFillWithMemset	.\VectorTraits.h	/^        static const bool canFillWithMemset = false;$/;"	m	struct:WTF::VectorTraitsBase	access:public
canFillWithMemset	.\VectorTraits.h	/^        static const bool canFillWithMemset = sizeof(T) == sizeof(char);$/;"	m	struct:WTF::VectorTraitsBase	access:public
canInitializeWithMemset	.\VectorTraits.h	/^        static const bool canInitializeWithMemset = FirstTraits::canInitializeWithMemset && SecondTraits::canInitializeWithMemset;$/;"	m	struct:WTF::VectorTraits	access:public
canInitializeWithMemset	.\VectorTraits.h	/^        static const bool canInitializeWithMemset = false;$/;"	m	struct:WTF::VectorTraitsBase	access:public
canInitializeWithMemset	.\VectorTraits.h	/^        static const bool canInitializeWithMemset = true;$/;"	m	struct:WTF::SimpleClassVectorTraits	access:public
canMoveWithMemcpy	.\VectorTraits.h	/^        static const bool canMoveWithMemcpy = FirstTraits::canMoveWithMemcpy && SecondTraits::canMoveWithMemcpy;$/;"	m	struct:WTF::VectorTraits	access:public
canMoveWithMemcpy	.\VectorTraits.h	/^        static const bool canMoveWithMemcpy = false;$/;"	m	struct:WTF::VectorTraitsBase	access:public
canMoveWithMemcpy	.\VectorTraits.h	/^        static const bool canMoveWithMemcpy = true;$/;"	m	struct:WTF::SimpleClassVectorTraits	access:public
canMoveWithMemcpy	.\VectorTraits.h	/^        static const bool canMoveWithMemcpy = true;$/;"	m	struct:WTF::VectorTraitsBase	access:public
canShrink	.\text\StringBuilder.cpp	/^bool StringBuilder::canShrink() const$/;"	f	class:WTF::StringBuilder	signature:() const
canShrink	.\text\StringBuilder.h	/^    WTF_EXPORT_PRIVATE bool canShrink() const;$/;"	p	class:WTF::StringBuilder	access:public	signature:() const
cancelCallOnMainThread	.\MainThread.cpp	/^void cancelCallOnMainThread(MainThreadFunction* function, void* context)$/;"	f	namespace:WTF	signature:(MainThreadFunction* function, void* context)
cancelCallOnMainThread	.\MainThread.h	/^WTF_EXPORT_PRIVATE void cancelCallOnMainThread(MainThreadFunction*, void* context);$/;"	p	namespace:WTF	signature:(MainThreadFunction*, void* context)
cancelMessageSuppression	.\RefCountedLeakCounter.cpp	/^void RefCountedLeakCounter::cancelMessageSuppression(const char*) { }$/;"	f	class:WTF::RefCountedLeakCounter	signature:(const char*)
cancelMessageSuppression	.\RefCountedLeakCounter.h	/^        WTF_EXPORT_PRIVATE static void cancelMessageSuppression(const char*);$/;"	p	struct:WTF::RefCountedLeakCounter	access:public	signature:(const char*)
canonicalize	.\url\src\URLQueryCanonicalizer.h	/^    static void canonicalize(const InChar* spec, const URLComponent& query, URLBuffer<OutChar>& buffer, URLComponent& resultQuery)$/;"	f	class:WTF::URLQueryCanonicalizer	access:public	signature:(const InChar* spec, const URLComponent& query, URLBuffer<OutChar>& buffer, URLComponent& resultQuery)
capacity	.\HashCountedSet.h	/^        int capacity() const;$/;"	p	class:WTF::HashCountedSet	access:public	signature:() const
capacity	.\HashCountedSet.h	/^    inline int HashCountedSet<Value, HashFunctions, Traits>::capacity() const$/;"	f	class:WTF::HashCountedSet	signature:() const
capacity	.\HashMap.h	/^        int capacity() const;$/;"	p	class:WTF::HashMap	access:public	signature:() const
capacity	.\HashMap.h	/^    inline int HashMap<T, U, V, W, X>::capacity() const$/;"	f	class:WTF::HashMap	signature:() const
capacity	.\HashSet.h	/^        int capacity() const;$/;"	p	class:WTF::HashSet	access:public	signature:() const
capacity	.\HashSet.h	/^    inline int HashSet<T, U, V>::capacity() const$/;"	f	class:WTF::HashSet	signature:() const
capacity	.\HashTable.h	/^        int capacity() const { return m_tableSize; }$/;"	f	class:WTF::HashTable	access:public	signature:() const
capacity	.\ListHashSet.h	/^        int capacity() const;$/;"	p	class:WTF::ListHashSet	access:public	signature:() const
capacity	.\ListHashSet.h	/^    inline int ListHashSet<T, inlineCapacity, U>::capacity() const$/;"	f	class:WTF::ListHashSet	signature:() const
capacity	.\RefPtrHashMap.h	/^        int capacity() const;$/;"	p	class:WTF::HashMap	access:public	signature:() const
capacity	.\RefPtrHashMap.h	/^    inline int HashMap<RefPtr<T>, U, V, W, X>::capacity() const$/;"	f	class:WTF::HashMap	signature:() const
capacity	.\Vector.h	/^        size_t capacity() const { return m_buffer.capacity(); }$/;"	f	class:WTF::Vector	access:public	signature:() const
capacity	.\Vector.h	/^        size_t capacity() const { return m_capacity; }$/;"	f	class:WTF::VectorBufferBase	access:public	signature:() const
capacity	.\text\StringBuilder.h	/^    unsigned capacity() const$/;"	f	class:WTF::StringBuilder	access:public	signature:() const
capacity	.\url\src\URLBuffer.h	/^    int capacity() const { return m_capacity; }$/;"	f	class:WTF::URLBuffer	access:public	signature:() const
carriageReturn	.\unicode\CharacterNames.h	/^const UChar carriageReturn = 0x000D;$/;"	v
caseFoldDiff	.\unicode\qt4\UnicodeQt4.h	/^        signed short caseFoldDiff : 16;$/;"	m	struct:QUnicodeTables::Properties	access:public
caseFoldSpecial	.\unicode\qt4\UnicodeQt4.h	/^        ushort caseFoldSpecial : 1; \/* currently unused *\/$/;"	m	struct:QUnicodeTables::Properties	access:public
category	.\unicode\glib\UnicodeGLib.h	/^inline CharCategory category(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
category	.\unicode\icu\UnicodeIcu.h	/^inline CharCategory category(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
category	.\unicode\qt4\UnicodeQt4.h	/^        ushort category : 8;$/;"	m	struct:QUnicodeTables::Properties	access:public
category	.\unicode\qt4\UnicodeQt4.h	/^inline CharCategory category(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
category	.\unicode\wince\UnicodeWinCE.cpp	/^CharCategory category(unsigned int c)$/;"	f	namespace:WTF::Unicode	signature:(unsigned int c)
category	.\unicode\wince\UnicodeWinCE.h	/^CharCategory category(unsigned int);$/;"	p	namespace:WTF::Unicode	signature:(unsigned int)
ceil	.\MathExtras.h	89;"	d
central_bytes	.\FastMalloc.cpp	/^  uint64_t central_bytes;       \/\/ Bytes in central cache$/;"	m	struct:WTF::TCMallocStats	file:	access:public
central_cache	.\FastMalloc.cpp	/^static TCMalloc_Central_FreeListPadded central_cache[kNumClasses];$/;"	v	file:
cfree	.\FastMalloc.cpp	/^void cfree(void* ptr) {$/;"	f	namespace:WTF	signature:(void* ptr)
characterStartingAt	.\text\StringImpl.cpp	/^UChar32 StringImpl::characterStartingAt(unsigned i)$/;"	f	class:WTF::StringImpl	signature:(unsigned i)
characterStartingAt	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE UChar32 characterStartingAt(unsigned);$/;"	p	class:WTF::StringImpl	access:public	signature:(unsigned)
characterStartingAt	.\text\WTFString.cpp	/^UChar32 String::characterStartingAt(unsigned i) const$/;"	f	class:WTF::String	signature:(unsigned i) const
characterStartingAt	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE UChar32 characterStartingAt(unsigned) const; \/\/ Ditto.$/;"	p	class:WTF::String	access:public	signature:(unsigned) const
characterTypeTable	.\url\src\URLCharacterTypes.cpp	/^const unsigned char URLCharacterTypes::characterTypeTable[0x100] = {$/;"	m	class:WTF::URLCharacterTypes	file:
characterTypeTable	.\url\src\URLCharacterTypes.h	/^    static const unsigned char characterTypeTable[0x100];$/;"	m	class:WTF::URLCharacterTypes	access:private
characters	.\text\AtomicString.cpp	/^    const UChar* characters;$/;"	m	struct:WTF::HashAndCharacters	file:	access:public
characters	.\text\AtomicString.cpp	/^    const char* characters;$/;"	m	struct:WTF::HashAndUTF8Characters	file:	access:public
characters	.\text\AtomicString.h	/^    const UChar* characters() const { return m_string.characters(); }$/;"	f	class:WTF::AtomicString	access:public	signature:() const
characters	.\text\StringBuffer.h	/^    CharType* characters() { return m_data; }$/;"	f	class:WTF::StringBuffer	access:public	signature:()
characters	.\text\StringBuilder.h	/^    const UChar* characters() const$/;"	f	class:WTF::StringBuilder	access:public	signature:() const
characters	.\text\StringImpl.h	/^    ALWAYS_INLINE const UChar* characters() const$/;"	f	class:WTF::StringImpl	access:public	signature:() const
characters	.\text\WTFString.h	/^    const UChar* characters() const$/;"	f	class:WTF::String	access:public	signature:() const
characters16	.\text\StringBuilder.h	/^    const UChar* characters16() const$/;"	f	class:WTF::StringBuilder	access:public	signature:() const
characters16	.\text\StringImpl.h	/^    ALWAYS_INLINE const UChar* characters16() const { ASSERT(!is8Bit()); return m_data16; }$/;"	f	class:WTF::StringImpl	access:public	signature:() const
characters16	.\text\WTFString.h	/^    const UChar* characters16() const$/;"	f	class:WTF::String	access:public	signature:() const
characters8	.\text\StringBuilder.h	/^    const LChar* characters8() const$/;"	f	class:WTF::StringBuilder	access:public	signature:() const
characters8	.\text\StringImpl.h	/^    ALWAYS_INLINE const LChar* characters8() const { ASSERT(is8Bit()); return m_data8; }$/;"	f	class:WTF::StringImpl	access:public	signature:() const
characters8	.\text\WTFString.h	/^    const LChar* characters8() const$/;"	f	class:WTF::String	access:public	signature:() const
charactersAreAllASCII	.\text\ASCIIFastPath.h	/^inline bool charactersAreAllASCII(const CharacterType* characters, size_t length)$/;"	f	namespace:WTF	signature:(const CharacterType* characters, size_t length)
charactersBefore	.\url\src\URLSegments.cpp	/^int URLSegments::charactersBefore(ComponentType type, bool includeDelimiter) const$/;"	f	class:WTF::URLSegments	signature:(ComponentType type, bool includeDelimiter) const
charactersBefore	.\url\src\URLSegments.h	/^    int charactersBefore(ComponentType, bool includeDelimiter) const;$/;"	p	class:WTF::URLSegments	access:public	signature:(ComponentType, bool includeDelimiter) const
charactersToDouble	.\text\WTFString.cpp	/^double charactersToDouble(const LChar* data, size_t length, bool* ok, bool* didReadNumber)$/;"	f	namespace:WTF	signature:(const LChar* data, size_t length, bool* ok, bool* didReadNumber)
charactersToDouble	.\text\WTFString.cpp	/^double charactersToDouble(const UChar* data, size_t length, bool* ok, bool* didReadNumber)$/;"	f	namespace:WTF	signature:(const UChar* data, size_t length, bool* ok, bool* didReadNumber)
charactersToDouble	.\text\WTFString.h	/^WTF_EXPORT_PRIVATE double charactersToDouble(const LChar*, size_t, bool* ok = 0, bool* didReadNumber = 0);$/;"	p	namespace:WTF	signature:(const LChar*, size_t, bool* ok = 0, bool* didReadNumber = 0)
charactersToDouble	.\text\WTFString.h	/^WTF_EXPORT_PRIVATE double charactersToDouble(const UChar*, size_t, bool* ok = 0, bool* didReadNumber = 0);$/;"	p	namespace:WTF	signature:(const UChar*, size_t, bool* ok = 0, bool* didReadNumber = 0)
charactersToFloat	.\text\WTFString.cpp	/^float charactersToFloat(const LChar* data, size_t length, bool* ok, bool* didReadNumber)$/;"	f	namespace:WTF	signature:(const LChar* data, size_t length, bool* ok, bool* didReadNumber)
charactersToFloat	.\text\WTFString.cpp	/^float charactersToFloat(const UChar* data, size_t length, bool* ok, bool* didReadNumber)$/;"	f	namespace:WTF	signature:(const UChar* data, size_t length, bool* ok, bool* didReadNumber)
charactersToFloat	.\text\WTFString.h	/^WTF_EXPORT_PRIVATE float charactersToFloat(const UChar*, size_t, bool* ok = 0, bool* didReadNumber = 0);$/;"	p	namespace:WTF	signature:(const UChar*, size_t, bool* ok = 0, bool* didReadNumber = 0)
charactersToFloat	.\text\WTFString.h	/^float charactersToFloat(const LChar*, size_t, bool* ok = 0, bool* didReadNumber = 0);$/;"	p	namespace:WTF	signature:(const LChar*, size_t, bool* ok = 0, bool* didReadNumber = 0)
charactersToFloatIgnoringJunk	.\text\WTFString.cpp	/^float charactersToFloatIgnoringJunk(const LChar* data, size_t length, bool* ok, bool* didReadNumber)$/;"	f	namespace:WTF	signature:(const LChar* data, size_t length, bool* ok, bool* didReadNumber)
charactersToFloatIgnoringJunk	.\text\WTFString.cpp	/^float charactersToFloatIgnoringJunk(const UChar* data, size_t length, bool* ok, bool* didReadNumber)$/;"	f	namespace:WTF	signature:(const UChar* data, size_t length, bool* ok, bool* didReadNumber)
charactersToFloatIgnoringJunk	.\text\WTFString.h	/^WTF_EXPORT_PRIVATE float charactersToFloatIgnoringJunk(const LChar*, size_t, bool* ok = 0, bool* didReadNumber = 0);$/;"	p	namespace:WTF	signature:(const LChar*, size_t, bool* ok = 0, bool* didReadNumber = 0)
charactersToFloatIgnoringJunk	.\text\WTFString.h	/^WTF_EXPORT_PRIVATE float charactersToFloatIgnoringJunk(const UChar*, size_t, bool* ok = 0, bool* didReadNumber = 0);$/;"	p	namespace:WTF	signature:(const UChar*, size_t, bool* ok = 0, bool* didReadNumber = 0)
charactersToInt	.\text\WTFString.cpp	/^int charactersToInt(const LChar* data, size_t length, bool* ok)$/;"	f	namespace:WTF	signature:(const LChar* data, size_t length, bool* ok)
charactersToInt	.\text\WTFString.cpp	/^int charactersToInt(const UChar* data, size_t length, bool* ok)$/;"	f	namespace:WTF	signature:(const UChar* data, size_t length, bool* ok)
charactersToInt	.\text\WTFString.h	/^WTF_EXPORT_PRIVATE int charactersToInt(const UChar*, size_t, bool* ok = 0); \/\/ ignores trailing garbage$/;"	p	namespace:WTF	signature:(const UChar*, size_t, bool* ok = 0)
charactersToInt	.\text\WTFString.h	/^int charactersToInt(const LChar*, size_t, bool* ok = 0); \/\/ ignores trailing garbage$/;"	p	namespace:WTF	signature:(const LChar*, size_t, bool* ok = 0)
charactersToInt64	.\text\WTFString.cpp	/^int64_t charactersToInt64(const LChar* data, size_t length, bool* ok)$/;"	f	namespace:WTF	signature:(const LChar* data, size_t length, bool* ok)
charactersToInt64	.\text\WTFString.cpp	/^int64_t charactersToInt64(const UChar* data, size_t length, bool* ok)$/;"	f	namespace:WTF	signature:(const UChar* data, size_t length, bool* ok)
charactersToInt64	.\text\WTFString.h	/^int64_t charactersToInt64(const LChar*, size_t, bool* ok = 0); \/\/ ignores trailing garbage$/;"	p	namespace:WTF	signature:(const LChar*, size_t, bool* ok = 0)
charactersToInt64	.\text\WTFString.h	/^int64_t charactersToInt64(const UChar*, size_t, bool* ok = 0); \/\/ ignores trailing garbage$/;"	p	namespace:WTF	signature:(const UChar*, size_t, bool* ok = 0)
charactersToInt64Strict	.\text\WTFString.cpp	/^int64_t charactersToInt64Strict(const LChar* data, size_t length, bool* ok, int base)$/;"	f	namespace:WTF	signature:(const LChar* data, size_t length, bool* ok, int base)
charactersToInt64Strict	.\text\WTFString.cpp	/^int64_t charactersToInt64Strict(const UChar* data, size_t length, bool* ok, int base)$/;"	f	namespace:WTF	signature:(const UChar* data, size_t length, bool* ok, int base)
charactersToInt64Strict	.\text\WTFString.h	/^int64_t charactersToInt64Strict(const LChar*, size_t, bool* ok = 0, int base = 10);$/;"	p	namespace:WTF	signature:(const LChar*, size_t, bool* ok = 0, int base = 10)
charactersToInt64Strict	.\text\WTFString.h	/^int64_t charactersToInt64Strict(const UChar*, size_t, bool* ok = 0, int base = 10);$/;"	p	namespace:WTF	signature:(const UChar*, size_t, bool* ok = 0, int base = 10)
charactersToIntPtr	.\text\WTFString.cpp	/^intptr_t charactersToIntPtr(const LChar* data, size_t length, bool* ok)$/;"	f	namespace:WTF	signature:(const LChar* data, size_t length, bool* ok)
charactersToIntPtr	.\text\WTFString.cpp	/^intptr_t charactersToIntPtr(const UChar* data, size_t length, bool* ok)$/;"	f	namespace:WTF	signature:(const UChar* data, size_t length, bool* ok)
charactersToIntPtr	.\text\WTFString.h	/^intptr_t charactersToIntPtr(const LChar*, size_t, bool* ok = 0); \/\/ ignores trailing garbage$/;"	p	namespace:WTF	signature:(const LChar*, size_t, bool* ok = 0)
charactersToIntPtr	.\text\WTFString.h	/^intptr_t charactersToIntPtr(const UChar*, size_t, bool* ok = 0); \/\/ ignores trailing garbage$/;"	p	namespace:WTF	signature:(const UChar*, size_t, bool* ok = 0)
charactersToIntPtrStrict	.\text\WTFString.cpp	/^intptr_t charactersToIntPtrStrict(const LChar* data, size_t length, bool* ok, int base)$/;"	f	namespace:WTF	signature:(const LChar* data, size_t length, bool* ok, int base)
charactersToIntPtrStrict	.\text\WTFString.cpp	/^intptr_t charactersToIntPtrStrict(const UChar* data, size_t length, bool* ok, int base)$/;"	f	namespace:WTF	signature:(const UChar* data, size_t length, bool* ok, int base)
charactersToIntPtrStrict	.\text\WTFString.h	/^intptr_t charactersToIntPtrStrict(const LChar*, size_t, bool* ok = 0, int base = 10);$/;"	p	namespace:WTF	signature:(const LChar*, size_t, bool* ok = 0, int base = 10)
charactersToIntPtrStrict	.\text\WTFString.h	/^intptr_t charactersToIntPtrStrict(const UChar*, size_t, bool* ok = 0, int base = 10);$/;"	p	namespace:WTF	signature:(const UChar*, size_t, bool* ok = 0, int base = 10)
charactersToIntStrict	.\text\WTFString.cpp	/^int charactersToIntStrict(const LChar* data, size_t length, bool* ok, int base)$/;"	f	namespace:WTF	signature:(const LChar* data, size_t length, bool* ok, int base)
charactersToIntStrict	.\text\WTFString.cpp	/^int charactersToIntStrict(const UChar* data, size_t length, bool* ok, int base)$/;"	f	namespace:WTF	signature:(const UChar* data, size_t length, bool* ok, int base)
charactersToIntStrict	.\text\WTFString.h	/^WTF_EXPORT_PRIVATE int charactersToIntStrict(const UChar*, size_t, bool* ok = 0, int base = 10);$/;"	p	namespace:WTF	signature:(const UChar*, size_t, bool* ok = 0, int base = 10)
charactersToIntStrict	.\text\WTFString.h	/^int charactersToIntStrict(const LChar*, size_t, bool* ok = 0, int base = 10);$/;"	p	namespace:WTF	signature:(const LChar*, size_t, bool* ok = 0, int base = 10)
charactersToUInt	.\text\WTFString.cpp	/^unsigned charactersToUInt(const LChar* data, size_t length, bool* ok)$/;"	f	namespace:WTF	signature:(const LChar* data, size_t length, bool* ok)
charactersToUInt	.\text\WTFString.cpp	/^unsigned charactersToUInt(const UChar* data, size_t length, bool* ok)$/;"	f	namespace:WTF	signature:(const UChar* data, size_t length, bool* ok)
charactersToUInt	.\text\WTFString.h	/^unsigned charactersToUInt(const LChar*, size_t, bool* ok = 0); \/\/ ignores trailing garbage$/;"	p	namespace:WTF	signature:(const LChar*, size_t, bool* ok = 0)
charactersToUInt	.\text\WTFString.h	/^unsigned charactersToUInt(const UChar*, size_t, bool* ok = 0); \/\/ ignores trailing garbage$/;"	p	namespace:WTF	signature:(const UChar*, size_t, bool* ok = 0)
charactersToUInt64	.\text\WTFString.cpp	/^uint64_t charactersToUInt64(const LChar* data, size_t length, bool* ok)$/;"	f	namespace:WTF	signature:(const LChar* data, size_t length, bool* ok)
charactersToUInt64	.\text\WTFString.cpp	/^uint64_t charactersToUInt64(const UChar* data, size_t length, bool* ok)$/;"	f	namespace:WTF	signature:(const UChar* data, size_t length, bool* ok)
charactersToUInt64	.\text\WTFString.h	/^uint64_t charactersToUInt64(const LChar*, size_t, bool* ok = 0); \/\/ ignores trailing garbage$/;"	p	namespace:WTF	signature:(const LChar*, size_t, bool* ok = 0)
charactersToUInt64	.\text\WTFString.h	/^uint64_t charactersToUInt64(const UChar*, size_t, bool* ok = 0); \/\/ ignores trailing garbage$/;"	p	namespace:WTF	signature:(const UChar*, size_t, bool* ok = 0)
charactersToUInt64Strict	.\text\WTFString.cpp	/^uint64_t charactersToUInt64Strict(const LChar* data, size_t length, bool* ok, int base)$/;"	f	namespace:WTF	signature:(const LChar* data, size_t length, bool* ok, int base)
charactersToUInt64Strict	.\text\WTFString.cpp	/^uint64_t charactersToUInt64Strict(const UChar* data, size_t length, bool* ok, int base)$/;"	f	namespace:WTF	signature:(const UChar* data, size_t length, bool* ok, int base)
charactersToUInt64Strict	.\text\WTFString.h	/^uint64_t charactersToUInt64Strict(const LChar*, size_t, bool* ok = 0, int base = 10);$/;"	p	namespace:WTF	signature:(const LChar*, size_t, bool* ok = 0, int base = 10)
charactersToUInt64Strict	.\text\WTFString.h	/^uint64_t charactersToUInt64Strict(const UChar*, size_t, bool* ok = 0, int base = 10);$/;"	p	namespace:WTF	signature:(const UChar*, size_t, bool* ok = 0, int base = 10)
charactersToUIntStrict	.\text\WTFString.cpp	/^unsigned charactersToUIntStrict(const LChar* data, size_t length, bool* ok, int base)$/;"	f	namespace:WTF	signature:(const LChar* data, size_t length, bool* ok, int base)
charactersToUIntStrict	.\text\WTFString.cpp	/^unsigned charactersToUIntStrict(const UChar* data, size_t length, bool* ok, int base)$/;"	f	namespace:WTF	signature:(const UChar* data, size_t length, bool* ok, int base)
charactersToUIntStrict	.\text\WTFString.h	/^WTF_EXPORT_PRIVATE unsigned charactersToUIntStrict(const UChar*, size_t, bool* ok = 0, int base = 10);$/;"	p	namespace:WTF	signature:(const UChar*, size_t, bool* ok = 0, int base = 10)
charactersToUIntStrict	.\text\WTFString.h	/^unsigned charactersToUIntStrict(const LChar*, size_t, bool* ok = 0, int base = 10);$/;"	p	namespace:WTF	signature:(const LChar*, size_t, bool* ok = 0, int base = 10)
charactersWithNullTermination	.\text\WTFString.cpp	/^const UChar* String::charactersWithNullTermination()$/;"	f	class:WTF::String	signature:()
charactersWithNullTermination	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE const UChar* charactersWithNullTermination();$/;"	p	class:WTF::String	access:public	signature:()
check	.\FastMalloc.cpp	/^    static boolean_t check(malloc_zone_t*) { return true; }$/;"	f	class:WTF::FastMallocZone	access:public	signature:(malloc_zone_t*)
checkConsistency	.\HashMap.h	/^        void checkConsistency() const;$/;"	p	class:WTF::HashMap	access:public	signature:() const
checkConsistency	.\HashMap.h	/^    inline void HashMap<T, U, V, W, X>::checkConsistency() const$/;"	f	class:WTF::HashMap	signature:() const
checkConsistency	.\StackBounds.h	/^    void checkConsistency() const$/;"	f	class:WTF::StackBounds	access:private	signature:() const
checkConsistency	.\ValueCheck.h	/^    static void checkConsistency(const P* p)$/;"	f	struct:WTF::ValueCheck	access:public	signature:(const P* p)
checkConsistency	.\ValueCheck.h	/^    static void checkConsistency(const T&) { }$/;"	f	struct:WTF::ValueCheck	access:public	signature:(const T&)
checkConsistency	.\Vector.h	/^        static void checkConsistency(const Vector<T>& v)$/;"	f	struct:WTF::ValueCheck	access:public	signature:(const Vector<T>& v)
checkConsistency	.\Vector.h	/^        void checkConsistency();$/;"	p	class:WTF::Vector	access:public	signature:()
checkConsistency	.\Vector.h	/^    inline void Vector<T, inlineCapacity>::checkConsistency()$/;"	f	class:WTF::Vector	signature:()
checkIndexValidity	.\Deque.h	/^        void checkIndexValidity(size_t) const;$/;"	p	class:WTF::Deque	access:private	signature:(size_t) const
checkIndexValidity	.\Deque.h	/^    template<typename T, size_t inlineCapacity> inline void Deque<T, inlineCapacity>::checkIndexValidity(size_t) const { }$/;"	f	class:WTF::Deque	signature:(size_t) const
checkIndexValidity	.\Deque.h	/^    void Deque<T, inlineCapacity>::checkIndexValidity(size_t index) const$/;"	f	class:WTF::Deque	signature:(size_t index) const
checkKey	.\HashTable.h	/^        template<typename HashTranslator, typename T> void checkKey(const T&);$/;"	p	class:WTF::HashTable	access:private	signature:(const T&)
checkKey	.\HashTable.h	/^    inline void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::checkKey(const T&)$/;"	f	class:WTF::HashTable	signature:(const T&)
checkKey	.\HashTable.h	/^    void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::checkKey(const T& key)$/;"	f	class:WTF::HashTable	signature:(const T& key)
checkMonth	.\DateMath.cpp	/^static inline bool checkMonth(int dayInYear, int& startDayOfThisMonth, int& startDayOfNextMonth, int daysInThisMonth)$/;"	f	namespace:WTF	file:	signature:(int dayInYear, int& startDayOfThisMonth, int& startDayOfNextMonth, int daysInThisMonth)
checkTableConsistency	.\HashTable.h	/^        static void checkTableConsistency() { }$/;"	f	class:WTF::HashTable	access:public	signature:()
checkTableConsistency	.\HashTable.h	/^        void checkTableConsistency() const;$/;"	p	class:WTF::HashTable	access:public	signature:() const
checkTableConsistency	.\HashTable.h	/^    void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::checkTableConsistency() const$/;"	f	class:WTF::HashTable	signature:() const
checkTableConsistencyExceptSize	.\HashTable.h	/^        static void checkTableConsistencyExceptSize() { }$/;"	f	class:WTF::HashTable	access:private	signature:()
checkTableConsistencyExceptSize	.\HashTable.h	/^        void checkTableConsistencyExceptSize() const;$/;"	p	class:WTF::HashTable	access:private	signature:() const
checkTableConsistencyExceptSize	.\HashTable.h	/^    void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::checkTableConsistencyExceptSize() const$/;"	f	class:WTF::HashTable	signature:() const
checkValidity	.\Deque.h	/^        void checkValidity() const;$/;"	p	class:WTF::Deque	access:private	signature:() const
checkValidity	.\Deque.h	/^        void checkValidity() const;$/;"	p	class:WTF::DequeIteratorBase	access:private	signature:() const
checkValidity	.\Deque.h	/^        void checkValidity(const Base&) const;$/;"	p	class:WTF::DequeIteratorBase	access:private	signature:(const Base&) const
checkValidity	.\Deque.h	/^    template<typename T, size_t inlineCapacity> inline void Deque<T, inlineCapacity>::checkValidity() const { }$/;"	f	class:WTF::Deque	signature:() const
checkValidity	.\Deque.h	/^    template<typename T, size_t inlineCapacity> inline void DequeIteratorBase<T, inlineCapacity>::checkValidity() const { }$/;"	f	class:WTF::DequeIteratorBase	signature:() const
checkValidity	.\Deque.h	/^    template<typename T, size_t inlineCapacity> inline void DequeIteratorBase<T, inlineCapacity>::checkValidity(const DequeIteratorBase<T, inlineCapacity>&) const { }$/;"	f	class:WTF::DequeIteratorBase	signature:(const DequeIteratorBase<T, inlineCapacity>&) const
checkValidity	.\Deque.h	/^    void Deque<T, inlineCapacity>::checkValidity() const$/;"	f	class:WTF::Deque	signature:() const
checkValidity	.\Deque.h	/^    void DequeIteratorBase<T, inlineCapacity>::checkValidity() const$/;"	f	class:WTF::DequeIteratorBase	signature:() const
checkValidity	.\Deque.h	/^    void DequeIteratorBase<T, inlineCapacity>::checkValidity(const Base& other) const$/;"	f	class:WTF::DequeIteratorBase	signature:(const Base& other) const
checkValidity	.\HashTable.h	/^        void checkValidity() const$/;"	f	class:WTF::HashTableConstIterator	access:private	signature:() const
checkValidity	.\HashTable.h	/^        void checkValidity(const const_iterator& other) const$/;"	f	class:WTF::HashTableConstIterator	access:private	signature:(const const_iterator& other) const
checkValidity	.\HashTable.h	/^        void checkValidity(const const_iterator&) const { }$/;"	f	class:WTF::HashTableConstIterator	access:private	signature:(const const_iterator&) const
checksum	.\MD5.cpp	/^void MD5::checksum(Vector<uint8_t, 16>& digest)$/;"	f	class:WTF::MD5	signature:(Vector<uint8_t, 16>& digest)
checksum	.\MD5.h	/^    WTF_EXPORT_PRIVATE void checksum(Vector<uint8_t, 16>&);$/;"	p	class:WTF::MD5	access:public	signature:(Vector<uint8_t, 16>&)
clampIndex	.\ArrayBuffer.h	/^    inline unsigned clampIndex(int index) const;$/;"	p	class:WTF::ArrayBuffer	access:private	signature:(int index) const
clampIndex	.\ArrayBuffer.h	/^unsigned ArrayBuffer::clampIndex(int index) const$/;"	f	class:WTF::ArrayBuffer	signature:(int index) const
clampOffsetAndNumElements	.\ArrayBufferView.h	/^    static void clampOffsetAndNumElements(PassRefPtr<ArrayBuffer> buffer,$/;"	f	class:WTF::ArrayBufferView	access:protected	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned arrayByteOffset, unsigned *offset, unsigned *numElements)
clampTo	.\MathExtras.h	/^template<> inline long long int clampTo(double, long long int, long long int); \/\/ clampTo does not support long long ints.$/;"	p	signature:(double, long long int, long long int)
clampTo	.\MathExtras.h	/^template<typename T> inline T clampTo(double value, T min = defaultMinimumForClamp<T>(), T max = defaultMaximumForClamp<T>())$/;"	f	signature:(double value, T min = defaultMinimumForClamp<T>(), T max = defaultMaximumForClamp<T>())
clampToFloat	.\MathExtras.h	/^inline float clampToFloat(double value)$/;"	f	signature:(double value)
clampToInteger	.\MathExtras.h	/^inline int clampToInteger(double value)$/;"	f	signature:(double value)
clampToInteger	.\MathExtras.h	/^inline int clampToInteger(float value)$/;"	f	signature:(float value)
clampToInteger	.\MathExtras.h	/^inline int clampToInteger(unsigned x)$/;"	f	signature:(unsigned x)
clampToPositiveInteger	.\MathExtras.h	/^inline int clampToPositiveInteger(double value)$/;"	f	signature:(double value)
clampValue	.\ArrayBuffer.h	/^    static inline int clampValue(int x, int left, int right);$/;"	p	class:WTF::ArrayBuffer	access:private	signature:(int x, int left, int right)
clampValue	.\ArrayBuffer.h	/^int ArrayBuffer::clampValue(int x, int left, int right)$/;"	f	class:WTF::ArrayBuffer	signature:(int x, int left, int right)
class_array	.\FastMalloc.cpp	/^static unsigned char class_array[377];$/;"	v	file:
class_to_pages	.\FastMalloc.cpp	/^static size_t class_to_pages[kNumClasses];$/;"	v	file:
class_to_size	.\FastMalloc.cpp	/^static size_t class_to_size[kNumClasses];$/;"	v	file:
clear	.\BitVector.h	/^    void clear(size_t bit)$/;"	f	class:WTF::BitVector	access:public	signature:(size_t bit)
clear	.\Bitmap.h	/^    void clear(size_t);$/;"	p	class:WTF::Bitmap	access:public	signature:(size_t)
clear	.\Bitmap.h	/^inline void Bitmap<size, atomicMode>::clear(size_t n)$/;"	f	class:WTF::Bitmap	signature:(size_t n)
clear	.\BloomFilter.h	/^    void clear();$/;"	p	class:WTF::BloomFilter	access:public	signature:()
clear	.\BloomFilter.h	/^inline void BloomFilter<keyBits>::clear()$/;"	f	class:WTF::BloomFilter	signature:()
clear	.\ByteArray.h	/^        void clear() { memset(m_data, 0, m_size); }$/;"	f	class:WTF::ByteArray	access:public	signature:()
clear	.\Deque.h	/^        void clear();$/;"	p	class:WTF::Deque	access:public	signature:()
clear	.\Deque.h	/^    inline void Deque<T, inlineCapacity>::clear()$/;"	f	class:WTF::Deque	signature:()
clear	.\DoublyLinkedList.h	/^    void clear();$/;"	p	class:WTF::DoublyLinkedList	access:public	signature:()
clear	.\DoublyLinkedList.h	/^template<typename T> inline void DoublyLinkedList<T>::clear()$/;"	f	class:WTF::DoublyLinkedList	signature:()
clear	.\HashCountedSet.h	/^        void clear();$/;"	p	class:WTF::HashCountedSet	access:public	signature:()
clear	.\HashCountedSet.h	/^    inline void HashCountedSet<Value, HashFunctions, Traits>::clear()$/;"	f	class:WTF::HashCountedSet	signature:()
clear	.\HashMap.h	/^        void clear();$/;"	p	class:WTF::HashMap	access:public	signature:()
clear	.\HashMap.h	/^    inline void HashMap<T, U, V, W, X>::clear()$/;"	f	class:WTF::HashMap	signature:()
clear	.\HashSet.h	/^        void clear();$/;"	p	class:WTF::HashSet	access:public	signature:()
clear	.\HashSet.h	/^    inline void HashSet<T, U, V>::clear()$/;"	f	class:WTF::HashSet	signature:()
clear	.\HashTable.h	/^        void clear();$/;"	p	class:WTF::HashTable	access:public	signature:()
clear	.\HashTable.h	/^    void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::clear()$/;"	f	class:WTF::HashTable	signature:()
clear	.\ListHashSet.h	/^        void clear();$/;"	p	class:WTF::ListHashSet	access:public	signature:()
clear	.\ListHashSet.h	/^    inline void ListHashSet<T, inlineCapacity, U>::clear()$/;"	f	class:WTF::ListHashSet	signature:()
clear	.\OwnArrayPtr.h	/^    void clear();$/;"	p	class:WTF::OwnArrayPtr	access:public	signature:()
clear	.\OwnArrayPtr.h	/^template<typename T> inline void OwnArrayPtr<T>::clear()$/;"	f	class:WTF::OwnArrayPtr	signature:()
clear	.\OwnPtr.h	/^        void clear();$/;"	p	class:WTF::OwnPtr	access:public	signature:()
clear	.\OwnPtr.h	/^    template<typename T> inline void OwnPtr<T>::clear()$/;"	f	class:WTF::OwnPtr	signature:()
clear	.\RefPtr.h	/^        void clear();$/;"	p	class:WTF::RefPtr	access:public	signature:()
clear	.\RefPtr.h	/^    template<typename T> inline void RefPtr<T>::clear()$/;"	f	class:WTF::RefPtr	signature:()
clear	.\RefPtrHashMap.h	/^        void clear();$/;"	p	class:WTF::HashMap	access:public	signature:()
clear	.\RefPtrHashMap.h	/^    inline void HashMap<RefPtr<T>, U, V, W, X>::clear()$/;"	f	class:WTF::HashMap	signature:()
clear	.\RetainPtr.h	/^        void clear();$/;"	p	class:WTF::RetainPtr	access:public	signature:()
clear	.\RetainPtr.h	/^    template<typename T> inline void RetainPtr<T>::clear()$/;"	f	class:WTF::RetainPtr	signature:()
clear	.\SegmentedVector.h	/^        void clear()$/;"	f	class:WTF::SegmentedVector	access:public	signature:()
clear	.\Vector.h	/^        void clear() { shrinkCapacity(0); }$/;"	f	class:WTF::Vector	access:public	signature:()
clear	.\dtoa.cpp	/^    void clear()$/;"	f	struct:WTF::BigInt	access:public	signature:()
clear	.\gobject\GOwnPtr.h	/^    void clear()$/;"	f	class:WTF::GOwnPtr	access:public	signature:()
clear	.\gobject\GRefPtr.h	/^    void clear()$/;"	f	class:WTF::GRefPtr	access:public	signature:()
clear	.\text\StringBuilder.h	/^    void clear()$/;"	f	class:WTF::StringBuilder	access:public	signature:()
clearAll	.\BitVector.cpp	/^void BitVector::clearAll()$/;"	f	class:WTF::BitVector	signature:()
clearAll	.\BitVector.h	/^    void clearAll();$/;"	p	class:WTF::BitVector	access:public	signature:()
clearAll	.\Bitmap.h	/^    void clearAll();$/;"	p	class:WTF::Bitmap	access:public	signature:()
clearAll	.\Bitmap.h	/^inline void Bitmap<size, atomicMode>::clearAll()$/;"	f	class:WTF::Bitmap	signature:()
clearAll	.\PackedIntVector.h	/^    void clearAll()$/;"	f	class:WTF::PackedIntVector	access:public	signature:()
clearOverflow	.\CheckedArithmetic.h	/^    void clearOverflow() { }$/;"	f	class:WTF::CrashOnOverflow	access:protected	signature:()
clearOverflow	.\CheckedArithmetic.h	/^    void clearOverflow()$/;"	f	class:WTF::RecordOverflow	access:protected	signature:()
clearPthreadHandleForIdentifier	.\ThreadIdentifierDataPthreads.cpp	/^void clearPthreadHandleForIdentifier(ThreadIdentifier);$/;"	p	namespace:WTF	file:	signature:(ThreadIdentifier)
clearPthreadHandleForIdentifier	.\ThreadingPthreads.cpp	/^void clearPthreadHandleForIdentifier(ThreadIdentifier id)$/;"	f	namespace:WTF	signature:(ThreadIdentifier id)
clearPthreadHandleForIdentifier	.\ThreadingPthreads.cpp	/^void clearPthreadHandleForIdentifier(ThreadIdentifier);$/;"	p	namespace:WTF	file:	signature:(ThreadIdentifier)
clearThreadHandleForIdentifier	.\ThreadingWin.cpp	/^static void clearThreadHandleForIdentifier(ThreadIdentifier id)$/;"	f	namespace:WTF	file:	signature:(ThreadIdentifier id)
clear_lowwatermark	.\FastMalloc.cpp	/^  void clear_lowwatermark() { lowater_ = length_; }$/;"	f	class:WTF::TCMalloc_ThreadCache_FreeList	access:public	signature:()
cmp	.\dtoa.cpp	/^static int cmp(const BigInt& a, const BigInt& b)$/;"	f	namespace:WTF	file:	signature:(const BigInt& a, const BigInt& b)
cmp_k_n	.\AVLTree.h	/^        int cmp_k_n(key k, handle h) { return tree_->abs.compare_key_node(k, h); }$/;"	f	class:WTF::AVLTree::Iterator	access:protected	signature:(key k, handle h)
cmp_k_n	.\AVLTree.h	/^    int cmp_k_n(key k, handle h) { return abs.compare_key_node(k, h); }$/;"	f	class:WTF::AVLTree	access:protected	signature:(key k, handle h)
cmp_n_n	.\AVLTree.h	/^        int cmp_n_n(handle h1, handle h2) { return tree_->abs.compare_node_node(h1, h2); }$/;"	f	class:WTF::AVLTree::Iterator	access:protected	signature:(handle h1, handle h2)
cmp_n_n	.\AVLTree.h	/^    int cmp_n_n(handle h1, handle h2) { return abs.compare_node_node(h1, h2); }$/;"	f	class:WTF::AVLTree	access:protected	signature:(handle h1, handle h2)
codePointCompare	.\text\StringImpl.h	/^static inline int codePointCompare(const StringImpl* string1, const StringImpl* string2)$/;"	f	namespace:WTF	signature:(const StringImpl* string1, const StringImpl* string2)
codePointCompare	.\text\StringImpl.h	/^static inline int codePointCompare(unsigned l1, unsigned l2, const CharacterType1* c1, const CharacterType2* c2)$/;"	f	namespace:WTF	signature:(unsigned l1, unsigned l2, const CharacterType1* c1, const CharacterType2* c2)
codePointCompare	.\text\WTFString.cpp	/^int codePointCompare(const String& a, const String& b)$/;"	f	namespace:WTF	signature:(const String& a, const String& b)
codePointCompare	.\text\WTFString.h	/^WTF_EXPORT_PRIVATE int codePointCompare(const String&, const String&);$/;"	p	namespace:WTF	signature:(const String&, const String&)
codePointCompare16	.\text\StringImpl.h	/^static inline int codePointCompare16(const StringImpl* string1, const StringImpl* string2)$/;"	f	namespace:WTF	signature:(const StringImpl* string1, const StringImpl* string2)
codePointCompare8	.\text\StringImpl.h	/^static inline int codePointCompare8(const StringImpl* string1, const StringImpl* string2)$/;"	f	namespace:WTF	signature:(const StringImpl* string1, const StringImpl* string2)
codePointCompare8To16	.\text\StringImpl.h	/^static inline int codePointCompare8To16(const StringImpl* string1, const StringImpl* string2)$/;"	f	namespace:WTF	signature:(const StringImpl* string1, const StringImpl* string2)
codePointCompareLessThan	.\text\WTFString.h	/^inline bool codePointCompareLessThan(const String& a, const String& b)$/;"	f	namespace:WTF	signature:(const String& a, const String& b)
collate	.\unicode\Collator.h	/^        WTF_EXPORT_PRIVATE Result collate(const ::UChar*, size_t, const ::UChar*, size_t) const;$/;"	p	class:WTF::Collator	access:public	signature:(const ::UChar*, size_t, const ::UChar*, size_t) const
collate	.\unicode\CollatorDefault.cpp	/^Collator::Result Collator::collate(const UChar* lhs, size_t lhsLength, const UChar* rhs, size_t rhsLength) const$/;"	f	class:WTF::Collator	signature:(const UChar* lhs, size_t lhsLength, const UChar* rhs, size_t rhsLength) const
collate	.\unicode\icu\CollatorICU.cpp	/^Collator::Result Collator::collate(const UChar* lhs, size_t lhsLength, const UChar* rhs, size_t rhsLength) const$/;"	f	class:WTF::Collator	signature:(const UChar* lhs, size_t lhsLength, const UChar* rhs, size_t rhsLength) const
collisionGraph	.\HashTable.cpp	/^int HashTableStats::collisionGraph[4096];$/;"	m	class:WTF::HashTableStats	file:
collisionGraph	.\HashTable.h	/^        static int collisionGraph[4096];$/;"	m	struct:WTF::HashTableStats	access:public
color	.\RedBlackTree.h	/^        Color color() const$/;"	f	class:WTF::RedBlackTree::Node	access:private	signature:() const
combiningClass	.\unicode\glib\UnicodeGLib.h	/^inline uint8_t combiningClass(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
combiningClass	.\unicode\icu\UnicodeIcu.h	/^inline uint8_t combiningClass(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
combiningClass	.\unicode\qt4\UnicodeQt4.h	/^        ushort combiningClass :8;$/;"	m	struct:QUnicodeTables::Properties	access:public
combiningClass	.\unicode\qt4\UnicodeQt4.h	/^inline uint8_t combiningClass(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
combiningClass	.\unicode\wince\UnicodeWinCE.cpp	/^unsigned char combiningClass(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
combiningClass	.\unicode\wince\UnicodeWinCE.h	/^unsigned char combiningClass(UChar32);$/;"	p	namespace:WTF::Unicode	signature:(UChar32)
commit	.\OSAllocator.h	/^    static void commit(void*, size_t, bool writable, bool executable);$/;"	p	class:WTF::OSAllocator	access:public	signature:(void*, size_t, bool writable, bool executable)
commit	.\OSAllocatorPosix.cpp	/^void OSAllocator::commit(void* address, size_t bytes, bool writable, bool executable)$/;"	f	class:WTF::OSAllocator	signature:(void* address, size_t bytes, bool writable, bool executable)
commit	.\OSAllocatorWin.cpp	/^void OSAllocator::commit(void* address, size_t bytes, bool writable, bool executable)$/;"	f	class:WTF::OSAllocator	signature:(void* address, size_t bytes, bool writable, bool executable)
commit	.\PageReservation.h	/^    void commit(void* start, size_t size)$/;"	f	class:WTF::PageReservation	access:public	signature:(void* start, size_t size)
committed	.\PageReservation.h	/^    size_t committed()$/;"	f	class:WTF::PageReservation	access:public	signature:()
committedVMBytes	.\FastMalloc.h	/^        size_t committedVMBytes;$/;"	m	struct:WTF::FastMallocStatistics	access:public
compare	.\Vector.h	/^        static bool compare(const T* a, const T* b, size_t size)$/;"	f	struct:WTF::VectorComparer	access:public	signature:(const T* a, const T* b, size_t size)
compare	.\Vector.h	/^        static bool compare(const T* a, const T* b, size_t size)$/;"	f	struct:WTF::VectorTypeOperations	access:public	signature:(const T* a, const T* b, size_t size)
compatEntryPoint	.\Threading.cpp	/^static void compatEntryPoint(void* param)$/;"	f	namespace:WTF	file:	signature:(void* param)
complexFromMagnitudePhase	.\Complex.h	/^inline Complex complexFromMagnitudePhase(double magnitude, double phase)$/;"	f	namespace:WTF	signature:(double magnitude, double phase)
computeHash	.\SHA1.cpp	/^void SHA1::computeHash(Vector<uint8_t, 20>& digest)$/;"	f	class:WTF::SHA1	signature:(Vector<uint8_t, 20>& digest)
computeHash	.\SHA1.h	/^    WTF_EXPORT_PRIVATE void computeHash(Vector<uint8_t, 20>&);$/;"	p	class:WTF::SHA1	access:public	signature:(Vector<uint8_t, 20>&)
computeHash	.\StringHasher.h	/^    template<typename T, UChar Converter(T)> static inline unsigned computeHash(const T* data)$/;"	f	class:WTF::StringHasher	access:public	signature:(const T* data)
computeHash	.\StringHasher.h	/^    template<typename T, UChar Converter(T)> static inline unsigned computeHash(const T* data, unsigned length)$/;"	f	class:WTF::StringHasher	access:public	signature:(const T* data, unsigned length)
computeHash	.\StringHasher.h	/^    template<typename T> static inline unsigned computeHash(const T* data)$/;"	f	class:WTF::StringHasher	access:public	signature:(const T* data)
computeHash	.\StringHasher.h	/^    template<typename T> static inline unsigned computeHash(const T* data, unsigned length)$/;"	f	class:WTF::StringHasher	access:public	signature:(const T* data, unsigned length)
concurrentTestAndClear	.\Bitmap.h	/^    bool concurrentTestAndClear(size_t);$/;"	p	class:WTF::Bitmap	access:public	signature:(size_t)
concurrentTestAndClear	.\Bitmap.h	/^inline bool Bitmap<size, atomicMode>::concurrentTestAndClear(size_t n)$/;"	f	class:WTF::Bitmap	signature:(size_t n)
concurrentTestAndSet	.\Bitmap.h	/^    bool concurrentTestAndSet(size_t);$/;"	p	class:WTF::Bitmap	access:public	signature:(size_t)
concurrentTestAndSet	.\Bitmap.h	/^inline bool Bitmap<size, atomicMode>::concurrentTestAndSet(size_t n)$/;"	f	class:WTF::Bitmap	signature:(size_t n)
consecutiveSlashes	.\url\src\URLParser.h	/^    static inline int consecutiveSlashes(const CharacterType *string, int beginOffset, int stringLength)$/;"	f	class:WTF::URLParser	access:public	signature:(const CharacterType *string, int beginOffset, int stringLength)
const_iterator	.\Deque.h	/^        typedef DequeConstIterator<T, inlineCapacity> const_iterator;$/;"	t	class:WTF::Deque	access:public
const_iterator	.\HashCountedSet.h	/^        typedef typename ImplType::const_iterator const_iterator;$/;"	t	class:WTF::HashCountedSet	access:public
const_iterator	.\HashMap.h	/^            typedef typename HashMap::const_iterator::Keys const_iterator;$/;"	t	class:WTF::HashMap::HashMapKeysProxy	access:public
const_iterator	.\HashMap.h	/^            typedef typename HashMap::const_iterator::Values const_iterator;$/;"	t	class:WTF::HashMap::HashMapValuesProxy	access:public
const_iterator	.\HashMap.h	/^        typedef HashTableConstIteratorAdapter<HashTableType, ValueType> const_iterator;$/;"	t	class:WTF::HashMap	access:public
const_iterator	.\HashSet.h	/^        typedef HashTableConstIteratorAdapter<HashTableType, ValueType> const_iterator;$/;"	t	class:WTF::HashSet	access:public
const_iterator	.\HashTable.h	/^        typedef HashTableConstIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits> const_iterator;$/;"	t	class:WTF::HashTable	access:public
const_iterator	.\HashTable.h	/^        typedef HashTableConstIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits> const_iterator;$/;"	t	class:WTF::HashTableConstIterator	access:private
const_iterator	.\HashTable.h	/^        typedef HashTableConstIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits> const_iterator;$/;"	t	class:WTF::HashTableIterator	access:private
const_iterator	.\ListHashSet.h	/^        typedef ListHashSetConstIterator<ValueArg, inlineCapacity, HashArg> const_iterator;$/;"	t	class:WTF::ListHashSetConstIterator	access:private
const_iterator	.\ListHashSet.h	/^        typedef ListHashSetConstIterator<ValueArg, inlineCapacity, HashArg> const_iterator;$/;"	t	class:WTF::ListHashSetIterator	access:private
const_iterator	.\ListHashSet.h	/^        typedef ListHashSetConstIterator<ValueType, inlineCapacity, HashArg> const_iterator;$/;"	t	class:WTF::ListHashSet	access:public
const_iterator	.\RefPtrHashMap.h	/^        typedef HashTableConstIteratorAdapter<HashTableType, ValueType> const_iterator;$/;"	t	class:WTF::HashMap	access:public
const_iterator	.\Spectrum.h	/^    typedef typename HashMap<T, unsigned long>::const_iterator const_iterator;$/;"	t	class:WTF::Spectrum	access:public
const_iterator	.\Vector.h	/^            typedef typename Vector::const_reverse_iterator const_iterator;$/;"	t	class:WTF::Vector::VectorReverseProxy	access:public
const_iterator	.\Vector.h	/^        typedef const T* const_iterator;$/;"	t	class:WTF::Vector	access:public
const_pointer_cast	.\PassOwnArrayPtr.h	/^template<typename T, typename U> inline PassOwnArrayPtr<T> const_pointer_cast(const PassOwnArrayPtr<U>& p) $/;"	f	namespace:WTF	signature:(const PassOwnArrayPtr<U>& p)
const_pointer_cast	.\PassOwnPtr.h	/^    template<typename T, typename U> inline PassOwnPtr<T> const_pointer_cast(const PassOwnPtr<U>& p) $/;"	f	namespace:WTF	signature:(const PassOwnPtr<U>& p)
const_pointer_cast	.\PassRefPtr.h	/^    template<typename T, typename U> inline PassRefPtr<T> const_pointer_cast(const PassRefPtr<U>& p) $/;"	f	namespace:WTF	signature:(const PassRefPtr<U>& p)
const_pointer_cast	.\RefPtr.h	/^    template<typename T, typename U> inline RefPtr<T> const_pointer_cast(const RefPtr<U>& p)$/;"	f	namespace:WTF	signature:(const RefPtr<U>& p)
const_pointer_cast	.\gobject\GRefPtr.h	/^template <typename T, typename U> inline GRefPtr<T> const_pointer_cast(const GRefPtr<U>& p)$/;"	f	namespace:WTF	signature:(const GRefPtr<U>& p)
const_reverse_iterator	.\Deque.h	/^        typedef DequeConstReverseIterator<T, inlineCapacity> const_reverse_iterator;$/;"	t	class:WTF::Deque	access:public
const_reverse_iterator	.\ListHashSet.h	/^        typedef ListHashSetConstReverseIterator<ValueArg, inlineCapacity, HashArg> const_reverse_iterator;$/;"	t	class:WTF::ListHashSetConstReverseIterator	access:private
const_reverse_iterator	.\ListHashSet.h	/^        typedef ListHashSetConstReverseIterator<ValueArg, inlineCapacity, HashArg> const_reverse_iterator;$/;"	t	class:WTF::ListHashSetReverseIterator	access:private
const_reverse_iterator	.\ListHashSet.h	/^        typedef ListHashSetConstReverseIterator<ValueType, inlineCapacity, HashArg> const_reverse_iterator;$/;"	t	class:WTF::ListHashSet	access:public
const_reverse_iterator	.\Vector.h	/^        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:WTF::Vector	access:public
constructDeletedValue	.\HashTraits.h	/^        static void constructDeletedValue(P*& slot) { slot = reinterpret_cast<P*>(-1); }$/;"	f	struct:WTF::HashTraits	access:public	signature:(P*& slot)
constructDeletedValue	.\HashTraits.h	/^        static void constructDeletedValue(T& slot) { new (NotNull, &slot) T(HashTableDeletedValue); }$/;"	f	struct:WTF::SimpleClassHashTraits	access:public	signature:(T& slot)
constructDeletedValue	.\HashTraits.h	/^        static void constructDeletedValue(T& slot) { slot = -std::numeric_limits<T>::infinity(); }$/;"	f	struct:WTF::FloatHashTraits	access:public	signature:(T& slot)
constructDeletedValue	.\HashTraits.h	/^        static void constructDeletedValue(T& slot) { slot = static_cast<T>(-1); }$/;"	f	struct:WTF::GenericHashTraitsBase	access:public	signature:(T& slot)
constructDeletedValue	.\HashTraits.h	/^        static void constructDeletedValue(T& slot) { slot = std::numeric_limits<T>::max() - 1; }$/;"	f	struct:WTF::UnsignedWithZeroKeyHashTraits	access:public	signature:(T& slot)
constructDeletedValue	.\HashTraits.h	/^        static void constructDeletedValue(TraitType& slot) { FirstTraits::constructDeletedValue(slot.first); }$/;"	f	struct:WTF::PairHashTraits	access:public	signature:(TraitType& slot)
constructDeletedValue	.\text\AtomicStringHash.h	/^        static void constructDeletedValue(WTF::AtomicString& slot) { new (NotNull, &slot) WTF::AtomicString(HashTableDeletedValue); }$/;"	f	struct:WTF::HashTraits	access:public	signature:(WTF::AtomicString& slot)
contains	.\HashCountedSet.h	/^        bool contains(const ValueType&) const;$/;"	p	class:WTF::HashCountedSet	access:public	signature:(const ValueType&) const
contains	.\HashCountedSet.h	/^    inline bool HashCountedSet<Value, HashFunctions, Traits>::contains(const ValueType& value) const$/;"	f	class:WTF::HashCountedSet	signature:(const ValueType& value) const
contains	.\HashMap.h	/^        bool contains(const KeyType&) const;$/;"	p	class:WTF::HashMap	access:public	signature:(const KeyType&) const
contains	.\HashMap.h	/^        template<typename T, typename HashTranslator> bool contains(const T&) const;$/;"	p	class:WTF::HashMap	access:public	signature:(const T&) const
contains	.\HashMap.h	/^    HashMap<T, U, V, W, X>::contains(const TYPE& value) const$/;"	f	class:WTF::HashMap	signature:(const TYPE& value) const
contains	.\HashMap.h	/^    inline bool HashMap<T, U, V, W, X>::contains(const KeyType& key) const$/;"	f	class:WTF::HashMap	signature:(const KeyType& key) const
contains	.\HashSet.h	/^        bool contains(const ValueType&) const;$/;"	p	class:WTF::HashSet	access:public	signature:(const ValueType&) const
contains	.\HashSet.h	/^        template<typename T, typename HashTranslator> bool contains(const T&) const;$/;"	p	class:WTF::HashSet	access:public	signature:(const T&) const
contains	.\HashSet.h	/^    inline bool HashSet<T, U, V>::contains(const ValueType& value) const$/;"	f	class:WTF::HashSet	signature:(const ValueType& value) const
contains	.\HashSet.h	/^    inline bool HashSet<Value, HashFunctions, Traits>::contains(const T& value) const$/;"	f	class:WTF::HashSet	signature:(const T& value) const
contains	.\HashTable.h	/^        bool contains(const KeyType& key) const { return contains<IdentityTranslatorType>(key); }$/;"	f	class:WTF::HashTable	access:public	signature:(const KeyType& key) const
contains	.\HashTable.h	/^        template<typename HashTranslator, typename T> bool contains(const T&) const;$/;"	p	class:WTF::HashTable	access:public	signature:(const T&) const
contains	.\HashTable.h	/^    bool HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::contains(const T& key) const$/;"	f	class:WTF::HashTable	signature:(const T& key) const
contains	.\ListHashSet.h	/^        bool contains(const ValueType&) const;$/;"	p	class:WTF::ListHashSet	access:public	signature:(const ValueType&) const
contains	.\ListHashSet.h	/^        template<typename T, typename HashTranslator> bool contains(const T&) const;$/;"	p	class:WTF::ListHashSet	access:public	signature:(const T&) const
contains	.\ListHashSet.h	/^    inline bool ListHashSet<T, inlineCapacity, U>::contains(const ValueType& value) const$/;"	f	class:WTF::ListHashSet	signature:(const ValueType& value) const
contains	.\ListHashSet.h	/^    inline bool ListHashSet<ValueType, inlineCapacity, U>::contains(const T& value) const$/;"	f	class:WTF::ListHashSet	signature:(const T& value) const
contains	.\PageBlock.h	/^    bool contains(void* containedBase, size_t containedSize)$/;"	f	class:WTF::PageBlock	access:public	signature:(void* containedBase, size_t containedSize)
contains	.\RefPtrHashMap.h	/^        bool contains(RawKeyType) const;$/;"	p	class:WTF::HashMap	access:public	signature:(RawKeyType) const
contains	.\RefPtrHashMap.h	/^        bool contains(const KeyType&) const;$/;"	p	class:WTF::HashMap	access:public	signature:(const KeyType&) const
contains	.\RefPtrHashMap.h	/^    inline bool HashMap<RefPtr<T>, U, V, W, X>::contains(RawKeyType key) const$/;"	f	class:WTF::HashMap	signature:(RawKeyType key) const
contains	.\RefPtrHashMap.h	/^    inline bool HashMap<RefPtr<T>, U, V, W, X>::contains(const KeyType& key) const$/;"	f	class:WTF::HashMap	signature:(const KeyType& key) const
contains	.\Vector.h	/^        template<typename U> bool contains(const U&) const;$/;"	p	class:WTF::Vector	access:public	signature:(const U&) const
contains	.\Vector.h	/^    bool Vector<T, inlineCapacity>::contains(const U& value) const$/;"	f	class:WTF::Vector	signature:(const U& value) const
contains	.\text\AtomicString.h	/^    bool contains(UChar c) const { return m_string.contains(c); }$/;"	f	class:WTF::AtomicString	access:public	signature:(UChar c) const
contains	.\text\AtomicString.h	/^    bool contains(const LChar* s, bool caseSensitive = true) const$/;"	f	class:WTF::AtomicString	access:public	signature:(const LChar* s, bool caseSensitive = true) const
contains	.\text\AtomicString.h	/^    bool contains(const String& s, bool caseSensitive = true) const$/;"	f	class:WTF::AtomicString	access:public	signature:(const String& s, bool caseSensitive = true) const
contains	.\text\WTFString.h	/^    bool contains(UChar c) const { return find(c) != notFound; }$/;"	f	class:WTF::String	access:public	signature:(UChar c) const
contains	.\text\WTFString.h	/^    bool contains(const LChar* str, bool caseSensitive = true) const { return find(str, 0, caseSensitive) != notFound; }$/;"	f	class:WTF::String	access:public	signature:(const LChar* str, bool caseSensitive = true) const
contains	.\text\WTFString.h	/^    bool contains(const String& str, bool caseSensitive = true) const { return find(str, 0, caseSensitive) != notFound; }$/;"	f	class:WTF::String	access:public	signature:(const String& str, bool caseSensitive = true) const
containsOnlyASCII	.\text\WTFString.h	/^    bool containsOnlyASCII() const;$/;"	p	class:WTF::String	access:public	signature:() const
containsOnlyASCII	.\text\WTFString.h	/^inline bool String::containsOnlyASCII() const$/;"	f	class:WTF::String	signature:() const
containsOnlyLatin1	.\text\WTFString.h	/^    bool containsOnlyLatin1() const;$/;"	p	class:WTF::String	access:public	signature:() const
containsOnlyLatin1	.\text\WTFString.h	/^inline bool String::containsOnlyLatin1() const$/;"	f	class:WTF::String	signature:() const
containsOnlyWhitespace	.\text\StringImpl.cpp	/^bool StringImpl::containsOnlyWhitespace()$/;"	f	class:WTF::StringImpl	signature:()
containsOnlyWhitespace	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE bool containsOnlyWhitespace();$/;"	p	class:WTF::StringImpl	access:public	signature:()
containsOnlyWhitespace	.\text\WTFString.h	/^    bool containsOnlyWhitespace() const { return !m_impl || m_impl->containsOnlyWhitespace(); }$/;"	f	class:WTF::String	access:public	signature:() const
context	.\MainThread.cpp	/^    void* context;$/;"	m	struct:WTF::FunctionWithContext	file:	access:public
conversionOK	.\unicode\UTF8.h	/^            conversionOK,       \/\/ conversion successful$/;"	e	enum:WTF::Unicode::__anon13
convertCase	.\unicode\glib\UnicodeGLib.cpp	/^static int convertCase(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error, UTF8CaseFunction caseFunction)$/;"	f	namespace:WTF::Unicode	file:	signature:(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error, UTF8CaseFunction caseFunction)
convertLatin1ToUTF8	.\unicode\UTF8.cpp	/^ConversionResult convertLatin1ToUTF8($/;"	f	namespace:WTF::Unicode	signature:( const LChar** sourceStart, const LChar* sourceEnd, char** targetStart, char* targetEnd)
convertLatin1ToUTF8	.\unicode\UTF8.h	/^    ConversionResult convertLatin1ToUTF8($/;"	p	namespace:WTF::Unicode	signature:( const LChar** sourceStart, const LChar* sourceEnd, char** targetStart, char* targetEnd)
convertToQueryEncoding	.\url\src\URLQueryCanonicalizer.h	/^    static void convertToQueryEncoding(const InChar* spec, const URLComponent& query, URLBuffer<OutChar>& buffer)$/;"	f	class:WTF::URLQueryCanonicalizer	access:private	signature:(const InChar* spec, const URLComponent& query, URLBuffer<OutChar>& buffer)
convertUTF16ToUTF8	.\unicode\UTF8.cpp	/^ConversionResult convertUTF16ToUTF8($/;"	f	namespace:WTF::Unicode	signature:( const UChar** sourceStart, const UChar* sourceEnd, char** targetStart, char* targetEnd, bool strict)
convertUTF16ToUTF8	.\unicode\UTF8.h	/^    WTF_EXPORT_PRIVATE ConversionResult convertUTF16ToUTF8($/;"	p	namespace:WTF::Unicode	signature:( const UChar** sourceStart, const UChar* sourceEnd, char** targetStart, char* targetEnd, bool strict = true)
convertUTF8ToUTF16	.\unicode\UTF8.cpp	/^ConversionResult convertUTF8ToUTF16($/;"	f	namespace:WTF::Unicode	signature:( const char** sourceStart, const char* sourceEnd, UChar** targetStart, UChar* targetEnd, bool strict)
convertUTF8ToUTF16	.\unicode\UTF8.h	/^    WTF_EXPORT_PRIVATE ConversionResult convertUTF8ToUTF16($/;"	p	namespace:WTF::Unicode	signature:( const char** sourceStart, const char* sourceEnd, UChar** targetStart, UChar* targetEnd, bool strict = true)
copyBufferIfNeeded	.\text\CString.cpp	/^void CString::copyBufferIfNeeded()$/;"	f	class:WTF::CString	signature:()
copyBufferIfNeeded	.\text\CString.h	/^    void copyBufferIfNeeded();$/;"	p	class:WTF::CString	access:private	signature:()
copyChars	.\text\StringImpl.h	/^    template <typename T> static void copyChars(T* destination, const T* source, unsigned numCharacters)$/;"	f	class:WTF::StringImpl	access:public	signature:(T* destination, const T* source, unsigned numCharacters)
copyKeysToVector	.\HashMap.h	/^    inline void copyKeysToVector(const HashMap<T, U, V, W, X>& collection, Y& vector)$/;"	f	namespace:WTF	signature:(const HashMap<T, U, V, W, X>& collection, Y& vector)
copyToVector	.\HashCountedSet.h	/^    inline void copyToVector(const HashCountedSet<Value, HashFunctions, Traits>& collection, Vector<Value>& vector)$/;"	f	namespace:WTF	signature:(const HashCountedSet<Value, HashFunctions, Traits>& collection, Vector<Value>& vector)
copyToVector	.\HashCountedSet.h	/^    inline void copyToVector(const HashCountedSet<Value, HashFunctions, Traits>& collection, VectorType& vector)$/;"	f	namespace:WTF	signature:(const HashCountedSet<Value, HashFunctions, Traits>& collection, VectorType& vector)
copyToVector	.\HashSet.h	/^    inline void copyToVector(const HashSet<T, U, V>& collection, W& vector)$/;"	f	namespace:WTF	signature:(const HashSet<T, U, V>& collection, W& vector)
copyValuesToVector	.\HashMap.h	/^    inline void copyValuesToVector(const HashMap<T, U, V, W, X>& collection, Y& vector)$/;"	f	namespace:WTF	signature:(const HashMap<T, U, V, W, X>& collection, Y& vector)
copysign	.\MathExtras.h	/^inline double copysign(double x, double y) { return _copysign(x, y); }$/;"	f	signature:(double x, double y)
cost	.\text\StringImpl.h	/^    size_t cost()$/;"	f	class:WTF::StringImpl	access:public	signature:()
count	.\Bitmap.h	/^    size_t count(size_t = 0) const;$/;"	p	class:WTF::Bitmap	access:public	signature:(size_t = 0) const
count	.\Bitmap.h	/^inline size_t Bitmap<size, atomicMode>::count(size_t start) const$/;"	f	class:WTF::Bitmap	signature:(size_t start) const
count	.\HashCountedSet.h	/^        unsigned count(const ValueType&) const;$/;"	p	class:WTF::HashCountedSet	access:public	signature:(const ValueType&) const
count	.\HashCountedSet.h	/^    inline unsigned HashCountedSet<Value, HashFunctions, Traits>::count(const ValueType& value) const$/;"	f	class:WTF::HashCountedSet	signature:(const ValueType& value) const
count	.\SimpleStats.h	/^    double count() const$/;"	f	class:WTF::SimpleStats	access:public	signature:() const
count	.\Spectrum.h	/^        unsigned long count;$/;"	m	struct:WTF::Spectrum::KeyAndCount	access:public
counter_	.\FastMalloc.cpp	/^  size_t   counter_;        \/\/ Number of free objects in cache entry$/;"	m	class:WTF::TCMalloc_Central_FreeList	file:	access:private
cpp_alloc	.\FastMalloc.cpp	/^static inline void* cpp_alloc(size_t size, bool nothrow) {$/;"	f	namespace:WTF	file:	signature:(size_t size, bool nothrow)
create	.\ArrayBuffer.h	/^    static inline PassRefPtr<ArrayBuffer> create(ArrayBuffer*);$/;"	p	class:WTF::ArrayBuffer	access:public	signature:(ArrayBuffer*)
create	.\ArrayBuffer.h	/^    static inline PassRefPtr<ArrayBuffer> create(ArrayBufferContents&);$/;"	p	class:WTF::ArrayBuffer	access:public	signature:(ArrayBufferContents&)
create	.\ArrayBuffer.h	/^    static inline PassRefPtr<ArrayBuffer> create(const void* source, unsigned byteLength);$/;"	p	class:WTF::ArrayBuffer	access:public	signature:(const void* source, unsigned byteLength)
create	.\ArrayBuffer.h	/^    static inline PassRefPtr<ArrayBuffer> create(unsigned numElements, unsigned elementByteSize);$/;"	p	class:WTF::ArrayBuffer	access:public	signature:(unsigned numElements, unsigned elementByteSize)
create	.\ArrayBuffer.h	/^PassRefPtr<ArrayBuffer> ArrayBuffer::create(ArrayBuffer* other)$/;"	f	class:WTF::ArrayBuffer	signature:(ArrayBuffer* other)
create	.\ArrayBuffer.h	/^PassRefPtr<ArrayBuffer> ArrayBuffer::create(ArrayBufferContents& contents)$/;"	f	class:WTF::ArrayBuffer	signature:(ArrayBufferContents& contents)
create	.\ArrayBuffer.h	/^PassRefPtr<ArrayBuffer> ArrayBuffer::create(const void* source, unsigned byteLength)$/;"	f	class:WTF::ArrayBuffer	signature:(const void* source, unsigned byteLength)
create	.\ArrayBuffer.h	/^PassRefPtr<ArrayBuffer> ArrayBuffer::create(unsigned numElements, unsigned elementByteSize)$/;"	f	class:WTF::ArrayBuffer	signature:(unsigned numElements, unsigned elementByteSize)
create	.\BitVector.cpp	/^BitVector::OutOfLineBits* BitVector::OutOfLineBits::create(size_t numBits)$/;"	f	class:WTF::BitVector::OutOfLineBits	signature:(size_t numBits)
create	.\BitVector.h	/^        static OutOfLineBits* create(size_t numBits);$/;"	p	class:WTF::BitVector::OutOfLineBits	access:public	signature:(size_t numBits)
create	.\BumpPointerAllocator.h	/^    static BumpPointerPool* create(size_t minimumCapacity = 0)$/;"	f	class:WTF::BumpPointerPool	access:private	signature:(size_t minimumCapacity = 0)
create	.\ByteArray.cpp	/^PassRefPtr<ByteArray> ByteArray::create(size_t size)$/;"	f	class:WTF::ByteArray	signature:(size_t size)
create	.\ByteArray.h	/^        WTF_EXPORT_PRIVATE static PassRefPtr<ByteArray> create(size_t size);$/;"	p	class:WTF::ByteArray	access:public	signature:(size_t size)
create	.\Float32Array.h	/^    static inline PassRefPtr<Float32Array> create(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length);$/;"	p	class:WTF::Float32Array	access:public	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
create	.\Float32Array.h	/^    static inline PassRefPtr<Float32Array> create(const float* array, unsigned length);$/;"	p	class:WTF::Float32Array	access:public	signature:(const float* array, unsigned length)
create	.\Float32Array.h	/^    static inline PassRefPtr<Float32Array> create(unsigned length);$/;"	p	class:WTF::Float32Array	access:public	signature:(unsigned length)
create	.\Float32Array.h	/^PassRefPtr<Float32Array> Float32Array::create(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Float32Array	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
create	.\Float32Array.h	/^PassRefPtr<Float32Array> Float32Array::create(const float* array, unsigned length)$/;"	f	class:WTF::Float32Array	signature:(const float* array, unsigned length)
create	.\Float32Array.h	/^PassRefPtr<Float32Array> Float32Array::create(unsigned length)$/;"	f	class:WTF::Float32Array	signature:(unsigned length)
create	.\Float64Array.h	/^    static inline PassRefPtr<Float64Array> create(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length);$/;"	p	class:WTF::Float64Array	access:public	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
create	.\Float64Array.h	/^    static inline PassRefPtr<Float64Array> create(const double* array, unsigned length);$/;"	p	class:WTF::Float64Array	access:public	signature:(const double* array, unsigned length)
create	.\Float64Array.h	/^    static inline PassRefPtr<Float64Array> create(unsigned length);$/;"	p	class:WTF::Float64Array	access:public	signature:(unsigned length)
create	.\Float64Array.h	/^PassRefPtr<Float64Array> Float64Array::create(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Float64Array	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
create	.\Float64Array.h	/^PassRefPtr<Float64Array> Float64Array::create(const double* array, unsigned length)$/;"	f	class:WTF::Float64Array	signature:(const double* array, unsigned length)
create	.\Float64Array.h	/^PassRefPtr<Float64Array> Float64Array::create(unsigned length)$/;"	f	class:WTF::Float64Array	signature:(unsigned length)
create	.\Int16Array.h	/^    static inline PassRefPtr<Int16Array> create(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length);$/;"	p	class:WTF::Int16Array	access:public	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
create	.\Int16Array.h	/^    static inline PassRefPtr<Int16Array> create(const short* array, unsigned length);$/;"	p	class:WTF::Int16Array	access:public	signature:(const short* array, unsigned length)
create	.\Int16Array.h	/^    static inline PassRefPtr<Int16Array> create(unsigned length);$/;"	p	class:WTF::Int16Array	access:public	signature:(unsigned length)
create	.\Int16Array.h	/^PassRefPtr<Int16Array> Int16Array::create(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Int16Array	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
create	.\Int16Array.h	/^PassRefPtr<Int16Array> Int16Array::create(const short* array, unsigned length)$/;"	f	class:WTF::Int16Array	signature:(const short* array, unsigned length)
create	.\Int16Array.h	/^PassRefPtr<Int16Array> Int16Array::create(unsigned length)$/;"	f	class:WTF::Int16Array	signature:(unsigned length)
create	.\Int32Array.h	/^    static inline PassRefPtr<Int32Array> create(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length);$/;"	p	class:WTF::Int32Array	access:public	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
create	.\Int32Array.h	/^    static inline PassRefPtr<Int32Array> create(const int* array, unsigned length);$/;"	p	class:WTF::Int32Array	access:public	signature:(const int* array, unsigned length)
create	.\Int32Array.h	/^    static inline PassRefPtr<Int32Array> create(unsigned length);$/;"	p	class:WTF::Int32Array	access:public	signature:(unsigned length)
create	.\Int32Array.h	/^PassRefPtr<Int32Array> Int32Array::create(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Int32Array	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
create	.\Int32Array.h	/^PassRefPtr<Int32Array> Int32Array::create(const int* array, unsigned length)$/;"	f	class:WTF::Int32Array	signature:(const int* array, unsigned length)
create	.\Int32Array.h	/^PassRefPtr<Int32Array> Int32Array::create(unsigned length)$/;"	f	class:WTF::Int32Array	signature:(unsigned length)
create	.\Int8Array.h	/^    static inline PassRefPtr<Int8Array> create(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length);$/;"	p	class:WTF::Int8Array	access:public	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
create	.\Int8Array.h	/^    static inline PassRefPtr<Int8Array> create(const signed char* array, unsigned length);$/;"	p	class:WTF::Int8Array	access:public	signature:(const signed char* array, unsigned length)
create	.\Int8Array.h	/^    static inline PassRefPtr<Int8Array> create(unsigned length);$/;"	p	class:WTF::Int8Array	access:public	signature:(unsigned length)
create	.\Int8Array.h	/^PassRefPtr<Int8Array> Int8Array::create(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Int8Array	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
create	.\Int8Array.h	/^PassRefPtr<Int8Array> Int8Array::create(const signed char* array, unsigned length)$/;"	f	class:WTF::Int8Array	signature:(const signed char* array, unsigned length)
create	.\Int8Array.h	/^PassRefPtr<Int8Array> Int8Array::create(unsigned length)$/;"	f	class:WTF::Int8Array	signature:(unsigned length)
create	.\ParallelJobsGeneric.h	/^        static PassRefPtr<ThreadPrivate> create()$/;"	f	class:WTF::ParallelEnvironment::ThreadPrivate	access:public	signature:()
create	.\TypedArrayBase.h	/^    static PassRefPtr<Subclass> create(PassRefPtr<ArrayBuffer> buffer,$/;"	f	class:WTF::TypedArrayBase	access:protected	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
create	.\TypedArrayBase.h	/^    static PassRefPtr<Subclass> create(const T* array, unsigned length)$/;"	f	class:WTF::TypedArrayBase	access:protected	signature:(const T* array, unsigned length)
create	.\TypedArrayBase.h	/^    static PassRefPtr<Subclass> create(unsigned length)$/;"	f	class:WTF::TypedArrayBase	access:protected	signature:(unsigned length)
create	.\Uint16Array.h	/^    static inline PassRefPtr<Uint16Array> create(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length);$/;"	p	class:WTF::Uint16Array	access:public	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
create	.\Uint16Array.h	/^    static inline PassRefPtr<Uint16Array> create(const unsigned short* array, unsigned length);$/;"	p	class:WTF::Uint16Array	access:public	signature:(const unsigned short* array, unsigned length)
create	.\Uint16Array.h	/^    static inline PassRefPtr<Uint16Array> create(unsigned length);$/;"	p	class:WTF::Uint16Array	access:public	signature:(unsigned length)
create	.\Uint16Array.h	/^PassRefPtr<Uint16Array> Uint16Array::create(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Uint16Array	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
create	.\Uint16Array.h	/^PassRefPtr<Uint16Array> Uint16Array::create(const unsigned short* array, unsigned length)$/;"	f	class:WTF::Uint16Array	signature:(const unsigned short* array, unsigned length)
create	.\Uint16Array.h	/^PassRefPtr<Uint16Array> Uint16Array::create(unsigned length)$/;"	f	class:WTF::Uint16Array	signature:(unsigned length)
create	.\Uint32Array.h	/^    static inline PassRefPtr<Uint32Array> create(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length);$/;"	p	class:WTF::Uint32Array	access:public	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
create	.\Uint32Array.h	/^    static inline PassRefPtr<Uint32Array> create(const unsigned int* array, unsigned length);$/;"	p	class:WTF::Uint32Array	access:public	signature:(const unsigned int* array, unsigned length)
create	.\Uint32Array.h	/^    static inline PassRefPtr<Uint32Array> create(unsigned length);$/;"	p	class:WTF::Uint32Array	access:public	signature:(unsigned length)
create	.\Uint32Array.h	/^PassRefPtr<Uint32Array> Uint32Array::create(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Uint32Array	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
create	.\Uint32Array.h	/^PassRefPtr<Uint32Array> Uint32Array::create(const unsigned int* array, unsigned length)$/;"	f	class:WTF::Uint32Array	signature:(const unsigned int* array, unsigned length)
create	.\Uint32Array.h	/^PassRefPtr<Uint32Array> Uint32Array::create(unsigned length)$/;"	f	class:WTF::Uint32Array	signature:(unsigned length)
create	.\Uint8Array.h	/^    static inline PassRefPtr<Uint8Array> create(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length);$/;"	p	class:WTF::Uint8Array	access:public	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
create	.\Uint8Array.h	/^    static inline PassRefPtr<Uint8Array> create(const unsigned char* array, unsigned length);$/;"	p	class:WTF::Uint8Array	access:public	signature:(const unsigned char* array, unsigned length)
create	.\Uint8Array.h	/^    static inline PassRefPtr<Uint8Array> create(unsigned length);$/;"	p	class:WTF::Uint8Array	access:public	signature:(unsigned length)
create	.\Uint8Array.h	/^PassRefPtr<Uint8Array> Uint8Array::create(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Uint8Array	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
create	.\Uint8Array.h	/^PassRefPtr<Uint8Array> Uint8Array::create(const unsigned char* array, unsigned length)$/;"	f	class:WTF::Uint8Array	signature:(const unsigned char* array, unsigned length)
create	.\Uint8Array.h	/^PassRefPtr<Uint8Array> Uint8Array::create(unsigned length)$/;"	f	class:WTF::Uint8Array	signature:(unsigned length)
create	.\Uint8ClampedArray.h	/^    static inline PassRefPtr<Uint8ClampedArray> create(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length);$/;"	p	class:WTF::Uint8ClampedArray	access:public	signature:(PassRefPtr<ArrayBuffer>, unsigned byteOffset, unsigned length)
create	.\Uint8ClampedArray.h	/^    static inline PassRefPtr<Uint8ClampedArray> create(const unsigned char* array, unsigned length);$/;"	p	class:WTF::Uint8ClampedArray	access:public	signature:(const unsigned char* array, unsigned length)
create	.\Uint8ClampedArray.h	/^    static inline PassRefPtr<Uint8ClampedArray> create(unsigned length);$/;"	p	class:WTF::Uint8ClampedArray	access:public	signature:(unsigned length)
create	.\Uint8ClampedArray.h	/^PassRefPtr<Uint8ClampedArray> Uint8ClampedArray::create(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)$/;"	f	class:WTF::Uint8ClampedArray	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned length)
create	.\Uint8ClampedArray.h	/^PassRefPtr<Uint8ClampedArray> Uint8ClampedArray::create(const unsigned char* array, unsigned length)$/;"	f	class:WTF::Uint8ClampedArray	signature:(const unsigned char* array, unsigned length)
create	.\Uint8ClampedArray.h	/^PassRefPtr<Uint8ClampedArray> Uint8ClampedArray::create(unsigned length)$/;"	f	class:WTF::Uint8ClampedArray	signature:(unsigned length)
create	.\text\AtomicString.cpp	/^    static AtomicStringTable* create()$/;"	f	class:WTF::AtomicStringTable	access:public	signature:()
create	.\text\CString.h	/^    static PassRefPtr<CStringBuffer> create(size_t length) { return adoptRef(new CStringBuffer(length)); }$/;"	f	class:WTF::CStringBuffer	access:private	signature:(size_t length)
create	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::create(const LChar* characters, unsigned length)$/;"	f	class:WTF::StringImpl	signature:(const LChar* characters, unsigned length)
create	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::create(const LChar* string)$/;"	f	class:WTF::StringImpl	signature:(const LChar* string)
create	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::create(const UChar* characters, unsigned length)$/;"	f	class:WTF::StringImpl	signature:(const UChar* characters, unsigned length)
create	.\text\StringImpl.h	/^    ALWAYS_INLINE static PassRefPtr<StringImpl> create(const char* s) { return create(reinterpret_cast<const LChar*>(s)); }$/;"	f	class:WTF::StringImpl	access:public	signature:(const char* s)
create	.\text\StringImpl.h	/^    ALWAYS_INLINE static PassRefPtr<StringImpl> create(const char* s, unsigned length) { return create(reinterpret_cast<const LChar*>(s), length); }$/;"	f	class:WTF::StringImpl	access:public	signature:(const char* s, unsigned length)
create	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE static PassRefPtr<StringImpl> create(const LChar*);$/;"	p	class:WTF::StringImpl	access:public	signature:(const LChar*)
create	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE static PassRefPtr<StringImpl> create(const UChar*, unsigned length);$/;"	p	class:WTF::StringImpl	access:public	signature:(const UChar*, unsigned length)
create	.\text\StringImpl.h	/^    static ALWAYS_INLINE PassRefPtr<StringImpl> create(PassRefPtr<StringImpl> rep, unsigned offset, unsigned length)$/;"	f	class:WTF::StringImpl	access:public	signature:(PassRefPtr<StringImpl> rep, unsigned offset, unsigned length)
create	.\text\StringImpl.h	/^    static PassRefPtr<StringImpl> create(const LChar*, unsigned length);$/;"	p	class:WTF::StringImpl	access:public	signature:(const LChar*, unsigned length)
create8	.\text\StringImpl.h	/^    static ALWAYS_INLINE PassRefPtr<StringImpl> create8(PassRefPtr<StringImpl> rep, unsigned offset, unsigned length)$/;"	f	class:WTF::StringImpl	access:public	signature:(PassRefPtr<StringImpl> rep, unsigned offset, unsigned length)
createCFString	.\text\AtomicString.h	/^    CFStringRef createCFString() const { return m_string.createCFString(); }$/;"	f	class:WTF::AtomicString	access:public	signature:() const
createCFString	.\text\StringImpl.h	/^    CFStringRef createCFString();$/;"	p	class:WTF::StringImpl	access:public	signature:()
createCFString	.\text\WTFString.h	/^    CFStringRef createCFString() const;$/;"	p	class:WTF::String	access:public	signature:() const
createCollator	.\unicode\Collator.h	/^        void createCollator() const;$/;"	p	class:WTF::Collator	access:private	signature:() const
createCollator	.\unicode\icu\CollatorICU.cpp	/^void Collator::createCollator() const$/;"	f	class:WTF::Collator	signature:() const
createCompatibleBitmap	.\wince\MemoryManager.cpp	/^HBITMAP MemoryManager::createCompatibleBitmap(HDC hdc, int width, int height)$/;"	f	class:WTF::MemoryManager	signature:(HDC hdc, int width, int height)
createCompatibleBitmap	.\wince\MemoryManager.h	/^        static HBITMAP createCompatibleBitmap(HDC hdc, int width, int height);$/;"	p	class:WTF::MemoryManager	access:public	signature:(HDC hdc, int width, int height)
createDIBSection	.\wince\MemoryManager.cpp	/^HBITMAP MemoryManager::createDIBSection(const BITMAPINFO* pbmi, void** ppvBits)$/;"	f	class:WTF::MemoryManager	signature:(const BITMAPINFO* pbmi, void** ppvBits)
createDIBSection	.\wince\MemoryManager.h	/^        static HBITMAP createDIBSection(const BITMAPINFO* pbmi, void** ppvBits);$/;"	p	class:WTF::MemoryManager	access:public	signature:(const BITMAPINFO* pbmi, void** ppvBits)
createThread	.\Threading.cpp	/^ThreadIdentifier createThread(ThreadFunction entryPoint, void* data, const char* name)$/;"	f	namespace:WTF	signature:(ThreadFunction entryPoint, void* data, const char* name)
createThread	.\Threading.cpp	/^ThreadIdentifier createThread(ThreadFunctionWithReturnValue entryPoint, void* data)$/;"	f	namespace:WTF	signature:(ThreadFunctionWithReturnValue entryPoint, void* data)
createThread	.\Threading.cpp	/^ThreadIdentifier createThread(ThreadFunctionWithReturnValue entryPoint, void* data, const char* name)$/;"	f	namespace:WTF	signature:(ThreadFunctionWithReturnValue entryPoint, void* data, const char* name)
createThread	.\Threading.cpp	/^WTF_EXPORT_PRIVATE ThreadIdentifier createThread(ThreadFunctionWithReturnValue entryPoint, void* data);$/;"	p	namespace:WTF	file:	signature:(ThreadFunctionWithReturnValue entryPoint, void* data)
createThread	.\Threading.cpp	/^WTF_EXPORT_PRIVATE ThreadIdentifier createThread(ThreadFunctionWithReturnValue entryPoint, void* data, const char* name);$/;"	p	namespace:WTF	file:	signature:(ThreadFunctionWithReturnValue entryPoint, void* data, const char* name)
createThread	.\Threading.h	/^WTF_EXPORT_PRIVATE ThreadIdentifier createThread(ThreadFunction, void*, const char* threadName);$/;"	p	namespace:WTF	signature:(ThreadFunction, void*, const char* threadName)
createThreadInternal	.\Threading.h	/^ThreadIdentifier createThreadInternal(ThreadFunction, void*, const char* threadName);$/;"	p	namespace:WTF	signature:(ThreadFunction, void*, const char* threadName)
createThreadInternal	.\ThreadingPthreads.cpp	/^ThreadIdentifier createThreadInternal(ThreadFunction entryPoint, void* data, const char* threadName)$/;"	f	namespace:WTF	signature:(ThreadFunction entryPoint, void* data, const char* threadName)
createThreadInternal	.\ThreadingPthreads.cpp	/^ThreadIdentifier createThreadInternal(ThreadFunction entryPoint, void* data, const char*)$/;"	f	namespace:WTF	signature:(ThreadFunction entryPoint, void* data, const char*)
createThreadInternal	.\ThreadingWin.cpp	/^ThreadIdentifier createThreadInternal(ThreadFunction entryPoint, void* data, const char* threadName)$/;"	f	namespace:WTF	signature:(ThreadFunction entryPoint, void* data, const char* threadName)
createUninitialized	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::createUninitialized(unsigned length, LChar*& data)$/;"	f	class:WTF::StringImpl	signature:(unsigned length, LChar*& data)
createUninitialized	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::createUninitialized(unsigned length, UChar*& data)$/;"	f	class:WTF::StringImpl	signature:(unsigned length, UChar*& data)
createUninitialized	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE static PassRefPtr<StringImpl> createUninitialized(unsigned length, UChar*& data);$/;"	p	class:WTF::StringImpl	access:public	signature:(unsigned length, UChar*& data)
createUninitialized	.\text\StringImpl.h	/^    static PassRefPtr<StringImpl> createUninitialized(unsigned length, LChar*& data);$/;"	p	class:WTF::StringImpl	access:public	signature:(unsigned length, LChar*& data)
createUninitialized	.\text\WTFString.h	/^    static String createUninitialized(unsigned length, UChar*& data) { return StringImpl::createUninitialized(length, data); }$/;"	f	class:WTF::String	access:public	signature:(unsigned length, UChar*& data)
createWithTerminatingNullCharacter	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::createWithTerminatingNullCharacter(const StringImpl& string)$/;"	f	class:WTF::StringImpl	signature:(const StringImpl& string)
createWithTerminatingNullCharacter	.\text\StringImpl.h	/^    static PassRefPtr<StringImpl> createWithTerminatingNullCharacter(const StringImpl&);$/;"	p	class:WTF::StringImpl	access:public	signature:(const StringImpl&)
creationMutex	.\Threading.cpp	/^    Mutex creationMutex;$/;"	m	struct:WTF::NewThreadContext	file:	access:public
cryptographicallyRandomNumber	.\CryptographicallyRandomNumber.cpp	/^uint32_t cryptographicallyRandomNumber()$/;"	f	namespace:WTF	signature:()
cryptographicallyRandomNumber	.\CryptographicallyRandomNumber.h	/^WTF_EXPORT_PRIVATE uint32_t cryptographicallyRandomNumber();$/;"	p	namespace:WTF	signature:()
cryptographicallyRandomValues	.\CryptographicallyRandomNumber.cpp	/^void cryptographicallyRandomValues(void* buffer, size_t length)$/;"	f	namespace:WTF	signature:(void* buffer, size_t length)
cryptographicallyRandomValues	.\CryptographicallyRandomNumber.h	/^WTF_EXPORT_PRIVATE void cryptographicallyRandomValues(void* buffer, size_t length);$/;"	p	namespace:WTF	signature:(void* buffer, size_t length)
cryptographicallyRandomValuesFromOS	.\OSRandomSource.cpp	/^void cryptographicallyRandomValuesFromOS(unsigned char* buffer, size_t length)$/;"	f	namespace:WTF	signature:(unsigned char* buffer, size_t length)
cryptographicallyRandomValuesFromOS	.\OSRandomSource.h	/^void cryptographicallyRandomValuesFromOS(unsigned char* buffer, size_t length);$/;"	p	namespace:WTF	signature:(unsigned char* buffer, size_t length)
current	.\StackBounds.h	/^    void* current() const$/;"	f	class:WTF::StackBounds	access:public	signature:() const
currentIdentifierTable	.\WTFThreadData.h	/^    JSC::IdentifierTable* currentIdentifierTable()$/;"	f	class:WTF::WTFThreadData	access:public	signature:()
currentStatistics	.\MetaAllocator.cpp	/^MetaAllocator::Statistics MetaAllocator::currentStatistics()$/;"	f	class:WTF::MetaAllocator	signature:()
currentStatistics	.\MetaAllocator.h	/^    Statistics currentStatistics();$/;"	p	class:WTF::MetaAllocator	access:public	signature:()
currentSystemTime	.\CurrentTime.cpp	/^static double currentSystemTime()$/;"	f	namespace:WTF	file:	signature:()
currentThread	.\Threading.h	/^WTF_EXPORT_PRIVATE ThreadIdentifier currentThread();$/;"	p	namespace:WTF	signature:()
currentThread	.\ThreadingPthreads.cpp	/^ThreadIdentifier currentThread()$/;"	f	namespace:WTF	signature:()
currentThread	.\ThreadingWin.cpp	/^ThreadIdentifier currentThread()$/;"	f	namespace:WTF	signature:()
currentThreadStackBounds	.\StackBounds.h	/^    static StackBounds currentThreadStackBounds()$/;"	f	class:WTF::StackBounds	access:public	signature:()
currentTime	.\CurrentTime.cpp	/^double currentTime()$/;"	f	namespace:WTF	signature:()
currentTime	.\CurrentTime.h	/^WTF_EXPORT_PRIVATE double currentTime();$/;"	p	namespace:WTF	signature:()
currentTimeMS	.\CurrentTime.h	/^inline double currentTimeMS()$/;"	f	namespace:WTF	signature:()
d	.\SizeLimits.cpp	/^    ThreadRestrictionVerifier d;$/;"	m	struct:WTF::SameSizeAsRefCounted	file:	access:public
d	.\TCSystemAlloc.cpp	/^  double d;$/;"	m	union:MemoryAligner	file:	access:public
d	.\dtoa.cpp	/^    double d;$/;"	m	union:WTF::__anon4	file:	access:public
d0	.\dtoa.cpp	593;"	d	file:
d0	.\dtoa.cpp	631;"	d	file:
d1	.\dtoa.cpp	594;"	d	file:
d1	.\dtoa.cpp	632;"	d	file:
d2b	.\dtoa.cpp	/^static ALWAYS_INLINE void d2b(BigInt& b, U* d, int* e, int* bits)$/;"	f	namespace:WTF	file:	signature:(BigInt& b, U* d, int* e, int* bits)
d64_	.\dtoa\double.h	/^        const uint64_t d64_;$/;"	m	class:WTF::double_conversion::Double	access:private
data	.\ArrayBuffer.h	/^    inline const void* data() const;$/;"	p	class:WTF::ArrayBuffer	access:public	signature:() const
data	.\ArrayBuffer.h	/^    inline void* data();$/;"	p	class:WTF::ArrayBuffer	access:public	signature:()
data	.\ArrayBuffer.h	/^    void* data() { return m_data; }$/;"	f	class:WTF::ArrayBufferContents	access:public	signature:()
data	.\ArrayBuffer.h	/^const void* ArrayBuffer::data() const$/;"	f	class:WTF::ArrayBuffer	signature:() const
data	.\ArrayBuffer.h	/^void* ArrayBuffer::data()$/;"	f	class:WTF::ArrayBuffer	signature:()
data	.\ByteArray.h	/^        unsigned char* data() { return m_data; }$/;"	f	class:WTF::ByteArray	access:public	signature:()
data	.\FixedArray.h	/^    T* data() { return m_data; }$/;"	f	class:WTF::FixedArray	access:public	signature:()
data	.\RefCountedArray.h	/^    T* data() { return m_data; }$/;"	f	class:WTF::RefCountedArray	access:public	signature:()
data	.\RefCountedArray.h	/^    const T* data() const { return m_data; }$/;"	f	class:WTF::RefCountedArray	access:public	signature:() const
data	.\ThreadFunctionInvocation.h	/^    void* data;$/;"	m	struct:WTF::ThreadFunctionInvocation	access:public
data	.\Threading.cpp	/^    void* data;$/;"	m	struct:WTF::NewThreadContext	file:	access:public
data	.\Threading.cpp	/^    void* data;$/;"	m	struct:WTF::ThreadFunctionWithReturnValueInvocation	file:	access:public
data	.\TypedArrayBase.h	/^    T* data() const { return static_cast<T*>(baseAddress()); }$/;"	f	class:WTF::TypedArrayBase	access:public	signature:() const
data	.\Vector.h	/^        T* data() { return m_buffer.buffer(); }$/;"	f	class:WTF::Vector	access:public	signature:()
data	.\Vector.h	/^        const T* data() const { return m_buffer.buffer(); }$/;"	f	class:WTF::Vector	access:public	signature:() const
data	.\text\CString.h	/^    const char* data() const$/;"	f	class:WTF::CString	access:public	signature:() const
data	.\text\CString.h	/^    const char* data() { return m_vector.data(); }$/;"	f	class:WTF::CStringBuffer	access:public	signature:()
data	.\url\src\URLBuffer.h	/^    CharacterType* data() { return m_buffer; }$/;"	f	class:WTF::URLBuffer	access:public	signature:()
data	.\url\src\URLBuffer.h	/^    const CharacterType* data() const { return m_buffer; }$/;"	f	class:WTF::URLBuffer	access:public	signature:() const
dataFile	.\DataLog.cpp	/^FILE* dataFile()$/;"	f	namespace:WTF	signature:()
dataFile	.\DataLog.h	/^FILE* dataFile();$/;"	p	namespace:WTF	signature:()
dataLog	.\DataLog.cpp	/^void dataLog(const char* format, ...)$/;"	f	namespace:WTF	signature:(const char* format, ...)
dataLogV	.\DataLog.cpp	/^void dataLogV(const char* format, va_list argList)$/;"	f	namespace:WTF	signature:(const char* format, va_list argList)
dataOffset	.\text\StringImpl.h	/^    static unsigned dataOffset() { return OBJECT_OFFSETOF(StringImpl, m_data8); }$/;"	f	class:WTF::StringImpl	access:public	signature:()
dataSlot	.\Vector.h	/^        T** dataSlot() { return m_buffer.bufferSlot(); }$/;"	f	class:WTF::Vector	access:public	signature:()
dateToDaysFrom1970	.\DateMath.cpp	/^double dateToDaysFrom1970(int year, int month, int day)$/;"	f	namespace:WTF	signature:(int year, int month, int day)
dateToDaysFrom1970	.\DateMath.h	/^WTF_EXPORT_PRIVATE double dateToDaysFrom1970(int year, int month, int day);$/;"	p	namespace:WTF	signature:(int year, int month, int day)
dayInMonthFromDayInYear	.\DateMath.cpp	/^int dayInMonthFromDayInYear(int dayInYear, bool leapYear)$/;"	f	namespace:WTF	signature:(int dayInYear, bool leapYear)
dayInMonthFromDayInYear	.\DateMath.h	/^WTF_EXPORT_PRIVATE int dayInMonthFromDayInYear(int dayInYear, bool leapYear);$/;"	p	namespace:WTF	signature:(int dayInYear, bool leapYear)
dayInYear	.\DateMath.cpp	/^int dayInYear(double ms, int year)$/;"	f	namespace:WTF	signature:(double ms, int year)
dayInYear	.\DateMath.h	/^WTF_EXPORT_PRIVATE int dayInYear(double ms, int year);$/;"	p	namespace:WTF	signature:(double ms, int year)
daysFrom1970ToYear	.\DateMath.cpp	/^static inline double daysFrom1970ToYear(int year)$/;"	f	namespace:WTF	file:	signature:(int year)
daysInYear	.\DateMath.cpp	/^static inline int daysInYear(int year)$/;"	f	namespace:WTF	file:	signature:(int year)
dealloc	.\BumpPointerAllocator.h	/^    BumpPointerPool* dealloc(void* position)$/;"	f	class:WTF::BumpPointerPool	access:public	signature:(void* position)
deallocCrossPool	.\BumpPointerAllocator.h	/^    static BumpPointerPool* deallocCrossPool(BumpPointerPool* pool, void* position)$/;"	f	class:WTF::BumpPointerPool	access:private	signature:(BumpPointerPool* pool, void* position)
deallocate	.\ListHashSet.h	/^        void deallocate(Node* node) $/;"	f	struct:WTF::ListHashSetNodeAllocator	access:public	signature:(Node* node)
deallocate	.\PageAllocation.h	/^    void deallocate()$/;"	f	class:WTF::PageAllocation	access:public	signature:()
deallocate	.\PageAllocationAligned.cpp	/^void PageAllocationAligned::deallocate()$/;"	f	class:WTF::PageAllocationAligned	signature:()
deallocate	.\PageAllocationAligned.h	/^    void deallocate();$/;"	p	class:WTF::PageAllocationAligned	access:public	signature:()
deallocate	.\PageReservation.h	/^    void deallocate()$/;"	f	class:WTF::PageReservation	access:public	signature:()
deallocateBuffer	.\Vector.h	/^        void deallocateBuffer(T* bufferToDeallocate)$/;"	f	class:WTF::VectorBuffer	access:public	signature:(T* bufferToDeallocate)
deallocateBuffer	.\Vector.h	/^        void deallocateBuffer(T* bufferToDeallocate)$/;"	f	class:WTF::VectorBufferBase	access:public	signature:(T* bufferToDeallocate)
deallocateTable	.\HashTable.h	/^        static void deallocateTable(ValueType* table, int size);$/;"	p	class:WTF::HashTable	access:private	signature:(ValueType* table, int size)
deallocateTable	.\HashTable.h	/^    void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::deallocateTable(ValueType* table, int size)$/;"	f	class:WTF::HashTable	signature:(ValueType* table, int size)
debugFreeSpaceSize	.\MetaAllocator.cpp	/^size_t MetaAllocator::debugFreeSpaceSize()$/;"	f	class:WTF::MetaAllocator	signature:()
debugFreeSpaceSize	.\MetaAllocator.h	/^    WTF_EXPORT_PRIVATE size_t debugFreeSpaceSize();$/;"	p	class:WTF::MetaAllocator	access:public	signature:()
decimal_exponent	.\dtoa\cached-powers.cc	/^        int16_t decimal_exponent;$/;"	m	struct:WTF::double_conversion::CachedPower	file:	access:public
decimal_in_shortest_high_	.\dtoa\double-conversion.h	/^        const int decimal_in_shortest_high_;$/;"	m	class:WTF::double_conversion::DoubleToStringConverter	access:private
decimal_in_shortest_low_	.\dtoa\double-conversion.h	/^        const int decimal_in_shortest_low_;$/;"	m	class:WTF::double_conversion::DoubleToStringConverter	access:private
decodeBool	.\Decoder.h	/^    virtual bool decodeBool(bool&) = 0;$/;"	p	class:WTF::Decoder	access:public	signature:(bool&)
decodeBytes	.\Decoder.h	/^    virtual bool decodeBytes(Vector<uint8_t>&) = 0;$/;"	p	class:WTF::Decoder	access:public	signature:(Vector<uint8_t>&)
decodeDouble	.\Decoder.h	/^    virtual bool decodeDouble(double&) = 0;$/;"	p	class:WTF::Decoder	access:public	signature:(double&)
decodeFloat	.\Decoder.h	/^    virtual bool decodeFloat(float&) = 0;$/;"	p	class:WTF::Decoder	access:public	signature:(float&)
decodeInt32	.\Decoder.h	/^    virtual bool decodeInt32(int32_t&) = 0;$/;"	p	class:WTF::Decoder	access:public	signature:(int32_t&)
decodeInt64	.\Decoder.h	/^    virtual bool decodeInt64(int64_t&) = 0;$/;"	p	class:WTF::Decoder	access:public	signature:(int64_t&)
decodeString	.\Decoder.h	/^    virtual bool decodeString(String&) = 0;$/;"	p	class:WTF::Decoder	access:public	signature:(String&)
decodeUInt32	.\Decoder.h	/^    virtual bool decodeUInt32(uint32_t&) = 0;$/;"	p	class:WTF::Decoder	access:public	signature:(uint32_t&)
decodeUInt64	.\Decoder.h	/^    virtual bool decodeUInt64(uint64_t&) = 0;$/;"	p	class:WTF::Decoder	access:public	signature:(uint64_t&)
decodeUTF8Sequence	.\unicode\UTF8.cpp	/^int decodeUTF8Sequence(const char* sequence)$/;"	f	namespace:WTF::Unicode	signature:(const char* sequence)
decodeUTF8Sequence	.\unicode\UTF8.h	/^    int decodeUTF8Sequence(const char*);$/;"	p	namespace:WTF::Unicode	signature:(const char*)
decommit	.\OSAllocator.h	/^    static void decommit(void*, size_t);$/;"	p	class:WTF::OSAllocator	access:public	signature:(void*, size_t)
decommit	.\OSAllocatorPosix.cpp	/^void OSAllocator::decommit(void* address, size_t bytes)$/;"	f	class:WTF::OSAllocator	signature:(void* address, size_t bytes)
decommit	.\OSAllocatorWin.cpp	/^void OSAllocator::decommit(void* address, size_t bytes)$/;"	f	class:WTF::OSAllocator	signature:(void* address, size_t bytes)
decommit	.\PageReservation.h	/^    void decommit(void* start, size_t size)$/;"	f	class:WTF::PageReservation	access:public	signature:(void* start, size_t size)
decommitAndRelease	.\OSAllocator.h	/^    static void decommitAndRelease(void* base, size_t size);$/;"	p	class:WTF::OSAllocator	access:public	signature:(void* base, size_t size)
decommitAndRelease	.\OSAllocator.h	/^    static void decommitAndRelease(void* releaseBase, size_t releaseSize, void* decommitBase, size_t decommitSize);$/;"	p	class:WTF::OSAllocator	access:public	signature:(void* releaseBase, size_t releaseSize, void* decommitBase, size_t decommitSize)
decommitAndRelease	.\OSAllocator.h	/^inline void OSAllocator::decommitAndRelease(void* base, size_t size)$/;"	f	class:WTF::OSAllocator	signature:(void* base, size_t size)
decommitAndRelease	.\OSAllocator.h	/^inline void OSAllocator::decommitAndRelease(void* releaseBase, size_t releaseSize, void* decommitBase, size_t decommitSize)$/;"	f	class:WTF::OSAllocator	signature:(void* releaseBase, size_t releaseSize, void* decommitBase, size_t decommitSize)
decommitted	.\FastMalloc.cpp	/^  bool decommitted : 1;$/;"	m	struct:WTF::Span	file:	access:public
decomposeDouble	.\MathExtras.h	/^inline void decomposeDouble(double number, bool& sign, int32_t& exponent, uint64_t& mantissa)$/;"	f	signature:(double number, bool& sign, int32_t& exponent, uint64_t& mantissa)
decompositionType	.\unicode\glib\UnicodeGLib.h	/^inline DecompositionType decompositionType(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
decompositionType	.\unicode\icu\UnicodeIcu.h	/^inline DecompositionType decompositionType(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
decompositionType	.\unicode\qt4\UnicodeQt4.h	/^inline DecompositionType decompositionType(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
decompositionType	.\unicode\wince\UnicodeWinCE.cpp	/^DecompositionType decompositionType(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
decompositionType	.\unicode\wince\UnicodeWinCE.h	/^DecompositionType decompositionType(UChar32);$/;"	p	namespace:WTF::Unicode	signature:(UChar32)
decrement	.\Deque.h	/^        void decrement();$/;"	p	class:WTF::DequeIteratorBase	access:protected	signature:()
decrement	.\Deque.h	/^    inline void DequeIteratorBase<T, inlineCapacity>::decrement()$/;"	f	class:WTF::DequeIteratorBase	signature:()
decrement	.\RefCountedLeakCounter.cpp	/^void RefCountedLeakCounter::decrement() { }$/;"	f	class:WTF::RefCountedLeakCounter	signature:()
decrement	.\RefCountedLeakCounter.h	/^        WTF_EXPORT_PRIVATE void decrement();$/;"	p	struct:WTF::RefCountedLeakCounter	access:public	signature:()
decrementPageOccupancy	.\MetaAllocator.cpp	/^void MetaAllocator::decrementPageOccupancy(void* address, size_t sizeInBytes)$/;"	f	class:WTF::MetaAllocator	signature:(void* address, size_t sizeInBytes)
decrementPageOccupancy	.\MetaAllocator.h	/^    void decrementPageOccupancy(void* address, size_t sizeInBytes);$/;"	p	class:WTF::MetaAllocator	access:private	signature:(void* address, size_t sizeInBytes)
defaultConverter	.\StringHasher.h	/^    static inline UChar defaultConverter(LChar ch)$/;"	f	class:WTF::StringHasher	access:private	signature:(LChar ch)
defaultConverter	.\StringHasher.h	/^    static inline UChar defaultConverter(UChar ch)$/;"	f	class:WTF::StringHasher	access:private	signature:(UChar ch)
defaultMaximumForClamp	.\MathExtras.h	/^template<typename T> inline T defaultMaximumForClamp() { return std::numeric_limits<T>::max(); }$/;"	f	signature:()
defaultMinimumForClamp	.\MathExtras.h	/^template<> inline double defaultMinimumForClamp() { return -std::numeric_limits<double>::max(); }$/;"	f	signature:()
defaultMinimumForClamp	.\MathExtras.h	/^template<> inline float defaultMinimumForClamp() { return -std::numeric_limits<float>::max(); }$/;"	f	signature:()
defaultMinimumForClamp	.\MathExtras.h	/^template<typename T> inline T defaultMinimumForClamp() { return std::numeric_limits<T>::min(); }$/;"	f	signature:()
defaultName	.\Assertions.h	/^    const char *defaultName;$/;"	m	struct:__anon2	access:public
defaultWritingDirection	.\text\StringImpl.cpp	/^WTF::Unicode::Direction StringImpl::defaultWritingDirection(bool* hasStrongDirectionality)$/;"	f	class:WTF::StringImpl	signature:(bool* hasStrongDirectionality)
defaultWritingDirection	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE WTF::Unicode::Direction defaultWritingDirection(bool* hasStrongDirectionality = 0);$/;"	p	class:WTF::StringImpl	access:public	signature:(bool* hasStrongDirectionality = 0)
defaultWritingDirection	.\text\WTFString.h	/^    WTF::Unicode::Direction defaultWritingDirection(bool* hasStrongDirectionality = 0) const$/;"	f	class:WTF::String	access:public	signature:(bool* hasStrongDirectionality = 0) const
deg2grad	.\MathExtras.h	/^inline double deg2grad(double d) { return d * 400.0 \/ 360.0; }$/;"	f	signature:(double d)
deg2grad	.\MathExtras.h	/^inline float deg2grad(float d) { return d * 400.0f \/ 360.0f; }$/;"	f	signature:(float d)
deg2rad	.\MathExtras.h	/^inline double deg2rad(double d)  { return d * piDouble \/ 180.0; }$/;"	f	signature:(double d)
deg2rad	.\MathExtras.h	/^inline float deg2rad(float d)  { return d * piFloat \/ 180.0f; }$/;"	f	signature:(float d)
deg2turn	.\MathExtras.h	/^inline double deg2turn(double d) { return d \/ 360.0; }$/;"	f	signature:(double d)
deg2turn	.\MathExtras.h	/^inline float deg2turn(float d) { return d \/ 360.0f; }$/;"	f	signature:(float d)
deleteAllKeys	.\HashMap.h	/^    inline void deleteAllKeys(const HashMap<T, U, V, W, X>& collection)$/;"	f	namespace:WTF	signature:(const HashMap<T, U, V, W, X>& collection)
deleteAllNodes	.\ListHashSet.h	/^        void deleteAllNodes();$/;"	p	class:WTF::ListHashSet	access:private	signature:()
deleteAllNodes	.\ListHashSet.h	/^    void ListHashSet<T, inlineCapacity, U>::deleteAllNodes()$/;"	f	class:WTF::ListHashSet	signature:()
deleteAllPairFirsts	.\HashMap.h	/^    void deleteAllPairFirsts(HashTableType& collection)$/;"	f	namespace:WTF	signature:(HashTableType& collection)
deleteAllPairSeconds	.\HashMap.h	/^    void deleteAllPairSeconds(HashTableType& collection)$/;"	f	namespace:WTF	signature:(HashTableType& collection)
deleteAllSegments	.\SegmentedVector.h	/^        void deleteAllSegments()$/;"	f	class:WTF::SegmentedVector	access:private	signature:()
deleteAllValues	.\Deque.h	/^    void deleteAllValues(const Deque<T, inlineCapacity>& collection)$/;"	f	namespace:WTF	signature:(const Deque<T, inlineCapacity>& collection)
deleteAllValues	.\HashMap.h	/^    inline void deleteAllValues(const HashMap<T, U, V, W, X>& collection)$/;"	f	namespace:WTF	signature:(const HashMap<T, U, V, W, X>& collection)
deleteAllValues	.\HashSet.h	/^        friend void deleteAllValues<>(const HashSet&);$/;"	p	class:WTF::HashSet	access:friend	signature:(const HashSet&)
deleteAllValues	.\HashSet.h	/^    inline void deleteAllValues(const HashSet<T, U, V>& collection)$/;"	f	namespace:WTF	signature:(const HashSet<T, U, V>& collection)
deleteAllValues	.\HashSet.h	/^    void deleteAllValues(HashTableType& collection)$/;"	f	namespace:WTF	signature:(HashTableType& collection)
deleteAllValues	.\HashSet.h	/^    void deleteAllValues(const HashSet<Value, HashFunctions, Traits>&);$/;"	p	namespace:WTF	signature:(const HashSet<Value, HashFunctions, Traits>&)
deleteAllValues	.\ListHashSet.h	/^        friend void deleteAllValues<>(const ListHashSet&);$/;"	p	class:WTF::ListHashSet	access:friend	signature:(const ListHashSet&)
deleteAllValues	.\ListHashSet.h	/^    inline void deleteAllValues(const ListHashSet<T, inlineCapacity, U>& collection)$/;"	f	namespace:WTF	signature:(const ListHashSet<T, inlineCapacity, U>& collection)
deleteAllValues	.\ListHashSet.h	/^    void deleteAllValues(HashTableType& collection)$/;"	f	namespace:WTF	signature:(HashTableType& collection)
deleteAllValues	.\ListHashSet.h	/^    void deleteAllValues(const ListHashSet<Value, inlineCapacity, HashFunctions>&);$/;"	p	namespace:WTF	signature:(const ListHashSet<Value, inlineCapacity, HashFunctions>&)
deleteAllValues	.\Vector.h	/^    void deleteAllValues(const Vector<T, inlineCapacity>& collection)$/;"	f	namespace:WTF	signature:(const Vector<T, inlineCapacity>& collection)
deleteBucket	.\HashTable.h	/^        static void deleteBucket(ValueType& bucket) { bucket.~ValueType(); Traits::constructDeletedValue(bucket); }$/;"	f	class:WTF::HashTable	access:private	signature:(ValueType& bucket)
deleteOwnedArrayPtr	.\PassOwnArrayPtr.h	/^template<typename T> inline void deleteOwnedArrayPtr(T* ptr)$/;"	f	namespace:WTF	signature:(T* ptr)
deleteOwnedArrayPtr	.\PassOwnArrayPtr.h	/^template<typename T> void deleteOwnedArrayPtr(T* ptr);$/;"	p	namespace:WTF	signature:(T* ptr)
deleteOwnedPtr	.\OwnPtrCommon.h	/^    template <typename T> inline void deleteOwnedPtr(T* ptr)$/;"	f	namespace:WTF	signature:(T* ptr)
deleteOwnedPtr	.\OwnPtrCommon.h	/^    void deleteOwnedPtr(Ecore_Evas*);$/;"	p	namespace:WTF	signature:(Ecore_Evas*)
deleteOwnedPtr	.\OwnPtrCommon.h	/^    void deleteOwnedPtr(Ecore_Pipe*);$/;"	p	namespace:WTF	signature:(Ecore_Pipe*)
deleteOwnedPtr	.\OwnPtrCommon.h	/^    void deleteOwnedPtr(Ecore_Timer*);$/;"	p	namespace:WTF	signature:(Ecore_Timer*)
deleteOwnedPtr	.\OwnPtrCommon.h	/^    void deleteOwnedPtr(Eina_Module*);$/;"	p	namespace:WTF	signature:(Eina_Module*)
deleteOwnedPtr	.\OwnPtrCommon.h	/^    void deleteOwnedPtr(Evas_Object*);$/;"	p	namespace:WTF	signature:(Evas_Object*)
deleteOwnedPtr	.\OwnPtrCommon.h	/^    void deleteOwnedPtr(HBITMAP);$/;"	p	namespace:WTF	signature:(HBITMAP)
deleteOwnedPtr	.\OwnPtrCommon.h	/^    void deleteOwnedPtr(HBRUSH);$/;"	p	namespace:WTF	signature:(HBRUSH)
deleteOwnedPtr	.\OwnPtrCommon.h	/^    void deleteOwnedPtr(HDC);$/;"	p	namespace:WTF	signature:(HDC)
deleteOwnedPtr	.\OwnPtrCommon.h	/^    void deleteOwnedPtr(HFONT);$/;"	p	namespace:WTF	signature:(HFONT)
deleteOwnedPtr	.\OwnPtrCommon.h	/^    void deleteOwnedPtr(HPALETTE);$/;"	p	namespace:WTF	signature:(HPALETTE)
deleteOwnedPtr	.\OwnPtrCommon.h	/^    void deleteOwnedPtr(HPEN);$/;"	p	namespace:WTF	signature:(HPEN)
deleteOwnedPtr	.\OwnPtrCommon.h	/^    void deleteOwnedPtr(HRGN);$/;"	p	namespace:WTF	signature:(HRGN)
deleteOwnedPtr	.\efl\OwnPtrEfl.cpp	/^void deleteOwnedPtr(Ecore_Evas* ptr)$/;"	f	namespace:WTF	signature:(Ecore_Evas* ptr)
deleteOwnedPtr	.\efl\OwnPtrEfl.cpp	/^void deleteOwnedPtr(Ecore_Pipe* ptr)$/;"	f	namespace:WTF	signature:(Ecore_Pipe* ptr)
deleteOwnedPtr	.\efl\OwnPtrEfl.cpp	/^void deleteOwnedPtr(Ecore_Timer* ptr)$/;"	f	namespace:WTF	signature:(Ecore_Timer* ptr)
deleteOwnedPtr	.\efl\OwnPtrEfl.cpp	/^void deleteOwnedPtr(Eina_Module* ptr)$/;"	f	namespace:WTF	signature:(Eina_Module* ptr)
deleteOwnedPtr	.\efl\OwnPtrEfl.cpp	/^void deleteOwnedPtr(Evas_Object* ptr)$/;"	f	namespace:WTF	signature:(Evas_Object* ptr)
deleteOwnedPtr	.\win\OwnPtrWin.cpp	/^void deleteOwnedPtr(HBITMAP ptr)$/;"	f	namespace:WTF	signature:(HBITMAP ptr)
deleteOwnedPtr	.\win\OwnPtrWin.cpp	/^void deleteOwnedPtr(HBRUSH ptr)$/;"	f	namespace:WTF	signature:(HBRUSH ptr)
deleteOwnedPtr	.\win\OwnPtrWin.cpp	/^void deleteOwnedPtr(HDC ptr)$/;"	f	namespace:WTF	signature:(HDC ptr)
deleteOwnedPtr	.\win\OwnPtrWin.cpp	/^void deleteOwnedPtr(HFONT ptr)$/;"	f	namespace:WTF	signature:(HFONT ptr)
deleteOwnedPtr	.\win\OwnPtrWin.cpp	/^void deleteOwnedPtr(HPALETTE ptr)$/;"	f	namespace:WTF	signature:(HPALETTE ptr)
deleteOwnedPtr	.\win\OwnPtrWin.cpp	/^void deleteOwnedPtr(HPEN ptr)$/;"	f	namespace:WTF	signature:(HPEN ptr)
deleteOwnedPtr	.\win\OwnPtrWin.cpp	/^void deleteOwnedPtr(HRGN ptr)$/;"	f	namespace:WTF	signature:(HRGN ptr)
deletionHasBegun	.\RefCounted.h	/^    bool deletionHasBegun() const$/;"	f	class:WTF::RefCountedBase	access:protected	signature:() const
depth	.\AVLTree.h	/^        unsigned depth;$/;"	m	class:WTF::AVLTree::Iterator	access:protected
depth	.\FastMalloc.cpp	/^  uintptr_t depth;         \/\/ Number of PC values stored in array below$/;"	m	struct:WTF::StackTrace	file:	access:public
deref	.\ByteArray.h	/^        void deref()$/;"	f	class:WTF::ByteArray	access:public	signature:()
deref	.\Functional.h	/^        void deref();$/;"	p	struct:WTF::HasRefAndDeref::BaseMixin	access:public	signature:()
deref	.\Functional.h	/^    static void deref(T) { }$/;"	f	struct:WTF::RefAndDeref	access:public	signature:(T)
deref	.\Functional.h	/^    static void deref(T* t) { t->deref(); }$/;"	f	struct:WTF::RefAndDeref	access:public	signature:(T* t)
deref	.\RefCounted.h	/^    void deref()$/;"	f	class:WTF::RefCounted	access:public	signature:()
deref	.\RefCounted.h	/^    void deref()$/;"	f	class:WTF::RefCountedCustomAllocated	access:public	signature:()
deref	.\ThreadSafeRefCounted.h	/^    void deref()$/;"	f	class:WTF::ThreadSafeRefCounted	access:public	signature:()
deref	.\text\StringImpl.h	/^    inline void deref()$/;"	f	class:WTF::StringImpl	access:public	signature:()
derefBase	.\RefCounted.h	/^    bool derefBase()$/;"	f	class:WTF::RefCountedBase	access:protected	signature:()
derefBase	.\ThreadSafeRefCounted.h	/^    bool derefBase()$/;"	f	class:WTF::ThreadSafeRefCountedBase	access:protected	signature:()
derefCheck	.\Functional.h	/^    static NoType derefCheck(U*, TypeChecker<void (BaseMixin::*)(), &U::deref>* = 0);$/;"	p	class:WTF::HasRefAndDeref	access:private	signature:(U*, TypeChecker<void (BaseMixin::*)(), &U::deref>* = 0)
derefCheck	.\Functional.h	/^    static YesType derefCheck(...);$/;"	p	class:WTF::HasRefAndDeref	access:private	signature:(....)
derefGPtr	.\gobject\GRefPtr.cpp	/^template <> void derefGPtr(GHashTable* ptr)$/;"	f	namespace:WTF	signature:(GHashTable* ptr)
derefGPtr	.\gobject\GRefPtr.cpp	/^template <> void derefGPtr(GMainContext* ptr)$/;"	f	namespace:WTF	signature:(GMainContext* ptr)
derefGPtr	.\gobject\GRefPtr.cpp	/^template <> void derefGPtr(GMainLoop* ptr)$/;"	f	namespace:WTF	signature:(GMainLoop* ptr)
derefGPtr	.\gobject\GRefPtr.cpp	/^template <> void derefGPtr(GSource* ptr)$/;"	f	namespace:WTF	signature:(GSource* ptr)
derefGPtr	.\gobject\GRefPtr.cpp	/^template <> void derefGPtr(GVariant* ptr)$/;"	f	namespace:WTF	signature:(GVariant* ptr)
derefGPtr	.\gobject\GRefPtr.h	/^template <> void derefGPtr(GHashTable* ptr);$/;"	p	namespace:WTF	signature:(GHashTable* ptr)
derefGPtr	.\gobject\GRefPtr.h	/^template <> void derefGPtr(GMainContext* ptr);$/;"	p	namespace:WTF	signature:(GMainContext* ptr)
derefGPtr	.\gobject\GRefPtr.h	/^template <> void derefGPtr(GMainLoop* ptr);$/;"	p	namespace:WTF	signature:(GMainLoop* ptr)
derefGPtr	.\gobject\GRefPtr.h	/^template <> void derefGPtr(GSource* ptr);$/;"	p	namespace:WTF	signature:(GSource* ptr)
derefGPtr	.\gobject\GRefPtr.h	/^template <> void derefGPtr(GVariant* ptr);$/;"	p	namespace:WTF	signature:(GVariant* ptr)
derefGPtr	.\gobject\GRefPtr.h	/^template <typename T> inline void derefGPtr(T* ptr)$/;"	f	namespace:WTF	signature:(T* ptr)
derefGPtr	.\gobject\GRefPtr.h	/^template <typename T> inline void derefGPtr(T*);$/;"	p	namespace:WTF	signature:(T*)
derefIfNotNull	.\PassRefPtr.h	/^    template<typename T> REF_DEREF_INLINE void derefIfNotNull(T* ptr)$/;"	f	namespace:WTF	signature:(T* ptr)
destroy	.\BitVector.cpp	/^void BitVector::OutOfLineBits::destroy(OutOfLineBits* outOfLineBits)$/;"	f	class:WTF::BitVector::OutOfLineBits	signature:(OutOfLineBits* outOfLineBits)
destroy	.\BitVector.h	/^        static void destroy(OutOfLineBits*);$/;"	p	class:WTF::BitVector::OutOfLineBits	access:public	signature:(OutOfLineBits*)
destroy	.\BumpPointerAllocator.h	/^    void destroy()$/;"	f	class:WTF::BumpPointerPool	access:private	signature:()
destroy	.\ListHashSet.h	/^        void destroy(NodeAllocator* allocator)$/;"	f	struct:WTF::ListHashSetNode	access:public	signature:(NodeAllocator* allocator)
destroy	.\ThreadSpecific.h	/^    void static destroy(void* ptr);$/;"	p	class:WTF::ThreadSpecific	access:private	signature:(void* ptr)
destroy	.\ThreadSpecific.h	/^inline void ThreadSpecific<T>::destroy(void* ptr)$/;"	f	class:WTF::ThreadSpecific	signature:(void* ptr)
destroy	.\text\AtomicString.cpp	/^    static void destroy(AtomicStringTable* table)$/;"	f	class:WTF::AtomicStringTable	file:	access:private	signature:(AtomicStringTable* table)
destroyAll	.\Deque.h	/^        void destroyAll();$/;"	p	class:WTF::Deque	access:private	signature:()
destroyAll	.\Deque.h	/^    inline void Deque<T, inlineCapacity>::destroyAll()$/;"	f	class:WTF::Deque	signature:()
destruct	.\ThreadIdentifierDataPthreads.cpp	/^void ThreadIdentifierData::destruct(void* data)$/;"	f	class:WTF::ThreadIdentifierData	signature:(void* data)
destruct	.\ThreadIdentifierDataPthreads.h	/^    static void destruct(void* data);$/;"	p	class:WTF::ThreadIdentifierData	access:private	signature:(void* data)
destruct	.\Vector.h	/^        static void destruct(T* begin, T* end) $/;"	f	struct:WTF::VectorDestructor	access:public	signature:(T* begin, T* end)
destruct	.\Vector.h	/^        static void destruct(T* begin, T* end)$/;"	f	struct:WTF::VectorTypeOperations	access:public	signature:(T* begin, T* end)
destruct	.\Vector.h	/^        static void destruct(T*, T*) {}$/;"	f	struct:WTF::VectorDestructor	access:public	signature:(T*, T*)
destructor	.\ThreadSpecific.h	/^        void (*destructor)(void*);$/;"	m	struct:WTF::ThreadSpecific::Data	access:public
detachThread	.\Threading.h	/^WTF_EXPORT_PRIVATE void detachThread(ThreadIdentifier);$/;"	p	namespace:WTF	signature:(ThreadIdentifier)
detachThread	.\ThreadingPthreads.cpp	/^void detachThread(ThreadIdentifier threadID)$/;"	f	namespace:WTF	signature:(ThreadIdentifier threadID)
detachThread	.\ThreadingWin.cpp	/^void detachThread(ThreadIdentifier threadID)$/;"	f	namespace:WTF	signature:(ThreadIdentifier threadID)
detectGrowingDownward	.\StackBounds.cpp	/^static bool detectGrowingDownward(void* previousFrame)$/;"	f	namespace:WTF	file:	signature:(void* previousFrame)
devmem_failure	.\TCSystemAlloc.cpp	/^static bool devmem_failure = false;$/;"	v	file:
diff	.\dtoa.cpp	/^static ALWAYS_INLINE void diff(BigInt& c, const BigInt& aRef, const BigInt& bRef)$/;"	f	namespace:WTF	file:	signature:(BigInt& c, const BigInt& aRef, const BigInt& bRef)
digitValue	.\unicode\glib\UnicodeGLib.h	/^inline int digitValue(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
digitValue	.\unicode\qt4\UnicodeQt4.h	/^        signed short digitValue : 6; \/* 5 needed *\/$/;"	m	struct:QUnicodeTables::Properties	access:public
digitValue	.\unicode\wince\UnicodeWinCE.cpp	/^int digitValue(UChar c)$/;"	f	namespace:WTF::Unicode	signature:(UChar c)
digitValue	.\unicode\wince\UnicodeWinCE.h	/^int digitValue(UChar);$/;"	p	namespace:WTF::Unicode	signature:(UChar)
direction	.\unicode\glib\UnicodeGLib.cpp	/^Direction direction(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
direction	.\unicode\glib\UnicodeGLib.h	/^Direction direction(UChar32);$/;"	p	namespace:WTF::Unicode	signature:(UChar32)
direction	.\unicode\icu\UnicodeIcu.h	/^inline Direction direction(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
direction	.\unicode\qt4\UnicodeQt4.h	/^        ushort direction : 8;$/;"	m	struct:QUnicodeTables::Properties	access:public
direction	.\unicode\qt4\UnicodeQt4.h	/^inline Direction direction(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
direction	.\unicode\wince\UnicodeWinCE.cpp	/^Direction direction(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
direction	.\unicode\wince\UnicodeWinCE.h	/^Direction direction(UChar32);$/;"	p	namespace:WTF::Unicode	signature:(UChar32)
dispatchFunctionsFromMainThread	.\MainThread.cpp	/^void dispatchFunctionsFromMainThread()$/;"	f	namespace:WTF	signature:()
dispatchFunctionsFromMainThread	.\MainThread.h	/^void dispatchFunctionsFromMainThread();$/;"	p	namespace:WTF	signature:()
do_free	.\FastMalloc.cpp	/^static ALWAYS_INLINE void do_free(void* ptr) {$/;"	f	namespace:WTF	file:	signature:(void* ptr)
do_mallinfo	.\FastMalloc.cpp	/^static inline struct mallinfo do_mallinfo() {$/;"	f	namespace:WTF	file:	signature:()
do_malloc	.\FastMalloc.cpp	/^static ALWAYS_INLINE void* do_malloc(size_t size) {$/;"	f	namespace:WTF	file:	signature:(size_t size)
do_malloc	.\FastMalloc.cpp	3860;"	d	file:
do_malloc	.\FastMalloc.cpp	4105;"	d	file:
do_malloc_stats	.\FastMalloc.cpp	/^static inline void do_malloc_stats() {$/;"	f	namespace:WTF	file:	signature:()
do_mallopt	.\FastMalloc.cpp	/^static inline int do_mallopt(int, int) {$/;"	f	namespace:WTF	file:	signature:(int, int)
do_memalign	.\FastMalloc.cpp	/^static void* do_memalign(size_t align, size_t size) {$/;"	f	namespace:WTF	file:	signature:(size_t align, size_t size)
doubleHash	.\HashTable.h	/^    inline unsigned doubleHash(unsigned key)$/;"	f	namespace:WTF	signature:(unsigned key)
doubleToInteger	.\MathExtras.h	/^inline void doubleToInteger(double d, unsigned long long& value)$/;"	f	signature:(double d, unsigned long long& value)
double_conversion	.\dtoa\bignum-dtoa.cc	/^namespace double_conversion {$/;"	n	namespace:WTF	file:
double_conversion	.\dtoa\bignum-dtoa.h	/^namespace double_conversion {$/;"	n	namespace:WTF
double_conversion	.\dtoa\bignum.cc	/^namespace double_conversion {$/;"	n	namespace:WTF	file:
double_conversion	.\dtoa\bignum.h	/^namespace double_conversion {$/;"	n	namespace:WTF
double_conversion	.\dtoa\cached-powers.cc	/^namespace double_conversion {$/;"	n	namespace:WTF	file:
double_conversion	.\dtoa\cached-powers.h	/^namespace double_conversion {$/;"	n	namespace:WTF
double_conversion	.\dtoa\diy-fp.cc	/^namespace double_conversion {$/;"	n	namespace:WTF	file:
double_conversion	.\dtoa\diy-fp.h	/^namespace double_conversion {$/;"	n	namespace:WTF
double_conversion	.\dtoa\double-conversion.cc	/^namespace double_conversion {$/;"	n	namespace:WTF	file:
double_conversion	.\dtoa\double-conversion.h	/^namespace double_conversion {$/;"	n	namespace:WTF
double_conversion	.\dtoa\double.h	/^namespace double_conversion {$/;"	n	namespace:WTF
double_conversion	.\dtoa\fast-dtoa.cc	/^namespace double_conversion {$/;"	n	namespace:WTF	file:
double_conversion	.\dtoa\fast-dtoa.h	/^namespace double_conversion {$/;"	n	namespace:WTF
double_conversion	.\dtoa\fixed-dtoa.cc	/^namespace double_conversion {$/;"	n	namespace:WTF	file:
double_conversion	.\dtoa\fixed-dtoa.h	/^namespace double_conversion {$/;"	n	namespace:WTF
double_conversion	.\dtoa\strtod.cc	/^namespace double_conversion {$/;"	n	namespace:WTF	file:
double_conversion	.\dtoa\strtod.h	/^namespace double_conversion {$/;"	n	namespace:WTF
double_conversion	.\dtoa\utils.h	/^namespace double_conversion {$/;"	n	namespace:WTF
double_to_uint64	.\dtoa\double.h	/^    static uint64_t double_to_uint64(double d) { return BitCast<uint64_t>(d); }$/;"	f	namespace:WTF::double_conversion	signature:(double d)
dtoa	.\dtoa.cpp	/^void dtoa(DtoaBuffer result, double dd, bool& sign, int& exponent, unsigned& precision)$/;"	f	namespace:WTF	signature:(DtoaBuffer result, double dd, bool& sign, int& exponent, unsigned& precision)
dtoa	.\dtoa.cpp	/^void dtoa(DtoaBuffer result, double dd, int ndigits, bool& signOut, int& exponentOut, unsigned& precisionOut)$/;"	f	namespace:WTF	signature:(DtoaBuffer result, double dd, int ndigits, bool& signOut, int& exponentOut, unsigned& precisionOut)
dtoa	.\dtoa.h	/^WTF_EXPORT_PRIVATE void dtoa(DtoaBuffer result, double dd, bool& sign, int& exponent, unsigned& precision);$/;"	p	namespace:WTF	signature:(DtoaBuffer result, double dd, bool& sign, int& exponent, unsigned& precision)
dtoaRoundDP	.\dtoa.cpp	/^void dtoaRoundDP(DtoaBuffer result, double dd, int ndigits, bool& sign, int& exponent, unsigned& precision)$/;"	f	namespace:WTF	signature:(DtoaBuffer result, double dd, int ndigits, bool& sign, int& exponent, unsigned& precision)
dtoaRoundDP	.\dtoa.h	/^WTF_EXPORT_PRIVATE void dtoaRoundDP(DtoaBuffer result, double dd, int ndigits, bool& sign, int& exponent, unsigned& precision);$/;"	p	namespace:WTF	signature:(DtoaBuffer result, double dd, int ndigits, bool& sign, int& exponent, unsigned& precision)
dtoaRoundSF	.\dtoa.cpp	/^void dtoaRoundSF(DtoaBuffer result, double dd, int ndigits, bool& sign, int& exponent, unsigned& precision)$/;"	f	namespace:WTF	signature:(DtoaBuffer result, double dd, int ndigits, bool& sign, int& exponent, unsigned& precision)
dtoaRoundSF	.\dtoa.h	/^WTF_EXPORT_PRIVATE void dtoaRoundSF(DtoaBuffer result, double dd, int ndigits, bool& sign, int& exponent, unsigned& precision);$/;"	p	namespace:WTF	signature:(DtoaBuffer result, double dd, int ndigits, bool& sign, int& exponent, unsigned& precision)
dump	.\BitVector.cpp	/^void BitVector::dump(FILE* out)$/;"	f	class:WTF::BitVector	signature:(FILE* out)
dump	.\BitVector.h	/^    void dump(FILE* out);$/;"	p	class:WTF::BitVector	access:public	signature:(FILE* out)
dumpProfile	.\MetaAllocator.cpp	/^void MetaAllocator::dumpProfile()$/;"	f	class:WTF::MetaAllocator	signature:()
dumpProfile	.\MetaAllocator.h	/^    void dumpProfile() { }$/;"	f	class:WTF::MetaAllocator	access:public	signature:()
dumpProfile	.\MetaAllocator.h	/^    void dumpProfile();$/;"	p	class:WTF::MetaAllocator	access:public	signature:()
dval	.\dtoa.cpp	107;"	d	file:
dwFlags	.\ThreadingWin.cpp	/^    DWORD dwFlags; \/\/ reserved for future use, must be zero$/;"	m	struct:WTF::tagTHREADNAME_INFO	file:	access:public
dwThreadID	.\ThreadingWin.cpp	/^    DWORD dwThreadID; \/\/ thread ID (-1=caller thread)$/;"	m	struct:WTF::tagTHREADNAME_INFO	file:	access:public
dwType	.\ThreadingWin.cpp	/^    DWORD dwType; \/\/ must be 0x1000$/;"	m	struct:WTF::tagTHREADNAME_INFO	file:	access:public
e	.\dtoa\diy-fp.h	/^        int e() const { return e_; }$/;"	f	class:WTF::double_conversion::DiyFp	access:public	signature:() const
e_	.\dtoa\diy-fp.h	/^        int e_;$/;"	m	class:WTF::double_conversion::DiyFp	access:private
empty	.\FastMalloc.cpp	/^  bool empty() const {$/;"	f	class:WTF::TCMalloc_ThreadCache_FreeList	access:public	signature:() const
empty	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE static StringImpl* empty();$/;"	p	class:WTF::StringImpl	access:public	signature:()
empty	.\text\StringStatics.cpp	/^StringImpl* StringImpl::empty()$/;"	f	class:WTF::StringImpl	signature:()
emptyString	.\text\WTFString.cpp	/^const String& emptyString()$/;"	f	namespace:WTF	signature:()
emptyString	.\text\WTFString.h	/^WTF_EXPORT_PRIVATE const String& emptyString();$/;"	p	namespace:WTF	signature:()
emptyValue	.\HashTraits.h	/^        static EmptyValueType emptyValue() { return make_pair(FirstTraits::emptyValue(), SecondTraits::emptyValue()); }$/;"	f	struct:WTF::PairHashTraits	access:public	signature:()
emptyValue	.\HashTraits.h	/^        static EmptyValueType emptyValue() { return nullptr; }$/;"	f	struct:WTF::HashTraits	access:public	signature:()
emptyValue	.\HashTraits.h	/^        static T emptyValue() { return T(); }$/;"	f	struct:WTF::GenericHashTraits	access:public	signature:()
emptyValue	.\HashTraits.h	/^        static T emptyValue() { return std::numeric_limits<T>::infinity(); }$/;"	f	struct:WTF::FloatHashTraits	access:public	signature:()
emptyValue	.\HashTraits.h	/^        static T emptyValue() { return std::numeric_limits<T>::max(); }$/;"	f	struct:WTF::UnsignedWithZeroKeyHashTraits	access:public	signature:()
emptyValueIsZero	.\HashTraits.h	/^        static const bool emptyValueIsZero = FirstTraits::emptyValueIsZero && SecondTraits::emptyValueIsZero;$/;"	m	struct:WTF::PairHashTraits	access:public
emptyValueIsZero	.\HashTraits.h	/^        static const bool emptyValueIsZero = false;$/;"	m	struct:WTF::GenericHashTraitsBase	access:public
emptyValueIsZero	.\HashTraits.h	/^        static const bool emptyValueIsZero = false;$/;"	m	struct:WTF::UnsignedWithZeroKeyHashTraits	access:public
emptyValueIsZero	.\HashTraits.h	/^        static const bool emptyValueIsZero = true;$/;"	m	struct:WTF::GenericHashTraitsBase	access:public
emptyValueIsZero	.\HashTraits.h	/^        static const bool emptyValueIsZero = true;$/;"	m	struct:WTF::HashTraits	access:public
emptyValueIsZero	.\HashTraits.h	/^        static const bool emptyValueIsZero = true;$/;"	m	struct:WTF::SimpleClassHashTraits	access:public
emptyValueIsZero	.\text\AtomicStringHash.h	/^        static const bool emptyValueIsZero = true;$/;"	m	struct:WTF::HashTraits	access:public
empty_	.\FastMalloc.cpp	/^  Span     empty_;          \/\/ Dummy header for list of empty spans$/;"	m	class:WTF::TCMalloc_Central_FreeList	file:	access:private
empty_string_value_	.\dtoa\double-conversion.h	/^        const double empty_string_value_;$/;"	m	class:WTF::double_conversion::StringToDoubleConverter	access:private
encodeBool	.\Encoder.h	/^    virtual void encodeBool(bool) = 0;$/;"	p	class:WTF::Encoder	access:public	signature:(bool)
encodeBytes	.\Encoder.h	/^    virtual void encodeBytes(const uint8_t*, size_t) = 0;$/;"	p	class:WTF::Encoder	access:public	signature:(const uint8_t*, size_t)
encodeDouble	.\Encoder.h	/^    virtual void encodeDouble(double) = 0;$/;"	p	class:WTF::Encoder	access:public	signature:(double)
encodeFloat	.\Encoder.h	/^    virtual void encodeFloat(float) = 0;$/;"	p	class:WTF::Encoder	access:public	signature:(float)
encodeInt32	.\Encoder.h	/^    virtual void encodeInt32(int32_t) = 0;$/;"	p	class:WTF::Encoder	access:public	signature:(int32_t)
encodeInt64	.\Encoder.h	/^    virtual void encodeInt64(int64_t) = 0;$/;"	p	class:WTF::Encoder	access:public	signature:(int64_t)
encodeString	.\Encoder.h	/^    virtual void encodeString(const String&) = 0;$/;"	p	class:WTF::Encoder	access:public	signature:(const String&)
encodeUInt32	.\Encoder.h	/^    virtual void encodeUInt32(uint32_t) = 0;$/;"	p	class:WTF::Encoder	access:public	signature:(uint32_t)
encodeUInt64	.\Encoder.h	/^    virtual void encodeUInt64(uint64_t) = 0;$/;"	p	class:WTF::Encoder	access:public	signature:(uint64_t)
end	.\Deque.h	/^        const_iterator end() const { return const_iterator(this, m_end); }$/;"	f	class:WTF::Deque	access:public	signature:() const
end	.\Deque.h	/^        iterator end() { return iterator(this, m_end); }$/;"	f	class:WTF::Deque	access:public	signature:()
end	.\HashCountedSet.h	/^        const_iterator end() const;$/;"	p	class:WTF::HashCountedSet	access:public	signature:() const
end	.\HashCountedSet.h	/^        iterator end();$/;"	p	class:WTF::HashCountedSet	access:public	signature:()
end	.\HashCountedSet.h	/^    inline typename HashCountedSet<Value, HashFunctions, Traits>::const_iterator HashCountedSet<Value, HashFunctions, Traits>::end() const$/;"	f	class:WTF::HashCountedSet	signature:() const
end	.\HashCountedSet.h	/^    inline typename HashCountedSet<Value, HashFunctions, Traits>::iterator HashCountedSet<Value, HashFunctions, Traits>::end()$/;"	f	class:WTF::HashCountedSet	signature:()
end	.\HashMap.h	/^            const_iterator end() const$/;"	f	class:WTF::HashMap::HashMapKeysProxy	access:public	signature:() const
end	.\HashMap.h	/^            const_iterator end() const$/;"	f	class:WTF::HashMap::HashMapValuesProxy	access:public	signature:() const
end	.\HashMap.h	/^            iterator end()$/;"	f	class:WTF::HashMap::HashMapKeysProxy	access:public	signature:()
end	.\HashMap.h	/^            iterator end()$/;"	f	class:WTF::HashMap::HashMapValuesProxy	access:public	signature:()
end	.\HashMap.h	/^        const_iterator end() const;$/;"	p	class:WTF::HashMap	access:public	signature:() const
end	.\HashMap.h	/^        iterator end();$/;"	p	class:WTF::HashMap	access:public	signature:()
end	.\HashMap.h	/^    inline typename HashMap<T, U, V, W, X>::const_iterator HashMap<T, U, V, W, X>::end() const$/;"	f	class:WTF::HashMap	signature:() const
end	.\HashMap.h	/^    inline typename HashMap<T, U, V, W, X>::iterator HashMap<T, U, V, W, X>::end()$/;"	f	class:WTF::HashMap	signature:()
end	.\HashSet.h	/^        iterator end() const;$/;"	p	class:WTF::HashSet	access:public	signature:() const
end	.\HashSet.h	/^    inline typename HashSet<T, U, V>::iterator HashSet<T, U, V>::end() const$/;"	f	class:WTF::HashSet	signature:() const
end	.\HashTable.h	/^        const_iterator end() const { return makeKnownGoodConstIterator(m_table + m_tableSize); }$/;"	f	class:WTF::HashTable	access:public	signature:() const
end	.\HashTable.h	/^        iterator end() { return makeKnownGoodIterator(m_table + m_tableSize); }$/;"	f	class:WTF::HashTable	access:public	signature:()
end	.\ListHashSet.h	/^        const_iterator end() const;$/;"	p	class:WTF::ListHashSet	access:public	signature:() const
end	.\ListHashSet.h	/^        iterator end();$/;"	p	class:WTF::ListHashSet	access:public	signature:()
end	.\ListHashSet.h	/^    inline typename ListHashSet<T, inlineCapacity, U>::const_iterator ListHashSet<T, inlineCapacity, U>::end() const$/;"	f	class:WTF::ListHashSet	signature:() const
end	.\ListHashSet.h	/^    inline typename ListHashSet<T, inlineCapacity, U>::iterator ListHashSet<T, inlineCapacity, U>::end()$/;"	f	class:WTF::ListHashSet	signature:()
end	.\MetaAllocatorHandle.h	/^    void* end()$/;"	f	class:WTF::MetaAllocatorHandle	access:public	signature:()
end	.\RefCountedArray.h	/^    T* end()$/;"	f	class:WTF::RefCountedArray	access:public	signature:()
end	.\RefCountedArray.h	/^    const T* end() const { return const_cast<RefCountedArray*>(this)->end(); }$/;"	f	class:WTF::RefCountedArray	access:public	signature:() const
end	.\RefPtrHashMap.h	/^        const_iterator end() const;$/;"	p	class:WTF::HashMap	access:public	signature:() const
end	.\RefPtrHashMap.h	/^        iterator end();$/;"	p	class:WTF::HashMap	access:public	signature:()
end	.\RefPtrHashMap.h	/^    inline typename HashMap<RefPtr<T>, U, V, W, X>::const_iterator HashMap<RefPtr<T>, U, V, W, X>::end() const$/;"	f	class:WTF::HashMap	signature:() const
end	.\RefPtrHashMap.h	/^    inline typename HashMap<RefPtr<T>, U, V, W, X>::iterator HashMap<RefPtr<T>, U, V, W, X>::end()$/;"	f	class:WTF::HashMap	signature:()
end	.\SegmentedVector.h	/^        Iterator end()$/;"	f	class:WTF::SegmentedVector	access:public	signature:()
end	.\SentinelLinkedList.h	/^    iterator end();$/;"	p	class:WTF::SentinelLinkedList	access:public	signature:()
end	.\SentinelLinkedList.h	/^template <typename T, typename RawNode> inline typename SentinelLinkedList<T, RawNode>::iterator SentinelLinkedList<T, RawNode>::end()$/;"	f	class:WTF::SentinelLinkedList	signature:()
end	.\Spectrum.h	/^    const_iterator end() const { return m_map.end(); }$/;"	f	class:WTF::Spectrum	access:public	signature:() const
end	.\Spectrum.h	/^    iterator end() { return m_map.end(); }$/;"	f	class:WTF::Spectrum	access:public	signature:()
end	.\Vector.h	/^            const_iterator end() const { return Vector::rend(); }$/;"	f	class:WTF::Vector::VectorReverseProxy	access:public	signature:() const
end	.\Vector.h	/^            iterator end() { return Vector::rend(); }$/;"	f	class:WTF::Vector::VectorReverseProxy	access:public	signature:()
end	.\Vector.h	/^        const_iterator end() const { return begin() + m_size; }$/;"	f	class:WTF::Vector	access:public	signature:() const
end	.\Vector.h	/^        iterator end() { return begin() + m_size; }$/;"	f	class:WTF::Vector	access:public	signature:()
end	.\url\src\URLComponent.h	/^    int end() const { return m_begin + m_length; }$/;"	f	class:WTF::URLComponent	access:public	signature:() const
endsWith	.\text\AtomicString.h	/^    bool endsWith(const String& s, bool caseSensitive = true) const$/;"	f	class:WTF::AtomicString	access:public	signature:(const String& s, bool caseSensitive = true) const
endsWith	.\text\StringImpl.cpp	/^bool StringImpl::endsWith(StringImpl* matchString, bool caseSensitive)$/;"	f	class:WTF::StringImpl	signature:(StringImpl* matchString, bool caseSensitive)
endsWith	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE bool endsWith(StringImpl*, bool caseSensitive = true);$/;"	p	class:WTF::StringImpl	access:public	signature:(StringImpl*, bool caseSensitive = true)
endsWith	.\text\WTFString.h	/^    bool endsWith(const String& s, bool caseSensitive = true) const$/;"	f	class:WTF::String	access:public	signature:(const String& s, bool caseSensitive = true) const
ensureCapacity	.\BumpPointerAllocator.h	/^    BumpPointerPool* ensureCapacity(size_t size)$/;"	f	class:WTF::BumpPointerPool	access:public	signature:(size_t size)
ensureCapacityCrossPool	.\BumpPointerAllocator.h	/^    static BumpPointerPool* ensureCapacityCrossPool(BumpPointerPool* previousPool, size_t size)$/;"	f	class:WTF::BumpPointerPool	access:private	signature:(BumpPointerPool* previousPool, size_t size)
ensureSegment	.\SegmentedVector.h	/^        void ensureSegment(size_t segmentIndex, size_t size)$/;"	f	class:WTF::SegmentedVector	access:private	signature:(size_t segmentIndex, size_t size)
ensureSegmentsFor	.\SegmentedVector.h	/^        void ensureSegmentsFor(size_t size)$/;"	f	class:WTF::SegmentedVector	access:private	signature:(size_t size)
ensureSize	.\BitVector.h	/^    void ensureSize(size_t numBits)$/;"	f	class:WTF::BitVector	access:public	signature:(size_t numBits)
ensureSize	.\PackedIntVector.h	/^    void ensureSize(size_t numInts)$/;"	f	class:WTF::PackedIntVector	access:public	signature:(size_t numInts)
entryPoint	.\Threading.cpp	/^    ThreadFunction entryPoint;$/;"	m	struct:WTF::NewThreadContext	file:	access:public
enumerate	.\FastMalloc.cpp	/^    static kern_return_t enumerate(task_t, void*, unsigned typeMmask, vm_address_t zoneAddress, memory_reader_t, vm_range_recorder_t);$/;"	p	class:WTF::FastMallocZone	file:	access:public	signature:(task_t, void*, unsigned typeMmask, vm_address_t zoneAddress, memory_reader_t, vm_range_recorder_t)
enumerate	.\FastMalloc.cpp	/^kern_return_t FastMallocZone::enumerate(task_t task, void* context, unsigned typeMask, vm_address_t zoneAddress, memory_reader_t reader, vm_range_recorder_t recorder)$/;"	f	class:WTF::FastMallocZone	signature:(task_t task, void* context, unsigned typeMask, vm_address_t zoneAddress, memory_reader_t reader, vm_range_recorder_t recorder)
enumerateFreeObjects	.\FastMalloc.cpp	/^  void enumerateFreeObjects(Finder& finder, const Reader& reader)$/;"	f	class:WTF::TCMalloc_ThreadCache	access:public	signature:(Finder& finder, const Reader& reader)
enumerateFreeObjects	.\FastMalloc.cpp	/^  void enumerateFreeObjects(Finder& finder, const Reader& reader)$/;"	f	class:WTF::TCMalloc_ThreadCache_FreeList	access:public	signature:(Finder& finder, const Reader& reader)
enumerateFreeObjects	.\FastMalloc.cpp	/^  void enumerateFreeObjects(Finder& finder, const Reader& reader, TCMalloc_Central_FreeList* remoteCentralFreeList)$/;"	f	class:WTF::TCMalloc_Central_FreeList	access:public	signature:(Finder& finder, const Reader& reader, TCMalloc_Central_FreeList* remoteCentralFreeList)
equal	.\HashFunctions.h	/^        static bool equal(P* a, const RefPtr<P>& b) { return a == b; }$/;"	f	struct:WTF::PtrHash	access:public	signature:(P* a, const RefPtr<P>& b)
equal	.\HashFunctions.h	/^        static bool equal(T a, T b) { return a == b; }$/;"	f	struct:WTF::FloatHash	access:public	signature:(T a, T b)
equal	.\HashFunctions.h	/^        static bool equal(T a, T b) { return a == b; }$/;"	f	struct:WTF::IntHash	access:public	signature:(T a, T b)
equal	.\HashFunctions.h	/^        static bool equal(T a, T b) { return a == b; }$/;"	f	struct:WTF::PtrHash	access:public	signature:(T a, T b)
equal	.\HashFunctions.h	/^        static bool equal(const RefPtr<P>& a, P* b) { return a == b; }$/;"	f	struct:WTF::PtrHash	access:public	signature:(const RefPtr<P>& a, P* b)
equal	.\HashFunctions.h	/^        static bool equal(const RefPtr<P>& a, const RefPtr<P>& b) { return a == b; }$/;"	f	struct:WTF::PtrHash	access:public	signature:(const RefPtr<P>& a, const RefPtr<P>& b)
equal	.\HashFunctions.h	/^        static bool equal(const std::pair<T, U>& a, const std::pair<T, U>& b)$/;"	f	struct:WTF::PairHash	access:public	signature:(const std::pair<T, U>& a, const std::pair<T, U>& b)
equal	.\HashMap.h	/^        template<typename T, typename U> static bool equal(const T& a, const U& b) { return HashFunctions::equal(a, b); }$/;"	f	struct:WTF::HashMapTranslator	access:public	signature:(const T& a, const U& b)
equal	.\HashMap.h	/^        template<typename T, typename U> static bool equal(const T& a, const U& b) { return Translator::equal(a, b); }$/;"	f	struct:WTF::HashMapTranslatorAdapter	access:public	signature:(const T& a, const U& b)
equal	.\HashSet.h	/^        template<typename T, typename U> static bool equal(const T& a, const U& b) { return Translator::equal(a, b); }$/;"	f	struct:WTF::HashSetTranslatorAdapter	access:public	signature:(const T& a, const U& b)
equal	.\HashTable.h	/^        template<typename T> static bool equal(const T& a, const T& b) { return HashFunctions::equal(a, b); }$/;"	f	class:WTF::IdentityHashTranslator	access:public	signature:(const T& a, const T& b)
equal	.\ListHashSet.h	/^        template<typename T, typename U> static bool equal(const T& a, const U& b) { return HashFunctions::equal(a->m_value, b); }$/;"	f	struct:WTF::ListHashSetTranslator	access:public	signature:(const T& a, const U& b)
equal	.\ListHashSet.h	/^        template<typename T, typename U> static bool equal(const T& a, const U& b) { return Translator::equal(a->m_value, b); }$/;"	f	struct:WTF::ListHashSetTranslatorAdapter	access:public	signature:(const T& a, const U& b)
equal	.\ListHashSet.h	/^        template<typename T> static bool equal(const T& a, const T& b) { return HashArg::equal(a->m_value, b->m_value); }$/;"	f	struct:WTF::ListHashSetNodeHashFunctions	access:public	signature:(const T& a, const T& b)
equal	.\RetainPtr.h	/^        static bool equal(const RetainPtr<P>& a, const RetainPtr<P>& b) { return a == b; }$/;"	f	struct:WTF::PtrHash	access:public	signature:(const RetainPtr<P>& a, const RetainPtr<P>& b)
equal	.\RetainPtr.h	/^        static bool equal(const RetainPtr<P>& a, typename RetainPtr<P>::PtrType b) { return a == b; }$/;"	f	struct:WTF::PtrHash	access:public	signature:(const RetainPtr<P>& a, typename RetainPtr<P>::PtrType b)
equal	.\RetainPtr.h	/^        static bool equal(typename RetainPtr<P>::PtrType a, const RetainPtr<P>& b) { return a == b; }$/;"	f	struct:WTF::PtrHash	access:public	signature:(typename RetainPtr<P>::PtrType a, const RetainPtr<P>& b)
equal	.\text\AtomicString.cpp	/^    static bool equal(StringImpl* const& str, const UCharBuffer& buf)$/;"	f	struct:WTF::UCharBufferTranslator	access:public	signature:(StringImpl* const& str, const UCharBuffer& buf)
equal	.\text\AtomicString.cpp	/^    static bool equal(StringImpl* const& string, const HashAndCharacters& buffer)$/;"	f	struct:WTF::HashAndCharactersTranslator	access:public	signature:(StringImpl* const& string, const HashAndCharacters& buffer)
equal	.\text\AtomicString.cpp	/^    static bool equal(StringImpl* const& string, const HashAndUTF8Characters& buffer)$/;"	f	struct:WTF::HashAndUTF8CharactersTranslator	access:public	signature:(StringImpl* const& string, const HashAndUTF8Characters& buffer)
equal	.\text\AtomicString.cpp	/^    static bool equal(StringImpl* const& string, const SubstringLocation& buffer)$/;"	f	struct:WTF::SubstringTranslator	access:public	signature:(StringImpl* const& string, const SubstringLocation& buffer)
equal	.\text\AtomicString.cpp	/^    static inline bool equal(StringImpl* r, const LChar* s)$/;"	f	struct:WTF::CStringTranslator	access:public	signature:(StringImpl* r, const LChar* s)
equal	.\text\AtomicStringHash.h	/^        static bool equal(const AtomicString& a, const AtomicString& b)$/;"	f	struct:WTF::AtomicStringHash	access:public	signature:(const AtomicString& a, const AtomicString& b)
equal	.\text\StringBuilder.h	/^bool equal(const StringBuilder& a, const StringType& b)$/;"	f	namespace:WTF	signature:(const StringBuilder& a, const StringType& b)
equal	.\text\StringBuilder.h	/^bool equal(const StringBuilder& s, const CharType* buffer, unsigned length)$/;"	f	namespace:WTF	signature:(const StringBuilder& s, const CharType* buffer, unsigned length)
equal	.\text\StringHash.h	/^        static bool equal(const AtomicString& a, const AtomicString& b)$/;"	f	class:WTF::CaseFoldingHash	access:public	signature:(const AtomicString& a, const AtomicString& b)
equal	.\text\StringHash.h	/^        static bool equal(const RefPtr<StringImpl>& a, const RefPtr<StringImpl>& b)$/;"	f	class:WTF::CaseFoldingHash	access:public	signature:(const RefPtr<StringImpl>& a, const RefPtr<StringImpl>& b)
equal	.\text\StringHash.h	/^        static bool equal(const RefPtr<StringImpl>& a, const RefPtr<StringImpl>& b)$/;"	f	struct:WTF::StringHash	access:public	signature:(const RefPtr<StringImpl>& a, const RefPtr<StringImpl>& b)
equal	.\text\StringHash.h	/^        static bool equal(const String& a, const String& b)$/;"	f	class:WTF::CaseFoldingHash	access:public	signature:(const String& a, const String& b)
equal	.\text\StringHash.h	/^        static bool equal(const String& a, const String& b)$/;"	f	struct:WTF::StringHash	access:public	signature:(const String& a, const String& b)
equal	.\text\StringHash.h	/^        static bool equal(const StringImpl* a, const StringImpl* b)$/;"	f	class:WTF::CaseFoldingHash	access:public	signature:(const StringImpl* a, const StringImpl* b)
equal	.\text\StringHash.h	/^        static bool equal(const StringImpl* a, const StringImpl* b)$/;"	f	struct:WTF::StringHash	access:public	signature:(const StringImpl* a, const StringImpl* b)
equal	.\text\StringImpl.cpp	/^bool equal(const StringImpl* a, const LChar* b)$/;"	f	namespace:WTF	signature:(const StringImpl* a, const LChar* b)
equal	.\text\StringImpl.cpp	/^bool equal(const StringImpl* a, const LChar* b, unsigned length)$/;"	f	namespace:WTF	signature:(const StringImpl* a, const LChar* b, unsigned length)
equal	.\text\StringImpl.cpp	/^bool equal(const StringImpl* a, const StringImpl* b)$/;"	f	namespace:WTF	signature:(const StringImpl* a, const StringImpl* b)
equal	.\text\StringImpl.cpp	/^bool equal(const StringImpl* a, const UChar* b, unsigned length)$/;"	f	namespace:WTF	signature:(const StringImpl* a, const UChar* b, unsigned length)
equal	.\text\StringImpl.h	/^ALWAYS_INLINE bool equal(const LChar* a, const LChar* b, unsigned length)$/;"	f	namespace:WTF	signature:(const LChar* a, const LChar* b, unsigned length)
equal	.\text\StringImpl.h	/^ALWAYS_INLINE bool equal(const LChar* a, const UChar* b, unsigned length)$/;"	f	namespace:WTF	signature:(const LChar* a, const UChar* b, unsigned length)
equal	.\text\StringImpl.h	/^ALWAYS_INLINE bool equal(const UChar* a, const LChar* b, unsigned length)$/;"	f	namespace:WTF	signature:(const UChar* a, const LChar* b, unsigned length)
equal	.\text\StringImpl.h	/^ALWAYS_INLINE bool equal(const UChar* a, const UChar* b, unsigned length)$/;"	f	namespace:WTF	signature:(const UChar* a, const UChar* b, unsigned length)
equal	.\text\StringImpl.h	/^WTF_EXPORT_PRIVATE bool equal(const StringImpl*, const LChar*);$/;"	p	namespace:WTF	signature:(const StringImpl*, const LChar*)
equal	.\text\StringImpl.h	/^WTF_EXPORT_PRIVATE bool equal(const StringImpl*, const LChar*, unsigned);$/;"	p	namespace:WTF	signature:(const StringImpl*, const LChar*, unsigned)
equal	.\text\StringImpl.h	/^WTF_EXPORT_PRIVATE bool equal(const StringImpl*, const StringImpl*);$/;"	p	namespace:WTF	signature:(const StringImpl*, const StringImpl*)
equal	.\text\StringImpl.h	/^WTF_EXPORT_PRIVATE bool equal(const StringImpl*, const UChar*, unsigned);$/;"	p	namespace:WTF	signature:(const StringImpl*, const UChar*, unsigned)
equal	.\text\StringImpl.h	/^inline bool equal(const LChar* a, StringImpl* b) { return equal(b, a); }$/;"	f	namespace:WTF	signature:(const LChar* a, StringImpl* b)
equal	.\text\StringImpl.h	/^inline bool equal(const StringImpl* a, const char* b) { return equal(a, reinterpret_cast<const LChar*>(b)); }$/;"	f	namespace:WTF	signature:(const StringImpl* a, const char* b)
equal	.\text\StringImpl.h	/^inline bool equal(const StringImpl* a, const char* b, unsigned length) { return equal(a, reinterpret_cast<const LChar*>(b), length); }$/;"	f	namespace:WTF	signature:(const StringImpl* a, const char* b, unsigned length)
equal	.\text\StringImpl.h	/^inline bool equal(const char* a, StringImpl* b) { return equal(b, reinterpret_cast<const LChar*>(a)); }$/;"	f	namespace:WTF	signature:(const char* a, StringImpl* b)
equalIgnoringCase	.\text\AtomicString.h	/^inline bool equalIgnoringCase(const AtomicString& a, const AtomicString& b) { return equalIgnoringCase(a.impl(), b.impl()); }$/;"	f	namespace:WTF	signature:(const AtomicString& a, const AtomicString& b)
equalIgnoringCase	.\text\AtomicString.h	/^inline bool equalIgnoringCase(const AtomicString& a, const LChar* b) { return equalIgnoringCase(a.impl(), b); }$/;"	f	namespace:WTF	signature:(const AtomicString& a, const LChar* b)
equalIgnoringCase	.\text\AtomicString.h	/^inline bool equalIgnoringCase(const AtomicString& a, const String& b) { return equalIgnoringCase(a.impl(), b.impl()); }$/;"	f	namespace:WTF	signature:(const AtomicString& a, const String& b)
equalIgnoringCase	.\text\AtomicString.h	/^inline bool equalIgnoringCase(const AtomicString& a, const char* b) { return equalIgnoringCase(a.impl(), reinterpret_cast<const LChar*>(b)); }$/;"	f	namespace:WTF	signature:(const AtomicString& a, const char* b)
equalIgnoringCase	.\text\AtomicString.h	/^inline bool equalIgnoringCase(const LChar* a, const AtomicString& b) { return equalIgnoringCase(a, b.impl()); }$/;"	f	namespace:WTF	signature:(const LChar* a, const AtomicString& b)
equalIgnoringCase	.\text\AtomicString.h	/^inline bool equalIgnoringCase(const String& a, const AtomicString& b) { return equalIgnoringCase(a.impl(), b.impl()); }$/;"	f	namespace:WTF	signature:(const String& a, const AtomicString& b)
equalIgnoringCase	.\text\AtomicString.h	/^inline bool equalIgnoringCase(const char* a, const AtomicString& b) { return equalIgnoringCase(reinterpret_cast<const LChar*>(a), b.impl()); }$/;"	f	namespace:WTF	signature:(const char* a, const AtomicString& b)
equalIgnoringCase	.\text\StringImpl.cpp	/^bool equalIgnoringCase(StringImpl* a, StringImpl* b)$/;"	f	namespace:WTF	signature:(StringImpl* a, StringImpl* b)
equalIgnoringCase	.\text\StringImpl.cpp	/^bool equalIgnoringCase(StringImpl* a, const LChar* b)$/;"	f	namespace:WTF	signature:(StringImpl* a, const LChar* b)
equalIgnoringCase	.\text\StringImpl.cpp	/^bool equalIgnoringCase(const LChar* a, const LChar* b, unsigned length)$/;"	f	namespace:WTF	signature:(const LChar* a, const LChar* b, unsigned length)
equalIgnoringCase	.\text\StringImpl.cpp	/^bool equalIgnoringCase(const UChar* a, const LChar* b, unsigned length)$/;"	f	namespace:WTF	signature:(const UChar* a, const LChar* b, unsigned length)
equalIgnoringCase	.\text\StringImpl.cpp	/^static inline bool equalIgnoringCase(const UChar* a, const UChar* b, int length)$/;"	f	namespace:WTF	file:	signature:(const UChar* a, const UChar* b, int length)
equalIgnoringCase	.\text\StringImpl.h	/^WTF_EXPORT_PRIVATE bool equalIgnoringCase(StringImpl*, StringImpl*);$/;"	p	namespace:WTF	signature:(StringImpl*, StringImpl*)
equalIgnoringCase	.\text\StringImpl.h	/^WTF_EXPORT_PRIVATE bool equalIgnoringCase(StringImpl*, const LChar*);$/;"	p	namespace:WTF	signature:(StringImpl*, const LChar*)
equalIgnoringCase	.\text\StringImpl.h	/^WTF_EXPORT_PRIVATE bool equalIgnoringCase(const LChar*, const LChar*, unsigned);$/;"	p	namespace:WTF	signature:(const LChar*, const LChar*, unsigned)
equalIgnoringCase	.\text\StringImpl.h	/^WTF_EXPORT_PRIVATE bool equalIgnoringCase(const UChar*, const LChar*, unsigned);$/;"	p	namespace:WTF	signature:(const UChar*, const LChar*, unsigned)
equalIgnoringCase	.\text\StringImpl.h	/^inline bool equalIgnoringCase(const LChar* a, StringImpl* b) { return equalIgnoringCase(b, a); }$/;"	f	namespace:WTF	signature:(const LChar* a, StringImpl* b)
equalIgnoringCase	.\text\StringImpl.h	/^inline bool equalIgnoringCase(const LChar* a, const UChar* b, unsigned length) { return equalIgnoringCase(b, a, length); }$/;"	f	namespace:WTF	signature:(const LChar* a, const UChar* b, unsigned length)
equalIgnoringCase	.\text\StringImpl.h	/^inline bool equalIgnoringCase(const UChar* a, const char* b, unsigned length) { return equalIgnoringCase(a, reinterpret_cast<const LChar*>(b), length); }$/;"	f	namespace:WTF	signature:(const UChar* a, const char* b, unsigned length)
equalIgnoringCase	.\text\StringImpl.h	/^inline bool equalIgnoringCase(const char* a, const UChar* b, unsigned length) { return equalIgnoringCase(b, reinterpret_cast<const LChar*>(a), length); }$/;"	f	namespace:WTF	signature:(const char* a, const UChar* b, unsigned length)
equalIgnoringCase	.\text\WTFString.h	/^inline bool equalIgnoringCase(const LChar* a, const String& b) { return equalIgnoringCase(a, b.impl()); }$/;"	f	namespace:WTF	signature:(const LChar* a, const String& b)
equalIgnoringCase	.\text\WTFString.h	/^inline bool equalIgnoringCase(const String& a, const LChar* b) { return equalIgnoringCase(a.impl(), b); }$/;"	f	namespace:WTF	signature:(const String& a, const LChar* b)
equalIgnoringCase	.\text\WTFString.h	/^inline bool equalIgnoringCase(const String& a, const String& b) { return equalIgnoringCase(a.impl(), b.impl()); }$/;"	f	namespace:WTF	signature:(const String& a, const String& b)
equalIgnoringCase	.\text\WTFString.h	/^inline bool equalIgnoringCase(const String& a, const char* b) { return equalIgnoringCase(a.impl(), reinterpret_cast<const LChar*>(b)); }$/;"	f	namespace:WTF	signature:(const String& a, const char* b)
equalIgnoringCase	.\text\WTFString.h	/^inline bool equalIgnoringCase(const char* a, const String& b) { return equalIgnoringCase(reinterpret_cast<const LChar*>(a), b.impl()); }$/;"	f	namespace:WTF	signature:(const char* a, const String& b)
equalIgnoringNullity	.\text\StringImpl.cpp	/^bool equalIgnoringNullity(StringImpl* a, StringImpl* b)$/;"	f	namespace:WTF	signature:(StringImpl* a, StringImpl* b)
equalIgnoringNullity	.\text\StringImpl.h	/^WTF_EXPORT_PRIVATE bool equalIgnoringNullity(StringImpl*, StringImpl*);$/;"	p	namespace:WTF	signature:(StringImpl*, StringImpl*)
equalIgnoringNullity	.\text\StringImpl.h	/^bool equalIgnoringNullity(const Vector<UChar, inlineCapacity>& a, StringImpl* b)$/;"	f	namespace:WTF	signature:(const Vector<UChar, inlineCapacity>& a, StringImpl* b)
equalIgnoringNullity	.\text\WTFString.h	/^inline bool equalIgnoringNullity(const String& a, const String& b) { return equalIgnoringNullity(a.impl(), b.impl()); }$/;"	f	namespace:WTF	signature:(const String& a, const String& b)
equalIgnoringNullity	.\text\WTFString.h	/^inline bool equalIgnoringNullity(const Vector<UChar, inlineCapacity>& a, const String& b) { return equalIgnoringNullity(a, b.impl()); }$/;"	f	namespace:WTF	signature:(const Vector<UChar, inlineCapacity>& a, const String& b)
equalPossiblyIgnoringCase	.\text\WTFString.h	/^inline bool equalPossiblyIgnoringCase(const String& a, const String& b, bool ignoreCase) $/;"	f	namespace:WTF	signature:(const String& a, const String& b, bool ignoreCase)
equalUTF16WithUTF8	.\unicode\UTF8.cpp	/^bool equalUTF16WithUTF8(const UChar* a, const UChar* aEnd, const char* b, const char* bEnd)$/;"	f	namespace:WTF::Unicode	signature:(const UChar* a, const UChar* aEnd, const char* b, const char* bEnd)
equalUTF16WithUTF8	.\unicode\UTF8.h	/^    bool equalUTF16WithUTF8(const UChar* a, const UChar* aEnd, const char* b, const char* bEnd);$/;"	p	namespace:WTF::Unicode	signature:(const UChar* a, const UChar* aEnd, const char* b, const char* bEnd)
equals	.\CheckedArithmetic.h	/^    static inline bool equals(LHS lhs, RHS rhs) { return lhs == rhs; }$/;"	f	struct:WTF::ArithmeticOperations	access:public	signature:(LHS lhs, RHS rhs)
equals	.\CheckedArithmetic.h	/^    static inline bool equals(int lhs, unsigned rhs)$/;"	f	struct:WTF::ArithmeticOperations	access:public	signature:(int lhs, unsigned rhs)
equals	.\CheckedArithmetic.h	/^    static inline bool equals(unsigned lhs, int rhs)$/;"	f	struct:WTF::ArithmeticOperations	access:public	signature:(unsigned lhs, int rhs)
equivalentYearForDST	.\DateMath.cpp	/^int equivalentYearForDST(int year)$/;"	f	namespace:WTF	signature:(int year)
equivalentYearForDST	.\DateMath.h	/^int equivalentYearForDST(int year);$/;"	p	namespace:WTF	signature:(int year)
escapeHtml	.\qt\UtilsQt.h	/^inline QString escapeHtml(const QString& string)$/;"	f	signature:(const QString& string)
establishIdentifierForPthreadHandle	.\ThreadingPthreads.cpp	/^static ThreadIdentifier establishIdentifierForPthreadHandle(const pthread_t& pthreadHandle)$/;"	f	namespace:WTF	file:	signature:(const pthread_t& pthreadHandle)
estimateStackBound	.\StackBounds.cpp	/^static void* estimateStackBound(void* origin)$/;"	f	namespace:WTF	file:	signature:(void* origin)
estimatedStackSize	.\StackBounds.cpp	/^static const ptrdiff_t estimatedStackSize = 128 * sizeof(void*) * 1024;$/;"	v	file:
ethiopicPrefaceColon	.\unicode\CharacterNames.h	/^const UChar ethiopicPrefaceColon = 0x1366;$/;"	v
ethiopicWordspace	.\unicode\CharacterNames.h	/^const UChar ethiopicWordspace = 0x1361;$/;"	v
event	.\qt\MainThreadQt.cpp	/^    virtual bool event(QEvent*);$/;"	p	class:WTF::MainThreadInvoker	file:	access:public	signature:(QEvent*)
event	.\qt\MainThreadQt.cpp	/^bool MainThreadInvoker::event(QEvent* e)$/;"	f	class:WTF::MainThreadInvoker	signature:(QEvent* e)
event	.\threads\BinarySemaphore.h	/^    HANDLE event() const { return m_event; }$/;"	f	class:WTF::BinarySemaphore	access:public	signature:() const
exact_powers_of_ten	.\dtoa\strtod.cc	/^    static const double exact_powers_of_ten[] = {$/;"	v	file:
execute	.\ParallelJobs.h	/^    void execute()$/;"	f	class:WTF::ParallelJobs	access:public	signature:()
execute	.\ParallelJobsGeneric.cpp	/^void ParallelEnvironment::ThreadPrivate::execute(ThreadFunction threadFunction, void* parameters)$/;"	f	class:WTF::ParallelEnvironment::ThreadPrivate	signature:(ThreadFunction threadFunction, void* parameters)
execute	.\ParallelJobsGeneric.cpp	/^void ParallelEnvironment::execute(void* parameters)$/;"	f	class:WTF::ParallelEnvironment	signature:(void* parameters)
execute	.\ParallelJobsGeneric.h	/^        void execute(ThreadFunction, void*);$/;"	p	class:WTF::ParallelEnvironment::ThreadPrivate	access:public	signature:(ThreadFunction, void*)
execute	.\ParallelJobsGeneric.h	/^    void execute(void* parameters);$/;"	p	class:WTF::ParallelEnvironment	access:public	signature:(void* parameters)
execute	.\ParallelJobsLibdispatch.h	/^    void execute(unsigned char* parameters)$/;"	f	class:WTF::ParallelEnvironment	access:public	signature:(unsigned char* parameters)
execute	.\ParallelJobsOpenMP.h	/^    void execute(unsigned char* parameters)$/;"	f	class:WTF::ParallelEnvironment	access:public	signature:(unsigned char* parameters)
existingHash	.\text\StringImpl.h	/^    unsigned existingHash() const$/;"	f	class:WTF::StringImpl	access:public	signature:() const
expand	.\HashTable.h	/^        void expand();$/;"	p	class:WTF::HashTable	access:private	signature:()
expand	.\HashTable.h	/^    void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::expand()$/;"	f	class:WTF::HashTable	signature:()
expandCapacity	.\Deque.h	/^        void expandCapacity();$/;"	p	class:WTF::Deque	access:private	signature:()
expandCapacity	.\Deque.h	/^    void Deque<T, inlineCapacity>::expandCapacity()$/;"	f	class:WTF::Deque	signature:()
expandCapacity	.\Vector.h	/^        const T* expandCapacity(size_t newMinCapacity, const T*);$/;"	p	class:WTF::Vector	access:private	signature:(size_t newMinCapacity, const T*)
expandCapacity	.\Vector.h	/^        template<typename U> U* expandCapacity(size_t newMinCapacity, U*); $/;"	p	class:WTF::Vector	access:private	signature:(size_t newMinCapacity, U*)
expandCapacity	.\Vector.h	/^        void expandCapacity(size_t newMinCapacity);$/;"	p	class:WTF::Vector	access:private	signature:(size_t newMinCapacity)
expandCapacity	.\Vector.h	/^    const T* Vector<T, inlineCapacity>::expandCapacity(size_t newMinCapacity, const T* ptr)$/;"	f	class:WTF::Vector	signature:(size_t newMinCapacity, const T* ptr)
expandCapacity	.\Vector.h	/^    inline U* Vector<T, inlineCapacity>::expandCapacity(size_t newMinCapacity, U* ptr)$/;"	f	class:WTF::Vector	signature:(size_t newMinCapacity, U* ptr)
expandCapacity	.\Vector.h	/^    void Vector<T, inlineCapacity>::expandCapacity(size_t newMinCapacity)$/;"	f	class:WTF::Vector	signature:(size_t newMinCapacity)
expandCapacityIfNeeded	.\Deque.h	/^        void expandCapacityIfNeeded();$/;"	p	class:WTF::Deque	access:private	signature:()
expandCapacityIfNeeded	.\Deque.h	/^    inline void Deque<T, inlineCapacity>::expandCapacityIfNeeded()$/;"	f	class:WTF::Deque	signature:()
exponent	.\DecimalNumber.h	/^    int exponent() const { return m_exponent; }$/;"	f	class:WTF::DecimalNumber	access:public	signature:() const
exponent_	.\dtoa\bignum.h	/^        int exponent_;$/;"	m	class:WTF::double_conversion::Bignum	access:private
exponent_character_	.\dtoa\double-conversion.h	/^        const char exponent_character_;$/;"	m	class:WTF::double_conversion::DoubleToStringConverter	access:private
extract	.\HashMap.h	/^        static const typename PairType::first_type& extract(const PairType& p) { return p.first; }$/;"	f	struct:WTF::PairFirstExtractor	access:public	signature:(const PairType& p)
extract	.\HashSet.h	/^        template<typename T> static const T& extract(const T& t) { return t; }$/;"	f	struct:WTF::IdentityExtractor	access:public	signature:(const T& t)
extractFileName	.\url\src\URLParser.h	/^    static void extractFileName(const CharacterType* spec, const URLComponent& path, URLComponent& fileName)$/;"	f	class:WTF::URLParser	access:public	signature:(const CharacterType* spec, const URLComponent& path, URLComponent& fileName)
extractQueryKeyValue	.\url\src\URLParser.h	/^    static bool extractQueryKeyValue(const CharacterType* spec, URLComponent& query, URLComponent& key, URLComponent& value)$/;"	f	class:WTF::URLParser	access:public	signature:(const CharacterType* spec, URLComponent& query, URLComponent& key, URLComponent& value)
extractScheme	.\url\src\URLParser.h	/^    static bool extractScheme(const CharacterType* spec, int specLength, URLComponent& scheme)$/;"	f	class:WTF::URLParser	access:public	signature:(const CharacterType* spec, int specLength, URLComponent& scheme)
f	.\SHA1.cpp	/^static inline uint32_t f(int t, uint32_t b, uint32_t c, uint32_t d)$/;"	f	namespace:WTF	file:	signature:(int t, uint32_t b, uint32_t c, uint32_t d)
f	.\dtoa\diy-fp.h	/^        uint64_t f() const { return f_; }$/;"	f	class:WTF::double_conversion::DiyFp	access:public	signature:() const
f_	.\dtoa\diy-fp.h	/^        uint64_t f_;$/;"	m	class:WTF::double_conversion::DiyFp	access:private
fake	.\gobject\GRefPtr.cpp	/^    bool fake;$/;"	m	struct:WTF::_GVariant	file:	access:public
false_type	.\TypeTraits.h	/^    typedef IntegralConstant<bool, false> false_type;$/;"	t	namespace:WTF
fastCalloc	.\FastMalloc.cpp	/^void* fastCalloc(size_t n, size_t elem_size)$/;"	f	namespace:WTF	signature:(size_t n, size_t elem_size)
fastCalloc	.\FastMalloc.cpp	/^void* fastCalloc(size_t n_elements, size_t element_size)$/;"	f	namespace:WTF	signature:(size_t n_elements, size_t element_size)
fastCalloc	.\FastMalloc.h	/^    WTF_EXPORT_PRIVATE void* fastCalloc(size_t numElements, size_t elementSize);$/;"	p	namespace:WTF	signature:(size_t numElements, size_t elementSize)
fastCalloc	.\wince\FastMallocWinCE.h	/^void* fastCalloc(size_t n_elements, size_t element_size);$/;"	p	signature:(size_t n_elements, size_t element_size)
fastCalloc	.\wince\MemoryManager.cpp	/^void *fastCalloc(size_t n_elements, size_t element_size) { return MemoryManager::m_calloc(n_elements, element_size); }$/;"	f	namespace:WTF	signature:(size_t n_elements, size_t element_size)
fastCalloc	.\wince\MemoryManager.cpp	/^void *fastCalloc(size_t n_elements, size_t element_size) { return calloc(n_elements, element_size); }$/;"	f	namespace:WTF	signature:(size_t n_elements, size_t element_size)
fastDelete	.\FastAllocBase.h	/^    inline void fastDelete(T* p)$/;"	f	namespace:WTF	signature:(T* p)
fastDeleteAllValues	.\HashSet.h	/^        friend void fastDeleteAllValues<>(const HashSet&);$/;"	p	class:WTF::HashSet	access:friend	signature:(const HashSet&)
fastDeleteAllValues	.\HashSet.h	/^    inline void fastDeleteAllValues(const HashSet<T, U, V>& collection)$/;"	f	namespace:WTF	signature:(const HashSet<T, U, V>& collection)
fastDeleteAllValues	.\HashSet.h	/^    void fastDeleteAllValues(HashTableType& collection)$/;"	f	namespace:WTF	signature:(HashTableType& collection)
fastDeleteAllValues	.\HashSet.h	/^    void fastDeleteAllValues(const HashSet<Value, HashFunctions, Traits>&);$/;"	p	namespace:WTF	signature:(const HashSet<Value, HashFunctions, Traits>&)
fastDeleteArray	.\FastAllocBase.h	/^            static void fastDeleteArray(T* p)$/;"	f	struct:WTF::Internal::DeleteArrayImpl	access:public	signature:(T* p)
fastDeleteArray	.\FastAllocBase.h	/^            static void fastDeleteArray(void* p)$/;"	f	struct:WTF::Internal::DeleteArrayImpl	access:public	signature:(void* p)
fastDeleteArray	.\FastAllocBase.h	/^    void fastDeleteArray(T* p)$/;"	f	namespace:WTF	signature:(T* p)
fastDeleteSkippingDestructor	.\FastAllocBase.h	/^    inline void fastDeleteSkippingDestructor(T* p)$/;"	f	namespace:WTF	signature:(T* p)
fastFree	.\FastMalloc.cpp	/^void fastFree(void* p)$/;"	f	namespace:WTF	signature:(void* p)
fastFree	.\FastMalloc.h	/^    WTF_EXPORT_PRIVATE void fastFree(void*);$/;"	p	namespace:WTF	signature:(void*)
fastFree	.\wince\FastMallocWinCE.h	/^void fastFree(void* p);$/;"	p	signature:(void* p)
fastFree	.\wince\MemoryManager.cpp	/^void fastFree(void* p) { return MemoryManager::m_free(p); }$/;"	f	namespace:WTF	signature:(void* p)
fastFree	.\wince\MemoryManager.cpp	/^void fastFree(void* p) { return free(p); }$/;"	f	namespace:WTF	signature:(void* p)
fastMalloc	.\FastMalloc.cpp	/^void* fastMalloc(size_t n) $/;"	f	namespace:WTF	signature:(size_t n)
fastMalloc	.\FastMalloc.cpp	/^void* fastMalloc(size_t size)$/;"	f	namespace:WTF	signature:(size_t size)
fastMalloc	.\FastMalloc.h	/^    WTF_EXPORT_PRIVATE void* fastMalloc(size_t);$/;"	p	namespace:WTF	signature:(size_t)
fastMalloc	.\wince\FastMallocWinCE.h	/^void* fastMalloc(size_t n);$/;"	p	signature:(size_t n)
fastMalloc	.\wince\MemoryManager.cpp	/^void *fastMalloc(size_t n) { return MemoryManager::m_malloc(n); }$/;"	f	namespace:WTF	signature:(size_t n)
fastMalloc	.\wince\MemoryManager.cpp	/^void *fastMalloc(size_t n) { return malloc(n); }$/;"	f	namespace:WTF	signature:(size_t n)
fastMallocAllow	.\FastMalloc.cpp	/^void fastMallocAllow()$/;"	f	namespace:WTF	signature:()
fastMallocAllow	.\FastMalloc.h	/^    void fastMallocAllow();$/;"	p	namespace:WTF	signature:()
fastMallocAllow	.\wince\FastMallocWinCE.h	/^void fastMallocAllow();$/;"	p	signature:()
fastMallocAllow	.\wince\MemoryManager.cpp	/^void fastMallocAllow() {}$/;"	f	namespace:WTF	signature:()
fastMallocForbid	.\FastMalloc.cpp	/^void fastMallocForbid()$/;"	f	namespace:WTF	signature:()
fastMallocForbid	.\FastMalloc.h	/^    void fastMallocForbid();$/;"	p	namespace:WTF	signature:()
fastMallocForbid	.\wince\FastMallocWinCE.h	/^void fastMallocForbid();$/;"	p	signature:()
fastMallocForbid	.\wince\MemoryManager.cpp	/^void fastMallocForbid() {}$/;"	f	namespace:WTF	signature:()
fastMallocMatchFailed	.\FastMalloc.cpp	/^NO_RETURN_DUE_TO_CRASH void fastMallocMatchFailed(void*)$/;"	f	namespace:WTF::Internal	signature:(void*)
fastMallocMatchFailed	.\FastMalloc.cpp	/^WTF_EXPORT_PRIVATE void fastMallocMatchFailed(void*);$/;"	p	namespace:WTF::Internal	file:	signature:(void*)
fastMallocMatchFailed	.\FastMalloc.h	/^        void fastMallocMatchFailed(void* p);$/;"	p	namespace:WTF::Internal	signature:(void* p)
fastMallocMatchFailed	.\wince\FastMallocWinCE.h	/^        void fastMallocMatchFailed(void* p);$/;"	p	namespace:WTF::Internal	signature:(void* p)
fastMallocMatchValidateFree	.\FastMalloc.h	/^    inline void fastMallocMatchValidateFree(void* p, Internal::AllocType)$/;"	f	namespace:WTF	signature:(void* p, Internal::AllocType)
fastMallocMatchValidateFree	.\FastMalloc.h	/^    inline void fastMallocMatchValidateFree(void*, Internal::AllocType)$/;"	f	namespace:WTF	signature:(void*, Internal::AllocType)
fastMallocMatchValidateFree	.\wince\FastMallocWinCE.h	/^    inline void fastMallocMatchValidateFree(void* p, Internal::AllocType allocType)$/;"	f	namespace:WTF	signature:(void* p, Internal::AllocType allocType)
fastMallocMatchValidateFree	.\wince\FastMallocWinCE.h	/^    inline void fastMallocMatchValidateFree(void*, Internal::AllocType)$/;"	f	namespace:WTF	signature:(void*, Internal::AllocType)
fastMallocMatchValidateMalloc	.\FastMalloc.h	/^    inline void fastMallocMatchValidateMalloc(void* p, Internal::AllocType allocType)$/;"	f	namespace:WTF	signature:(void* p, Internal::AllocType allocType)
fastMallocMatchValidateMalloc	.\FastMalloc.h	/^    inline void fastMallocMatchValidateMalloc(void*, Internal::AllocType)$/;"	f	namespace:WTF	signature:(void*, Internal::AllocType)
fastMallocMatchValidateMalloc	.\wince\FastMallocWinCE.h	/^    inline void fastMallocMatchValidateMalloc(void* p, Internal::AllocType allocType)$/;"	f	namespace:WTF	signature:(void* p, Internal::AllocType allocType)
fastMallocMatchValidateMalloc	.\wince\FastMallocWinCE.h	/^    inline void fastMallocMatchValidateMalloc(void*, Internal::AllocType)$/;"	f	namespace:WTF	signature:(void*, Internal::AllocType)
fastMallocMatchValidationType	.\FastMalloc.h	/^        inline AllocType fastMallocMatchValidationType(void* p)$/;"	f	namespace:WTF::Internal	signature:(void* p)
fastMallocMatchValidationType	.\wince\FastMallocWinCE.h	/^        inline AllocType fastMallocMatchValidationType(const void* p)$/;"	f	namespace:WTF::Internal	signature:(const void* p)
fastMallocMatchValidationValue	.\wince\FastMallocWinCE.h	/^        inline AllocAlignmentInteger* fastMallocMatchValidationValue(void* p)$/;"	f	namespace:WTF::Internal	signature:(void* p)
fastMallocSize	.\FastMalloc.cpp	/^size_t fastMallocSize(const void* p)$/;"	f	namespace:WTF	signature:(const void* p)
fastMallocSize	.\FastMalloc.cpp	/^size_t fastMallocSize(const void* ptr)$/;"	f	namespace:WTF	signature:(const void* ptr)
fastMallocSize	.\FastMalloc.h	/^    WTF_EXPORT_PRIVATE size_t fastMallocSize(const void*);$/;"	p	namespace:WTF	signature:(const void*)
fastMallocStatistics	.\FastMalloc.cpp	/^FastMallocStatistics fastMallocStatistics()$/;"	f	namespace:WTF	signature:()
fastMallocStatistics	.\FastMalloc.h	/^    WTF_EXPORT_PRIVATE FastMallocStatistics fastMallocStatistics();$/;"	p	namespace:WTF	signature:()
fastMallocValidate	.\FastMalloc.h	/^    inline void fastMallocValidate(void* p)$/;"	f	namespace:WTF	signature:(void* p)
fastMallocValidationHeader	.\FastMalloc.h	/^        inline ValidationHeader* fastMallocValidationHeader(void* p)$/;"	f	namespace:WTF::Internal	signature:(void* p)
fastMallocValidationSuffix	.\FastMalloc.h	/^        inline ValidationTag* fastMallocValidationSuffix(void* p)$/;"	f	namespace:WTF::Internal	signature:(void* p)
fastNew	.\FastAllocBase.h	/^    inline T* fastNew()$/;"	f	namespace:WTF	signature:()
fastNew	.\FastAllocBase.h	/^    inline T* fastNew(Arg1 arg1)$/;"	f	namespace:WTF	signature:(Arg1 arg1)
fastNew	.\FastAllocBase.h	/^    inline T* fastNew(Arg1 arg1, Arg2 arg2)$/;"	f	namespace:WTF	signature:(Arg1 arg1, Arg2 arg2)
fastNew	.\FastAllocBase.h	/^    inline T* fastNew(Arg1 arg1, Arg2 arg2, Arg3 arg3)$/;"	f	namespace:WTF	signature:(Arg1 arg1, Arg2 arg2, Arg3 arg3)
fastNew	.\FastAllocBase.h	/^    inline T* fastNew(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4)$/;"	f	namespace:WTF	signature:(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4)
fastNew	.\FastAllocBase.h	/^    inline T* fastNew(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5)$/;"	f	namespace:WTF	signature:(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5)
fastNewArray	.\FastAllocBase.h	/^            static T* fastNewArray(size_t count)$/;"	f	struct:WTF::Internal::NewArrayImpl	access:public	signature:(size_t count)
fastNewArray	.\FastAllocBase.h	/^    inline T* fastNewArray(size_t count)$/;"	f	namespace:WTF	signature:(size_t count)
fastNonNullDelete	.\FastAllocBase.h	/^    inline void fastNonNullDelete(T* p)$/;"	f	namespace:WTF	signature:(T* p)
fastNonNullDeleteArray	.\FastAllocBase.h	/^            static void fastNonNullDeleteArray(T* p)$/;"	f	struct:WTF::Internal::NonNullDeleteArrayImpl	access:public	signature:(T* p)
fastNonNullDeleteArray	.\FastAllocBase.h	/^            static void fastNonNullDeleteArray(void* p)$/;"	f	struct:WTF::Internal::NonNullDeleteArrayImpl	access:public	signature:(void* p)
fastNonNullDeleteArray	.\FastAllocBase.h	/^    void fastNonNullDeleteArray(T* p)$/;"	f	namespace:WTF	signature:(T* p)
fastRealloc	.\FastMalloc.cpp	/^void* fastRealloc(void* old_ptr, size_t new_size)$/;"	f	namespace:WTF	signature:(void* old_ptr, size_t new_size)
fastRealloc	.\FastMalloc.cpp	/^void* fastRealloc(void* p, size_t n)$/;"	f	namespace:WTF	signature:(void* p, size_t n)
fastRealloc	.\FastMalloc.h	/^    WTF_EXPORT_PRIVATE void* fastRealloc(void*, size_t);$/;"	p	namespace:WTF	signature:(void*, size_t)
fastRealloc	.\wince\FastMallocWinCE.h	/^void* fastRealloc(void* p, size_t n);$/;"	p	signature:(void* p, size_t n)
fastRealloc	.\wince\MemoryManager.cpp	/^void *fastRealloc(void* p, size_t n) { return MemoryManager::m_realloc(p, n); }$/;"	f	namespace:WTF	signature:(void* p, size_t n)
fastRealloc	.\wince\MemoryManager.cpp	/^void *fastRealloc(void* p, size_t n) { return realloc(p, n); }$/;"	f	namespace:WTF	signature:(void* p, size_t n)
fastStrDup	.\FastMalloc.cpp	/^char* fastStrDup(const char* src)$/;"	f	namespace:WTF	signature:(const char* src)
fastStrDup	.\FastMalloc.h	/^    WTF_EXPORT_PRIVATE char* fastStrDup(const char*);$/;"	p	namespace:WTF	signature:(const char*)
fastStrDup	.\wince\FastMallocWinCE.h	/^char* fastStrDup(const char*);$/;"	p	signature:(const char*)
fastStrDup	.\wince\MemoryManager.cpp	/^char* fastStrDup(const char* str)$/;"	f	namespace:WTF	signature:(const char* str)
fastZeroedMalloc	.\FastMalloc.cpp	/^void* fastZeroedMalloc(size_t n) $/;"	f	namespace:WTF	signature:(size_t n)
fastZeroedMalloc	.\FastMalloc.h	/^    WTF_EXPORT_PRIVATE void* fastZeroedMalloc(size_t);$/;"	p	namespace:WTF	signature:(size_t)
fastZeroedMalloc	.\wince\FastMallocWinCE.h	/^void* fastZeroedMalloc(size_t n);$/;"	p	signature:(size_t n)
fastZeroedMalloc	.\wince\MemoryManager.cpp	/^void* fastZeroedMalloc(size_t n)$/;"	f	namespace:WTF	signature:(size_t n)
file	.\DataLog.cpp	/^static FILE* file;$/;"	v	file:
fill	.\Vector.h	/^        void fill(const T& val) { fill(val, size()); }$/;"	f	class:WTF::Vector	access:public	signature:(const T& val)
fill	.\Vector.h	/^        void fill(const T&, size_t);$/;"	p	class:WTF::Vector	access:public	signature:(const T&, size_t)
fill	.\Vector.h	/^    void Vector<T, inlineCapacity>::fill(const T& val, size_t newSize)$/;"	f	class:WTF::Vector	signature:(const T& val, size_t newSize)
fill	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::fill(UChar character)$/;"	f	class:WTF::StringImpl	signature:(UChar character)
fill	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE PassRefPtr<StringImpl> fill(UChar);$/;"	p	class:WTF::StringImpl	access:public	signature:(UChar)
fill	.\text\WTFString.h	/^    void fill(UChar c) { if (m_impl) m_impl = m_impl->fill(c); }$/;"	f	class:WTF::String	access:public	signature:(UChar c)
finalize	.\SHA1.cpp	/^void SHA1::finalize()$/;"	f	class:WTF::SHA1	signature:()
finalize	.\SHA1.h	/^    void finalize();$/;"	p	class:WTF::SHA1	access:private	signature:()
find	.\HashCountedSet.h	/^        const_iterator find(const ValueType&) const;$/;"	p	class:WTF::HashCountedSet	access:public	signature:(const ValueType&) const
find	.\HashCountedSet.h	/^        iterator find(const ValueType&);$/;"	p	class:WTF::HashCountedSet	access:public	signature:(const ValueType&)
find	.\HashCountedSet.h	/^    inline typename HashCountedSet<Value, HashFunctions, Traits>::const_iterator HashCountedSet<Value, HashFunctions, Traits>::find(const ValueType& value) const$/;"	f	class:WTF::HashCountedSet	signature:(const ValueType& value) const
find	.\HashCountedSet.h	/^    inline typename HashCountedSet<Value, HashFunctions, Traits>::iterator HashCountedSet<Value, HashFunctions, Traits>::find(const ValueType& value)$/;"	f	class:WTF::HashCountedSet	signature:(const ValueType& value)
find	.\HashMap.h	/^        const_iterator find(const KeyType&) const;$/;"	p	class:WTF::HashMap	access:public	signature:(const KeyType&) const
find	.\HashMap.h	/^        iterator find(const KeyType&);$/;"	p	class:WTF::HashMap	access:public	signature:(const KeyType&)
find	.\HashMap.h	/^        template<typename T, typename HashTranslator> const_iterator find(const T&) const;$/;"	p	class:WTF::HashMap	access:public	signature:(const T&) const
find	.\HashMap.h	/^        template<typename T, typename HashTranslator> iterator find(const T&);$/;"	p	class:WTF::HashMap	access:public	signature:(const T&)
find	.\HashMap.h	/^    HashMap<T, U, V, W, X>::find(const TYPE& value) const$/;"	f	class:WTF::HashMap	signature:(const TYPE& value) const
find	.\HashMap.h	/^    HashMap<T, U, V, W, X>::find(const TYPE& value)$/;"	f	class:WTF::HashMap	signature:(const TYPE& value)
find	.\HashMap.h	/^    inline typename HashMap<T, U, V, W, X>::const_iterator HashMap<T, U, V, W, X>::find(const KeyType& key) const$/;"	f	class:WTF::HashMap	signature:(const KeyType& key) const
find	.\HashMap.h	/^    inline typename HashMap<T, U, V, W, X>::iterator HashMap<T, U, V, W, X>::find(const KeyType& key)$/;"	f	class:WTF::HashMap	signature:(const KeyType& key)
find	.\HashSet.h	/^        iterator find(const ValueType&) const;$/;"	p	class:WTF::HashSet	access:public	signature:(const ValueType&) const
find	.\HashSet.h	/^        template<typename T, typename HashTranslator> iterator find(const T&) const;$/;"	p	class:WTF::HashSet	access:public	signature:(const T&) const
find	.\HashSet.h	/^    inline HashSet<Value, HashFunctions, Traits>::find(const T& value) const$/;"	f	class:WTF::HashSet::HashSet	signature:(const T& value) const
find	.\HashSet.h	/^    inline typename HashSet<T, U, V>::iterator HashSet<T, U, V>::find(const ValueType& value) const$/;"	f	class:WTF::HashSet	signature:(const ValueType& value) const
find	.\HashTable.h	/^        const_iterator find(const KeyType& key) const { return find<IdentityTranslatorType>(key); }$/;"	f	class:WTF::HashTable	access:public	signature:(const KeyType& key) const
find	.\HashTable.h	/^        iterator find(const KeyType& key) { return find<IdentityTranslatorType>(key); }$/;"	f	class:WTF::HashTable	access:public	signature:(const KeyType& key)
find	.\HashTable.h	/^        template<typename HashTranslator, typename T> const_iterator find(const T&) const;$/;"	p	class:WTF::HashTable	access:public	signature:(const T&) const
find	.\HashTable.h	/^        template<typename HashTranslator, typename T> iterator find(const T&);$/;"	p	class:WTF::HashTable	access:public	signature:(const T&)
find	.\HashTable.h	/^    typename HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::const_iterator HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::find(const T& key) const$/;"	f	class:WTF::HashTable	signature:(const T& key) const
find	.\HashTable.h	/^    typename HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::iterator HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::find(const T& key)$/;"	f	class:WTF::HashTable	signature:(const T& key)
find	.\ListHashSet.h	/^        const_iterator find(const ValueType&) const;$/;"	p	class:WTF::ListHashSet	access:public	signature:(const ValueType&) const
find	.\ListHashSet.h	/^        iterator find(const ValueType&);$/;"	p	class:WTF::ListHashSet	access:public	signature:(const ValueType&)
find	.\ListHashSet.h	/^        template<typename T, typename HashTranslator> const_iterator find(const T&) const;$/;"	p	class:WTF::ListHashSet	access:public	signature:(const T&) const
find	.\ListHashSet.h	/^        template<typename T, typename HashTranslator> iterator find(const T&);$/;"	p	class:WTF::ListHashSet	access:public	signature:(const T&)
find	.\ListHashSet.h	/^    inline typename ListHashSet<T, inlineCapacity, U>::const_iterator ListHashSet<T, inlineCapacity, U>::find(const ValueType& value) const$/;"	f	class:WTF::ListHashSet	signature:(const ValueType& value) const
find	.\ListHashSet.h	/^    inline typename ListHashSet<T, inlineCapacity, U>::iterator ListHashSet<T, inlineCapacity, U>::find(const ValueType& value)$/;"	f	class:WTF::ListHashSet	signature:(const ValueType& value)
find	.\ListHashSet.h	/^    inline typename ListHashSet<ValueType, inlineCapacity, U>::const_iterator ListHashSet<ValueType, inlineCapacity, U>::find(const T& value) const$/;"	f	class:WTF::ListHashSet	signature:(const T& value) const
find	.\ListHashSet.h	/^    inline typename ListHashSet<ValueType, inlineCapacity, U>::iterator ListHashSet<ValueType, inlineCapacity, U>::find(const T& value)$/;"	f	class:WTF::ListHashSet	signature:(const T& value)
find	.\MetaAllocator.h	/^    MetaAllocatorHandle* find(void* address)$/;"	f	class:WTF::MetaAllocatorTracker	access:public	signature:(void* address)
find	.\RefPtrHashMap.h	/^        const_iterator find(RawKeyType) const;$/;"	p	class:WTF::HashMap	access:public	signature:(RawKeyType) const
find	.\RefPtrHashMap.h	/^        const_iterator find(const KeyType&) const;$/;"	p	class:WTF::HashMap	access:public	signature:(const KeyType&) const
find	.\RefPtrHashMap.h	/^        iterator find(RawKeyType);$/;"	p	class:WTF::HashMap	access:public	signature:(RawKeyType)
find	.\RefPtrHashMap.h	/^        iterator find(const KeyType&);$/;"	p	class:WTF::HashMap	access:public	signature:(const KeyType&)
find	.\RefPtrHashMap.h	/^    inline typename HashMap<RefPtr<T>, U, V, W, X>::const_iterator HashMap<RefPtr<T>, U, V, W, X>::find(RawKeyType key) const$/;"	f	class:WTF::HashMap	signature:(RawKeyType key) const
find	.\RefPtrHashMap.h	/^    inline typename HashMap<RefPtr<T>, U, V, W, X>::const_iterator HashMap<RefPtr<T>, U, V, W, X>::find(const KeyType& key) const$/;"	f	class:WTF::HashMap	signature:(const KeyType& key) const
find	.\RefPtrHashMap.h	/^    inline typename HashMap<RefPtr<T>, U, V, W, X>::iterator HashMap<RefPtr<T>, U, V, W, X>::find(RawKeyType key)$/;"	f	class:WTF::HashMap	signature:(RawKeyType key)
find	.\RefPtrHashMap.h	/^    inline typename HashMap<RefPtr<T>, U, V, W, X>::iterator HashMap<RefPtr<T>, U, V, W, X>::find(const KeyType& key)$/;"	f	class:WTF::HashMap	signature:(const KeyType& key)
find	.\UnionFind.h	/^    T* find()$/;"	f	class:WTF::UnionFind	access:public	signature:()
find	.\Vector.h	/^        template<typename U> size_t find(const U&) const;$/;"	p	class:WTF::Vector	access:public	signature:(const U&) const
find	.\Vector.h	/^    size_t Vector<T, inlineCapacity>::find(const U& value) const$/;"	f	class:WTF::Vector	signature:(const U& value) const
find	.\text\AtomicString.cpp	/^AtomicStringImpl* AtomicString::find(const UChar* s, unsigned length, unsigned existingHash)$/;"	f	class:WTF::AtomicString	signature:(const UChar* s, unsigned length, unsigned existingHash)
find	.\text\AtomicString.h	/^    WTF_EXPORT_PRIVATE static AtomicStringImpl* find(const UChar* s, unsigned length, unsigned existingHash);$/;"	p	class:WTF::AtomicString	access:public	signature:(const UChar* s, unsigned length, unsigned existingHash)
find	.\text\AtomicString.h	/^    size_t find(UChar c, size_t start = 0) const { return m_string.find(c, start); }$/;"	f	class:WTF::AtomicString	access:public	signature:(UChar c, size_t start = 0) const
find	.\text\AtomicString.h	/^    size_t find(const LChar* s, size_t start = 0, bool caseSentitive = true) const$/;"	f	class:WTF::AtomicString	access:public	signature:(const LChar* s, size_t start = 0, bool caseSentitive = true) const
find	.\text\AtomicString.h	/^    size_t find(const String& s, size_t start = 0, bool caseSentitive = true) const$/;"	f	class:WTF::AtomicString	access:public	signature:(const String& s, size_t start = 0, bool caseSentitive = true) const
find	.\text\StringImpl.cpp	/^size_t StringImpl::find(CharacterMatchFunctionPtr matchFunction, unsigned start)$/;"	f	class:WTF::StringImpl	signature:(CharacterMatchFunctionPtr matchFunction, unsigned start)
find	.\text\StringImpl.cpp	/^size_t StringImpl::find(StringImpl* matchString, unsigned index)$/;"	f	class:WTF::StringImpl	signature:(StringImpl* matchString, unsigned index)
find	.\text\StringImpl.cpp	/^size_t StringImpl::find(UChar c, unsigned start)$/;"	f	class:WTF::StringImpl	signature:(UChar c, unsigned start)
find	.\text\StringImpl.cpp	/^size_t StringImpl::find(const LChar* matchString, unsigned index)$/;"	f	class:WTF::StringImpl	signature:(const LChar* matchString, unsigned index)
find	.\text\StringImpl.h	/^    ALWAYS_INLINE size_t find(const char* s, unsigned index = 0) { return find(reinterpret_cast<const LChar*>(s), index); };$/;"	f	class:WTF::StringImpl	access:public	signature:(const char* s, unsigned index = 0)
find	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE size_t find(CharacterMatchFunctionPtr, unsigned index = 0);$/;"	p	class:WTF::StringImpl	access:public	signature:(CharacterMatchFunctionPtr, unsigned index = 0)
find	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE size_t find(StringImpl*, unsigned index = 0);$/;"	p	class:WTF::StringImpl	access:public	signature:(StringImpl*, unsigned index = 0)
find	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE size_t find(UChar, unsigned index = 0);$/;"	p	class:WTF::StringImpl	access:public	signature:(UChar, unsigned index = 0)
find	.\text\StringImpl.h	/^    size_t find(const LChar*, unsigned index = 0);$/;"	p	class:WTF::StringImpl	access:public	signature:(const LChar*, unsigned index = 0)
find	.\text\WTFString.h	/^    size_t find(CharacterMatchFunctionPtr matchFunction, unsigned start = 0) const$/;"	f	class:WTF::String	access:public	signature:(CharacterMatchFunctionPtr matchFunction, unsigned start = 0) const
find	.\text\WTFString.h	/^    size_t find(UChar c, unsigned start = 0) const$/;"	f	class:WTF::String	access:public	signature:(UChar c, unsigned start = 0) const
find	.\text\WTFString.h	/^    size_t find(const LChar* str, unsigned start = 0) const$/;"	f	class:WTF::String	access:public	signature:(const LChar* str, unsigned start = 0) const
find	.\text\WTFString.h	/^    size_t find(const LChar* str, unsigned start, bool caseSensitive) const$/;"	f	class:WTF::String	access:public	signature:(const LChar* str, unsigned start, bool caseSensitive) const
find	.\text\WTFString.h	/^    size_t find(const String& str, unsigned start = 0) const$/;"	f	class:WTF::String	access:public	signature:(const String& str, unsigned start = 0) const
find	.\text\WTFString.h	/^    size_t find(const String& str, unsigned start, bool caseSensitive) const$/;"	f	class:WTF::String	access:public	signature:(const String& str, unsigned start, bool caseSensitive) const
find	.\text\WTFString.h	/^inline size_t find(const LChar* characters, unsigned length, CharacterMatchFunctionPtr matchFunction, unsigned index = 0)$/;"	f	namespace:WTF	signature:(const LChar* characters, unsigned length, CharacterMatchFunctionPtr matchFunction, unsigned index = 0)
find	.\text\WTFString.h	/^inline size_t find(const LChar* characters, unsigned length, LChar matchCharacter, unsigned index = 0)$/;"	f	namespace:WTF	signature:(const LChar* characters, unsigned length, LChar matchCharacter, unsigned index = 0)
find	.\text\WTFString.h	/^inline size_t find(const UChar* characters, unsigned length, CharacterMatchFunctionPtr matchFunction, unsigned index = 0)$/;"	f	namespace:WTF	signature:(const UChar* characters, unsigned length, CharacterMatchFunctionPtr matchFunction, unsigned index = 0)
find	.\text\WTFString.h	/^inline size_t find(const UChar* characters, unsigned length, UChar matchCharacter, unsigned index = 0)$/;"	f	namespace:WTF	signature:(const UChar* characters, unsigned length, UChar matchCharacter, unsigned index = 0)
findAndRemoveFreeSpace	.\MetaAllocator.cpp	/^void* MetaAllocator::findAndRemoveFreeSpace(size_t sizeInBytes)$/;"	f	class:WTF::MetaAllocator	signature:(size_t sizeInBytes)
findAndRemoveFreeSpace	.\MetaAllocator.h	/^    void* findAndRemoveFreeSpace(size_t sizeInBytes);$/;"	p	class:WTF::MetaAllocator	access:private	signature:(size_t sizeInBytes)
findExact	.\RedBlackTree.h	/^    NodeType* findExact(const KeyType& key) const$/;"	f	class:WTF::RedBlackTree	access:public	signature:(const KeyType& key) const
findFreeObjects	.\FastMalloc.cpp	/^    void findFreeObjects(TCMalloc_Central_FreeListPadded* centralFreeList, size_t numSizes, TCMalloc_Central_FreeListPadded* remoteCentralFreeList)$/;"	f	class:WTF::FreeObjectFinder	access:public	signature:(TCMalloc_Central_FreeListPadded* centralFreeList, size_t numSizes, TCMalloc_Central_FreeListPadded* remoteCentralFreeList)
findFreeObjects	.\FastMalloc.cpp	/^    void findFreeObjects(TCMalloc_ThreadCache* threadCache)$/;"	f	class:WTF::FreeObjectFinder	access:public	signature:(TCMalloc_ThreadCache* threadCache)
findGreatestLessThanOrEqual	.\RedBlackTree.h	/^    NodeType* findGreatestLessThanOrEqual(const KeyType& key) const$/;"	f	class:WTF::RedBlackTree	access:public	signature:(const KeyType& key) const
findIf	.\Deque.h	/^        iterator findIf(Predicate&);$/;"	p	class:WTF::Deque	access:public	signature:(Predicate&)
findIf	.\Deque.h	/^    inline DequeIterator<T, inlineCapacity> Deque<T, inlineCapacity>::findIf(Predicate& predicate)$/;"	f	class:WTF::Deque	signature:(Predicate& predicate)
findIgnoringCase	.\text\StringImpl.cpp	/^size_t StringImpl::findIgnoringCase(StringImpl* matchString, unsigned index)$/;"	f	class:WTF::StringImpl	signature:(StringImpl* matchString, unsigned index)
findIgnoringCase	.\text\StringImpl.cpp	/^size_t StringImpl::findIgnoringCase(const LChar* matchString, unsigned index)$/;"	f	class:WTF::StringImpl	signature:(const LChar* matchString, unsigned index)
findIgnoringCase	.\text\StringImpl.h	/^    ALWAYS_INLINE size_t findIgnoringCase(const char* s, unsigned index = 0) { return findIgnoringCase(reinterpret_cast<const LChar*>(s), index); };$/;"	f	class:WTF::StringImpl	access:public	signature:(const char* s, unsigned index = 0)
findIgnoringCase	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE size_t findIgnoringCase(StringImpl*, unsigned index = 0);$/;"	p	class:WTF::StringImpl	access:public	signature:(StringImpl*, unsigned index = 0)
findIgnoringCase	.\text\StringImpl.h	/^    size_t findIgnoringCase(const LChar*, unsigned index = 0);$/;"	p	class:WTF::StringImpl	access:public	signature:(const LChar*, unsigned index = 0)
findIgnoringCase	.\text\WTFString.h	/^    size_t findIgnoringCase(const LChar* str, unsigned start = 0) const$/;"	f	class:WTF::String	access:public	signature:(const LChar* str, unsigned start = 0) const
findIgnoringCase	.\text\WTFString.h	/^    size_t findIgnoringCase(const String& str, unsigned start = 0) const$/;"	f	class:WTF::String	access:public	signature:(const String& str, unsigned start = 0) const
findInner	.\text\StringImpl.cpp	/^ALWAYS_INLINE static size_t findInner(const CharType* searchCharacters, const CharType* matchCharacters, unsigned index, unsigned searchLength, unsigned matchLength)$/;"	f	namespace:WTF	file:	signature:(const CharType* searchCharacters, const CharType* matchCharacters, unsigned index, unsigned searchLength, unsigned matchLength)
findLeastGreaterThanOrEqual	.\RedBlackTree.h	/^    NodeType* findLeastGreaterThanOrEqual(const KeyType& key) const$/;"	f	class:WTF::RedBlackTree	access:public	signature:(const KeyType& key) const
findMonth	.\DateMath.cpp	/^static int findMonth(const char* monthStr)$/;"	f	namespace:WTF	file:	signature:(const char* monthStr)
findRunOfZeros	.\Bitmap.h	/^    int64_t findRunOfZeros(size_t) const;$/;"	p	class:WTF::Bitmap	access:public	signature:(size_t) const
findRunOfZeros	.\Bitmap.h	/^inline int64_t Bitmap<size, atomicMode>::findRunOfZeros(size_t runLength) const$/;"	f	class:WTF::Bitmap	signature:(size_t runLength) const
first	.\Deque.h	/^        T& first() { ASSERT(m_start != m_end); return m_buffer.buffer()[m_start]; }$/;"	f	class:WTF::Deque	access:public	signature:()
first	.\Deque.h	/^        const T& first() const { ASSERT(m_start != m_end); return m_buffer.buffer()[m_start]; }$/;"	f	class:WTF::Deque	access:public	signature:() const
first	.\ListHashSet.h	/^        ValueType& first();$/;"	p	class:WTF::ListHashSet	access:public	signature:()
first	.\ListHashSet.h	/^        const ValueType& first() const;$/;"	p	class:WTF::ListHashSet	access:public	signature:() const
first	.\ListHashSet.h	/^    inline T& ListHashSet<T, inlineCapacity, U>::first()$/;"	f	class:WTF::ListHashSet	signature:()
first	.\ListHashSet.h	/^    inline const T& ListHashSet<T, inlineCapacity, U>::first() const$/;"	f	class:WTF::ListHashSet	signature:() const
first	.\RedBlackTree.h	/^    NodeType* first() const$/;"	f	class:WTF::RedBlackTree	access:public	signature:() const
first	.\Vector.h	/^        T& first() { return at(0); }$/;"	f	class:WTF::Vector	access:public	signature:()
first	.\Vector.h	/^        const T& first() const { return at(0); }$/;"	f	class:WTF::Vector	access:public	signature:() const
first	.\dtoa\utils.h	/^        T& first() { return start_[0]; }$/;"	f	class:WTF::double_conversion::Vector	access:public	signature:()
first	.\text\TextPosition.h	/^    static OrdinalNumber first() { return OrdinalNumber(0); }$/;"	f	class:WTF::OrdinalNumber	access:public	signature:()
firstByteMark	.\unicode\UTF8.cpp	/^static const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };$/;"	v	file:
firstDayOfMonth	.\DateMath.cpp	/^static const int firstDayOfMonth[2][12] = {$/;"	v	file:
firstSlot	.\BloomFilter.h	/^    const uint8_t& firstSlot(unsigned hash) const { return m_table[hash & keyMask]; }$/;"	f	class:WTF::BloomFilter	access:private	signature:(unsigned hash) const
firstSlot	.\BloomFilter.h	/^    uint8_t& firstSlot(unsigned hash) { return m_table[hash & keyMask]; }$/;"	f	class:WTF::BloomFilter	access:private	signature:(unsigned hash)
fisheye	.\unicode\CharacterNames.h	/^const UChar fisheye = 0x25C9;$/;"	v
flagCount	.\StringHasher.h	/^    static const unsigned flagCount = 8; \/\/ Save 8 bits for StringImpl to use as flags.$/;"	m	class:WTF::StringHasher	access:public
flagIs8Bit	.\text\StringImpl.h	/^    static unsigned flagIs8Bit() { return s_hashFlag8BitBuffer; }$/;"	f	class:WTF::StringImpl	access:public	signature:()
flagsOffset	.\text\StringImpl.h	/^    static unsigned flagsOffset() { return OBJECT_OFFSETOF(StringImpl, m_hashAndFlags); }$/;"	f	class:WTF::StringImpl	access:public	signature:()
flags_	.\dtoa\double-conversion.h	/^        const int flags_;$/;"	m	class:WTF::double_conversion::DoubleToStringConverter	access:private
flags_	.\dtoa\double-conversion.h	/^        const int flags_;$/;"	m	class:WTF::double_conversion::StringToDoubleConverter	access:private
floatCheck	.\TypeTraits.h	/^            static NoType floatCheck(...);$/;"	p	class:WTF::IsConvertibleToInteger::IsConvertibleToDouble	access:private	signature:(....)
floatCheck	.\TypeTraits.h	/^            static YesType floatCheck(long double);$/;"	p	class:WTF::IsConvertibleToInteger::IsConvertibleToDouble	access:private	signature:(long double)
fmod	.\MathExtras.h	207;"	d
foldCase	.\text\StringHash.h	/^        template<typename T> static inline UChar foldCase(T ch)$/;"	f	class:WTF::CaseFoldingHash	access:public	signature:(T ch)
foldCase	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::foldCase()$/;"	f	class:WTF::StringImpl	signature:()
foldCase	.\text\StringImpl.h	/^    PassRefPtr<StringImpl> foldCase();$/;"	p	class:WTF::StringImpl	access:public	signature:()
foldCase	.\text\WTFString.cpp	/^String String::foldCase() const$/;"	f	class:WTF::String	signature:() const
foldCase	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE String foldCase() const;$/;"	p	class:WTF::String	access:public	signature:() const
foldCase	.\unicode\glib\UnicodeGLib.cpp	/^UChar32 foldCase(UChar32 ch)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 ch)
foldCase	.\unicode\glib\UnicodeGLib.cpp	/^int foldCase(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)$/;"	f	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)
foldCase	.\unicode\glib\UnicodeGLib.h	/^UChar32 foldCase(UChar32);$/;"	p	namespace:WTF::Unicode	signature:(UChar32)
foldCase	.\unicode\glib\UnicodeGLib.h	/^int foldCase(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error);$/;"	p	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)
foldCase	.\unicode\icu\UnicodeIcu.h	/^inline UChar32 foldCase(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
foldCase	.\unicode\icu\UnicodeIcu.h	/^inline int foldCase(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)$/;"	f	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)
foldCase	.\unicode\qt4\UnicodeQt4.h	/^inline UChar32 foldCase(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
foldCase	.\unicode\qt4\UnicodeQt4.h	/^inline int foldCase(UChar* result, int resultLength, const UChar* src, int srcLength,  bool* error)$/;"	f	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)
foldCase	.\unicode\wince\UnicodeWinCE.cpp	/^UChar foldCase(UChar c)$/;"	f	namespace:WTF::Unicode	signature:(UChar c)
foldCase	.\unicode\wince\UnicodeWinCE.cpp	/^int foldCase(UChar* result, int resultLength, const UChar* source, int sourceLength, bool* isError)$/;"	f	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* source, int sourceLength, bool* isError)
foldCase	.\unicode\wince\UnicodeWinCE.h	/^UChar foldCase(UChar);$/;"	p	namespace:WTF::Unicode	signature:(UChar)
foldCase	.\unicode\wince\UnicodeWinCE.h	/^int foldCase(UChar* result, int resultLength, const UChar* source, int sourceLength, bool* isError);$/;"	p	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* source, int sourceLength, bool* isError)
forAlignment	.\ListHashSet.h	/^            double forAlignment;$/;"	m	union:WTF::ListHashSetNodeAllocator::__anon9	access:public
forceLock	.\FastMalloc.cpp	/^    static void forceLock(malloc_zone_t*) { }$/;"	f	class:WTF::FastMallocZone	access:public	signature:(malloc_zone_t*)
forceUnlock	.\FastMalloc.cpp	/^    static void forceUnlock(malloc_zone_t*) { }$/;"	f	class:WTF::FastMallocZone	access:public	signature:(malloc_zone_t*)
format	.\text\WTFString.cpp	/^String String::format(const char *format, ...)$/;"	f	class:WTF::String	signature:(const char *format, ...)
format	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE static String format(const char *, ...);$/;"	p	class:WTF::String	access:public	signature:(const char *, ...)
formatStringTruncatingTrailingZerosIfNeeded	.\dtoa.cpp	/^static inline const char* formatStringTruncatingTrailingZerosIfNeeded(NumberToStringBuffer buffer, double_conversion::StringBuilder& builder)$/;"	f	namespace:WTF	file:	signature:(NumberToStringBuffer buffer, double_conversion::StringBuilder& builder)
fragment	.\url\api\ParsedURL.cpp	/^String ParsedURL::fragment() const$/;"	f	class:WTF::ParsedURL	signature:() const
fragment	.\url\api\ParsedURL.h	/^    WTF_EXPORT_PRIVATE String fragment() const;$/;"	p	class:WTF::ParsedURL	access:public	signature:() const
fragment	.\url\src\URLSegments.h	/^    URLComponent fragment;$/;"	m	class:WTF::URLSegments	access:public
free	.\FastMalloc.cpp	/^  unsigned int  free : 1;       \/\/ Is the span free$/;"	m	struct:WTF::Span	file:	access:public
free	.\FastMalloc.cpp	/^void free(void* ptr) {$/;"	f	namespace:WTF	signature:(void* ptr)
free	.\FastMalloc.cpp	4658;"	d	file:
free	.\FastMalloc.cpp	500;"	d	file:
free	.\wince\FastMallocWinCE.h	55;"	d
free	.\wince\MemoryManager.cpp	26;"	d	file:
free64kBlock	.\wince\MemoryManager.cpp	/^void MemoryManager::free64kBlock(void* p)$/;"	f	class:WTF::MemoryManager	signature:(void* p)
free64kBlock	.\wince\MemoryManager.h	/^        static void free64kBlock(void*);$/;"	p	class:WTF::MemoryManager	access:public	signature:(void*)
freeFreeSpaceNode	.\MetaAllocator.cpp	/^void MetaAllocator::freeFreeSpaceNode(FreeSpaceNode* node)$/;"	f	class:WTF::MetaAllocator	signature:(FreeSpaceNode* node)
freeFreeSpaceNode	.\MetaAllocator.h	/^    WTF_EXPORT_PRIVATE void freeFreeSpaceNode(FreeSpaceNode*);$/;"	p	class:WTF::MetaAllocator	access:private	signature:(FreeSpaceNode*)
freeListBytes	.\FastMalloc.h	/^        size_t freeListBytes;$/;"	m	struct:WTF::FastMallocStatistics	access:public
freeObjectCount	.\FastMalloc.cpp	/^    size_t freeObjectCount() const { return m_freeObjects.size(); }$/;"	f	class:WTF::FreeObjectFinder	access:public	signature:() const
freeOwnedGPtr	.\gobject\GOwnPtr.cpp	/^template <> void freeOwnedGPtr<GDir>(GDir* ptr)$/;"	f	namespace:WTF	signature:(GDir* ptr)
freeOwnedGPtr	.\gobject\GOwnPtr.cpp	/^template <> void freeOwnedGPtr<GError>(GError* ptr)$/;"	f	namespace:WTF	signature:(GError* ptr)
freeOwnedGPtr	.\gobject\GOwnPtr.cpp	/^template <> void freeOwnedGPtr<GKeyFile>(GKeyFile* ptr)$/;"	f	namespace:WTF	signature:(GKeyFile* ptr)
freeOwnedGPtr	.\gobject\GOwnPtr.cpp	/^template <> void freeOwnedGPtr<GList>(GList* ptr)$/;"	f	namespace:WTF	signature:(GList* ptr)
freeOwnedGPtr	.\gobject\GOwnPtr.cpp	/^template <> void freeOwnedGPtr<GPatternSpec>(GPatternSpec* ptr)$/;"	f	namespace:WTF	signature:(GPatternSpec* ptr)
freeOwnedGPtr	.\gobject\GOwnPtr.cpp	/^template <> void freeOwnedGPtr<GSList>(GSList* ptr)$/;"	f	namespace:WTF	signature:(GSList* ptr)
freeOwnedGPtr	.\gobject\GOwnPtr.cpp	/^template <> void freeOwnedGPtr<GTimer>(GTimer* ptr)$/;"	f	namespace:WTF	signature:(GTimer* ptr)
freeOwnedGPtr	.\gobject\GOwnPtr.h	/^template <typename T> inline void freeOwnedGPtr(T* ptr)$/;"	f	namespace:WTF	signature:(T* ptr)
freeOwnedGPtr	.\gobject\GOwnPtr.h	/^template <typename T> inline void freeOwnedGPtr(T* ptr);$/;"	p	namespace:WTF	signature:(T* ptr)
freeOwnedGPtr	.\gobject\GOwnPtr.h	/^template<> void freeOwnedGPtr<GDir>(GDir*);$/;"	p	namespace:WTF	signature:(GDir*)
freeOwnedGPtr	.\gobject\GOwnPtr.h	/^template<> void freeOwnedGPtr<GError>(GError*);$/;"	p	namespace:WTF	signature:(GError*)
freeOwnedGPtr	.\gobject\GOwnPtr.h	/^template<> void freeOwnedGPtr<GKeyFile>(GKeyFile*);$/;"	p	namespace:WTF	signature:(GKeyFile*)
freeOwnedGPtr	.\gobject\GOwnPtr.h	/^template<> void freeOwnedGPtr<GList>(GList*);$/;"	p	namespace:WTF	signature:(GList*)
freeOwnedGPtr	.\gobject\GOwnPtr.h	/^template<> void freeOwnedGPtr<GPatternSpec>(GPatternSpec*);$/;"	p	namespace:WTF	signature:(GPatternSpec*)
freeOwnedGPtr	.\gobject\GOwnPtr.h	/^template<> void freeOwnedGPtr<GSList>(GSList*);$/;"	p	namespace:WTF	signature:(GSList*)
freeOwnedGPtr	.\gobject\GOwnPtr.h	/^template<> void freeOwnedGPtr<GTimer>(GTimer*);$/;"	p	namespace:WTF	signature:(GTimer*)
free_	.\FastMalloc.cpp	/^  SpanList free_[kMaxPages];$/;"	m	class:WTF::TCMalloc_PageHeap	file:	access:private
free_area_	.\FastMalloc.cpp	/^  char* free_area_;$/;"	m	class:WTF::PageHeapAllocator	file:	access:private
free_avail_	.\FastMalloc.cpp	/^  size_t free_avail_;$/;"	m	class:WTF::PageHeapAllocator	file:	access:private
free_committed_pages_	.\FastMalloc.cpp	/^  Length free_committed_pages_;$/;"	m	class:WTF::TCMalloc_PageHeap	file:	access:private
free_list_	.\FastMalloc.cpp	/^  void* free_list_;$/;"	m	class:WTF::PageHeapAllocator	file:	access:private
free_pages_	.\FastMalloc.cpp	/^  uintptr_t free_pages_;$/;"	m	class:WTF::TCMalloc_PageHeap	file:	access:private
freelist_length	.\FastMalloc.cpp	/^  int freelist_length(size_t cl) const { return list_[cl].length(); }$/;"	f	class:WTF::TCMalloc_ThreadCache	access:public	signature:(size_t cl) const
fromOneBasedInt	.\text\TextPosition.h	/^    static OrdinalNumber fromOneBasedInt(int oneBasedInt) { return OrdinalNumber(oneBasedInt - 1); }$/;"	f	class:WTF::OrdinalNumber	access:public	signature:(int oneBasedInt)
fromPayload	.\RefCountedArray.h	/^        static Header* fromPayload(T* payload)$/;"	f	struct:WTF::RefCountedArray::Header	access:public	signature:(T* payload)
fromRange	.\url\src\URLComponent.h	/^    static inline URLComponent fromRange(int begin, int end)$/;"	f	class:WTF::URLComponent	access:public	signature:(int begin, int end)
fromUTF8	.\text\AtomicString.h	/^    static AtomicString fromUTF8(const char*);$/;"	p	class:WTF::AtomicString	access:public	signature:(const char*)
fromUTF8	.\text\AtomicString.h	/^    static AtomicString fromUTF8(const char*, size_t);$/;"	p	class:WTF::AtomicString	access:public	signature:(const char*, size_t)
fromUTF8	.\text\AtomicString.h	/^inline AtomicString AtomicString::fromUTF8(const char* characters)$/;"	f	class:WTF::AtomicString	signature:(const char* characters)
fromUTF8	.\text\AtomicString.h	/^inline AtomicString AtomicString::fromUTF8(const char* characters, size_t length)$/;"	f	class:WTF::AtomicString	signature:(const char* characters, size_t length)
fromUTF8	.\text\WTFString.cpp	/^String String::fromUTF8(const LChar* string)$/;"	f	class:WTF::String	signature:(const LChar* string)
fromUTF8	.\text\WTFString.cpp	/^String String::fromUTF8(const LChar* stringStart, size_t length)$/;"	f	class:WTF::String	signature:(const LChar* stringStart, size_t length)
fromUTF8	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE static String fromUTF8(const LChar*);$/;"	p	class:WTF::String	access:public	signature:(const LChar*)
fromUTF8	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE static String fromUTF8(const LChar*, size_t);$/;"	p	class:WTF::String	access:public	signature:(const LChar*, size_t)
fromUTF8	.\text\WTFString.h	/^    static String fromUTF8(const char* s) { return fromUTF8(reinterpret_cast<const LChar*>(s)); };$/;"	f	class:WTF::String	access:public	signature:(const char* s)
fromUTF8	.\text\WTFString.h	/^    static String fromUTF8(const char* s, size_t length) { return fromUTF8(reinterpret_cast<const LChar*>(s), length); };$/;"	f	class:WTF::String	access:public	signature:(const char* s, size_t length)
fromUTF8Internal	.\text\AtomicString.cpp	/^AtomicString AtomicString::fromUTF8Internal(const char* charactersStart, const char* charactersEnd)$/;"	f	class:WTF::AtomicString	signature:(const char* charactersStart, const char* charactersEnd)
fromUTF8Internal	.\text\AtomicString.h	/^    WTF_EXPORT_PRIVATE static AtomicString fromUTF8Internal(const char*, const char*);$/;"	p	class:WTF::AtomicString	access:private	signature:(const char*, const char*)
fromUTF8WithLatin1Fallback	.\text\WTFString.cpp	/^String String::fromUTF8WithLatin1Fallback(const LChar* string, size_t size)$/;"	f	class:WTF::String	signature:(const LChar* string, size_t size)
fromUTF8WithLatin1Fallback	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE static String fromUTF8WithLatin1Fallback(const LChar*, size_t);$/;"	p	class:WTF::String	access:public	signature:(const LChar*, size_t)
fromUTF8WithLatin1Fallback	.\text\WTFString.h	/^    static String fromUTF8WithLatin1Fallback(const char* s, size_t length) { return fromUTF8WithLatin1Fallback(reinterpret_cast<const LChar*>(s), length); };$/;"	f	class:WTF::String	access:public	signature:(const char* s, size_t length)
fromZeroBasedInt	.\text\TextPosition.h	/^    static OrdinalNumber fromZeroBasedInt(int zeroBasedInt) { return OrdinalNumber(zeroBasedInt); }$/;"	f	class:WTF::OrdinalNumber	access:public	signature:(int zeroBasedInt)
fullLookupForWriting	.\HashTable.h	/^        template<typename HashTranslator, typename T> FullLookupType fullLookupForWriting(const T&);$/;"	p	class:WTF::HashTable	access:private	signature:(const T&)
fullLookupForWriting	.\HashTable.h	/^    inline typename HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::FullLookupType HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::fullLookupForWriting(const T& key)$/;"	f	class:WTF::HashTable	signature:(const T& key)
function	.\MainThread.cpp	/^    MainThreadFunction* function;$/;"	m	struct:WTF::FunctionWithContext	file:	access:public
function	.\ThreadFunctionInvocation.h	/^    ThreadFunction function;$/;"	m	struct:WTF::ThreadFunctionInvocation	access:public
function	.\Threading.cpp	/^    ThreadFunctionWithReturnValue function;$/;"	m	struct:WTF::ThreadFunctionWithReturnValueInvocation	file:	access:public
functionQueue	.\MainThread.cpp	/^static FunctionQueue& functionQueue()$/;"	f	namespace:WTF	file:	signature:()
g_free	.\gobject\GOwnPtr.h	/^extern "C" void g_free(void*);$/;"	p	signature:(void*)
g_object_unref	.\gobject\GRefPtr.h	/^extern "C" void g_object_unref(gpointer);$/;"	p	signature:(gpointer)
gboolean	.\gobject\GTypedefs.h	/^typedef gint gboolean;$/;"	t
gchar	.\gobject\GTypedefs.h	/^typedef char gchar;$/;"	t
gdouble	.\gobject\GTypedefs.h	/^typedef double gdouble;$/;"	t
genericBinarySearch	.\StdLibExtras.h	/^inline ArrayElementType* genericBinarySearch(ArrayType& array, size_t size, KeyType key)$/;"	f	namespace:WTF	signature:(ArrayType& array, size_t size, KeyType key)
get	.\BitVector.h	/^    bool get(size_t bit) const$/;"	f	class:WTF::BitVector	access:public	signature:(size_t bit) const
get	.\Bitmap.h	/^    bool get(size_t) const;$/;"	p	class:WTF::Bitmap	access:public	signature:(size_t) const
get	.\Bitmap.h	/^inline bool Bitmap<size, atomicMode>::get(size_t n) const$/;"	f	class:WTF::Bitmap	signature:(size_t n) const
get	.\BoundsCheckedPointer.h	/^    T* get()$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:()
get	.\ByteArray.h	/^        bool get(unsigned index, unsigned char& result) const$/;"	f	class:WTF::ByteArray	access:public	signature:(unsigned index, unsigned char& result) const
get	.\ByteArray.h	/^        unsigned char get(unsigned index) const$/;"	f	class:WTF::ByteArray	access:public	signature:(unsigned index) const
get	.\HashIterators.h	/^        KeyType* get() const { return &(m_impl.get()->first); }$/;"	f	struct:WTF::HashTableKeysIterator	access:public	signature:() const
get	.\HashIterators.h	/^        MappedType* get() const { return &(m_impl.get()->second); }$/;"	f	struct:WTF::HashTableValuesIterator	access:public	signature:() const
get	.\HashIterators.h	/^        ValueType* get() const { return (ValueType*)m_impl.get(); }$/;"	f	struct:WTF::HashTableIteratorAdapter	access:public	signature:() const
get	.\HashIterators.h	/^        const KeyType* get() const { return &(m_impl.get()->first); }$/;"	f	struct:WTF::HashTableConstKeysIterator	access:public	signature:() const
get	.\HashIterators.h	/^        const MappedType* get() const { return &(m_impl.get()->second); }$/;"	f	struct:WTF::HashTableConstValuesIterator	access:public	signature:() const
get	.\HashIterators.h	/^        const ValueType* get() const { return (const ValueType*)m_impl.get(); }$/;"	f	struct:WTF::HashTableConstIteratorAdapter	access:public	signature:() const
get	.\HashMap.h	/^        MappedPeekType get(const KeyType&) const;$/;"	p	class:WTF::HashMap	access:public	signature:(const KeyType&) const
get	.\HashMap.h	/^    HashMap<T, U, V, W, MappedTraits>::get(const KeyType& key) const$/;"	f	class:WTF::HashMap	signature:(const KeyType& key) const
get	.\HashTable.h	/^        PointerType get() const { return const_cast<PointerType>(m_iterator.get()); }$/;"	f	class:WTF::HashTableIterator	access:public	signature:() const
get	.\HashTable.h	/^        PointerType get() const$/;"	f	class:WTF::HashTableConstIterator	access:public	signature:() const
get	.\HashTable.h	/^        ValueType* get() const { return (ValueType*)m_impl.get(); }$/;"	f	struct:WTF::HashTableIteratorAdapter	access:public	signature:() const
get	.\HashTable.h	/^        const ValueType* get() const { return (const ValueType*)m_impl.get(); }$/;"	f	struct:WTF::HashTableConstIteratorAdapter	access:public	signature:() const
get	.\ListHashSet.h	/^        PointerType get() const { return const_cast<PointerType>(m_iterator.get()); }$/;"	f	class:WTF::ListHashSetIterator	access:public	signature:() const
get	.\ListHashSet.h	/^        PointerType get() const { return const_cast<PointerType>(m_iterator.get()); }$/;"	f	class:WTF::ListHashSetReverseIterator	access:public	signature:() const
get	.\ListHashSet.h	/^        PointerType get() const$/;"	f	class:WTF::ListHashSetConstIterator	access:public	signature:() const
get	.\ListHashSet.h	/^        PointerType get() const$/;"	f	class:WTF::ListHashSetConstReverseIterator	access:public	signature:() const
get	.\OwnArrayPtr.h	/^    PtrType get() const { return m_ptr; }$/;"	f	class:WTF::OwnArrayPtr	access:public	signature:() const
get	.\OwnPtr.h	/^        PtrType get() const { return m_ptr; }$/;"	f	class:WTF::OwnPtr	access:public	signature:() const
get	.\PackedIntVector.h	/^    T get(size_t index) const$/;"	f	class:WTF::PackedIntVector	access:public	signature:(size_t index) const
get	.\PassOwnArrayPtr.h	/^    PtrType get() const { return m_ptr; }$/;"	f	class:WTF::PassOwnArrayPtr	access:public	signature:() const
get	.\PassOwnPtr.h	/^        PtrType get() const { return m_ptr; }$/;"	f	class:WTF::PassOwnPtr	access:public	signature:() const
get	.\PassRefPtr.h	/^        T* get() const { return m_ptr; }$/;"	f	class:WTF::NonNullPassRefPtr	access:public	signature:() const
get	.\PassRefPtr.h	/^        T* get() const { return m_ptr; }$/;"	f	class:WTF::PassRefPtr	access:public	signature:() const
get	.\RefPtr.h	/^        T* get() const { return m_ptr; }$/;"	f	class:WTF::RefPtr	access:public	signature:() const
get	.\RefPtrHashMap.h	/^        MappedPeekType get(RawKeyType) const;$/;"	p	class:WTF::HashMap	access:public	signature:(RawKeyType) const
get	.\RefPtrHashMap.h	/^        MappedPeekType get(const KeyType&) const;$/;"	p	class:WTF::HashMap	access:public	signature:(const KeyType&) const
get	.\RefPtrHashMap.h	/^    HashMap<RefPtr<T>, U, V, W, MappedTraits>::get(RawKeyType key) const$/;"	f	class:WTF::HashMap	signature:(RawKeyType key) const
get	.\RefPtrHashMap.h	/^    HashMap<RefPtr<T>, U, V, W, MappedTraits>::get(const KeyType& key) const$/;"	f	class:WTF::HashMap	signature:(const KeyType& key) const
get	.\RetainPtr.h	/^        PtrType get() const { return m_ptr; }$/;"	f	class:WTF::RetainPtr	access:public	signature:() const
get	.\Spectrum.h	/^    unsigned long get(const T& key) const$/;"	f	class:WTF::Spectrum	access:public	signature:(const T& key) const
get	.\TCPageMap.h	/^  void* get(Number k) const {$/;"	f	class:TCMalloc_PageMap1	access:public	signature:(Number k) const
get	.\TCPageMap.h	/^  void* get(Number k) const {$/;"	f	class:TCMalloc_PageMap2	access:public	signature:(Number k) const
get	.\TCPageMap.h	/^  void* get(Number k) const {$/;"	f	class:TCMalloc_PageMap3	access:public	signature:(Number k) const
get	.\ThreadSpecific.h	/^    T* get();$/;"	p	class:WTF::ThreadSpecific	access:private	signature:()
get	.\ThreadSpecific.h	/^inline T* ThreadSpecific<T>::get()$/;"	f	class:WTF::ThreadSpecific	signature:()
get	.\gobject\GOwnPtr.h	/^    T* get() const { return m_ptr; }$/;"	f	class:WTF::GOwnPtr	access:public	signature:() const
get	.\gobject\GRefPtr.h	/^    T* get() const { return m_ptr; }$/;"	f	class:WTF::GRefPtr	access:public	signature:() const
getBufferCharacters	.\text\StringBuilder.h	/^    ALWAYS_INLINE CharType * getBufferCharacters();$/;"	p	class:WTF::StringBuilder	access:private	signature:()
getBufferCharacters	.\text\StringBuilder.h	/^ALWAYS_INLINE LChar* StringBuilder::getBufferCharacters<LChar>()$/;"	f	class:WTF::StringBuilder	signature:()
getBufferCharacters	.\text\StringBuilder.h	/^ALWAYS_INLINE UChar* StringBuilder::getBufferCharacters<UChar>()$/;"	f	class:WTF::StringBuilder	signature:()
getByte	.\CryptographicallyRandomNumber.cpp	/^    inline uint8_t getByte();$/;"	p	class:WTF::__anon3::ARC4RandomNumberGenerator	file:	access:private	signature:()
getByte	.\CryptographicallyRandomNumber.cpp	/^uint8_t ARC4RandomNumberGenerator::getByte()$/;"	f	class:WTF::__anon3::ARC4RandomNumberGenerator	signature:()
getCharacters	.\text\StringImpl.h	/^    ALWAYS_INLINE const CharType * getCharacters() const;$/;"	p	class:WTF::StringImpl	access:public	signature:() const
getCharacters	.\text\StringImpl.h	/^ALWAYS_INLINE const LChar* StringImpl::getCharacters<LChar>() const { return characters8(); }$/;"	f	class:WTF::StringImpl	signature:() const
getCharacters	.\text\StringImpl.h	/^ALWAYS_INLINE const UChar* StringImpl::getCharacters<UChar>() const { return characters(); }$/;"	f	class:WTF::StringImpl	signature:() const
getCharacters	.\text\WTFString.h	/^    inline const CharType* getCharacters() const;$/;"	p	class:WTF::String	access:public	signature:() const
getCharacters	.\text\WTFString.h	/^inline const LChar* String::getCharacters<LChar>() const$/;"	f	class:WTF::String	signature:() const
getCharacters	.\text\WTFString.h	/^inline const UChar* String::getCharacters<UChar>() const$/;"	f	class:WTF::String	signature:() const
getCurrentExecutablePath	.\gobject\GlibUtilities.cpp	/^CString getCurrentExecutablePath()$/;"	f	signature:()
getCurrentExecutablePath	.\gobject\GlibUtilities.h	/^CString getCurrentExecutablePath();$/;"	p	signature:()
getData16SlowCase	.\text\StringImpl.cpp	/^const UChar* StringImpl::getData16SlowCase() const$/;"	f	class:WTF::StringImpl	signature:() const
getData16SlowCase	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE NEVER_INLINE const UChar* getData16SlowCase() const;$/;"	p	class:WTF::StringImpl	access:private	signature:() const
getLocalTime	.\CurrentTime.h	/^inline void getLocalTime(const time_t* localTime, struct tm* localTM)$/;"	f	namespace:WTF	signature:(const time_t* localTime, struct tm* localTM)
getLowerStackBound	.\StackBounds.cpp	/^static inline void* getLowerStackBound(char* currentPage, DWORD pageSize)$/;"	f	namespace:WTF	file:	signature:(char* currentPage, DWORD pageSize)
getPageHeap	.\FastMalloc.cpp	/^static inline TCMalloc_PageHeap* getPageHeap()$/;"	f	namespace:WTF	file:	signature:()
getPtr	.\GetPtr.h	/^    template <typename T> inline T* getPtr(T* p)$/;"	f	namespace:WTF	signature:(T* p)
getPtr	.\ListRefPtr.h	/^    template <typename T> inline T* getPtr(const ListRefPtr<T>& p)$/;"	f	namespace:WTF	signature:(const ListRefPtr<T>& p)
getPtr	.\OwnArrayPtr.h	/^template <typename T> inline T* getPtr(const OwnArrayPtr<T>& p)$/;"	f	namespace:WTF	signature:(const OwnArrayPtr<T>& p)
getPtr	.\OwnPtr.h	/^    template<typename T> inline typename OwnPtr<T>::PtrType getPtr(const OwnPtr<T>& p)$/;"	f	namespace:WTF	signature:(const OwnPtr<T>& p)
getPtr	.\PassOwnArrayPtr.h	/^template<typename T> inline T* getPtr(const PassOwnArrayPtr<T>& p)$/;"	f	namespace:WTF	signature:(const PassOwnArrayPtr<T>& p)
getPtr	.\PassOwnPtr.h	/^    template<typename T> inline T* getPtr(const PassOwnPtr<T>& p)$/;"	f	namespace:WTF	signature:(const PassOwnPtr<T>& p)
getPtr	.\PassRefPtr.h	/^    template<typename T> inline T* getPtr(const PassRefPtr<T>& p)$/;"	f	namespace:WTF	signature:(const PassRefPtr<T>& p)
getPtr	.\RefPtr.h	/^    template<typename T> inline T* getPtr(const RefPtr<T>& p)$/;"	f	namespace:WTF	signature:(const RefPtr<T>& p)
getPtr	.\gobject\GOwnPtr.h	/^template <typename T> inline typename GOwnPtr<T>::PtrType getPtr(const GOwnPtr<T>& p)$/;"	f	namespace:WTF	signature:(const GOwnPtr<T>& p)
getPtr	.\gobject\GRefPtr.h	/^template <typename T> inline T* getPtr(const GRefPtr<T>& p)$/;"	f	namespace:WTF	signature:(const GRefPtr<T>& p)
getUTF16LengthFromUTF8	.\unicode\glib\UnicodeGLib.cpp	/^static int getUTF16LengthFromUTF8(const gchar* utf8String, int length)$/;"	f	namespace:WTF::Unicode	file:	signature:(const gchar* utf8String, int length)
getUpperStackBound	.\StackBounds.cpp	/^static inline void* getUpperStackBound(char* currentPage, DWORD pageSize)$/;"	f	namespace:WTF	file:	signature:(char* currentPage, DWORD pageSize)
getValue	.\FastMalloc.h	/^    template <typename T> bool TryMallocReturnValue::getValue(T& data)$/;"	f	class:WTF::TryMallocReturnValue	signature:(T& data)
getValue	.\PossiblyNull.h	/^template <typename T> bool PossiblyNull<T>::getValue(T& out)$/;"	f	class:WTF::PossiblyNull	signature:(T& out)
getWord	.\CryptographicallyRandomNumber.cpp	/^    inline uint32_t getWord();$/;"	p	class:WTF::__anon3::ARC4RandomNumberGenerator	file:	access:private	signature:()
getWord	.\CryptographicallyRandomNumber.cpp	/^uint32_t ARC4RandomNumberGenerator::getWord()$/;"	f	class:WTF::__anon3::ARC4RandomNumberGenerator	signature:()
get_bf	.\AVLTree.h	/^    int get_bf(handle h) { return abs.get_balance_factor(h); }$/;"	f	class:WTF::AVLTree	access:protected	signature:(handle h)
get_gt	.\AVLTree.h	/^        handle get_gt(handle h) { return tree_->abs.get_greater(h); }$/;"	f	class:WTF::AVLTree::Iterator	access:protected	signature:(handle h)
get_gt	.\AVLTree.h	/^    handle get_gt(handle h) { return abs.get_greater(h); }$/;"	f	class:WTF::AVLTree	access:protected	signature:(handle h)
get_lt	.\AVLTree.h	/^        handle get_lt(handle h) { return tree_->abs.get_less(h); }$/;"	f	class:WTF::AVLTree::Iterator	access:protected	signature:(handle h)
get_lt	.\AVLTree.h	/^    handle get_lt(handle h) { return abs.get_less(h); }$/;"	f	class:WTF::AVLTree	access:protected	signature:(handle h)
gfloat	.\gobject\GTypedefs.h	/^typedef float gfloat;$/;"	t
gint	.\gobject\GTypedefs.h	/^typedef int gint;$/;"	t
globalHook	.\Assertions.cpp	/^static WTFCrashHookFunction globalHook = 0;$/;"	v	file:
glong	.\gobject\GTypedefs.h	/^typedef long glong;$/;"	t
goodSize	.\FastMalloc.cpp	/^    static size_t goodSize(malloc_zone_t*, size_t size) { return size; }$/;"	f	class:WTF::FastMallocZone	access:public	signature:(malloc_zone_t*, size_t size)
gpointer	.\gobject\GTypedefs.h	/^typedef void* gpointer;$/;"	t
grad2deg	.\MathExtras.h	/^inline double grad2deg(double g) { return g * 360.0 \/ 400.0; }$/;"	f	signature:(double g)
grad2deg	.\MathExtras.h	/^inline float grad2deg(float g) { return g * 360.0f \/ 400.0f; }$/;"	f	signature:(float g)
grad2rad	.\MathExtras.h	/^inline double grad2rad(double g) { return g * piDouble \/ 200.0; }$/;"	f	signature:(double g)
grad2rad	.\MathExtras.h	/^inline float grad2rad(float g) { return g * piFloat \/ 200.0f; }$/;"	f	signature:(float g)
grow	.\BlockStack.h	/^    T* grow();$/;"	p	class:WTF::BlockStack	access:public	signature:()
grow	.\BlockStack.h	/^template <typename T> T* BlockStack<T>::grow()$/;"	f	class:WTF::BlockStack	signature:()
grow	.\SegmentedVector.h	/^        void grow(size_t size)$/;"	f	class:WTF::SegmentedVector	access:public	signature:(size_t size)
grow	.\Vector.h	/^        void grow(size_t size);$/;"	p	class:WTF::Vector	access:public	signature:(size_t size)
grow	.\Vector.h	/^    void Vector<T, inlineCapacity>::grow(size_t size)$/;"	f	class:WTF::Vector	signature:(size_t size)
grow	.\url\src\URLBuffer.h	/^    bool grow(int minimumAdditionalCapacity)$/;"	f	class:WTF::URLBuffer	access:protected	signature:(int minimumAdditionalCapacity)
gshort	.\gobject\GTypedefs.h	/^typedef short gshort;$/;"	t
guchar	.\gobject\GTypedefs.h	/^typedef unsigned char guchar;$/;"	t
guint	.\gobject\GTypedefs.h	/^typedef unsigned int guint;$/;"	t
gulong	.\gobject\GTypedefs.h	/^typedef unsigned long gulong;$/;"	t
gushort	.\gobject\GTypedefs.h	/^typedef unsigned short gushort;$/;"	t
handle	.\AVLTree.h	/^    typedef typename Abstractor::handle handle;$/;"	t	class:WTF::AVLTree	access:public
has16BitShadow	.\text\StringImpl.h	/^    bool has16BitShadow() const { return m_hashAndFlags & s_hashFlagHas16BitShadow; }$/;"	f	class:WTF::StringImpl	access:public	signature:() const
hasHash	.\text\StringImpl.h	/^    bool hasHash() const$/;"	f	class:WTF::StringImpl	access:public	signature:() const
hasLineBreakingPropertyComplexContext	.\unicode\glib\UnicodeGLib.h	/^inline bool hasLineBreakingPropertyComplexContext(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
hasLineBreakingPropertyComplexContext	.\unicode\icu\UnicodeIcu.h	/^inline bool hasLineBreakingPropertyComplexContext(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
hasLineBreakingPropertyComplexContext	.\unicode\qt4\UnicodeQt4.h	/^inline bool hasLineBreakingPropertyComplexContext(UChar32)$/;"	f	namespace:WTF::Unicode	signature:(UChar32)
hasLineBreakingPropertyComplexContext	.\unicode\wince\UnicodeWinCE.h	/^inline bool hasLineBreakingPropertyComplexContext(UChar32)$/;"	f	namespace:WTF::Unicode	signature:(UChar32)
hasLineBreakingPropertyComplexContextOrIdeographic	.\unicode\glib\UnicodeGLib.h	/^inline bool hasLineBreakingPropertyComplexContextOrIdeographic(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
hasLineBreakingPropertyComplexContextOrIdeographic	.\unicode\icu\UnicodeIcu.h	/^inline bool hasLineBreakingPropertyComplexContextOrIdeographic(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
hasOneRef	.\RefCounted.h	/^    bool hasOneRef() const$/;"	f	class:WTF::RefCountedBase	access:public	signature:() const
hasOneRef	.\ThreadSafeRefCounted.h	/^    bool hasOneRef()$/;"	f	class:WTF::ThreadSafeRefCountedBase	access:public	signature:()
hasOneRef	.\text\StringImpl.h	/^    inline bool hasOneRef() const$/;"	f	class:WTF::StringImpl	access:public	signature:() const
hasOverflowed	.\CheckedArithmetic.h	/^    bool hasOverflowed() const { return false; }$/;"	f	class:WTF::CrashOnOverflow	access:public	signature:() const
hasOverflowed	.\CheckedArithmetic.h	/^    bool hasOverflowed() const { return m_overflowed; }$/;"	f	class:WTF::RecordOverflow	access:public	signature:() const
hasTerminatingNullCharacter	.\text\StringImpl.h	/^    bool hasTerminatingNullCharacter() const { return m_hashAndFlags & s_hashFlagHasTerminatingNullCharacter; }$/;"	f	class:WTF::StringImpl	access:public	signature:() const
hash	.\HashFunctions.h	/^        static unsigned hash(T key) { return intHash(static_cast<typename IntTypes<sizeof(T)>::UnsignedType>(key)); }$/;"	f	struct:WTF::IntHash	access:public	signature:(T key)
hash	.\HashFunctions.h	/^        static unsigned hash(T key)$/;"	f	struct:WTF::FloatHash	access:public	signature:(T key)
hash	.\HashFunctions.h	/^        static unsigned hash(T key)$/;"	f	struct:WTF::PtrHash	access:public	signature:(T key)
hash	.\HashFunctions.h	/^        static unsigned hash(const RefPtr<P>& key) { return hash(key.get()); }$/;"	f	struct:WTF::PtrHash	access:public	signature:(const RefPtr<P>& key)
hash	.\HashFunctions.h	/^        static unsigned hash(const std::pair<T, U>& p)$/;"	f	struct:WTF::PairHash	access:public	signature:(const std::pair<T, U>& p)
hash	.\HashMap.h	/^        template<typename T> static unsigned hash(const T& key) { return HashFunctions::hash(key); }$/;"	f	struct:WTF::HashMapTranslator	access:public	signature:(const T& key)
hash	.\HashMap.h	/^        template<typename T> static unsigned hash(const T& key) { return Translator::hash(key); }$/;"	f	struct:WTF::HashMapTranslatorAdapter	access:public	signature:(const T& key)
hash	.\HashSet.h	/^        template<typename T> static unsigned hash(const T& key) { return Translator::hash(key); }$/;"	f	struct:WTF::HashSetTranslatorAdapter	access:public	signature:(const T& key)
hash	.\HashTable.h	/^        template<typename T> static unsigned hash(const T& key) { return HashFunctions::hash(key); }$/;"	f	class:WTF::IdentityHashTranslator	access:public	signature:(const T& key)
hash	.\ListHashSet.h	/^        template<typename T> static unsigned hash(const T& key) { return HashArg::hash(key->m_value); }$/;"	f	struct:WTF::ListHashSetNodeHashFunctions	access:public	signature:(const T& key)
hash	.\ListHashSet.h	/^        template<typename T> static unsigned hash(const T& key) { return HashFunctions::hash(key); }$/;"	f	struct:WTF::ListHashSetTranslator	access:public	signature:(const T& key)
hash	.\ListHashSet.h	/^        template<typename T> static unsigned hash(const T& key) { return Translator::hash(key); }$/;"	f	struct:WTF::ListHashSetTranslatorAdapter	access:public	signature:(const T& key)
hash	.\RetainPtr.h	/^        static unsigned hash(const RetainPtr<P>& key) { return hash(key.get()); }$/;"	f	struct:WTF::PtrHash	access:public	signature:(const RetainPtr<P>& key)
hash	.\StringHasher.h	/^    inline unsigned hash() const$/;"	f	class:WTF::StringHasher	access:public	signature:() const
hash	.\text\AtomicString.cpp	/^    static unsigned hash(const HashAndCharacters& buffer)$/;"	f	struct:WTF::HashAndCharactersTranslator	access:public	signature:(const HashAndCharacters& buffer)
hash	.\text\AtomicString.cpp	/^    static unsigned hash(const HashAndUTF8Characters& buffer)$/;"	f	struct:WTF::HashAndUTF8CharactersTranslator	access:public	signature:(const HashAndUTF8Characters& buffer)
hash	.\text\AtomicString.cpp	/^    static unsigned hash(const LChar* c)$/;"	f	struct:WTF::CStringTranslator	access:public	signature:(const LChar* c)
hash	.\text\AtomicString.cpp	/^    static unsigned hash(const SubstringLocation& buffer)$/;"	f	struct:WTF::SubstringTranslator	access:public	signature:(const SubstringLocation& buffer)
hash	.\text\AtomicString.cpp	/^    static unsigned hash(const UCharBuffer& buf)$/;"	f	struct:WTF::UCharBufferTranslator	access:public	signature:(const UCharBuffer& buf)
hash	.\text\AtomicString.cpp	/^    unsigned hash;$/;"	m	struct:WTF::HashAndCharacters	file:	access:public
hash	.\text\AtomicString.cpp	/^    unsigned hash;$/;"	m	struct:WTF::HashAndUTF8Characters	file:	access:public
hash	.\text\AtomicStringHash.h	/^        static unsigned hash(const AtomicString& key)$/;"	f	struct:WTF::AtomicStringHash	access:public	signature:(const AtomicString& key)
hash	.\text\StringHash.h	/^        static inline unsigned hash(const char* data, unsigned length)$/;"	f	class:WTF::CaseFoldingHash	access:public	signature:(const char* data, unsigned length)
hash	.\text\StringHash.h	/^        static unsigned hash(StringImpl* key) { return key->hash(); }$/;"	f	struct:WTF::StringHash	access:public	signature:(StringImpl* key)
hash	.\text\StringHash.h	/^        static unsigned hash(StringImpl* str)$/;"	f	class:WTF::CaseFoldingHash	access:public	signature:(StringImpl* str)
hash	.\text\StringHash.h	/^        static unsigned hash(const AtomicString& key)$/;"	f	class:WTF::CaseFoldingHash	access:public	signature:(const AtomicString& key)
hash	.\text\StringHash.h	/^        static unsigned hash(const LChar* data, unsigned length)$/;"	f	class:WTF::CaseFoldingHash	access:public	signature:(const LChar* data, unsigned length)
hash	.\text\StringHash.h	/^        static unsigned hash(const RefPtr<StringImpl>& key) $/;"	f	class:WTF::CaseFoldingHash	access:public	signature:(const RefPtr<StringImpl>& key)
hash	.\text\StringHash.h	/^        static unsigned hash(const RefPtr<StringImpl>& key) { return key->hash(); }$/;"	f	struct:WTF::StringHash	access:public	signature:(const RefPtr<StringImpl>& key)
hash	.\text\StringHash.h	/^        static unsigned hash(const String& key) { return key.impl()->hash(); }$/;"	f	struct:WTF::StringHash	access:public	signature:(const String& key)
hash	.\text\StringHash.h	/^        static unsigned hash(const String& key)$/;"	f	class:WTF::CaseFoldingHash	access:public	signature:(const String& key)
hash	.\text\StringHash.h	/^        static unsigned hash(const UChar* data, unsigned length)$/;"	f	class:WTF::CaseFoldingHash	access:public	signature:(const UChar* data, unsigned length)
hash	.\text\StringHash.h	/^        static unsigned hash(unsigned key) { return key; }$/;"	f	struct:WTF::AlreadyHashed	access:public	signature:(unsigned key)
hash	.\text\StringImpl.h	/^    unsigned hash() const$/;"	f	class:WTF::StringImpl	access:public	signature:() const
hashMemory	.\StringHasher.h	/^    static inline unsigned hashMemory(const void* data, unsigned size)$/;"	f	class:WTF::StringHasher	access:public	signature:(const void* data, unsigned size)
hashMemory	.\StringHasher.h	/^    template<size_t length> static inline unsigned hashMemory(const void* data)$/;"	f	class:WTF::StringHasher	access:public	signature:(const void* data)
hashSlowCase	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE NEVER_INLINE unsigned hashSlowCase() const;$/;"	p	class:WTF::StringImpl	access:private	signature:() const
hashSlowCase	.\text\StringStatics.cpp	/^NEVER_INLINE unsigned StringImpl::hashSlowCase() const$/;"	f	class:WTF::StringImpl	signature:() const
hashTableDeletedValue	.\RefPtr.h	/^        static T* hashTableDeletedValue() { return reinterpret_cast<T*>(-1); }$/;"	f	class:WTF::RefPtr	access:public	signature:()
hashTableDeletedValue	.\RetainPtr.h	/^        static PtrType hashTableDeletedValue() { return reinterpret_cast<PtrType>(-1); }$/;"	f	class:WTF::RetainPtr	access:private	signature:()
hashTableDeletedValue	.\gobject\GRefPtr.h	/^    static T* hashTableDeletedValue() { return reinterpret_cast<T*>(-1); }$/;"	f	class:WTF::GRefPtr	access:private	signature:()
hashTableStatsMutex	.\HashTable.cpp	/^static Mutex& hashTableStatsMutex()$/;"	f	namespace:WTF	file:	signature:()
hashTableSwap	.\HashTable.h	/^    template<typename T, typename U> inline void hashTableSwap(pair<T, U>& a, pair<T, U>& b)$/;"	f	namespace:WTF	signature:(pair<T, U>& a, pair<T, U>& b)
hashTableSwap	.\HashTable.h	/^    template<typename T> inline void hashTableSwap(T& a, T& b)$/;"	f	namespace:WTF	signature:(T& a, T& b)
head	.\DoublyLinkedList.h	/^    T* head() const;$/;"	p	class:WTF::DoublyLinkedList	access:public	signature:() const
head	.\DoublyLinkedList.h	/^template<typename T> inline T* DoublyLinkedList<T>::head() const$/;"	f	class:WTF::DoublyLinkedList	signature:() const
head	.\FastMalloc.cpp	/^  void *head;  \/\/ Head of chain of objects.$/;"	m	struct:WTF::TCEntry	file:	access:public
heapSort	.\NonCopyingSort.h	/^void heapSort(RandomAccessIterator start, RandomAccessIterator end, Predicate compareLess)$/;"	f	namespace:WTF	signature:(RandomAccessIterator start, RandomAccessIterator end, Predicate compareLess)
heap_key	.\FastMalloc.cpp	/^static const pthread_key_t heap_key = __PTK_FRAMEWORK_JAVASCRIPTCORE_KEY0;$/;"	v	file:
heap_key	.\FastMalloc.cpp	/^static pthread_key_t heap_key;$/;"	v	file:
heapify	.\NonCopyingSort.h	/^inline void heapify(RandomAccessIterator array, ptrdiff_t count, Predicate compareLess) $/;"	f	namespace:WTF	signature:(RandomAccessIterator array, ptrdiff_t count, Predicate compareLess)
hebrewPunctuationGeresh	.\unicode\CharacterNames.h	/^const UChar hebrewPunctuationGeresh = 0x05F3;$/;"	v
hebrewPunctuationGershayim	.\unicode\CharacterNames.h	/^const UChar hebrewPunctuationGershayim = 0x05F4;$/;"	v
held_	.\FastMalloc.cpp	/^  SpinLock *held_, *temp_;$/;"	m	class:WTF::__anon6::LockInverter	file:	access:private
hexCharacterTable	.\url\src\URLEscape.cpp	/^const char hexCharacterTable[16] = {$/;"	v
hexDigitsForMode	.\HexNumber.h	/^static const char* hexDigitsForMode(HexConversionMode mode)$/;"	f	namespace:WTF::Internal	signature:(HexConversionMode mode)
hi0bits	.\dtoa.cpp	/^static int hi0bits(uint32_t x)$/;"	f	namespace:WTF	file:	signature:(uint32_t x)
highResUpTime	.\CurrentTime.cpp	/^static double highResUpTime()$/;"	f	namespace:WTF	file:	signature:()
high_bits_	.\dtoa\fixed-dtoa.cc	/^        uint64_t high_bits_;$/;"	m	class:WTF::double_conversion::UInt128	file:	access:private
history	.\FastMalloc.cpp	/^  char history[64];$/;"	m	struct:WTF::Span	file:	access:public
horizontalEllipsis	.\unicode\CharacterNames.h	/^const UChar horizontalEllipsis = 0x2026;$/;"	v
host	.\url\api\ParsedURL.cpp	/^String ParsedURL::host() const$/;"	f	class:WTF::ParsedURL	signature:() const
host	.\url\api\ParsedURL.h	/^    WTF_EXPORT_PRIVATE String host() const;$/;"	p	class:WTF::ParsedURL	access:public	signature:() const
host	.\url\src\URLSegments.h	/^    URLComponent host;$/;"	m	class:WTF::URLSegments	access:public
hoursPerDay	.\DateMath.h	/^const double hoursPerDay = 24.0;$/;"	v
hyphen	.\unicode\CharacterNames.h	/^const UChar hyphen = 0x2010;$/;"	v
hyphenMinus	.\unicode\CharacterNames.h	/^const UChar hyphenMinus = 0x002D;$/;"	v
i	.\CryptographicallyRandomNumber.cpp	/^    uint8_t i;$/;"	m	class:WTF::__anon3::ARC4Stream	file:	access:public
i2b	.\dtoa.cpp	/^static void i2b(BigInt& b, int i)$/;"	f	namespace:WTF	file:	signature:(BigInt& b, int i)
identifier	.\ThreadIdentifierDataPthreads.cpp	/^ThreadIdentifier ThreadIdentifierData::identifier()$/;"	f	class:WTF::ThreadIdentifierData	signature:()
identifier	.\ThreadIdentifierDataPthreads.h	/^    static ThreadIdentifier identifier();$/;"	p	class:WTF::ThreadIdentifierData	access:public	signature:()
identifierByPthreadHandle	.\ThreadingPthreads.cpp	/^static ThreadIdentifier identifierByPthreadHandle(const pthread_t& pthreadHandle)$/;"	f	namespace:WTF	file:	signature:(const pthread_t& pthreadHandle)
ideographicComma	.\unicode\CharacterNames.h	/^const UChar ideographicComma = 0x3001;$/;"	v
ideographicFullStop	.\unicode\CharacterNames.h	/^const UChar ideographicFullStop = 0x3002;$/;"	v
ideographicSpace	.\unicode\CharacterNames.h	/^const UChar ideographicSpace = 0x3000;$/;"	v
impl	.\Functional.h	/^    template<typename FunctionType> FunctionImpl<FunctionType>* impl() const$/;"	f	class:WTF::FunctionBase	access:protected	signature:() const
impl	.\ThreadingPrimitives.h	/^    PlatformMutex& impl() { return m_mutex; }$/;"	f	class:WTF::Mutex	access:public	signature:()
impl	.\text\AtomicString.h	/^    AtomicStringImpl* impl() const { return static_cast<AtomicStringImpl *>(m_string.impl()); }$/;"	f	class:WTF::AtomicString	access:public	signature:() const
impl	.\text\WTFString.h	/^    StringImpl* impl() const { return m_impl.get(); }$/;"	f	class:WTF::String	access:public	signature:() const
inBounds	.\CheckedArithmetic.h	/^    static bool inBounds(Source value)$/;"	f	struct:WTF::BoundsChecker	access:public	signature:(Source value)
inBounds	.\CheckedArithmetic.h	/^    static bool inBounds(Source) { return true; }$/;"	f	struct:WTF::BoundsCheckElider	access:public	signature:(Source)
inPool	.\ListHashSet.h	/^        bool inPool(Node* node)$/;"	f	struct:WTF::ListHashSetNodeAllocator	access:private	signature:(Node* node)
in_setspecific_	.\FastMalloc.cpp	/^  bool          in_setspecific_;           \/\/ Called pthread_setspecific?$/;"	m	class:WTF::TCMalloc_ThreadCache	file:	access:private
increment	.\Deque.h	/^        void increment();$/;"	p	class:WTF::DequeIteratorBase	access:protected	signature:()
increment	.\Deque.h	/^    inline void DequeIteratorBase<T, inlineCapacity>::increment()$/;"	f	class:WTF::DequeIteratorBase	signature:()
increment	.\RefCountedLeakCounter.cpp	/^void RefCountedLeakCounter::increment() { }$/;"	f	class:WTF::RefCountedLeakCounter	signature:()
increment	.\RefCountedLeakCounter.h	/^        WTF_EXPORT_PRIVATE void increment();$/;"	p	struct:WTF::RefCountedLeakCounter	access:public	signature:()
incrementPageOccupancy	.\MetaAllocator.cpp	/^void MetaAllocator::incrementPageOccupancy(void* address, size_t sizeInBytes)$/;"	f	class:WTF::MetaAllocator	signature:(void* address, size_t sizeInBytes)
incrementPageOccupancy	.\MetaAllocator.h	/^    void incrementPageOccupancy(void* address, size_t sizeInBytes);$/;"	p	class:WTF::MetaAllocator	access:private	signature:(void* address, size_t sizeInBytes)
infiniteTime	.\MessageQueue.h	/^        static double infiniteTime() { return std::numeric_limits<double>::max(); }$/;"	f	class:WTF::MessageQueue	access:public	signature:()
infinity_symbol_	.\dtoa\double-conversion.h	/^        const char* const infinity_symbol_;$/;"	m	class:WTF::double_conversion::DoubleToStringConverter	access:private
infinity_symbol_	.\dtoa\double-conversion.h	/^        const char* const infinity_symbol_;$/;"	m	class:WTF::double_conversion::StringToDoubleConverter	access:private
init	.\FastMalloc.cpp	/^    static void init();$/;"	p	class:WTF::FastMallocZone	file:	access:public	signature:()
init	.\FastMalloc.cpp	/^  void init();$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:public	signature:()
init	.\FastMalloc.cpp	/^void FastMallocZone::init()$/;"	f	class:WTF::FastMallocZone	signature:()
init	.\FastMalloc.cpp	/^void TCMalloc_PageHeap::init()$/;"	f	class:WTF::TCMalloc_PageHeap	signature:()
init	.\TCPageMap.h	/^  void init(void* (*allocator)(size_t)) {$/;"	f	class:TCMalloc_PageMap1	access:public	signature:(void* (*allocator)(size_t))
init	.\TCPageMap.h	/^  void init(void* (*allocator)(size_t)) {$/;"	f	class:TCMalloc_PageMap2	access:public	signature:(void* (*allocator)(size_t))
init	.\TCPageMap.h	/^  void init(void* (*allocator)(size_t)) {$/;"	f	class:TCMalloc_PageMap3	access:public	signature:(void* (*allocator)(size_t))
init	.\text\AtomicString.h	/^    WTF_EXPORT_PRIVATE static void init();$/;"	p	class:WTF::AtomicString	access:public	signature:()
init	.\text\CString.cpp	/^void CString::init(const char* str, size_t length)$/;"	f	class:WTF::CString	signature:(const char* str, size_t length)
init	.\text\CString.h	/^    void init(const char*, size_t length);$/;"	p	class:WTF::CString	access:private	signature:(const char*, size_t length)
init	.\text\StringStatics.cpp	/^void AtomicString::init()$/;"	f	class:WTF::AtomicString	signature:()
init_by_array	.\RandomNumberSeed.h	/^void init_by_array(unsigned long init_key[],int key_length);$/;"	p	signature:(unsigned long init_key[],int key_length)
initialize	.\HashTable.h	/^        template<typename Traits, typename Value> static void initialize(Value& bucket)$/;"	f	struct:WTF::HashTableBucketInitializer	access:public	signature:(Value& bucket)
initialize	.\StackBounds.cpp	/^void StackBounds::initialize()$/;"	f	class:WTF::StackBounds	signature:()
initialize	.\StackBounds.h	/^    void initialize();$/;"	p	class:WTF::StackBounds	access:private	signature:()
initialize	.\ThreadIdentifierDataPthreads.cpp	/^void ThreadIdentifierData::initialize(ThreadIdentifier id)$/;"	f	class:WTF::ThreadIdentifierData	signature:(ThreadIdentifier id)
initialize	.\ThreadIdentifierDataPthreads.h	/^    static void initialize(ThreadIdentifier identifier);$/;"	p	class:WTF::ThreadIdentifierData	access:public	signature:(ThreadIdentifier identifier)
initialize	.\Vector.h	/^        static void initialize(T* begin, T* end) $/;"	f	struct:WTF::VectorInitializer	access:public	signature:(T* begin, T* end)
initialize	.\Vector.h	/^        static void initialize(T* begin, T* end)$/;"	f	struct:WTF::VectorTypeOperations	access:public	signature:(T* begin, T* end)
initialize	.\Vector.h	/^        static void initialize(T*, T*) {}$/;"	f	struct:WTF::VectorInitializer	access:public	signature:(T*, T*)
initialize	.\dtoa\cached-powers.cc	/^    void initialize() {$/;"	f	namespace:WTF::double_conversion	signature:()
initialize	.\dtoa\cached-powers.h	/^    void initialize();$/;"	p	namespace:WTF::double_conversion	signature:()
initializeBucket	.\HashTable.h	/^        static void initializeBucket(ValueType& bucket);$/;"	p	class:WTF::HashTable	access:private	signature:(ValueType& bucket)
initializeBucket	.\HashTable.h	/^    inline void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::initializeBucket(ValueType& bucket)$/;"	f	class:WTF::HashTable	signature:(ValueType& bucket)
initializeCurrentThreadInternal	.\Threading.h	/^void initializeCurrentThreadInternal(const char* threadName);$/;"	p	namespace:WTF	signature:(const char* threadName)
initializeCurrentThreadInternal	.\ThreadingPthreads.cpp	/^void initializeCurrentThreadInternal(const char* threadName)$/;"	f	namespace:WTF	signature:(const char* threadName)
initializeCurrentThreadInternal	.\ThreadingWin.cpp	/^void initializeCurrentThreadInternal(const char* szThreadName)$/;"	f	namespace:WTF	signature:(const char* szThreadName)
initializeDates	.\DateMath.cpp	/^void initializeDates()$/;"	f	namespace:WTF	signature:()
initializeDates	.\DateMath.h	/^void initializeDates();$/;"	p	namespace:WTF	signature:()
initializeGCThreads	.\MainThread.cpp	/^void initializeGCThreads()$/;"	f	namespace:WTF	signature:()
initializeGCThreads	.\MainThread.h	/^void initializeGCThreads();$/;"	p	namespace:WTF	signature:()
initializeLogFile	.\DataLog.cpp	/^static void initializeLogFile()$/;"	f	namespace:WTF	file:	signature:()
initializeLogFileOnce	.\DataLog.cpp	/^static void initializeLogFileOnce()$/;"	f	namespace:WTF	file:	signature:()
initializeLogFileOnceKey	.\DataLog.cpp	/^static pthread_once_t initializeLogFileOnceKey = PTHREAD_ONCE_INIT;$/;"	v	file:
initializeMainThread	.\MainThread.cpp	/^void initializeMainThread()$/;"	f	namespace:WTF	signature:()
initializeMainThread	.\MainThread.h	/^WTF_EXPORT_PRIVATE void initializeMainThread();$/;"	p	namespace:WTF	signature:()
initializeMainThread	.\chromium\MainThreadChromium.cpp	/^void initializeMainThread()$/;"	f	namespace:WTF	signature:()
initializeMainThreadKeyOnce	.\MainThread.cpp	/^static pthread_once_t initializeMainThreadKeyOnce = PTHREAD_ONCE_INIT;$/;"	v	file:
initializeMainThreadOnce	.\MainThread.cpp	/^static void initializeMainThreadOnce()$/;"	f	namespace:WTF	file:	signature:()
initializeMainThreadPlatform	.\MainThread.h	/^void initializeMainThreadPlatform();$/;"	p	namespace:WTF	signature:()
initializeMainThreadPlatform	.\blackberry\MainThreadBlackBerry.cpp	/^void initializeMainThreadPlatform()$/;"	f	namespace:WTF	signature:()
initializeMainThreadPlatform	.\efl\MainThreadEfl.cpp	/^void initializeMainThreadPlatform()$/;"	f	namespace:WTF	signature:()
initializeMainThreadPlatform	.\gtk\MainThreadGtk.cpp	/^void initializeMainThreadPlatform()$/;"	f	namespace:WTF	signature:()
initializeMainThreadPlatform	.\qt\MainThreadQt.cpp	/^void initializeMainThreadPlatform()$/;"	f	namespace:WTF	signature:()
initializeMainThreadPlatform	.\win\MainThreadWin.cpp	/^void initializeMainThreadPlatform()$/;"	f	namespace:WTF	signature:()
initializeMainThreadPlatform	.\wx\MainThreadWx.cpp	/^void initializeMainThreadPlatform()$/;"	f	namespace:WTF	signature:()
initializeMainThreadToProcessMainThread	.\MainThread.cpp	/^void initializeMainThreadToProcessMainThread()$/;"	f	namespace:WTF	signature:()
initializeMainThreadToProcessMainThread	.\MainThread.h	/^WTF_EXPORT_PRIVATE void initializeMainThreadToProcessMainThread();$/;"	p	namespace:WTF	signature:()
initializeMainThreadToProcessMainThreadOnce	.\MainThread.cpp	/^static void initializeMainThreadToProcessMainThreadOnce()$/;"	f	namespace:WTF	file:	signature:()
initializeMainThreadToProcessMainThreadPlatform	.\MainThread.h	/^void initializeMainThreadToProcessMainThreadPlatform();$/;"	p	namespace:WTF	signature:()
initializeOnce	.\ThreadIdentifierDataPthreads.cpp	/^void ThreadIdentifierData::initializeOnce()$/;"	f	class:WTF::ThreadIdentifierData	signature:()
initializeOnce	.\ThreadIdentifierDataPthreads.h	/^    static void initializeOnce();$/;"	p	class:WTF::ThreadIdentifierData	access:public	signature:()
initializeRandomNumberGenerator	.\RandomNumberSeed.h	/^inline void initializeRandomNumberGenerator()$/;"	f	namespace:WTF	signature:()
initializeScavenger	.\FastMalloc.cpp	/^  void initializeScavenger();$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:private	signature:()
initializeScavenger	.\FastMalloc.cpp	/^void TCMalloc_PageHeap::initializeScavenger()$/;"	f	class:WTF::TCMalloc_PageHeap	signature:()
initializeThreading	.\Threading.h	/^WTF_EXPORT_PRIVATE void initializeThreading();$/;"	p	namespace:WTF	signature:()
initializeThreading	.\ThreadingPthreads.cpp	/^void initializeThreading()$/;"	f	namespace:WTF	signature:()
initializeThreading	.\ThreadingWin.cpp	/^void initializeThreading()$/;"	f	namespace:WTF	signature:()
inlineAdd	.\HashMap.h	/^        pair<iterator, bool> inlineAdd(const KeyType&, MappedPassInReferenceType);$/;"	p	class:WTF::HashMap	access:private	signature:(const KeyType&, MappedPassInReferenceType)
inlineAdd	.\HashMap.h	/^    HashMap<T, U, V, W, X>::inlineAdd(const KeyType& key, MappedPassInReferenceType mapped) $/;"	f	class:WTF::HashMap	signature:(const KeyType& key, MappedPassInReferenceType mapped)
inlineAdd	.\RefPtrHashMap.h	/^        pair<iterator, bool> inlineAdd(RawKeyType, MappedPassInReferenceType);$/;"	p	class:WTF::HashMap	access:private	signature:(RawKeyType, MappedPassInReferenceType)
inlineAdd	.\RefPtrHashMap.h	/^        pair<iterator, bool> inlineAdd(const KeyType&, MappedPassInReferenceType);$/;"	p	class:WTF::HashMap	access:private	signature:(const KeyType&, MappedPassInReferenceType)
inlineAdd	.\RefPtrHashMap.h	/^    HashMap<RefPtr<T>, U, V, W, X>::inlineAdd(RawKeyType key, MappedPassInReferenceType mapped) $/;"	f	class:WTF::HashMap	signature:(RawKeyType key, MappedPassInReferenceType mapped)
inlineAdd	.\RefPtrHashMap.h	/^    HashMap<RefPtr<T>, U, V, W, X>::inlineAdd(const KeyType& key, MappedPassInReferenceType mapped) $/;"	f	class:WTF::HashMap	signature:(const KeyType& key, MappedPassInReferenceType mapped)
inlineBuffer	.\Vector.h	/^        T* inlineBuffer() { return reinterpret_cast_ptr<T*>(m_inlineBuffer.buffer); }$/;"	f	class:WTF::VectorBuffer	access:private	signature:()
inlineGet	.\RefPtrHashMap.h	/^        MappedPeekType inlineGet(RawKeyType) const;$/;"	p	class:WTF::HashMap	access:public	signature:(RawKeyType) const
inlineGet	.\RefPtrHashMap.h	/^    inline HashMap<RefPtr<T>, U, V, W, MappedTraits>::inlineGet(RawKeyType key) const$/;"	f	class:WTF::HashMap::HashMap	signature:(RawKeyType key) const
inlineUTF8SequenceLength	.\unicode\UTF8.cpp	/^inline int inlineUTF8SequenceLength(char b0)$/;"	f	namespace:WTF::Unicode	signature:(char b0)
inlineUTF8SequenceLengthNonASCII	.\unicode\UTF8.cpp	/^inline int inlineUTF8SequenceLengthNonASCII(char b0)$/;"	f	namespace:WTF::Unicode	signature:(char b0)
insert	.\AVLTree.h	/^    inline handle insert(handle h);$/;"	p	class:WTF::AVLTree	access:public	signature:(handle h)
insert	.\AVLTree.h	/^AVLTree<Abstractor, maxDepth, BSet>::insert(handle h)$/;"	f	class:WTF::AVLTree	signature:(handle h)
insert	.\RedBlackTree.h	/^    void insert(NodeType* x)$/;"	f	class:WTF::RedBlackTree	access:public	signature:(NodeType* x)
insert	.\Vector.h	/^        template<typename U, size_t c> void insert(size_t position, const Vector<U, c>&);$/;"	p	class:WTF::Vector	access:public	signature:(size_t position, const Vector<U, c>&)
insert	.\Vector.h	/^        template<typename U> void insert(size_t position, const U&);$/;"	p	class:WTF::Vector	access:public	signature:(size_t position, const U&)
insert	.\Vector.h	/^        template<typename U> void insert(size_t position, const U*, size_t);$/;"	p	class:WTF::Vector	access:public	signature:(size_t position, const U*, size_t)
insert	.\Vector.h	/^    inline void Vector<T, inlineCapacity>::insert(size_t position, const U& val)$/;"	f	class:WTF::Vector	signature:(size_t position, const U& val)
insert	.\Vector.h	/^    inline void Vector<T, inlineCapacity>::insert(size_t position, const Vector<U, c>& val)$/;"	f	class:WTF::Vector	signature:(size_t position, const Vector<U, c>& val)
insert	.\Vector.h	/^    void Vector<T, inlineCapacity>::insert(size_t position, const U* data, size_t dataSize)$/;"	f	class:WTF::Vector	signature:(size_t position, const U* data, size_t dataSize)
insert	.\text\WTFString.cpp	/^void String::insert(const String& str, unsigned pos)$/;"	f	class:WTF::String	signature:(const String& str, unsigned pos)
insert	.\text\WTFString.cpp	/^void String::insert(const UChar* charactersToInsert, unsigned lengthToInsert, unsigned position)$/;"	f	class:WTF::String	signature:(const UChar* charactersToInsert, unsigned lengthToInsert, unsigned position)
insert	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE void insert(const String&, unsigned pos);$/;"	p	class:WTF::String	access:public	signature:(const String&, unsigned pos)
insert	.\text\WTFString.h	/^    void insert(const UChar*, unsigned length, unsigned pos);$/;"	p	class:WTF::String	access:public	signature:(const UChar*, unsigned length, unsigned pos)
insertBefore	.\ListHashSet.h	/^        pair<iterator, bool> insertBefore(const ValueType& beforeValue, const ValueType& newValue);$/;"	p	class:WTF::ListHashSet	access:public	signature:(const ValueType& beforeValue, const ValueType& newValue)
insertBefore	.\ListHashSet.h	/^        pair<iterator, bool> insertBefore(iterator it, const ValueType&);$/;"	p	class:WTF::ListHashSet	access:public	signature:(iterator it, const ValueType&)
insertBefore	.\ListHashSet.h	/^    pair<typename ListHashSet<T, inlineCapacity, U>::iterator, bool> ListHashSet<T, inlineCapacity, U>::insertBefore(const ValueType& beforeValue, const ValueType& newValue)$/;"	f	class:WTF::ListHashSet	signature:(const ValueType& beforeValue, const ValueType& newValue)
insertBefore	.\ListHashSet.h	/^    pair<typename ListHashSet<T, inlineCapacity, U>::iterator, bool> ListHashSet<T, inlineCapacity, U>::insertBefore(iterator it, const ValueType& newValue)$/;"	f	class:WTF::ListHashSet	signature:(iterator it, const ValueType& newValue)
insertNodeBefore	.\ListHashSet.h	/^        void insertNodeBefore(Node* beforeNode, Node* newNode);$/;"	p	class:WTF::ListHashSet	access:private	signature:(Node* beforeNode, Node* newNode)
insertNodeBefore	.\ListHashSet.h	/^    void ListHashSet<T, inlineCapacity, U>::insertNodeBefore(Node* beforeNode, Node* newNode)$/;"	f	class:WTF::ListHashSet	signature:(Node* beforeNode, Node* newNode)
int16_t	.\dtoa\utils.h	/^typedef short int16_t;  \/\/ NOLINT$/;"	t
int32_t	.\dtoa\utils.h	/^typedef int int32_t;$/;"	t
int64_t	.\dtoa\utils.h	/^typedef __int64 int64_t;$/;"	t
int8_t	.\dtoa\utils.h	/^typedef signed char int8_t;$/;"	t
intHash	.\HashFunctions.h	/^    inline unsigned intHash(uint16_t key16)$/;"	f	namespace:WTF	signature:(uint16_t key16)
intHash	.\HashFunctions.h	/^    inline unsigned intHash(uint32_t key) $/;"	f	namespace:WTF	signature:(uint32_t key)
intHash	.\HashFunctions.h	/^    inline unsigned intHash(uint64_t key)$/;"	f	namespace:WTF	signature:(uint64_t key)
intHash	.\HashFunctions.h	/^    inline unsigned intHash(uint8_t key8)$/;"	f	namespace:WTF	signature:(uint8_t key8)
internalCheckTableConsistency	.\HashTable.h	/^        static void internalCheckTableConsistency() { }$/;"	f	class:WTF::HashTable	access:public	signature:()
internalCheckTableConsistency	.\HashTable.h	/^        void internalCheckTableConsistency() const { checkTableConsistency(); }$/;"	f	class:WTF::HashTable	access:public	signature:() const
internalCheckTableConsistencyExceptSize	.\HashTable.h	/^        static void internalCheckTableConsistencyExceptSize() { }$/;"	f	class:WTF::HashTable	access:public	signature:()
internalCheckTableConsistencyExceptSize	.\HashTable.h	/^        void internalCheckTableConsistencyExceptSize() const { checkTableConsistencyExceptSize(); }$/;"	f	class:WTF::HashTable	access:public	signature:() const
inuse	.\FastMalloc.cpp	/^  int inuse() const { return inuse_; }$/;"	f	class:WTF::PageHeapAllocator	access:public	signature:() const
inuse_	.\FastMalloc.cpp	/^  int inuse_;$/;"	m	class:WTF::PageHeapAllocator	file:	access:private
invalidateIterators	.\Deque.h	/^        void invalidateIterators();$/;"	p	class:WTF::Deque	access:private	signature:()
invalidateIterators	.\Deque.h	/^    template<typename T, size_t inlineCapacity> inline void Deque<T, inlineCapacity>::invalidateIterators() { }$/;"	f	class:WTF::Deque	signature:()
invalidateIterators	.\Deque.h	/^    void Deque<T, inlineCapacity>::invalidateIterators()$/;"	f	class:WTF::Deque	signature:()
invalidateIterators	.\HashTable.h	/^        static void invalidateIterators() { }$/;"	f	class:WTF::HashTable	access:private	signature:()
invalidateIterators	.\HashTable.h	/^        void invalidateIterators();$/;"	p	class:WTF::HashTable	access:private	signature:()
invalidateIterators	.\HashTable.h	/^    void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::invalidateIterators()$/;"	f	class:WTF::HashTable	signature:()
is8Bit	.\text\StringBuilder.h	/^    bool is8Bit() const { return m_is8Bit; }$/;"	f	class:WTF::StringBuilder	access:public	signature:() const
is8Bit	.\text\StringConcatenate.h	/^    bool is8Bit() { return false; }$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:()
is8Bit	.\text\StringConcatenate.h	/^    bool is8Bit() { return m_adapter.is8Bit(); }$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:()
is8Bit	.\text\StringConcatenate.h	/^    bool is8Bit() { return m_buffer <= 0xff; }$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:()
is8Bit	.\text\StringConcatenate.h	/^    bool is8Bit() { return m_buffer.isNull() || m_buffer.is8Bit(); }$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:()
is8Bit	.\text\StringConcatenate.h	/^    bool is8Bit() { return true; }$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:()
is8Bit	.\text\StringImpl.h	/^    bool is8Bit() const { return m_hashAndFlags & s_hashFlag8BitBuffer; }$/;"	f	class:WTF::StringImpl	access:public	signature:() const
is8Bit	.\text\StringOperators.h	/^    bool is8Bit() { return m_buffer.is8Bit(); }$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:()
is8Bit	.\text\StringOperators.h	/^    bool is8Bit()$/;"	f	class:WTF::StringAppend	access:public	signature:()
is8Bit	.\text\WTFString.h	/^    bool is8Bit() const { return m_impl->is8Bit(); }$/;"	f	class:WTF::String	access:public	signature:() const
is8ByteAligned	.\StdLibExtras.h	/^inline bool is8ByteAligned(void* p)$/;"	f	namespace:WTF	signature:(void* p)
isASCII	.\ASCIICType.h	/^template<typename CharType> inline bool isASCII(CharType c)$/;"	f	namespace:WTF	signature:(CharType c)
isASCIIAlpha	.\ASCIICType.h	/^template<typename CharType> inline bool isASCIIAlpha(CharType c)$/;"	f	namespace:WTF	signature:(CharType c)
isASCIIAlphaCaselessEqual	.\ASCIICType.h	/^template<typename CharType> inline bool isASCIIAlphaCaselessEqual(CharType cssCharacter, char character)$/;"	f	namespace:WTF	signature:(CharType cssCharacter, char character)
isASCIIAlphanumeric	.\ASCIICType.h	/^template<typename CharType> inline bool isASCIIAlphanumeric(CharType c)$/;"	f	namespace:WTF	signature:(CharType c)
isASCIIDigit	.\ASCIICType.h	/^template<typename CharType> inline bool isASCIIDigit(CharType c)$/;"	f	namespace:WTF	signature:(CharType c)
isASCIIHexDigit	.\ASCIICType.h	/^template<typename CharType> inline bool isASCIIHexDigit(CharType c)$/;"	f	namespace:WTF	signature:(CharType c)
isASCIILower	.\ASCIICType.h	/^template<typename CharType> inline bool isASCIILower(CharType c)$/;"	f	namespace:WTF	signature:(CharType c)
isASCIIOctalDigit	.\ASCIICType.h	/^template<typename CharType> inline bool isASCIIOctalDigit(CharType c)$/;"	f	namespace:WTF	signature:(CharType c)
isASCIIPrintable	.\ASCIICType.h	/^template<typename CharType> inline bool isASCIIPrintable(CharType c)$/;"	f	namespace:WTF	signature:(CharType c)
isASCIISpace	.\ASCIICType.h	/^template<typename CharType> inline bool isASCIISpace(CharType c)$/;"	f	namespace:WTF	signature:(CharType c)
isASCIIUpper	.\ASCIICType.h	/^template<typename CharType> inline bool isASCIIUpper(CharType c)$/;"	f	namespace:WTF	signature:(CharType c)
isAlignedToMachineWord	.\text\ASCIIFastPath.h	/^inline bool isAlignedToMachineWord(const void* pointer)$/;"	f	namespace:WTF	signature:(const void* pointer)
isAllASCII	.\text\ASCIIFastPath.h	/^inline bool isAllASCII(MachineWord word)$/;"	f	namespace:WTF	signature:(MachineWord word)
isAllASCII	.\url\src\URLQueryCanonicalizer.h	/^    static bool isAllASCII(const InChar* spec, const URLComponent& query)$/;"	f	class:WTF::URLQueryCanonicalizer	access:private	signature:(const InChar* spec, const URLComponent& query)
isAllSpecialCharacters	.\text\WTFString.h	/^    template<bool isSpecialCharacter(UChar)> bool isAllSpecialCharacters() const;$/;"	p	class:WTF::String	access:public	signature:() const
isAllSpecialCharacters	.\text\WTFString.h	/^template<bool isSpecialCharacter(UChar)> bool isAllSpecialCharacters(const UChar*, size_t);$/;"	p	namespace:WTF	signature:(const UChar*, size_t)
isAllSpecialCharacters	.\text\WTFString.h	/^template<bool isSpecialCharacter(UChar)> inline bool String::isAllSpecialCharacters() const$/;"	f	class:WTF::String	signature:() const
isAllSpecialCharacters	.\text\WTFString.h	/^template<bool isSpecialCharacter(UChar)> inline bool isAllSpecialCharacters(const UChar* characters, size_t length)$/;"	f	namespace:WTF	signature:(const UChar* characters, size_t length)
isAlphanumeric	.\unicode\glib\UnicodeGLib.h	/^inline bool isAlphanumeric(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
isAlphanumeric	.\unicode\icu\UnicodeIcu.h	/^inline bool isAlphanumeric(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
isAlphanumeric	.\unicode\wince\UnicodeWinCE.cpp	/^bool isAlphanumeric(UChar c)$/;"	f	namespace:WTF::Unicode	signature:(UChar c)
isAlphanumeric	.\unicode\wince\UnicodeWinCE.h	/^bool isAlphanumeric(UChar);$/;"	p	namespace:WTF::Unicode	signature:(UChar)
isArabicChar	.\unicode\glib\UnicodeGLib.h	/^inline bool isArabicChar(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
isArabicChar	.\unicode\icu\UnicodeIcu.h	/^inline bool isArabicChar(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
isArabicChar	.\unicode\qt4\UnicodeQt4.h	/^inline bool isArabicChar(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
isArabicChar	.\unicode\wince\UnicodeWinCE.h	/^inline bool isArabicChar(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
isAtomic	.\text\StringImpl.h	/^    bool isAtomic() const { return m_hashAndFlags & s_hashFlagIsAtomic; }$/;"	f	class:WTF::StringImpl	access:public	signature:() const
isByteArray	.\ArrayBufferView.h	/^    virtual bool isByteArray() const { return false; }$/;"	f	class:WTF::ArrayBufferView	access:public	signature:() const
isByteArray	.\Int8Array.h	/^    virtual bool isByteArray() const { return true; }$/;"	f	class:WTF::Int8Array	access:private	signature:() const
isCharOfType	.\url\src\URLCharacterTypes.h	/^    static inline bool isCharOfType(unsigned char c, CharTypes type)$/;"	f	class:WTF::URLCharacterTypes	access:private	signature:(unsigned char c, CharTypes type)
isCharacterAllowedInBase	.\text\WTFString.cpp	/^static bool isCharacterAllowedInBase(UChar c, int base)$/;"	f	namespace:WTF	file:	signature:(UChar c, int base)
isClear	.\BloomFilter.h	/^    bool isClear() const;$/;"	p	class:WTF::BloomFilter	access:public	signature:() const
isClear	.\BloomFilter.h	/^bool BloomFilter<keyBits>::isClear() const$/;"	f	class:WTF::BloomFilter	signature:() const
isDataView	.\ArrayBufferView.h	/^    virtual bool isDataView() const { return false; }$/;"	f	class:WTF::ArrayBufferView	access:public	signature:() const
isDeletedBucket	.\HashTable.h	/^        static bool isDeletedBucket(const ValueType& value) { return KeyTraits::isDeletedValue(Extractor::extract(value)); }$/;"	f	class:WTF::HashTable	access:public	signature:(const ValueType& value)
isDeletedValue	.\HashTraits.h	/^        static bool isDeletedValue(P* value) { return value == reinterpret_cast<P*>(-1); }$/;"	f	struct:WTF::HashTraits	access:public	signature:(P* value)
isDeletedValue	.\HashTraits.h	/^        static bool isDeletedValue(T value) { return value == -std::numeric_limits<T>::infinity(); }$/;"	f	struct:WTF::FloatHashTraits	access:public	signature:(T value)
isDeletedValue	.\HashTraits.h	/^        static bool isDeletedValue(T value) { return value == static_cast<T>(-1); }$/;"	f	struct:WTF::GenericHashTraitsBase	access:public	signature:(T value)
isDeletedValue	.\HashTraits.h	/^        static bool isDeletedValue(T value) { return value == std::numeric_limits<T>::max() - 1; }$/;"	f	struct:WTF::UnsignedWithZeroKeyHashTraits	access:public	signature:(T value)
isDeletedValue	.\HashTraits.h	/^        static bool isDeletedValue(const T& value) { return value.isHashTableDeletedValue(); }$/;"	f	struct:WTF::SimpleClassHashTraits	access:public	signature:(const T& value)
isDeletedValue	.\HashTraits.h	/^        static bool isDeletedValue(const TraitType& value) { return FirstTraits::isDeletedValue(value.first); }$/;"	f	struct:WTF::PairHashTraits	access:public	signature:(const TraitType& value)
isDeletedValue	.\text\AtomicStringHash.h	/^        static bool isDeletedValue(const WTF::AtomicString& slot) { return slot.isHashTableDeletedValue(); }$/;"	f	struct:WTF::HashTraits	access:public	signature:(const WTF::AtomicString& slot)
isDigit	.\dtoa\double-conversion.cc	/^    static bool isDigit(int x, int radix) {$/;"	f	namespace:WTF::double_conversion	file:	signature:(int x, int radix)
isDigit	.\unicode\glib\UnicodeGLib.h	/^inline bool isDigit(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
isDigit	.\unicode\wince\UnicodeWinCE.cpp	/^bool isDigit(UChar c)$/;"	f	namespace:WTF::Unicode	signature:(UChar c)
isDigit	.\unicode\wince\UnicodeWinCE.h	/^bool isDigit(UChar);$/;"	p	namespace:WTF::Unicode	signature:(UChar)
isDoubleArray	.\ArrayBufferView.h	/^    virtual bool isDoubleArray() const { return false; }$/;"	f	class:WTF::ArrayBufferView	access:public	signature:() const
isDoubleArray	.\Float64Array.h	/^    virtual bool isDoubleArray() const { return true; }$/;"	f	class:WTF::Float64Array	access:private	signature:() const
isEmpty	.\Bitmap.h	/^    size_t isEmpty() const;$/;"	p	class:WTF::Bitmap	access:public	signature:() const
isEmpty	.\Bitmap.h	/^inline size_t Bitmap<size, atomicMode>::isEmpty() const$/;"	f	class:WTF::Bitmap	signature:() const
isEmpty	.\Deque.h	/^        bool isEmpty() const { return m_start == m_end; }$/;"	f	class:WTF::Deque	access:public	signature:() const
isEmpty	.\DoublyLinkedList.h	/^    bool isEmpty() const;$/;"	p	class:WTF::DoublyLinkedList	access:public	signature:() const
isEmpty	.\DoublyLinkedList.h	/^template<typename T> inline bool DoublyLinkedList<T>::isEmpty() const$/;"	f	class:WTF::DoublyLinkedList	signature:() const
isEmpty	.\HashCountedSet.h	/^        bool isEmpty() const;$/;"	p	class:WTF::HashCountedSet	access:public	signature:() const
isEmpty	.\HashCountedSet.h	/^    inline bool HashCountedSet<Value, HashFunctions, Traits>::isEmpty() const$/;"	f	class:WTF::HashCountedSet	signature:() const
isEmpty	.\HashMap.h	/^        bool isEmpty() const;$/;"	p	class:WTF::HashMap	access:public	signature:() const
isEmpty	.\HashMap.h	/^    inline bool HashMap<T, U, V, W, X>::isEmpty() const$/;"	f	class:WTF::HashMap	signature:() const
isEmpty	.\HashSet.h	/^        bool isEmpty() const;$/;"	p	class:WTF::HashSet	access:public	signature:() const
isEmpty	.\HashSet.h	/^    inline bool HashSet<T, U, V>::isEmpty() const$/;"	f	class:WTF::HashSet	signature:() const
isEmpty	.\HashTable.h	/^        bool isEmpty() const { return !m_keyCount; }$/;"	f	class:WTF::HashTable	access:public	signature:() const
isEmpty	.\ListHashSet.h	/^        bool isEmpty() const;$/;"	p	class:WTF::ListHashSet	access:public	signature:() const
isEmpty	.\ListHashSet.h	/^    inline bool ListHashSet<T, inlineCapacity, U>::isEmpty() const$/;"	f	class:WTF::ListHashSet	signature:() const
isEmpty	.\MessageQueue.h	/^        bool isEmpty();$/;"	p	class:WTF::MessageQueue	access:public	signature:()
isEmpty	.\MessageQueue.h	/^    inline bool MessageQueue<DataType>::isEmpty()$/;"	f	class:WTF::MessageQueue	signature:()
isEmpty	.\RedBlackTree.h	/^    bool isEmpty()$/;"	f	class:WTF::RedBlackTree	access:public	signature:()
isEmpty	.\RefPtrHashMap.h	/^        bool isEmpty() const;$/;"	p	class:WTF::HashMap	access:public	signature:() const
isEmpty	.\RefPtrHashMap.h	/^    inline bool HashMap<RefPtr<T>, U, V, W, X>::isEmpty() const$/;"	f	class:WTF::HashMap	signature:() const
isEmpty	.\SegmentedVector.h	/^        bool isEmpty() const { return !size(); }$/;"	f	class:WTF::SegmentedVector	access:public	signature:() const
isEmpty	.\SentinelLinkedList.h	/^    bool isEmpty() { return begin() == end(); }$/;"	f	class:WTF::SentinelLinkedList	access:public	signature:()
isEmpty	.\SinglyLinkedList.h	/^    bool isEmpty();$/;"	p	class:WTF::SinglyLinkedList	access:public	signature:()
isEmpty	.\SinglyLinkedList.h	/^template <typename Node> inline bool SinglyLinkedList<Node>::isEmpty()$/;"	f	class:WTF::SinglyLinkedList	signature:()
isEmpty	.\Vector.h	/^        bool isEmpty() const { return !size(); }$/;"	f	class:WTF::Vector	access:public	signature:() const
isEmpty	.\text\AtomicString.h	/^    bool isEmpty() const { return m_string.isEmpty(); }$/;"	f	class:WTF::AtomicString	access:public	signature:() const
isEmpty	.\text\StringBuilder.h	/^    bool isEmpty() const { return !m_length; }$/;"	f	class:WTF::StringBuilder	access:public	signature:() const
isEmpty	.\text\WTFString.h	/^    bool isEmpty() const { return !m_impl || !m_impl->length(); }$/;"	f	class:WTF::String	access:public	signature:() const
isEmptyBucket	.\HashTable.h	/^        static bool isEmptyBucket(const ValueType& value) { return Extractor::extract(value) == KeyTraits::emptyValue(); }$/;"	f	class:WTF::HashTable	access:public	signature:(const ValueType& value)
isEmptyOrDeletedBucket	.\HashTable.h	/^        static bool isEmptyOrDeletedBucket(const ValueType& value) { return isEmptyBucket(value) || isDeletedBucket(value); }$/;"	f	class:WTF::HashTable	access:public	signature:(const ValueType& value)
isEmptyOrInvalid	.\url\src\URLComponent.h	/^    bool isEmptyOrInvalid() const { return m_length <= 0; }$/;"	f	class:WTF::URLComponent	access:public	signature:() const
isEqual	.\Deque.h	/^        bool isEqual(const Base&) const;$/;"	p	class:WTF::DequeIteratorBase	access:protected	signature:(const Base&) const
isEqual	.\Deque.h	/^    inline bool DequeIteratorBase<T, inlineCapacity>::isEqual(const Base& other) const$/;"	f	class:WTF::DequeIteratorBase	signature:(const Base& other) const
isFloatArray	.\ArrayBufferView.h	/^    virtual bool isFloatArray() const { return false; }$/;"	f	class:WTF::ArrayBufferView	access:public	signature:() const
isFloatArray	.\Float32Array.h	/^    virtual bool isFloatArray() const { return true; }$/;"	f	class:WTF::Float32Array	access:private	signature:() const
isForbidden	.\FastMalloc.cpp	/^static bool isForbidden()$/;"	f	namespace:WTF	file:	signature:()
isForibiddenTlsIndex	.\FastMalloc.cpp	/^static DWORD isForibiddenTlsIndex = TLS_OUT_OF_INDEXES;$/;"	v	file:
isFormatChar	.\unicode\glib\UnicodeGLib.h	/^inline bool isFormatChar(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
isFreeObject	.\FastMalloc.cpp	/^    bool isFreeObject(vm_address_t ptr) const { return isFreeObject(reinterpret_cast<void*>(ptr)); }$/;"	f	class:WTF::FreeObjectFinder	access:public	signature:(vm_address_t ptr) const
isFreeObject	.\FastMalloc.cpp	/^    bool isFreeObject(void* ptr) const { return m_freeObjects.contains(ptr); }$/;"	f	class:WTF::FreeObjectFinder	access:public	signature:(void* ptr) const
isFull	.\Bitmap.h	/^    size_t isFull() const;$/;"	p	class:WTF::Bitmap	access:public	signature:() const
isFull	.\Bitmap.h	/^inline size_t Bitmap<size, atomicMode>::isFull() const$/;"	f	class:WTF::Bitmap	signature:() const
isGCThread	.\MainThread.cpp	/^static ThreadSpecific<bool>* isGCThread;$/;"	v	file:
isGrowingDownward	.\StackBounds.h	/^    bool isGrowingDownward() const$/;"	f	class:WTF::StackBounds	access:private	signature:() const
isHashTableDeletedValue	.\RefPtr.h	/^        bool isHashTableDeletedValue() const { return m_ptr == hashTableDeletedValue(); }$/;"	f	class:WTF::RefPtr	access:public	signature:() const
isHashTableDeletedValue	.\RetainPtr.h	/^        bool isHashTableDeletedValue() const { return m_ptr == hashTableDeletedValue(); }$/;"	f	class:WTF::RetainPtr	access:public	signature:() const
isHashTableDeletedValue	.\gobject\GRefPtr.h	/^    bool isHashTableDeletedValue() const { return m_ptr == hashTableDeletedValue(); }$/;"	f	class:WTF::GRefPtr	access:public	signature:() const
isHashTableDeletedValue	.\text\AtomicString.h	/^    bool isHashTableDeletedValue() const { return m_string.isHashTableDeletedValue(); }$/;"	f	class:WTF::AtomicString	access:public	signature:() const
isHashTableDeletedValue	.\text\WTFString.h	/^    bool isHashTableDeletedValue() const { return m_impl.isHashTableDeletedValue(); }$/;"	f	class:WTF::String	access:public	signature:() const
isHexChar	.\url\src\URLCharacterTypes.h	/^    static inline bool isHexChar(unsigned char c) { return isCharOfType(c, HexCharacter); }$/;"	f	class:WTF::URLCharacterTypes	access:public	signature:(unsigned char c)
isHighSurrogate	.\unicode\wince\UnicodeWinCE.h	/^inline bool isHighSurrogate(UChar c) { return (c & 0xfc00) == 0xd800; }$/;"	f	namespace:WTF::Unicode	signature:(UChar c)
isIPv4Char	.\url\src\URLCharacterTypes.h	/^    static inline bool isIPv4Char(unsigned char c) { return isCharOfType(c, IPv4Character); }$/;"	f	class:WTF::URLCharacterTypes	access:public	signature:(unsigned char c)
isIdentifier	.\text\StringImpl.h	/^    bool isIdentifier() const { return m_hashAndFlags & s_hashFlagIsIdentifier; }$/;"	f	class:WTF::StringImpl	access:public	signature:() const
isInBounds	.\CheckedArithmetic.h	/^template <typename Target, typename Source> static inline bool isInBounds(Source value)$/;"	f	namespace:WTF	signature:(Source value)
isInline	.\BitVector.h	/^    bool isInline() const { return m_bitsOrPointer >> maxInlineBits(); }$/;"	f	class:WTF::BitVector	access:private	signature:() const
isIntArray	.\ArrayBufferView.h	/^    virtual bool isIntArray() const { return false; }$/;"	f	class:WTF::ArrayBufferView	access:public	signature:() const
isIntArray	.\Int32Array.h	/^    virtual bool isIntArray() const { return true; }$/;"	f	class:WTF::Int32Array	access:private	signature:() const
isLeapYear	.\DateMath.cpp	/^bool isLeapYear(int year)$/;"	f	namespace:WTF	signature:(int year)
isLeapYear	.\DateMath.h	/^bool isLeapYear(int year);$/;"	p	namespace:WTF	signature:(int year)
isLegalUTF8	.\unicode\UTF8.cpp	/^static bool isLegalUTF8(const unsigned char* source, int length)$/;"	f	namespace:WTF::Unicode	file:	signature:(const unsigned char* source, int length)
isLetter	.\unicode\wince\UnicodeWinCE.cpp	/^bool isLetter(UChar c)$/;"	f	namespace:WTF::Unicode	signature:(UChar c)
isLetter	.\unicode\wince\UnicodeWinCE.h	/^bool isLetter(UChar);$/;"	p	namespace:WTF::Unicode	signature:(UChar)
isLowSurrogate	.\unicode\wince\UnicodeWinCE.h	/^inline bool isLowSurrogate(UChar c) { return (c & 0xfc00) == 0xdc00; }$/;"	f	namespace:WTF::Unicode	signature:(UChar c)
isLower	.\unicode\glib\UnicodeGLib.h	/^inline bool isLower(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
isLower	.\unicode\icu\UnicodeIcu.h	/^inline bool isLower(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
isLower	.\unicode\qt4\UnicodeQt4.h	/^inline bool isLower(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
isLower	.\unicode\wince\UnicodeWinCE.cpp	/^bool isLower(UChar c)$/;"	f	namespace:WTF::Unicode	signature:(UChar c)
isLower	.\unicode\wince\UnicodeWinCE.h	/^bool isLower(UChar);$/;"	p	namespace:WTF::Unicode	signature:(UChar)
isMainThread	.\MainThread.cpp	/^bool isMainThread()$/;"	f	namespace:WTF	signature:()
isMainThread	.\MainThread.h	/^WTF_EXPORT_PRIVATE bool isMainThread();$/;"	p	namespace:WTF	signature:()
isMainThread	.\chromium\MainThreadChromium.cpp	/^bool isMainThread()$/;"	f	namespace:WTF	signature:()
isMainThreadOrGCThread	.\MainThread.cpp	/^bool isMainThreadOrGCThread()$/;"	f	namespace:WTF	signature:()
isMainThreadOrGCThread	.\MainThread.h	/^WTF_EXPORT_PRIVATE bool isMainThreadOrGCThread();$/;"	p	namespace:WTF	signature:()
isMainThreadOrGCThread	.\MainThread.h	/^inline bool isMainThreadOrGCThread() { return isMainThread(); }$/;"	f	namespace:WTF	signature:()
isManaged	.\MetaAllocatorHandle.h	/^    bool isManaged()$/;"	f	class:WTF::MetaAllocatorHandle	access:public	signature:()
isNeutered	.\ArrayBuffer.h	/^    bool isNeutered() { return !m_contents.m_data; }$/;"	f	class:WTF::ArrayBuffer	access:public	signature:()
isNonEmpty	.\url\src\URLComponent.h	/^    bool isNonEmpty() const { return m_length > 0; }$/;"	f	class:WTF::URLComponent	access:public	signature:() const
isNull	.\Functional.h	/^    bool isNull() const$/;"	f	class:WTF::FunctionBase	access:public	signature:() const
isNull	.\text\AtomicString.h	/^    bool isNull() const { return m_string.isNull(); }$/;"	f	class:WTF::AtomicString	access:public	signature:() const
isNull	.\text\CString.h	/^    bool isNull() const { return !m_buffer; }$/;"	f	class:WTF::CString	access:public	signature:() const
isNull	.\text\WTFString.h	/^    bool isNull() const { return !m_impl; }$/;"	f	class:WTF::String	access:public	signature:() const
isOnList	.\SentinelLinkedList.h	/^    bool isOnList() const$/;"	f	class:WTF::BasicRawSentinelNode	access:public	signature:() const
isPageAligned	.\PageBlock.h	/^inline bool isPageAligned(size_t size) { return !(size & (pageSize() - 1)); }$/;"	f	namespace:WTF	signature:(size_t size)
isPageAligned	.\PageBlock.h	/^inline bool isPageAligned(void* address) { return !(reinterpret_cast<intptr_t>(address) & (pageSize() - 1)); }$/;"	f	namespace:WTF	signature:(void* address)
isPageWritable	.\StackBounds.cpp	/^static inline bool isPageWritable(void* page)$/;"	f	namespace:WTF	file:	signature:(void* page)
isPointerAligned	.\StdLibExtras.h	/^inline bool isPointerAligned(void* p)$/;"	f	namespace:WTF	signature:(void* p)
isPointerTypeAlignmentOkay	.\StdLibExtras.h	/^bool isPointerTypeAlignmentOkay(Type* ptr)$/;"	f	signature:(Type* ptr)
isPortDigit	.\url\src\URLParser.h	/^    static inline bool isPortDigit(CharacterType ch)$/;"	f	class:WTF::URLParser	access:private	signature:(CharacterType ch)
isPossibleAuthorityTerminator	.\url\src\URLParser.h	/^    static bool isPossibleAuthorityTerminator(CharacterType ch)$/;"	f	class:WTF::URLParser	access:public	signature:(CharacterType ch)
isPowerOfTwo	.\PageBlock.h	/^inline bool isPowerOfTwo(size_t size) { return !(size & (size - 1)); }$/;"	f	namespace:WTF	signature:(size_t size)
isPrintableChar	.\unicode\glib\UnicodeGLib.h	/^inline bool isPrintableChar(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
isPrintableChar	.\unicode\icu\UnicodeIcu.h	/^inline bool isPrintableChar(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
isPrintableChar	.\unicode\qt4\UnicodeQt4.h	/^inline bool isPrintableChar(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
isPrintableChar	.\unicode\wince\UnicodeWinCE.cpp	/^bool isPrintableChar(UChar c)$/;"	f	namespace:WTF::Unicode	signature:(UChar c)
isPrintableChar	.\unicode\wince\UnicodeWinCE.h	/^bool isPrintableChar(UChar);$/;"	p	namespace:WTF::Unicode	signature:(UChar)
isPunct	.\unicode\glib\UnicodeGLib.h	/^inline bool isPunct(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
isPunct	.\unicode\icu\UnicodeIcu.h	/^inline bool isPunct(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
isPunct	.\unicode\qt4\UnicodeQt4.h	/^inline bool isPunct(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
isPunct	.\unicode\wince\UnicodeWinCE.cpp	/^bool isPunct(UChar c)$/;"	f	namespace:WTF::Unicode	signature:(UChar c)
isPunct	.\unicode\wince\UnicodeWinCE.h	/^bool isPunct(UChar);$/;"	p	namespace:WTF::Unicode	signature:(UChar)
isQueryChar	.\url\src\URLCharacterTypes.h	/^    static inline bool isQueryChar(unsigned char c) { return isCharOfType(c, QueryCharacter); }$/;"	f	class:WTF::URLCharacterTypes	access:public	signature:(unsigned char c)
isRaw8Bit	.\url\src\URLQueryCanonicalizer.h	/^    static bool isRaw8Bit(const InChar* source, int length)$/;"	f	class:WTF::URLQueryCanonicalizer	access:private	signature:(const InChar* source, int length)
isSafeToUse	.\ThreadRestrictionVerifier.h	/^    bool isSafeToUse() const$/;"	f	class:WTF::ThreadRestrictionVerifier	access:public	signature:() const
isScavengerSuspended	.\FastMalloc.cpp	/^  ALWAYS_INLINE bool isScavengerSuspended();$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:private	signature:()
isScavengerSuspended	.\FastMalloc.cpp	/^ALWAYS_INLINE bool TCMalloc_PageHeap::isScavengerSuspended()$/;"	f	class:WTF::TCMalloc_PageHeap	signature:()
isSeparatorSpace	.\unicode\glib\UnicodeGLib.h	/^inline bool isSeparatorSpace(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
isSeparatorSpace	.\unicode\icu\UnicodeIcu.h	/^inline bool isSeparatorSpace(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
isSeparatorSpace	.\unicode\qt4\UnicodeQt4.h	/^inline bool isSeparatorSpace(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
isSeparatorSpace	.\unicode\wince\UnicodeWinCE.h	/^inline bool isSeparatorSpace(UChar c) { return category(c) == Separator_Space; }$/;"	f	namespace:WTF::Unicode	signature:(UChar c)
isSet	.\ThreadSpecific.h	/^    bool isSet(); \/\/ Useful as a fast check to see if this thread has set this value.$/;"	p	class:WTF::ThreadSpecific	access:public	signature:()
isSet	.\ThreadSpecific.h	/^inline bool ThreadSpecific<T>::isSet()$/;"	f	class:WTF::ThreadSpecific	signature:()
isShortArray	.\ArrayBufferView.h	/^    virtual bool isShortArray() const { return false; }$/;"	f	class:WTF::ArrayBufferView	access:public	signature:() const
isShortArray	.\Int16Array.h	/^    virtual bool isShortArray() const { return true; }$/;"	f	class:WTF::Int16Array	access:private	signature:() const
isSpace	.\unicode\wince\UnicodeWinCE.cpp	/^bool isSpace(UChar c)$/;"	f	namespace:WTF::Unicode	signature:(UChar c)
isSpace	.\unicode\wince\UnicodeWinCE.h	/^bool isSpace(UChar);$/;"	p	namespace:WTF::Unicode	signature:(UChar)
isSpaceOrNewline	.\text\StringImpl.h	/^static inline bool isSpaceOrNewline(UChar c)$/;"	f	namespace:WTF	signature:(UChar c)
isStatic	.\text\StringImpl.h	/^    bool isStatic() const { return m_refCount & s_refCountFlagIsStaticString; }$/;"	f	class:WTF::StringImpl	access:private	signature:() const
isURLSlash	.\url\src\URLParser.h	/^    static inline bool isURLSlash(CharacterType ch)$/;"	f	class:WTF::URLParser	access:public	signature:(CharacterType ch)
isUnsignedByteArray	.\ArrayBufferView.h	/^    virtual bool isUnsignedByteArray() const { return false; }$/;"	f	class:WTF::ArrayBufferView	access:public	signature:() const
isUnsignedByteArray	.\Uint8Array.h	/^    virtual bool isUnsignedByteArray() const { return true; }$/;"	f	class:WTF::Uint8Array	access:protected	signature:() const
isUnsignedByteClampedArray	.\ArrayBufferView.h	/^    virtual bool isUnsignedByteClampedArray() const { return false; }$/;"	f	class:WTF::ArrayBufferView	access:public	signature:() const
isUnsignedByteClampedArray	.\Uint8ClampedArray.h	/^    virtual bool isUnsignedByteClampedArray() const { return true; }$/;"	f	class:WTF::Uint8ClampedArray	access:private	signature:() const
isUnsignedIntArray	.\ArrayBufferView.h	/^    virtual bool isUnsignedIntArray() const { return false; }$/;"	f	class:WTF::ArrayBufferView	access:public	signature:() const
isUnsignedIntArray	.\Uint32Array.h	/^    virtual bool isUnsignedIntArray() const { return true; }$/;"	f	class:WTF::Uint32Array	access:private	signature:() const
isUnsignedShortArray	.\ArrayBufferView.h	/^    virtual bool isUnsignedShortArray() const { return false; }$/;"	f	class:WTF::ArrayBufferView	access:public	signature:() const
isUnsignedShortArray	.\Uint16Array.h	/^    virtual bool isUnsignedShortArray() const { return true; }$/;"	f	class:WTF::Uint16Array	access:private	signature:() const
isUpper	.\unicode\wince\UnicodeWinCE.cpp	/^bool isUpper(UChar c)$/;"	f	namespace:WTF::Unicode	signature:(UChar c)
isUpper	.\unicode\wince\UnicodeWinCE.h	/^bool isUpper(UChar);$/;"	p	namespace:WTF::Unicode	signature:(UChar)
isValid	.\url\api\ParsedURL.h	/^    bool isValid() const { return !m_spec.string().isEmpty(); }$/;"	f	class:WTF::ParsedURL	access:public	signature:() const
isValid	.\url\src\URLComponent.h	/^    bool isValid() const { return m_length != -1; }$/;"	f	class:WTF::URLComponent	access:public	signature:() const
isWithinIntRange	.\MathExtras.h	/^inline bool isWithinIntRange(float x)$/;"	f	signature:(float x)
is_empty	.\AVLTree.h	/^    bool is_empty() { return abs.root == null(); }$/;"	f	class:WTF::AVLTree	access:public	signature:()
is_empty	.\dtoa\utils.h	/^        bool is_empty() const { return length_ == 0; }$/;"	f	class:WTF::double_conversion::Vector	access:public	signature:() const
is_finalized	.\dtoa\utils.h	/^        bool is_finalized() const { return position_ < 0; }$/;"	f	class:WTF::double_conversion::StringBuilder	access:private	signature:() const
isalnum	.\DisallowCType.h	40;"	d
isalnum	.\DisallowCType.h	57;"	d
isalpha	.\DisallowCType.h	41;"	d
isalpha	.\DisallowCType.h	58;"	d
isascii	.\DisallowCType.h	42;"	d
isascii	.\DisallowCType.h	59;"	d
isblank	.\DisallowCType.h	43;"	d
isblank	.\DisallowCType.h	60;"	d
iscntrl	.\DisallowCType.h	44;"	d
iscntrl	.\DisallowCType.h	61;"	d
isdigit	.\DisallowCType.h	45;"	d
isdigit	.\DisallowCType.h	62;"	d
isfinite	.\MathExtras.h	/^inline bool isfinite(double x) { return finite(x) && !isnand(x); }$/;"	f	signature:(double x)
isfinite	.\MathExtras.h	/^inline bool isfinite(double x) { return finite(x); }$/;"	f	signature:(double x)
isfinite	.\MathExtras.h	/^inline int isfinite(double x) { return _finite(x); }$/;"	f	signature:(double x)
isgraph	.\DisallowCType.h	46;"	d
isgraph	.\DisallowCType.h	63;"	d
isinf	.\MathExtras.h	/^inline bool isinf(double num) { return !_finite(num) && !_isnan(num); }$/;"	f	signature:(double num)
isinf	.\MathExtras.h	/^inline bool isinf(double x) { return !finite(x) && !isnand(x); }$/;"	f	signature:(double x)
islower	.\DisallowCType.h	47;"	d
islower	.\DisallowCType.h	64;"	d
isnan	.\MathExtras.h	/^inline bool isnan(double num) { return !!_isnan(num); }$/;"	f	signature:(double num)
isolatedCopy	.\text\StringImpl.h	/^    PassRefPtr<StringImpl> isolatedCopy() const;$/;"	p	class:WTF::StringImpl	access:public	signature:() const
isolatedCopy	.\text\StringImpl.h	/^inline PassRefPtr<StringImpl> StringImpl::isolatedCopy() const$/;"	f	class:WTF::StringImpl	signature:() const
isolatedCopy	.\text\WTFString.cpp	/^String String::isolatedCopy() const$/;"	f	class:WTF::String	signature:() const
isolatedCopy	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE String isolatedCopy() const;$/;"	p	class:WTF::String	access:public	signature:() const
isolatedCopy	.\url\api\ParsedURL.cpp	/^ParsedURL ParsedURL::isolatedCopy() const$/;"	f	class:WTF::ParsedURL	signature:() const
isolatedCopy	.\url\api\ParsedURL.h	/^    WTF_EXPORT_PRIVATE ParsedURL isolatedCopy() const;$/;"	p	class:WTF::ParsedURL	access:public	signature:() const
isprint	.\DisallowCType.h	48;"	d
isprint	.\DisallowCType.h	65;"	d
ispunct	.\DisallowCType.h	49;"	d
ispunct	.\DisallowCType.h	66;"	d
isspace	.\DisallowCType.h	50;"	d
isspace	.\DisallowCType.h	67;"	d
isupper	.\DisallowCType.h	51;"	d
isupper	.\DisallowCType.h	68;"	d
isxdigit	.\DisallowCType.h	52;"	d
isxdigit	.\DisallowCType.h	69;"	d
item	.\Float32Array.h	/^    float item(unsigned index) const$/;"	f	class:WTF::Float32Array	access:public	signature:(unsigned index) const
item	.\Float64Array.h	/^    double item(unsigned index) const$/;"	f	class:WTF::Float64Array	access:public	signature:(unsigned index) const
item	.\IntegralTypedArrayBase.h	/^    T item(unsigned index) const$/;"	f	class:WTF::IntegralTypedArrayBase	access:public	signature:(unsigned index) const
iterator	.\Deque.h	/^        typedef DequeIterator<T, inlineCapacity> iterator;$/;"	t	class:WTF::Deque	access:public
iterator	.\HashCountedSet.h	/^        typedef typename ImplType::iterator iterator;$/;"	t	class:WTF::HashCountedSet	access:public
iterator	.\HashMap.h	/^            typedef typename HashMap::iterator::Keys iterator;$/;"	t	class:WTF::HashMap::HashMapKeysProxy	access:public
iterator	.\HashMap.h	/^            typedef typename HashMap::iterator::Values iterator;$/;"	t	class:WTF::HashMap::HashMapValuesProxy	access:public
iterator	.\HashMap.h	/^        typedef HashTableIteratorAdapter<HashTableType, ValueType> iterator;$/;"	t	class:WTF::HashMap	access:public
iterator	.\HashSet.h	/^        typedef HashTableConstIteratorAdapter<HashTableType, ValueType> iterator;$/;"	t	class:WTF::HashSet	access:public
iterator	.\HashTable.h	/^        typedef HashTableIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits> iterator;$/;"	t	class:WTF::HashTable	access:public
iterator	.\HashTable.h	/^        typedef HashTableIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits> iterator;$/;"	t	class:WTF::HashTableConstIterator	access:private
iterator	.\HashTable.h	/^        typedef HashTableIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits> iterator;$/;"	t	class:WTF::HashTableIterator	access:private
iterator	.\ListHashSet.h	/^        typedef ListHashSetIterator<ValueArg, inlineCapacity, HashArg> iterator;$/;"	t	class:WTF::ListHashSetConstIterator	access:private
iterator	.\ListHashSet.h	/^        typedef ListHashSetIterator<ValueArg, inlineCapacity, HashArg> iterator;$/;"	t	class:WTF::ListHashSetIterator	access:private
iterator	.\ListHashSet.h	/^        typedef ListHashSetIterator<ValueType, inlineCapacity, HashArg> iterator;$/;"	t	class:WTF::ListHashSet	access:public
iterator	.\RefPtrHashMap.h	/^        typedef HashTableIteratorAdapter<HashTableType, ValueType> iterator;$/;"	t	class:WTF::HashMap	access:public
iterator	.\SentinelLinkedList.h	/^    typedef T* iterator;$/;"	t	class:WTF::SentinelLinkedList	access:public
iterator	.\Spectrum.h	/^    typedef typename HashMap<T, unsigned long>::iterator iterator;$/;"	t	class:WTF::Spectrum	access:public
iterator	.\Vector.h	/^            typedef typename Vector::reverse_iterator iterator;$/;"	t	class:WTF::Vector::VectorReverseProxy	access:public
iterator	.\Vector.h	/^        typedef T* iterator;$/;"	t	class:WTF::Vector	access:public
j	.\CryptographicallyRandomNumber.cpp	/^    uint8_t j;$/;"	m	class:WTF::__anon3::ARC4Stream	file:	access:public
joining	.\unicode\qt4\UnicodeQt4.h	/^        ushort joining : 2;$/;"	m	struct:QUnicodeTables::Properties	access:public
jsCurrentTime	.\DateMath.h	/^inline double jsCurrentTime()$/;"	f	namespace:WTF	signature:()
jscore_fastmalloc_introspection	.\FastMalloc.cpp	/^extern "C" WTF_EXPORT_PRIVATE const int jscore_fastmalloc_introspection = 0;$/;"	v
jscore_fastmalloc_introspection	.\FastMalloc.cpp	/^malloc_introspection_t jscore_fastmalloc_introspection = { &FastMallocZone::enumerate, &FastMallocZone::goodSize, &FastMallocZone::check, &FastMallocZone::print,$/;"	v
junk_string_value_	.\dtoa\double-conversion.h	/^        const double junk_string_value_;$/;"	m	class:WTF::double_conversion::StringToDoubleConverter	access:private
k	.\SHA1.cpp	/^static inline uint32_t k(int t)$/;"	f	namespace:WTF	file:	signature:(int t)
kAlignShift	.\FastMalloc.cpp	/^static const size_t kAlignShift = 3;$/;"	v	file:
kAlignedSize	.\FastMalloc.cpp	/^  static const size_t kAlignedSize$/;"	m	class:WTF::PageHeapAllocator	file:	access:private
kAlignment	.\FastMalloc.cpp	/^static const size_t kAlignment  = 1 << kAlignShift;$/;"	v	file:
kAllocIncrement	.\FastMalloc.cpp	/^  static const size_t kAllocIncrement = 32 << 10;$/;"	m	class:WTF::PageHeapAllocator	file:	access:private
kBase10MaximalLength	.\dtoa\double-conversion.h	/^        static const int kBase10MaximalLength = 17;$/;"	m	class:WTF::double_conversion::DoubleToStringConverter	access:public
kBigitCapacity	.\dtoa\bignum.h	/^        static const int kBigitCapacity = kMaxSignificantBits \/ kBigitSize;$/;"	m	class:WTF::double_conversion::Bignum	access:private
kBigitMask	.\dtoa\bignum.h	/^        static const Chunk kBigitMask = (1 << kBigitSize) - 1;$/;"	m	class:WTF::double_conversion::Bignum	access:private
kBigitSize	.\dtoa\bignum.h	/^        static const int kBigitSize = 28;$/;"	m	class:WTF::double_conversion::Bignum	access:private
kBitsUnusedOn64Bit	.\FastMalloc.cpp	/^static const size_t kBitsUnusedOn64Bit = 0;$/;"	v	file:
kBitsUnusedOn64Bit	.\FastMalloc.cpp	/^static const size_t kBitsUnusedOn64Bit = 16;$/;"	v	file:
kCachedPowers	.\dtoa\cached-powers.cc	/^    static CachedPower* kCachedPowers = 0;$/;"	v	file:
kCachedPowersLength	.\dtoa\cached-powers.cc	/^    static int kCachedPowersLength = 1;$/;"	v	file:
kCachedPowersOffset	.\dtoa\cached-powers.cc	/^    static int kCachedPowersOffset = 1;$/;"	v	file:
kCharSize	.\dtoa\utils.h	/^    static const int kCharSize = sizeof(char);$/;"	v
kChunkSize	.\dtoa\bignum.h	/^        static const int kChunkSize = sizeof(Chunk) * 8;$/;"	m	class:WTF::double_conversion::Bignum	access:private
kD_1_LOG2_10	.\dtoa\cached-powers.cc	/^    static const double kD_1_LOG2_10 = 0.30102999566398114;  \/\/  1 \/ lg(10)$/;"	v	file:
kDecimalExponentDistance	.\dtoa\cached-powers.cc	/^    int PowersOfTenCache::kDecimalExponentDistance = 1;$/;"	m	class:WTF::double_conversion::PowersOfTenCache	file:
kDecimalExponentDistance	.\dtoa\cached-powers.h	/^        static int kDecimalExponentDistance;$/;"	m	class:WTF::double_conversion::PowersOfTenCache	access:public
kDefaultOverallThreadCacheSize	.\FastMalloc.cpp	/^static const size_t kDefaultOverallThreadCacheSize = 16 << 20;$/;"	v	file:
kDenormalExponent	.\dtoa\double.h	/^        static const int kDenormalExponent = -kExponentBias + 1;$/;"	m	class:WTF::double_conversion::Double	access:private
kDoubleChunkSize	.\dtoa\bignum.h	/^        static const int kDoubleChunkSize = sizeof(DoubleChunk) * 8;$/;"	m	class:WTF::double_conversion::Bignum	access:private
kDoubleSignificandSize	.\dtoa\fixed-dtoa.cc	/^    static const int kDoubleSignificandSize = 53;  \/\/ Includes the hidden bit.$/;"	v	file:
kExactPowersOfTenSize	.\dtoa\strtod.cc	/^    static const int kExactPowersOfTenSize = ARRAY_SIZE(exact_powers_of_ten);$/;"	v	file:
kExponentBias	.\dtoa\double.h	/^        static const int kExponentBias = 0x3FF + kPhysicalSignificandSize;$/;"	m	class:WTF::double_conversion::Double	access:private
kExponentMask	.\dtoa\double.h	/^        static const uint64_t kExponentMask = UINT64_2PART_C(0x7FF00000, 00000000);$/;"	m	class:WTF::double_conversion::Double	access:public
kFastDtoaMaximalLength	.\dtoa\fast-dtoa.h	/^    static const int kFastDtoaMaximalLength = 17;$/;"	v
kHashbits	.\TCPackedCache.h	/^  static const size_t kHashbits = 12;$/;"	m	class:PackedCache	access:public
kHiddenBit	.\dtoa\double.h	/^        static const uint64_t kHiddenBit = UINT64_2PART_C(0x00100000, 00000000);$/;"	m	class:WTF::double_conversion::Double	access:public
kInfinity	.\dtoa\double.h	/^        static const uint64_t kInfinity = UINT64_2PART_C(0x7FF00000, 00000000);$/;"	m	class:WTF::double_conversion::Double	access:private
kKeyMask	.\TCPackedCache.h	/^  static const K kKeyMask = N_ONES_(K, kKeybits);$/;"	m	class:PackedCache	access:private
kMask32	.\dtoa\fixed-dtoa.cc	/^        static const uint64_t kMask32 = 0xFFFFFFFF;$/;"	m	class:WTF::double_conversion::UInt128	file:	access:private
kMaxDecimalExponent	.\dtoa\cached-powers.cc	/^    int PowersOfTenCache::kMaxDecimalExponent = 1;$/;"	m	class:WTF::double_conversion::PowersOfTenCache	file:
kMaxDecimalExponent	.\dtoa\cached-powers.h	/^        static int kMaxDecimalExponent;$/;"	m	class:WTF::double_conversion::PowersOfTenCache	access:public
kMaxDecimalPower	.\dtoa\strtod.cc	/^    static const int kMaxDecimalPower = 309;$/;"	v	file:
kMaxExactDoubleIntegerDecimalDigits	.\dtoa\strtod.cc	/^    static const int kMaxExactDoubleIntegerDecimalDigits = 15;$/;"	v	file:
kMaxExponent	.\dtoa\double.h	/^        static const int kMaxExponent = 0x7FF - kExponentBias;$/;"	m	class:WTF::double_conversion::Double	access:private
kMaxExponentialDigits	.\dtoa\double-conversion.h	/^        static const int kMaxExponentialDigits = 120;$/;"	m	class:WTF::double_conversion::DoubleToStringConverter	access:public
kMaxFixedDigitsAfterPoint	.\dtoa\double-conversion.h	/^        static const int kMaxFixedDigitsAfterPoint = 60;$/;"	m	class:WTF::double_conversion::DoubleToStringConverter	access:public
kMaxFixedDigitsBeforePoint	.\dtoa\double-conversion.h	/^        static const int kMaxFixedDigitsBeforePoint = 60;$/;"	m	class:WTF::double_conversion::DoubleToStringConverter	access:public
kMaxFreeListLength	.\FastMalloc.cpp	/^static const int kMaxFreeListLength = 256;$/;"	v	file:
kMaxPages	.\FastMalloc.cpp	/^static const size_t kMaxPages = kMinSystemAlloc;$/;"	v	file:
kMaxPrecisionDigits	.\dtoa\double-conversion.h	/^        static const int kMaxPrecisionDigits = 120;$/;"	m	class:WTF::double_conversion::DoubleToStringConverter	access:public
kMaxSignificantBits	.\dtoa\bignum.h	/^        static const int kMaxSignificantBits = 3584;$/;"	m	class:WTF::double_conversion::Bignum	access:public
kMaxSignificantDecimalDigits	.\dtoa\strtod.cc	/^    static const int kMaxSignificantDecimalDigits = 780;$/;"	v	file:
kMaxSignificantDigits	.\dtoa\double-conversion.cc	/^    const int kMaxSignificantDigits = 772;$/;"	v
kMaxSize	.\FastMalloc.cpp	/^static const size_t kMaxSize    = 8u * kPageSize;$/;"	v	file:
kMaxSmallSize	.\FastMalloc.cpp	/^static const size_t kMaxSmallSize = 1024;$/;"	v	file:
kMaxStackDepth	.\FastMalloc.cpp	/^static const int kMaxStackDepth = 31;$/;"	v	file:
kMaxThreadCacheSize	.\FastMalloc.cpp	/^static const size_t kMaxThreadCacheSize = 2 << 20;$/;"	v	file:
kMaxThreadCacheSize	.\FastMalloc.cpp	/^static const size_t kMaxThreadCacheSize = 512 * 1024;$/;"	v	file:
kMaxTlsKeySize	.\ThreadSpecific.h	/^const int kMaxTlsKeySize = 256;$/;"	v
kMaxUint64	.\dtoa\strtod.cc	/^    static const uint64_t kMaxUint64 = UINT64_2PART_C(0xFFFFFFFF, FFFFFFFF);$/;"	v	file:
kMaxUint64DecimalDigits	.\dtoa\strtod.cc	/^    static const int kMaxUint64DecimalDigits = 19;$/;"	v	file:
kMaxValidPages	.\FastMalloc.cpp	/^static const Length kMaxValidPages = (~static_cast<Length>(0)) >> kPageShift;$/;"	v	file:
kMaximalTargetExponent	.\dtoa\fast-dtoa.cc	/^    static const int kMaximalTargetExponent = -32;$/;"	v	file:
kMinDecimalExponent	.\dtoa\cached-powers.cc	/^    int PowersOfTenCache::kMinDecimalExponent = 1;$/;"	m	class:WTF::double_conversion::PowersOfTenCache	file:
kMinDecimalExponent	.\dtoa\cached-powers.h	/^        static int kMinDecimalExponent;$/;"	m	class:WTF::double_conversion::PowersOfTenCache	access:public
kMinDecimalPower	.\dtoa\strtod.cc	/^    static const int kMinDecimalPower = -324;$/;"	v	file:
kMinPrecisionDigits	.\dtoa\double-conversion.h	/^        static const int kMinPrecisionDigits = 1;$/;"	m	class:WTF::double_conversion::DoubleToStringConverter	access:public
kMinSpanListsWithSpans	.\FastMalloc.cpp	/^static const int kMinSpanListsWithSpans = 32;$/;"	v	file:
kMinSystemAlloc	.\FastMalloc.cpp	/^static const size_t kMinSystemAlloc = 1 << (20 - kPageShift);$/;"	v	file:
kMinThreadCacheSize	.\FastMalloc.cpp	/^static const size_t kMinThreadCacheSize = kMaxSize * 2;$/;"	v	file:
kMinimalTargetExponent	.\dtoa\fast-dtoa.cc	/^    static const int kMinimalTargetExponent = -60;$/;"	v	file:
kMinimumFreeCommittedPageCount	.\FastMalloc.cpp	/^static const size_t kMinimumFreeCommittedPageCount = kMinSpanListsWithSpans * ((1.0f+kMinSpanListsWithSpans) \/ 2.0f);$/;"	v	file:
kNaN	.\dtoa\double.h	/^        static const uint64_t kNaN = UINT64_2PART_C(0x7FF80000, 00000000);$/;"	m	class:WTF::double_conversion::Double	access:private
kNumClasses	.\FastMalloc.cpp	/^static const size_t kNumClasses = 68;$/;"	v	file:
kNumTransferEntries	.\FastMalloc.cpp	/^static const int kNumTransferEntries = kNumClasses;$/;"	v	file:
kPageMapBigAllocationThreshold	.\FastMalloc.cpp	/^static const size_t kPageMapBigAllocationThreshold = 128 << 20;$/;"	v	file:
kPageShift	.\FastMalloc.cpp	/^static const size_t kPageShift  = 12;$/;"	v	file:
kPageSize	.\FastMalloc.cpp	/^static const size_t kPageSize   = 1 << kPageShift;$/;"	v	file:
kPhysicalSignificandSize	.\dtoa\double.h	/^        static const int kPhysicalSignificandSize = 52;  \/\/ Excludes the hidden bit.$/;"	m	class:WTF::double_conversion::Double	access:public
kScavengeDelayInSeconds	.\FastMalloc.cpp	/^static const int kScavengeDelayInSeconds = 2;$/;"	v	file:
kScavengePercentage	.\FastMalloc.cpp	/^static const float kScavengePercentage = .5f;$/;"	v	file:
kSignMask	.\dtoa\double.h	/^        static const uint64_t kSignMask = UINT64_2PART_C(0x80000000, 00000000);$/;"	m	class:WTF::double_conversion::Double	access:public
kSignificandMask	.\dtoa\double.h	/^        static const uint64_t kSignificandMask = UINT64_2PART_C(0x000FFFFF, FFFFFFFF);$/;"	m	class:WTF::double_conversion::Double	access:public
kSignificandSize	.\dtoa\diy-fp.h	/^        static const int kSignificandSize = 64;$/;"	m	class:WTF::double_conversion::DiyFp	access:public
kSignificandSize	.\dtoa\double.h	/^        static const int kSignificandSize = 53;$/;"	m	class:WTF::double_conversion::Double	access:public
kTbits	.\TCPackedCache.h	/^  static const size_t kTbits = 8 * sizeof(T);$/;"	m	class:PackedCache	access:private
kTen4	.\dtoa\fast-dtoa.cc	/^    static const uint32_t kTen4 = 10000;$/;"	v	file:
kTen5	.\dtoa\fast-dtoa.cc	/^    static const uint32_t kTen5 = 100000;$/;"	v	file:
kTen6	.\dtoa\fast-dtoa.cc	/^    static const uint32_t kTen6 = 1000000;$/;"	v	file:
kTen7	.\dtoa\fast-dtoa.cc	/^    static const uint32_t kTen7 = 10000000;$/;"	v	file:
kTen8	.\dtoa\fast-dtoa.cc	/^    static const uint32_t kTen8 = 100000000;$/;"	v	file:
kTen9	.\dtoa\fast-dtoa.cc	/^    static const uint32_t kTen9 = 1000000000;$/;"	v	file:
kThreadingWindowClassName	.\win\MainThreadWin.cpp	/^const LPCWSTR kThreadingWindowClassName = L"ThreadingWindowClass";$/;"	v
kTlsAllowValue	.\FastMalloc.cpp	/^static const LPVOID kTlsAllowValue = reinterpret_cast<LPVOID>(0); \/\/ Must be zero.$/;"	v	file:
kTlsForbiddenValue	.\FastMalloc.cpp	/^static const LPVOID kTlsForbiddenValue = reinterpret_cast<LPVOID>(1);$/;"	v	file:
kUint64MSB	.\dtoa\diy-fp.h	/^        static const uint64_t kUint64MSB = UINT64_2PART_C(0x80000000, 00000000);$/;"	m	class:WTF::double_conversion::DiyFp	access:private
kUpperMask	.\TCPackedCache.h	/^  static const T kUpperMask = N_ONES_(T, kUpperbits) << kValuebits;$/;"	m	class:PackedCache	access:private
kUpperbits	.\TCPackedCache.h	/^  static const int kUpperbits = kKeybits - kHashbits;$/;"	m	class:PackedCache	access:private
kValueMask	.\TCPackedCache.h	/^  static const V kValueMask = N_ONES_(V, kValuebits);$/;"	m	class:PackedCache	access:private
kValuebits	.\TCPackedCache.h	/^  static const size_t kValuebits = 8;$/;"	m	class:PackedCache	access:public
kernel_supports_tls	.\FastMalloc.cpp	/^  static bool kernel_supports_tls = false;      \/\/ be conservative$/;"	v	file:
key	.\AVLTree.h	/^    typedef typename Abstractor::key key;$/;"	t	class:WTF::AVLTree	access:public
key	.\MetaAllocator.h	/^        size_t key()$/;"	f	class:WTF::MetaAllocator::FreeSpaceNode	access:public	signature:()
key	.\MetaAllocatorHandle.h	/^    void* key()$/;"	f	class:WTF::MetaAllocatorHandle	access:public	signature:()
key	.\Spectrum.h	/^        T key;$/;"	m	struct:WTF::Spectrum::KeyAndCount	access:public
keyMask	.\BloomFilter.h	/^    static const unsigned keyMask = (1 << keyBits) - 1;$/;"	m	class:WTF::BloomFilter	access:public
keys	.\HashIterators.h	/^        Keys keys() { return Keys(*this); }$/;"	f	struct:WTF::HashTableConstIteratorAdapter	access:public	signature:()
keys	.\HashIterators.h	/^        Keys keys() { return Keys(*this); }$/;"	f	struct:WTF::HashTableIteratorAdapter	access:public	signature:()
keys	.\HashMap.h	/^        HashMapKeysProxy& keys() { return static_cast<HashMapKeysProxy&>(*this); }$/;"	f	class:WTF::HashMap	access:public	signature:()
keys	.\HashMap.h	/^        const HashMapKeysProxy& keys() const { return static_cast<const HashMapKeysProxy&>(*this); }$/;"	f	class:WTF::HashMap	access:public	signature:() const
kill	.\MessageQueue.h	/^        void kill();$/;"	p	class:WTF::MessageQueue	access:public	signature:()
kill	.\MessageQueue.h	/^    inline void MessageQueue<DataType>::kill()$/;"	f	class:WTF::MessageQueue	signature:()
killed	.\MessageQueue.h	/^        bool killed() const;$/;"	p	class:WTF::MessageQueue	access:public	signature:() const
killed	.\MessageQueue.h	/^    inline bool MessageQueue<DataType>::killed() const$/;"	f	class:WTF::MessageQueue	signature:() const
known_zones	.\DateMath.cpp	/^} known_zones[] = {$/;"	v	typeref:struct:WTF::KnownZone	file:
large_	.\FastMalloc.cpp	/^  SpanList large_;$/;"	m	class:WTF::TCMalloc_PageHeap	file:	access:private
last	.\Deque.h	/^        T& last() { ASSERT(m_start != m_end); return *(--end()); }$/;"	f	class:WTF::Deque	access:public	signature:()
last	.\Deque.h	/^        const T& last() const { ASSERT(m_start != m_end); return *(--end()); }$/;"	f	class:WTF::Deque	access:public	signature:() const
last	.\ListHashSet.h	/^        ValueType& last();$/;"	p	class:WTF::ListHashSet	access:public	signature:()
last	.\ListHashSet.h	/^        const ValueType& last() const;$/;"	p	class:WTF::ListHashSet	access:public	signature:() const
last	.\ListHashSet.h	/^    inline T& ListHashSet<T, inlineCapacity, U>::last()$/;"	f	class:WTF::ListHashSet	signature:()
last	.\ListHashSet.h	/^    inline const T& ListHashSet<T, inlineCapacity, U>::last() const$/;"	f	class:WTF::ListHashSet	signature:() const
last	.\RedBlackTree.h	/^    NodeType* last() const$/;"	f	class:WTF::RedBlackTree	access:public	signature:() const
last	.\SegmentedVector.h	/^        T& last()$/;"	f	class:WTF::SegmentedVector	access:public	signature:()
last	.\Vector.h	/^        T& last() { return at(size() - 1); }$/;"	f	class:WTF::Vector	access:public	signature:()
last	.\Vector.h	/^        const T& last() const { return at(size() - 1); }$/;"	f	class:WTF::Vector	access:public	signature:() const
last	.\dtoa\utils.h	/^        T& last() { return start_[length_ - 1]; }$/;"	f	class:WTF::double_conversion::Vector	access:public	signature:()
latin1	.\text\WTFString.cpp	/^CString String::latin1() const$/;"	f	class:WTF::String	signature:() const
latin1	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE CString latin1() const;$/;"	p	class:WTF::String	access:public	signature:() const
leakPtr	.\OwnArrayPtr.h	/^template<typename T> inline typename OwnArrayPtr<T>::PtrType OwnArrayPtr<T>::leakPtr()$/;"	f	class:WTF::OwnArrayPtr	signature:()
leakPtr	.\OwnPtr.h	/^    template<typename T> inline typename OwnPtr<T>::PtrType OwnPtr<T>::leakPtr()$/;"	f	class:WTF::OwnPtr	signature:()
leakPtr	.\PassOwnArrayPtr.h	/^template<typename T> inline typename PassOwnArrayPtr<T>::PtrType PassOwnArrayPtr<T>::leakPtr() const$/;"	f	class:WTF::PassOwnArrayPtr	signature:() const
leakPtr	.\PassOwnPtr.h	/^    template<typename T> inline typename PassOwnPtr<T>::PtrType PassOwnPtr<T>::leakPtr() const$/;"	f	class:WTF::PassOwnPtr	signature:() const
leakRef	.\PassRefPtr.h	/^    template<typename T> inline T* PassRefPtr<T>::leakRef() const$/;"	f	class:WTF::PassRefPtr	signature:() const
leakRef	.\RetainPtr.h	/^    template<typename T> inline typename RetainPtr<T>::PtrType RetainPtr<T>::leakRef()$/;"	f	class:WTF::RetainPtr	signature:()
left	.\RedBlackTree.h	/^        NodeType* left() const$/;"	f	class:WTF::RedBlackTree::Node	access:private	signature:() const
left	.\text\WTFString.h	/^    String left(unsigned len) const { return substring(0, len); }$/;"	f	class:WTF::String	access:public	signature:(unsigned len) const
leftDoubleQuotationMark	.\unicode\CharacterNames.h	/^const UChar leftDoubleQuotationMark = 0x201C;$/;"	v
leftRotate	.\RedBlackTree.h	/^    NodeType* leftRotate(NodeType* x)$/;"	f	class:WTF::RedBlackTree	access:private	signature:(NodeType* x)
leftSingleQuotationMark	.\unicode\CharacterNames.h	/^const UChar leftSingleQuotationMark = 0x2018;$/;"	v
leftToRightEmbed	.\unicode\CharacterNames.h	/^const UChar leftToRightEmbed = 0x202A;$/;"	v
leftToRightMark	.\unicode\CharacterNames.h	/^const UChar leftToRightMark = 0x200E;$/;"	v
leftToRightOverride	.\unicode\CharacterNames.h	/^const UChar leftToRightOverride = 0x202D;$/;"	v
length	.\ByteArray.h	/^        unsigned length() const { return m_size; }$/;"	f	class:WTF::ByteArray	access:public	signature:() const
length	.\FastMalloc.cpp	/^  Length        length;         \/\/ Number of pages in span$/;"	m	struct:WTF::Span	file:	access:public
length	.\FastMalloc.cpp	/^  int length() const {$/;"	f	class:WTF::TCMalloc_ThreadCache_FreeList	access:public	signature:() const
length	.\FastMalloc.cpp	/^  size_t length() {$/;"	f	class:WTF::TCMalloc_Central_FreeList	access:public	signature:()
length	.\RefCountedArray.h	/^        unsigned length;$/;"	m	struct:WTF::RefCountedArray::Header	access:public
length	.\TypedArrayBase.h	/^    unsigned length() const$/;"	f	class:WTF::TypedArrayBase	access:public	signature:() const
length	.\dtoa\utils.h	/^        int length() const { return length_; }$/;"	f	class:WTF::double_conversion::Vector	access:public	signature:() const
length	.\text\AtomicString.cpp	/^    unsigned length;$/;"	m	struct:WTF::HashAndCharacters	file:	access:public
length	.\text\AtomicString.cpp	/^    unsigned length;$/;"	m	struct:WTF::HashAndUTF8Characters	file:	access:public
length	.\text\AtomicString.cpp	/^    unsigned length;$/;"	m	struct:WTF::SubstringLocation	file:	access:public
length	.\text\AtomicString.cpp	/^    unsigned length;$/;"	m	struct:WTF::UCharBuffer	file:	access:public
length	.\text\AtomicString.h	/^    unsigned length() const { return m_string.length(); }$/;"	f	class:WTF::AtomicString	access:public	signature:() const
length	.\text\CString.h	/^    size_t length() const$/;"	f	class:WTF::CString	access:public	signature:() const
length	.\text\CString.h	/^    size_t length() { return m_vector.size(); }$/;"	f	class:WTF::CStringBuffer	access:public	signature:()
length	.\text\StringBuffer.h	/^    unsigned length() const { return m_length; }$/;"	f	class:WTF::StringBuffer	access:public	signature:() const
length	.\text\StringBuilder.h	/^    unsigned length() const$/;"	f	class:WTF::StringBuilder	access:public	signature:() const
length	.\text\StringConcatenate.h	/^    size_t length() { return m_buffer.size(); }$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:()
length	.\text\StringConcatenate.h	/^    unsigned length() { return 1; }$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:()
length	.\text\StringConcatenate.h	/^    unsigned length() { return m_adapter.length(); }$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:()
length	.\text\StringConcatenate.h	/^    unsigned length() { return m_buffer.length(); }$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:()
length	.\text\StringConcatenate.h	/^    unsigned length() { return m_length; }$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:()
length	.\text\StringImpl.h	/^    unsigned length() const { return m_length; }$/;"	f	class:WTF::StringImpl	access:public	signature:() const
length	.\text\StringOperators.h	/^    unsigned length() { return m_buffer.length(); }$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:()
length	.\text\StringOperators.h	/^    unsigned length()$/;"	f	class:WTF::StringAppend	access:public	signature:()
length	.\text\WTFString.h	/^    unsigned length() const$/;"	f	class:WTF::String	access:public	signature:() const
length	.\url\src\URLBuffer.h	/^    int length() const { return m_length; }$/;"	f	class:WTF::URLBuffer	access:public	signature:() const
length	.\url\src\URLComponent.h	/^    int length() const { return m_length; }$/;"	f	class:WTF::URLComponent	access:public	signature:() const
length	.\url\src\URLSegments.cpp	/^int URLSegments::length() const$/;"	f	class:WTF::URLSegments	signature:() const
length	.\url\src\URLSegments.h	/^    int length() const;$/;"	p	class:WTF::URLSegments	access:public	signature:() const
lengthOfCharactersAsInteger	.\text\WTFString.cpp	/^static unsigned lengthOfCharactersAsInteger(const CharType* data, size_t length)$/;"	f	namespace:WTF	file:	signature:(const CharType* data, size_t length)
length_	.\FastMalloc.cpp	/^  uint16_t length_;     \/\/ Current length$/;"	m	class:WTF::TCMalloc_ThreadCache_FreeList	file:	access:private
length_	.\dtoa\utils.h	/^        int length_;$/;"	m	class:WTF::double_conversion::Vector	access:private
likelyEmpty	.\BloomFilter.h	/^    bool likelyEmpty() const;$/;"	p	class:WTF::BloomFilter	access:public	signature:() const
likelyEmpty	.\BloomFilter.h	/^bool BloomFilter<keyBits>::likelyEmpty() const$/;"	f	class:WTF::BloomFilter	signature:() const
line_break_class	.\unicode\qt4\UnicodeQt4.h	/^        ushort line_break_class : 8;$/;"	m	struct:QUnicodeTables::Properties	access:public
list_	.\FastMalloc.cpp	/^  FreeList      list_[kNumClasses];     \/\/ Array indexed by size-class$/;"	m	class:WTF::TCMalloc_ThreadCache	file:	access:private
list_	.\FastMalloc.cpp	/^  void*    list_;       \/\/ Linked list of nodes$/;"	m	class:WTF::TCMalloc_ThreadCache_FreeList	file:	access:private
literalTable	.\WTFThreadData.h	/^    LiteralIdentifierTable& literalTable() { return m_literalTable; }$/;"	f	class:JSC::IdentifierTable	access:public	signature:()
llround	.\MathExtras.h	/^inline long long llround(double num) { return static_cast<long long>(round(num)); }$/;"	f	signature:(double num)
llroundf	.\MathExtras.h	/^inline long long llroundf(float num) { return static_cast<long long>(roundf(num)); }$/;"	f	signature:(float num)
lo0bits	.\dtoa.cpp	/^static int lo0bits(uint32_t* y)$/;"	f	namespace:WTF	file:	signature:(uint32_t* y)
localtime	.\DateMath.cpp	/^extern "C" struct tm * localtime(const time_t *timer);$/;"	p	file:	signature:(const time_t *timer)
lock	.\ThreadingPrimitives.h	/^    WTF_EXPORT_PRIVATE void lock();$/;"	p	class:WTF::Mutex	access:public	signature:()
lock	.\ThreadingPthreads.cpp	/^void Mutex::lock()$/;"	f	class:WTF::Mutex	signature:()
lock	.\ThreadingWin.cpp	/^void Mutex::lock()$/;"	f	class:WTF::Mutex	signature:()
lockAtomicallyInitializedStaticMutex	.\Threading.h	/^WTF_EXPORT_PRIVATE void lockAtomicallyInitializedStaticMutex();$/;"	p	namespace:WTF	signature:()
lockAtomicallyInitializedStaticMutex	.\ThreadingPthreads.cpp	/^void lockAtomicallyInitializedStaticMutex()$/;"	f	namespace:WTF	signature:()
lockAtomicallyInitializedStaticMutex	.\ThreadingWin.cpp	/^void lockAtomicallyInitializedStaticMutex()$/;"	f	namespace:WTF	signature:()
lock_	.\FastMalloc.cpp	/^  SpinLock lock_;$/;"	m	class:WTF::TCMalloc_Central_FreeList	file:	access:private
lock_	.\TCSpinLock.h	/^  TCMalloc_SpinLock* lock_;$/;"	m	class:TCMalloc_SpinLockHolder	access:private
lockword_	.\TCSpinLock.h	/^    volatile unsigned int lockword_;$/;"	m	struct:TCMalloc_SpinLock	access:public
log	.\FastMalloc.cpp	/^    static void log(malloc_zone_t*, void*) { }$/;"	f	class:WTF::FastMallocZone	access:public	signature:(malloc_zone_t*, void*)
log2	.\MathExtras.h	/^inline double log2(double num)$/;"	f	signature:(double num)
log2f	.\MathExtras.h	/^inline float log2f(float num)$/;"	f	signature:(float num)
logger	.\HashTable.cpp	/^static HashTableStats logger;$/;"	v	file:
lookup	.\HashTable.h	/^        ValueType* lookup(const Key& key) { return lookup<IdentityTranslatorType>(key); }$/;"	f	class:WTF::HashTable	access:public	signature:(const Key& key)
lookup	.\HashTable.h	/^        template<typename HashTranslator, typename T> ValueType* lookup(const T&);$/;"	p	class:WTF::HashTable	access:public	signature:(const T&)
lookup	.\HashTable.h	/^    inline Value* HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::lookup(const T& key)$/;"	f	class:WTF::HashTable	signature:(const T& key)
lookupForWriting	.\HashTable.h	/^        LookupType lookupForWriting(const Key& key) { return lookupForWriting<IdentityTranslatorType>(key); };$/;"	f	class:WTF::HashTable	access:private	signature:(const Key& key)
lookupForWriting	.\HashTable.h	/^        template<typename HashTranslator, typename T> LookupType lookupForWriting(const T&);$/;"	p	class:WTF::HashTable	access:private	signature:(const T&)
lookupForWriting	.\HashTable.h	/^    inline typename HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::LookupType HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::lookupForWriting(const T& key)$/;"	f	class:WTF::HashTable	signature:(const T& key)
lowResUTCTime	.\CurrentTime.cpp	/^static double lowResUTCTime()$/;"	f	namespace:WTF	file:	signature:()
low_bits_	.\dtoa\fixed-dtoa.cc	/^        uint64_t low_bits_;$/;"	m	class:WTF::double_conversion::UInt128	file:	access:private
lowater_	.\FastMalloc.cpp	/^  uint16_t lowater_;    \/\/ Low water mark for list length$/;"	m	class:WTF::TCMalloc_ThreadCache_FreeList	file:	access:private
lower	.\text\AtomicString.cpp	/^AtomicString AtomicString::lower() const$/;"	f	class:WTF::AtomicString	signature:() const
lower	.\text\AtomicString.h	/^    WTF_EXPORT_PRIVATE AtomicString lower() const;$/;"	p	class:WTF::AtomicString	access:public	signature:() const
lower	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::lower()$/;"	f	class:WTF::StringImpl	signature:()
lower	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE PassRefPtr<StringImpl> lower();$/;"	p	class:WTF::StringImpl	access:public	signature:()
lower	.\text\WTFString.cpp	/^String String::lower() const$/;"	f	class:WTF::String	signature:() const
lower	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE String lower() const;$/;"	p	class:WTF::String	access:public	signature:() const
lowerCaseDiff	.\unicode\qt4\UnicodeQt4.h	/^        signed short lowerCaseDiff : 16;$/;"	m	struct:QUnicodeTables::Properties	access:public
lowerCaseSpecial	.\unicode\qt4\UnicodeQt4.h	/^        ushort lowerCaseSpecial : 1;$/;"	m	struct:QUnicodeTables::Properties	access:public
lowerNibbleToASCIIHexDigit	.\ASCIICType.h	/^inline char lowerNibbleToASCIIHexDigit(char c)$/;"	f	namespace:WTF	signature:(char c)
lowwatermark	.\FastMalloc.cpp	/^  int lowwatermark() const { return lowater_; }$/;"	f	class:WTF::TCMalloc_ThreadCache_FreeList	access:public	signature:() const
lround	.\MathExtras.h	/^inline long lround(double num) { return static_cast<long>(round(num)); }$/;"	f	signature:(double num)
lroundf	.\MathExtras.h	/^inline long lroundf(float num) { return static_cast<long>(roundf(num)); }$/;"	f	signature:(float num)
lshift	.\dtoa.cpp	/^static ALWAYS_INLINE void lshift(BigInt& b, int k)$/;"	f	namespace:WTF	file:	signature:(BigInt& b, int k)
m	.\MainThread.cpp	/^    FunctionWithContext m;$/;"	m	class:WTF::FunctionWithContextFinder	file:	access:public
m_adapter	.\text\StringConcatenate.h	/^    StringTypeAdapter<String> m_adapter;$/;"	m	class:WTF::StringTypeAdapter	access:private
m_adoptionIsRequired	.\RefCounted.h	/^    bool m_adoptionIsRequired;$/;"	m	class:WTF::RefCountedBase	access:private
m_alignment	.\FastMalloc.h	/^            unsigned m_alignment;$/;"	m	struct:WTF::Internal::ValidationHeader	access:public
m_allocation	.\BumpPointerAllocator.h	/^    PageAllocation m_allocation;$/;"	m	class:WTF::BumpPointerPool	access:private
m_allocationCanFail	.\wince\MemoryManager.h	/^        bool m_allocationCanFail;$/;"	m	class:WTF::MemoryManager	access:private
m_allocationGranule	.\MetaAllocator.h	/^    size_t m_allocationGranule;$/;"	m	class:WTF::MetaAllocator	access:private
m_allocations	.\MetaAllocator.h	/^    RedBlackTree<MetaAllocatorHandle, void*> m_allocations;$/;"	m	class:WTF::MetaAllocatorTracker	access:public
m_allocator	.\ListHashSet.h	/^        OwnPtr<NodeAllocator> m_allocator;$/;"	m	class:WTF::ListHashSet	access:private
m_allocator	.\MetaAllocatorHandle.h	/^    MetaAllocator* m_allocator;$/;"	m	class:WTF::MetaAllocatorHandle	access:private
m_atomicStringTable	.\WTFThreadData.h	/^    AtomicStringTable* m_atomicStringTable;$/;"	m	class:WTF::WTFThreadData	access:private
m_atomicStringTableDestructor	.\WTFThreadData.h	/^    AtomicStringTableDestructor m_atomicStringTableDestructor;$/;"	m	class:WTF::WTFThreadData	access:private
m_base	.\PageBlock.h	/^    void* m_base;$/;"	m	class:WTF::PageBlock	access:private
m_baseAddress	.\ArrayBufferView.h	/^    void* m_baseAddress;$/;"	m	class:WTF::ArrayBufferView	access:protected
m_begin	.\BoundsCheckedPointer.h	/^    T* m_begin;$/;"	m	class:WTF::BoundsCheckedPointer	access:private
m_begin	.\url\src\URLComponent.h	/^    int m_begin; \/\/ Byte offset in the string of this component.$/;"	m	class:WTF::URLComponent	access:private
m_bits	.\MD5.h	/^    uint32_t m_bits[2];$/;"	m	class:WTF::MD5	access:private
m_bits	.\PackedIntVector.h	/^    BitVector m_bits;$/;"	m	class:WTF::PackedIntVector	access:private
m_bitsOrPointer	.\BitVector.h	/^    uintptr_t m_bitsOrPointer;$/;"	m	class:WTF::BitVector	access:private
m_blocks	.\BlockStack.h	/^    Vector<T*> m_blocks;$/;"	m	class:WTF::BlockStack	access:private
m_bound	.\StackBounds.h	/^    void* m_bound;$/;"	m	class:WTF::StackBounds	access:private
m_buf	.\MD5.h	/^    uint32_t m_buf[4];$/;"	m	class:WTF::MD5	access:private
m_buffer	.\ArrayBufferView.h	/^    RefPtr<ArrayBuffer> m_buffer;$/;"	m	class:WTF::ArrayBufferView	access:private
m_buffer	.\Deque.h	/^        Buffer m_buffer;$/;"	m	class:WTF::Deque	access:private
m_buffer	.\SHA1.h	/^    uint8_t m_buffer[64];$/;"	m	class:WTF::SHA1	access:private
m_buffer	.\Vector.h	/^        Buffer m_buffer;$/;"	m	class:WTF::Vector	access:private
m_buffer	.\Vector.h	/^        T* m_buffer;$/;"	m	class:WTF::VectorBufferBase	access:protected
m_buffer	.\text\CString.h	/^    RefPtr<CStringBuffer> m_buffer;$/;"	m	class:WTF::CString	access:private
m_buffer	.\text\StringBuilder.h	/^    RefPtr<StringImpl> m_buffer;$/;"	m	class:WTF::StringBuilder	access:private
m_buffer	.\text\StringConcatenate.h	/^    LChar m_buffer;$/;"	m	class:WTF::StringTypeAdapter	access:private
m_buffer	.\text\StringConcatenate.h	/^    UChar m_buffer;$/;"	m	class:WTF::StringTypeAdapter	access:private
m_buffer	.\text\StringConcatenate.h	/^    const LChar* m_buffer;$/;"	m	class:WTF::StringTypeAdapter	access:private
m_buffer	.\text\StringConcatenate.h	/^    const String& m_buffer;$/;"	m	class:WTF::StringTypeAdapter	access:private
m_buffer	.\text\StringConcatenate.h	/^    const UChar* m_buffer;$/;"	m	class:WTF::StringTypeAdapter	access:private
m_buffer	.\text\StringConcatenate.h	/^    const Vector<LChar>& m_buffer;$/;"	m	class:WTF::StringTypeAdapter	access:private
m_buffer	.\text\StringConcatenate.h	/^    const Vector<char>& m_buffer;$/;"	m	class:WTF::StringTypeAdapter	access:private
m_buffer	.\text\StringConcatenate.h	/^    const char* m_buffer;$/;"	m	class:WTF::StringTypeAdapter	access:private
m_buffer	.\text\StringConcatenate.h	/^    unsigned char m_buffer;$/;"	m	class:WTF::StringTypeAdapter	access:private
m_buffer	.\text\StringImpl.h	/^        void* m_buffer;$/;"	m	union:WTF::StringImpl::__anon12	access:public
m_buffer	.\text\StringOperators.h	/^    StringAppend<StringType1, StringType2>& m_buffer;$/;"	m	class:WTF::StringTypeAdapter	access:private
m_buffer	.\url\src\URLBuffer.h	/^    CharacterType* m_buffer;$/;"	m	class:WTF::URLBuffer	access:protected
m_bufferCharacters16	.\text\StringBuilder.h	/^        UChar* m_bufferCharacters16;$/;"	m	union:WTF::StringBuilder::__anon10	access:public
m_bufferCharacters8	.\text\StringBuilder.h	/^        LChar* m_bufferCharacters8;$/;"	m	union:WTF::StringBuilder::__anon10	access:public
m_byteOffset	.\ArrayBufferView.h	/^    unsigned m_byteOffset;$/;"	m	class:WTF::ArrayBufferView	access:protected
m_bytesAllocated	.\MetaAllocator.h	/^    size_t m_bytesAllocated;$/;"	m	class:WTF::MetaAllocator	access:private
m_bytesCommitted	.\MetaAllocator.h	/^    size_t m_bytesCommitted;$/;"	m	class:WTF::MetaAllocator	access:private
m_bytesReserved	.\MetaAllocator.h	/^    size_t m_bytesReserved;$/;"	m	class:WTF::MetaAllocator	access:private
m_calloc	.\wince\MemoryManager.cpp	/^void* MemoryManager::m_calloc(size_t num, size_t size)$/;"	f	class:WTF::MemoryManager	signature:(size_t num, size_t size)
m_calloc	.\wince\MemoryManager.h	/^        static void* m_calloc(size_t num, size_t size);$/;"	p	class:WTF::MemoryManager	access:public	signature:(size_t num, size_t size)
m_capacity	.\Vector.h	/^        size_t m_capacity;$/;"	m	class:WTF::VectorBufferBase	access:protected
m_capacity	.\url\src\URLBuffer.h	/^    int m_capacity;$/;"	m	class:WTF::URLBuffer	access:protected
m_centralCaches	.\FastMalloc.cpp	/^    TCMalloc_Central_FreeListPadded* m_centralCaches;$/;"	m	class:WTF::FastMallocZone	file:	access:private
m_checked	.\CheckedBoolean.h	/^    bool m_checked;$/;"	m	class:CheckedBoolean	access:private
m_coalescedSpans	.\FastMalloc.cpp	/^    Vector<Span*> m_coalescedSpans;$/;"	m	class:WTF::PageMapMemoryUsageRecorder	file:	access:private
m_collator	.\unicode\Collator.h	/^        mutable UCollator* m_collator;$/;"	m	class:WTF::Collator	access:private
m_column	.\text\TextPosition.h	/^    OrdinalNumber m_column;$/;"	m	class:WTF::TextPosition	access:public
m_committed	.\PageReservation.h	/^    size_t m_committed;$/;"	m	class:WTF::PageReservation	access:private
m_condition	.\MessageQueue.h	/^        ThreadCondition m_condition;$/;"	m	class:WTF::MessageQueue	access:private
m_condition	.\ThreadingPrimitives.h	/^    PlatformCondition m_condition;$/;"	m	class:WTF::ThreadCondition	access:private
m_condition	.\threads\BinarySemaphore.h	/^    ThreadCondition m_condition;$/;"	m	class:WTF::BinarySemaphore	access:private
m_contents	.\ArrayBuffer.h	/^    ArrayBufferContents m_contents;$/;"	m	class:WTF::ArrayBuffer	access:private
m_context	.\FastMalloc.cpp	/^    void* m_context;$/;"	m	class:WTF::AdminRegionRecorder	file:	access:private
m_context	.\FastMalloc.cpp	/^    void* m_context;$/;"	m	class:WTF::PageMapMemoryUsageRecorder	file:	access:private
m_copyData16	.\text\StringImpl.h	/^        mutable UChar* m_copyData16;$/;"	m	union:WTF::StringImpl::__anon12	access:public
m_count	.\CryptographicallyRandomNumber.cpp	/^    int m_count;$/;"	m	class:WTF::__anon3::ARC4RandomNumberGenerator	file:	access:private
m_count	.\RefCountedLeakCounter.h	/^        int m_count;$/;"	m	struct:WTF::RefCountedLeakCounter	access:private
m_count	.\RefCountedLeakCounter.h	/^        volatile int m_count;$/;"	m	struct:WTF::RefCountedLeakCounter	access:private
m_count	.\SimpleStats.h	/^    double m_count;$/;"	m	class:WTF::SimpleStats	access:private
m_current	.\BumpPointerAllocator.h	/^    void* m_current;$/;"	m	class:WTF::BumpPointerPool	access:private
m_currentIdentifierTable	.\WTFThreadData.h	/^    JSC::IdentifierTable* m_currentIdentifierTable;$/;"	m	class:WTF::WTFThreadData	access:private
m_cursor	.\SHA1.h	/^    size_t m_cursor; \/\/ Number of bytes filled in m_buffer (0-64).$/;"	m	class:WTF::SHA1	access:private
m_data	.\AVLTree.h	/^    FixedArray<bool, maxDepth> m_data;$/;"	m	class:WTF::AVLTreeDefaultBSet	access:private
m_data	.\ArrayBuffer.h	/^    void* m_data;$/;"	m	class:WTF::ArrayBufferContents	access:private
m_data	.\ByteArray.h	/^        unsigned char m_data[INT_MAX];$/;"	m	class:WTF::ByteArray	access:private
m_data	.\ByteArray.h	/^        unsigned char m_data[];$/;"	m	class:WTF::ByteArray	access:private
m_data	.\FastMalloc.h	/^        mutable void* m_data;$/;"	m	struct:WTF::TryMallocReturnValue	access:private
m_data	.\FixedArray.h	/^    T m_data[Size];$/;"	m	class:WTF::FixedArray	access:private
m_data	.\PossiblyNull.h	/^    mutable T m_data;$/;"	m	struct:WTF::PossiblyNull	access:private
m_data	.\RefCountedArray.h	/^    T* m_data;$/;"	m	class:WTF::RefCountedArray	access:private
m_data	.\text\StringBuffer.h	/^    CharType* m_data;$/;"	m	class:WTF::StringBuffer	access:private
m_data16	.\text\StringImpl.h	/^        const UChar* m_data16;$/;"	m	union:WTF::StringImpl::__anon11	access:public
m_data8	.\text\StringImpl.h	/^        const LChar* m_data8;$/;"	m	union:WTF::StringImpl::__anon11	access:public
m_defaultIdentifierTable	.\WTFThreadData.h	/^    JSC::IdentifierTable* m_defaultIdentifierTable;$/;"	m	class:WTF::WTFThreadData	access:private
m_deletedCount	.\HashTable.h	/^        int m_deletedCount;$/;"	m	class:WTF::HashTable	access:private
m_deletionHasBegun	.\RefCounted.h	/^    bool m_deletionHasBegun;$/;"	m	class:WTF::RefCountedBase	access:private
m_deque	.\Deque.h	/^        Deque<T, inlineCapacity>* m_deque;$/;"	m	class:WTF::DequeIteratorBase	access:private
m_description	.\RefCountedLeakCounter.h	/^        const char* m_description;$/;"	m	struct:WTF::RefCountedLeakCounter	access:private
m_end	.\BoundsCheckedPointer.h	/^    T* m_end;$/;"	m	class:WTF::BoundsCheckedPointer	access:private
m_end	.\Deque.h	/^        size_t m_end;$/;"	m	class:WTF::Deque	access:private
m_endPosition	.\HashTable.h	/^        PointerType m_endPosition;$/;"	m	class:WTF::HashTableConstIterator	access:private
m_event	.\threads\BinarySemaphore.h	/^    HANDLE m_event;$/;"	m	class:WTF::BinarySemaphore	access:private
m_executable	.\PageReservation.h	/^    bool m_executable;$/;"	m	class:WTF::PageReservation	access:private
m_exponent	.\DecimalNumber.h	/^    int m_exponent;$/;"	m	class:WTF::DecimalNumber	access:private
m_firstView	.\ArrayBuffer.h	/^    ArrayBufferView* m_firstView;$/;"	m	class:WTF::ArrayBuffer	access:private
m_free	.\wince\MemoryManager.cpp	/^void MemoryManager::m_free(void* p)$/;"	f	class:WTF::MemoryManager	signature:(void* p)
m_free	.\wince\MemoryManager.h	/^        static void m_free(void*);$/;"	p	class:WTF::MemoryManager	access:public	signature:(void*)
m_freeList	.\ListHashSet.h	/^        Node* m_freeList;$/;"	m	struct:WTF::ListHashSetNodeAllocator	access:private
m_freeObjectFinder	.\FastMalloc.cpp	/^    FreeObjectFinder& m_freeObjectFinder;$/;"	m	class:WTF::PageMapFreeObjectFinder	file:	access:private
m_freeObjectFinder	.\FastMalloc.cpp	/^    const FreeObjectFinder& m_freeObjectFinder;$/;"	m	class:WTF::PageMapMemoryUsageRecorder	file:	access:private
m_freeObjects	.\FastMalloc.cpp	/^    HashSet<void*> m_freeObjects;$/;"	m	class:WTF::FreeObjectFinder	file:	access:private
m_freeSpaceEndAddressMap	.\MetaAllocator.h	/^    HashMap<void*, FreeSpaceNode*> m_freeSpaceEndAddressMap;$/;"	m	class:WTF::MetaAllocator	access:private
m_freeSpaceSizeMap	.\MetaAllocator.h	/^    Tree m_freeSpaceSizeMap;$/;"	m	class:WTF::MetaAllocator	access:private
m_freeSpaceStartAddressMap	.\MetaAllocator.h	/^    HashMap<void*, FreeSpaceNode*> m_freeSpaceStartAddressMap;$/;"	m	class:WTF::MetaAllocator	access:private
m_function	.\Functional.h	/^    R (*m_function)();$/;"	m	class:WTF::FunctionWrapper	access:private
m_function	.\Functional.h	/^    R (*m_function)(P1);$/;"	m	class:WTF::FunctionWrapper	access:private
m_function	.\Functional.h	/^    R (*m_function)(P1, P2);$/;"	m	class:WTF::FunctionWrapper	access:private
m_function	.\Functional.h	/^    R (*m_function)(P1, P2, P3);$/;"	m	class:WTF::FunctionWrapper	access:private
m_function	.\Functional.h	/^    R (C::*m_function)();$/;"	m	class:WTF::FunctionWrapper	access:private
m_function	.\Functional.h	/^    R (C::*m_function)(P1);$/;"	m	class:WTF::FunctionWrapper	access:private
m_function	.\Functional.h	/^    R (C::*m_function)(P1, P2);$/;"	m	class:WTF::FunctionWrapper	access:private
m_function	.\Functional.h	/^    R (C::*m_function)(P1, P2, P3);$/;"	m	class:WTF::FunctionWrapper	access:private
m_function	.\Functional.h	/^    R (C::*m_function)(P1, P2, P3, P4);$/;"	m	class:WTF::FunctionWrapper	access:private
m_function	.\Functional.h	/^    R (C::*m_function)(P1, P2, P3, P4, P5);$/;"	m	class:WTF::FunctionWrapper	access:private
m_function	.\text\StringImpl.cpp	/^    const CharacterMatchFunctionPtr m_function;$/;"	m	class:WTF::UCharPredicate	file:	access:private
m_functionWrapper	.\Functional.h	/^    FunctionWrapper m_functionWrapper;$/;"	m	class:WTF::BoundFunctionImpl	access:private
m_hasPendingCharacter	.\StringHasher.h	/^    bool m_hasPendingCharacter;$/;"	m	class:WTF::StringHasher	access:private
m_hash	.\SHA1.h	/^    uint32_t m_hash[5];$/;"	m	class:WTF::SHA1	access:private
m_hash	.\StringHasher.h	/^    unsigned m_hash;$/;"	m	class:WTF::StringHasher	access:private
m_hashAndFlags	.\text\StringImpl.h	/^    mutable unsigned m_hashAndFlags;$/;"	m	class:WTF::StringImpl	access:private
m_head	.\BumpPointerAllocator.h	/^    BumpPointerPool* m_head;$/;"	m	class:WTF::BumpPointerAllocator	access:private
m_head	.\DoublyLinkedList.h	/^    T* m_head;$/;"	m	class:WTF::DoublyLinkedList	access:private
m_head	.\ListHashSet.h	/^        Node* m_head;$/;"	m	class:WTF::ListHashSet	access:private
m_head	.\SinglyLinkedList.h	/^    Node* m_head;$/;"	m	class:WTF::SinglyLinkedList	access:private
m_headSentinel	.\SentinelLinkedList.h	/^    RawNode m_headSentinel;$/;"	m	class:WTF::SentinelLinkedList	access:private
m_identifier	.\ThreadIdentifierDataPthreads.h	/^    ThreadIdentifier m_identifier;$/;"	m	class:WTF::ThreadIdentifierData	access:private
m_impl	.\Functional.h	/^    RefPtr<FunctionImplBase> m_impl;$/;"	m	class:WTF::FunctionBase	access:private
m_impl	.\HashCountedSet.h	/^        ImplType m_impl;$/;"	m	class:WTF::HashCountedSet	access:private
m_impl	.\HashIterators.h	/^        ConstIterator m_impl;$/;"	m	struct:WTF::HashTableConstKeysIterator	access:public
m_impl	.\HashIterators.h	/^        ConstIterator m_impl;$/;"	m	struct:WTF::HashTableConstValuesIterator	access:public
m_impl	.\HashIterators.h	/^        Iterator m_impl;$/;"	m	struct:WTF::HashTableKeysIterator	access:public
m_impl	.\HashIterators.h	/^        Iterator m_impl;$/;"	m	struct:WTF::HashTableValuesIterator	access:public
m_impl	.\HashIterators.h	/^        typename HashTableType::const_iterator m_impl;$/;"	m	struct:WTF::HashTableConstIteratorAdapter	access:public
m_impl	.\HashIterators.h	/^        typename HashTableType::iterator m_impl;$/;"	m	struct:WTF::HashTableIteratorAdapter	access:public
m_impl	.\HashMap.h	/^        HashTableType m_impl;$/;"	m	class:WTF::HashMap	access:private
m_impl	.\HashSet.h	/^        HashTableType m_impl;$/;"	m	class:WTF::HashSet	access:private
m_impl	.\HashTable.h	/^        typename HashTableType::const_iterator m_impl;$/;"	m	struct:WTF::HashTableConstIteratorAdapter	access:public
m_impl	.\HashTable.h	/^        typename HashTableType::iterator m_impl;$/;"	m	struct:WTF::HashTableIteratorAdapter	access:public
m_impl	.\ListHashSet.h	/^        ImplType m_impl;$/;"	m	class:WTF::ListHashSet	access:private
m_impl	.\RefPtrHashMap.h	/^        HashTableType m_impl;$/;"	m	class:WTF::HashMap	access:private
m_impl	.\text\WTFString.h	/^    RefPtr<StringImpl> m_impl;$/;"	m	class:WTF::String	access:private
m_in	.\MD5.h	/^    uint8_t m_in[64];$/;"	m	class:WTF::MD5	access:private
m_index	.\Deque.h	/^        size_t m_index;$/;"	m	class:WTF::DequeIteratorBase	access:private
m_index	.\SegmentedVector.h	/^        size_t m_index;$/;"	m	class:WTF::SegmentedVectorIterator	access:private
m_index	.\ThreadSpecific.h	/^    int m_index;$/;"	m	class:WTF::ThreadSpecific	access:private
m_inlineBuffer	.\Vector.h	/^        AlignedBuffer<m_inlineBufferSize, WTF_ALIGN_OF(T)> m_inlineBuffer;$/;"	m	class:WTF::VectorBuffer	access:private
m_inlineBuffer	.\url\src\RawURLBuffer.h	/^    CharacterType m_inlineBuffer[inlineCapacity];$/;"	m	class:WTF::RawURLBuffer	access:protected
m_inlineBufferSize	.\Vector.h	/^        static const size_t m_inlineBufferSize = inlineCapacity * sizeof(T);$/;"	m	class:WTF::VectorBuffer	access:private
m_inlineSegment	.\SegmentedVector.h	/^        Segment m_inlineSegment;$/;"	m	class:WTF::SegmentedVector	access:private
m_is8Bit	.\text\StringBuilder.h	/^    bool m_is8Bit;$/;"	m	class:WTF::StringBuilder	access:private
m_isAllocated	.\ListHashSet.h	/^        bool m_isAllocated;$/;"	m	struct:WTF::ListHashSetNode	access:public
m_isDestroyedOnce	.\ThreadIdentifierDataPthreads.h	/^    bool m_isDestroyedOnce;$/;"	m	class:WTF::ThreadIdentifierData	access:private
m_isDoneWithInitialFreeList	.\ListHashSet.h	/^        bool m_isDoneWithInitialFreeList;$/;"	m	struct:WTF::ListHashSetNodeAllocator	access:private
m_isSet	.\threads\BinarySemaphore.h	/^    bool m_isSet;$/;"	m	class:WTF::BinarySemaphore	access:private
m_iterator	.\HashTable.h	/^        const_iterator m_iterator;$/;"	m	class:WTF::HashTableIterator	access:private
m_iterator	.\ListHashSet.h	/^        const_iterator m_iterator;$/;"	m	class:WTF::ListHashSetIterator	access:private
m_iterator	.\ListHashSet.h	/^        const_reverse_iterator m_iterator;$/;"	m	class:WTF::ListHashSetReverseIterator	access:private
m_iterators	.\Deque.h	/^        mutable IteratorBase* m_iterators;$/;"	m	class:WTF::Deque	access:private
m_iterators	.\HashTable.h	/^        mutable const_iterator* m_iterators;$/;"	m	class:WTF::HashTable	access:public
m_key	.\ThreadIdentifierDataPthreads.cpp	/^pthread_key_t ThreadIdentifierData::m_key = PTHREAD_KEYS_MAX;$/;"	m	class:WTF::ThreadIdentifierData	file:
m_key	.\ThreadIdentifierDataPthreads.h	/^    static pthread_key_t m_key;$/;"	m	class:WTF::ThreadIdentifierData	access:private
m_key	.\ThreadSpecific.h	/^    pthread_key_t m_key;$/;"	m	class:WTF::ThreadSpecific	access:private
m_keyCount	.\HashTable.h	/^        int m_keyCount;$/;"	m	class:WTF::HashTable	access:private
m_killed	.\MessageQueue.h	/^        bool m_killed;$/;"	m	class:WTF::MessageQueue	access:private
m_left	.\RedBlackTree.h	/^        NodeType* m_left;$/;"	m	class:WTF::RedBlackTree::Node	access:private
m_length	.\TypedArrayBase.h	/^    unsigned m_length;$/;"	m	class:WTF::TypedArrayBase	access:protected
m_length	.\text\StringBuffer.h	/^    unsigned m_length;$/;"	m	class:WTF::StringBuffer	access:private
m_length	.\text\StringBuilder.h	/^    unsigned m_length;$/;"	m	class:WTF::StringBuilder	access:private
m_length	.\text\StringConcatenate.h	/^    unsigned m_length;$/;"	m	class:WTF::StringTypeAdapter	access:private
m_length	.\text\StringImpl.h	/^    unsigned m_length;$/;"	m	class:WTF::StringImpl	access:private
m_length	.\url\src\URLBuffer.h	/^    int m_length; \/\/ Used characters in the buffer.$/;"	m	class:WTF::URLBuffer	access:protected
m_length	.\url\src\URLComponent.h	/^    int m_length; \/\/ Will be -1 if the component is unspecified.$/;"	m	class:WTF::URLComponent	access:private
m_line	.\text\TextPosition.h	/^    OrdinalNumber m_line;$/;"	m	class:WTF::TextPosition	access:public
m_literalTable	.\WTFThreadData.h	/^    LiteralIdentifierTable m_literalTable;$/;"	m	class:JSC::IdentifierTable	access:private
m_locale	.\unicode\Collator.h	/^        char* m_locale;$/;"	m	class:WTF::Collator	access:private
m_lock	.\MetaAllocator.h	/^    SpinLock m_lock;$/;"	m	class:WTF::MetaAllocator	access:private
m_lockable	.\Locker.h	/^    T& m_lockable;$/;"	m	class:WTF::Locker	access:private
m_lockword	.\TCSpinLock.h	/^    LONG m_lockword;$/;"	m	struct:TCMalloc_SpinLock	access:public
m_logAllocationGranule	.\MetaAllocator.h	/^    unsigned m_logAllocationGranule;$/;"	m	class:WTF::MetaAllocator	access:private
m_logPageSize	.\MetaAllocator.h	/^    unsigned m_logPageSize;$/;"	m	class:WTF::MetaAllocator	access:private
m_lowerFirst	.\unicode\Collator.h	/^        bool m_lowerFirst;$/;"	m	class:WTF::Collator	access:private
m_malloc	.\wince\MemoryManager.cpp	/^void* MemoryManager::m_malloc(size_t size)$/;"	f	class:WTF::MemoryManager	signature:(size_t size)
m_malloc	.\wince\MemoryManager.h	/^        static void* m_malloc(size_t size);$/;"	p	class:WTF::MemoryManager	access:public	signature:(size_t size)
m_mallocBalance	.\MetaAllocator.h	/^    size_t m_mallocBalance;$/;"	m	class:WTF::MetaAllocator	access:private
m_map	.\Spectrum.h	/^    HashMap<T, unsigned long> m_map;$/;"	m	class:WTF::Spectrum	access:private
m_maxLoad	.\HashTable.h	/^        static const int m_maxLoad = 2;$/;"	m	class:WTF::HashTable	access:private
m_memory	.\FastMalloc.cpp	/^    void* m_memory;$/;"	m	union:WTF::__anon5	file:	access:public
m_minLoad	.\HashTable.h	/^        static const int m_minLoad = 6;$/;"	m	class:WTF::HashTable	access:private
m_mode	.\ThreadRestrictionVerifier.h	/^    VerificationMode m_mode;$/;"	m	class:WTF::ThreadRestrictionVerifier	access:private
m_mutex	.\CryptographicallyRandomNumber.cpp	/^    Mutex m_mutex;$/;"	m	class:WTF::__anon3::ARC4RandomNumberGenerator	file:	access:private
m_mutex	.\HashTable.h	/^        mutable Mutex m_mutex;$/;"	m	class:WTF::HashTable	access:public
m_mutex	.\MessageQueue.h	/^        mutable Mutex m_mutex;$/;"	m	class:WTF::MessageQueue	access:private
m_mutex	.\ParallelJobsGeneric.h	/^        mutable Mutex m_mutex;$/;"	m	class:WTF::ParallelEnvironment::ThreadPrivate	access:private
m_mutex	.\ThreadRestrictionVerifier.h	/^    Mutex* m_mutex;$/;"	m	class:WTF::ThreadRestrictionVerifier	access:private
m_mutex	.\ThreadSafeRefCounted.h	/^    mutable Mutex m_mutex;$/;"	m	class:WTF::ThreadSafeRefCountedBase	access:private
m_mutex	.\ThreadingPrimitives.h	/^    PlatformMutex m_mutex;$/;"	m	class:WTF::Mutex	access:private
m_mutex	.\threads\BinarySemaphore.h	/^    Mutex m_mutex;$/;"	m	class:WTF::BinarySemaphore	access:private
m_next	.\BumpPointerAllocator.h	/^    BumpPointerPool* m_next;$/;"	m	class:WTF::BumpPointerPool	access:private
m_next	.\Deque.h	/^        mutable DequeIteratorBase* m_next;$/;"	m	class:WTF::DequeIteratorBase	access:private
m_next	.\HashTable.h	/^        mutable const_iterator* m_next;$/;"	m	class:WTF::HashTableConstIterator	access:public
m_next	.\ListHashSet.h	/^        ListHashSetNode* m_next;$/;"	m	struct:WTF::ListHashSetNode	access:public
m_next	.\SentinelLinkedList.h	/^    BasicRawSentinelNode* m_next;$/;"	m	class:WTF::BasicRawSentinelNode	access:private
m_nextView	.\ArrayBufferView.h	/^    ArrayBufferView* m_nextView;$/;"	m	class:WTF::ArrayBufferView	access:private
m_numAllocations	.\MetaAllocator.h	/^    unsigned m_numAllocations;$/;"	m	class:WTF::MetaAllocator	access:private
m_numBits	.\BitVector.h	/^        size_t m_numBits;$/;"	m	class:WTF::BitVector::OutOfLineBits	access:private
m_numFrees	.\MetaAllocator.h	/^    unsigned m_numFrees;$/;"	m	class:WTF::MetaAllocator	access:private
m_numberOfJobs	.\ParallelJobsGeneric.h	/^    int m_numberOfJobs;$/;"	m	class:WTF::ParallelEnvironment	access:private
m_numberOfJobs	.\ParallelJobsLibdispatch.h	/^    int m_numberOfJobs;$/;"	m	class:WTF::ParallelEnvironment	access:private
m_numberOfJobs	.\ParallelJobsOpenMP.h	/^    int m_numberOfJobs;$/;"	m	class:WTF::ParallelEnvironment	access:private
m_old	.\wince\MemoryManager.h	/^        bool m_old;$/;"	m	class:WTF::MemoryAllocationCanFail	access:private
m_old	.\wince\MemoryManager.h	/^        bool m_old;$/;"	m	class:WTF::MemoryAllocationCannotFail	access:private
m_origin	.\StackBounds.h	/^    void* m_origin;$/;"	m	class:WTF::StackBounds	access:private
m_originalValue	.\TemporaryChange.h	/^    T m_originalValue;$/;"	m	class:WTF::TemporaryChange	access:private
m_overflowed	.\CheckedArithmetic.h	/^    unsigned char m_overflowed;$/;"	m	class:WTF::RecordOverflow	access:private
m_ownerUID	.\MetaAllocatorHandle.h	/^    void* m_ownerUID;$/;"	m	class:WTF::MetaAllocatorHandle	access:private
m_owningQueue	.\ThreadRestrictionVerifier.h	/^    dispatch_queue_t m_owningQueue;$/;"	m	class:WTF::ThreadRestrictionVerifier	access:private
m_owningThread	.\ThreadRestrictionVerifier.h	/^    ThreadIdentifier m_owningThread;$/;"	m	class:WTF::ThreadRestrictionVerifier	access:private
m_p1	.\Functional.h	/^    typename ParamStorageTraits<P1>::StorageType m_p1;$/;"	m	class:WTF::BoundFunctionImpl	access:private
m_p2	.\Functional.h	/^    typename ParamStorageTraits<P2>::StorageType m_p2;$/;"	m	class:WTF::BoundFunctionImpl	access:private
m_p3	.\Functional.h	/^    typename ParamStorageTraits<P3>::StorageType m_p3;$/;"	m	class:WTF::BoundFunctionImpl	access:private
m_p4	.\Functional.h	/^    typename ParamStorageTraits<P4>::StorageType m_p4;$/;"	m	class:WTF::BoundFunctionImpl	access:private
m_p5	.\Functional.h	/^    typename ParamStorageTraits<P5>::StorageType m_p5;$/;"	m	class:WTF::BoundFunctionImpl	access:private
m_p6	.\Functional.h	/^    typename ParamStorageTraits<P6>::StorageType m_p6;$/;"	m	class:WTF::BoundFunctionImpl	access:private
m_pageHeap	.\FastMalloc.cpp	/^    TCMalloc_PageHeap* m_pageHeap;$/;"	m	class:WTF::FastMallocZone	file:	access:private
m_pageHeap	.\FastMalloc.cpp	/^    TCMalloc_PageHeap* m_pageHeap;$/;"	m	union:WTF::__anon5	file:	access:public
m_pageHeapAllocator	.\FastMalloc.cpp	/^    PageHeapAllocator<TCMalloc_ThreadCache>* m_pageHeapAllocator;$/;"	m	class:WTF::FastMallocZone	file:	access:private
m_pageOccupancyMap	.\MetaAllocator.h	/^    HashMap<uintptr_t, size_t> m_pageOccupancyMap;$/;"	m	class:WTF::MetaAllocator	access:private
m_pageSize	.\MetaAllocator.h	/^    size_t m_pageSize;$/;"	m	class:WTF::MetaAllocator	access:private
m_parallelEnvironment	.\ParallelJobs.h	/^    ParallelEnvironment m_parallelEnvironment;$/;"	m	class:WTF::ParallelJobs	access:private
m_parameters	.\ParallelJobs.h	/^    Vector<Type> m_parameters;$/;"	m	class:WTF::ParallelJobs	access:private
m_parameters	.\ParallelJobsGeneric.h	/^        void* m_parameters;$/;"	m	class:WTF::ParallelEnvironment::ThreadPrivate	access:private
m_parent	.\ParallelJobsGeneric.h	/^        ParallelEnvironment* m_parent;$/;"	m	class:WTF::ParallelEnvironment::ThreadPrivate	access:private
m_parent	.\UnionFind.h	/^    T* m_parent;$/;"	m	class:WTF::UnionFind	access:private
m_parentAndRed	.\RedBlackTree.h	/^        uintptr_t m_parentAndRed;$/;"	m	class:WTF::RedBlackTree::Node	access:private
m_pendingCharacter	.\StringHasher.h	/^    UChar m_pendingCharacter;$/;"	m	class:WTF::StringHasher	access:private
m_pendingRegions	.\FastMalloc.cpp	/^    Vector<vm_range_t, 1024> m_pendingRegions;$/;"	m	class:WTF::AdminRegionRecorder	file:	access:private
m_pointer	.\BoundsCheckedPointer.h	/^    T* m_pointer;$/;"	m	class:WTF::BoundsCheckedPointer	access:private
m_pool	.\ListHashSet.h	/^        } m_pool;$/;"	m	struct:WTF::ListHashSetNodeAllocator	typeref:union:WTF::ListHashSetNodeAllocator::__anon9	access:private
m_poolSize	.\ListHashSet.h	/^        static const size_t m_poolSize = inlineCapacity;$/;"	m	struct:WTF::ListHashSetNodeAllocator	access:private
m_position	.\HashTable.h	/^        PointerType m_position;$/;"	m	class:WTF::HashTableConstIterator	access:private
m_position	.\ListHashSet.h	/^        Node* m_position;$/;"	m	class:WTF::ListHashSetConstIterator	access:private
m_position	.\ListHashSet.h	/^        Node* m_position;$/;"	m	class:WTF::ListHashSetConstReverseIterator	access:private
m_precision	.\DecimalNumber.h	/^    unsigned m_precision;$/;"	m	class:WTF::DecimalNumber	access:private
m_prefix	.\FastMalloc.h	/^            ValidationTag m_prefix;$/;"	m	struct:WTF::Internal::ValidationHeader	access:public
m_prev	.\ListHashSet.h	/^        ListHashSetNode* m_prev;$/;"	m	struct:WTF::ListHashSetNode	access:public
m_prev	.\SentinelLinkedList.h	/^    BasicRawSentinelNode* m_prev;$/;"	m	class:WTF::BasicRawSentinelNode	access:private
m_prevView	.\ArrayBufferView.h	/^    ArrayBufferView* m_prevView;$/;"	m	class:WTF::ArrayBufferView	access:private
m_previous	.\BumpPointerAllocator.h	/^    BumpPointerPool* m_previous;$/;"	m	class:WTF::BumpPointerPool	access:private
m_previous	.\Deque.h	/^        mutable DequeIteratorBase* m_previous;$/;"	m	class:WTF::DequeIteratorBase	access:private
m_previous	.\HashTable.h	/^        mutable const_iterator* m_previous;$/;"	m	class:WTF::HashTableConstIterator	access:public
m_ptr	.\OwnArrayPtr.h	/^    PtrType m_ptr;$/;"	m	class:WTF::OwnArrayPtr	access:private
m_ptr	.\OwnPtr.h	/^        PtrType m_ptr;$/;"	m	class:WTF::OwnPtr	access:private
m_ptr	.\PassOwnArrayPtr.h	/^    mutable PtrType m_ptr;$/;"	m	class:WTF::PassOwnArrayPtr	access:private
m_ptr	.\PassOwnPtr.h	/^        mutable PtrType m_ptr;$/;"	m	class:WTF::PassOwnPtr	access:private
m_ptr	.\PassRefPtr.h	/^        mutable T* m_ptr;$/;"	m	class:WTF::NonNullPassRefPtr	access:private
m_ptr	.\PassRefPtr.h	/^        mutable T* m_ptr;$/;"	m	class:WTF::PassRefPtr	access:private
m_ptr	.\RefPtr.h	/^        T* m_ptr;$/;"	m	class:WTF::RefPtr	access:private
m_ptr	.\RetainPtr.h	/^        PtrType m_ptr;$/;"	m	class:WTF::RetainPtr	access:private
m_ptr	.\gobject\GOwnPtr.h	/^    T* m_ptr;$/;"	m	class:WTF::GOwnPtr	access:private
m_ptr	.\gobject\GRefPtr.h	/^    T* m_ptr;$/;"	m	class:WTF::GRefPtr	access:private
m_queue	.\MessageQueue.h	/^        Deque<DataType*> m_queue;$/;"	m	class:WTF::MessageQueue	access:private
m_readWriteLock	.\ThreadingPrimitives.h	/^    PlatformReadWriteLock m_readWriteLock;$/;"	m	class:WTF::ReadWriteLock	access:private
m_reader	.\FastMalloc.cpp	/^    const RemoteMemoryReader& m_reader;$/;"	m	class:WTF::AdminRegionRecorder	file:	access:private
m_reader	.\FastMalloc.cpp	/^    const RemoteMemoryReader& m_reader;$/;"	m	class:WTF::FreeObjectFinder	file:	access:private
m_reader	.\FastMalloc.cpp	/^    const RemoteMemoryReader& m_reader;$/;"	m	class:WTF::PageMapFreeObjectFinder	file:	access:private
m_reader	.\FastMalloc.cpp	/^    const RemoteMemoryReader& m_reader;$/;"	m	class:WTF::PageMapMemoryUsageRecorder	file:	access:private
m_reader	.\MallocZoneSupport.h	/^    memory_reader_t* m_reader;$/;"	m	class:WTF::RemoteMemoryReader	access:private
m_realBase	.\PageBlock.h	/^    void* m_realBase;$/;"	m	class:WTF::PageBlock	access:private
m_realloc	.\wince\MemoryManager.cpp	/^void* MemoryManager::m_realloc(void* p, size_t size)$/;"	f	class:WTF::MemoryManager	signature:(void* p, size_t size)
m_realloc	.\wince\MemoryManager.h	/^        static void* m_realloc(void* p, size_t size);$/;"	p	class:WTF::MemoryManager	access:public	signature:(void* p, size_t size)
m_recorder	.\FastMalloc.cpp	/^    vm_range_recorder_t* m_recorder;$/;"	m	class:WTF::AdminRegionRecorder	file:	access:private
m_recorder	.\FastMalloc.cpp	/^    vm_range_recorder_t* m_recorder;$/;"	m	class:WTF::PageMapMemoryUsageRecorder	file:	access:private
m_refCount	.\RefCounted.h	/^    int m_refCount;$/;"	m	class:WTF::RefCountedBase	access:private
m_refCount	.\ThreadSafeRefCounted.h	/^    int m_refCount;$/;"	m	class:WTF::ThreadSafeRefCountedBase	access:private
m_refCount	.\text\StringImpl.h	/^    unsigned m_refCount;$/;"	m	class:WTF::StringImpl	access:private
m_reservation	.\PageAllocationAligned.h	/^    PageBlock m_reservation;$/;"	m	class:WTF::PageAllocationAligned	access:private
m_right	.\RedBlackTree.h	/^        NodeType* m_right;$/;"	m	class:WTF::RedBlackTree::Node	access:private
m_root	.\RedBlackTree.h	/^    NodeType* m_root;$/;"	m	class:WTF::RedBlackTree	access:private
m_running	.\ParallelJobsGeneric.h	/^        bool m_running;$/;"	m	class:WTF::ParallelEnvironment::ThreadPrivate	access:private
m_scavengeCondition	.\FastMalloc.cpp	/^  pthread_cond_t m_scavengeCondition;$/;"	m	class:WTF::TCMalloc_PageHeap	file:	access:private
m_scavengeMutex	.\FastMalloc.cpp	/^  pthread_mutex_t m_scavengeMutex;$/;"	m	class:WTF::TCMalloc_PageHeap	file:	access:private
m_scavengeQueue	.\FastMalloc.cpp	/^  dispatch_queue_t m_scavengeQueue;$/;"	m	class:WTF::TCMalloc_PageHeap	file:	access:private
m_scavengeQueueTimer	.\FastMalloc.cpp	/^  HANDLE m_scavengeQueueTimer;$/;"	m	class:WTF::TCMalloc_PageHeap	file:	access:private
m_scavengeThreadActive	.\FastMalloc.cpp	/^  bool m_scavengeThreadActive;$/;"	m	class:WTF::TCMalloc_PageHeap	file:	access:private
m_scavengeTimer	.\FastMalloc.cpp	/^  dispatch_source_t m_scavengeTimer;$/;"	m	class:WTF::TCMalloc_PageHeap	file:	access:private
m_scavengingSuspended	.\FastMalloc.cpp	/^  bool m_scavengingSuspended;$/;"	m	class:WTF::TCMalloc_PageHeap	file:	access:private
m_scopedVariable	.\TemporaryChange.h	/^    T& m_scopedVariable;$/;"	m	class:WTF::TemporaryChange	access:private
m_seenPointers	.\FastMalloc.cpp	/^    HashSet<void*> m_seenPointers;$/;"	m	class:WTF::PageMapMemoryUsageRecorder	file:	access:private
m_segment	.\SegmentedVector.h	/^        size_t m_segment;$/;"	m	class:WTF::SegmentedVectorIterator	access:private
m_segments	.\SegmentedVector.h	/^        Vector<Segment*, 32> m_segments;$/;"	m	class:WTF::SegmentedVector	access:private
m_segments	.\url\api\ParsedURL.h	/^    URLSegments m_segments;$/;"	m	class:WTF::ParsedURL	access:private
m_set	.\ListHashSet.h	/^        const ListHashSetType* m_set;$/;"	m	class:WTF::ListHashSetConstIterator	access:private
m_set	.\ListHashSet.h	/^        const ListHashSetType* m_set;$/;"	m	class:WTF::ListHashSetConstReverseIterator	access:private
m_shared	.\ThreadRestrictionVerifier.h	/^    bool m_shared;$/;"	m	class:WTF::ThreadRestrictionVerifier	access:private
m_sign	.\DecimalNumber.h	/^    bool m_sign;$/;"	m	class:WTF::DecimalNumber	access:private
m_significand	.\DecimalNumber.h	/^    DtoaBuffer m_significand;$/;"	m	class:WTF::DecimalNumber	access:private
m_size	.\ByteArray.h	/^        size_t m_size;$/;"	m	class:WTF::ByteArray	access:private
m_size	.\FastMalloc.h	/^            unsigned m_size;$/;"	m	struct:WTF::Internal::ValidationHeader	access:public
m_size	.\PageBlock.h	/^    size_t m_size;$/;"	m	class:WTF::PageBlock	access:private
m_size	.\SegmentedVector.h	/^        size_t m_size;$/;"	m	class:WTF::SegmentedVector	access:private
m_size	.\Vector.h	/^        size_t m_size;$/;"	m	class:WTF::Vector	access:private
m_sizeInBytes	.\ArrayBuffer.h	/^    unsigned m_sizeInBytes;$/;"	m	class:WTF::ArrayBufferContents	access:private
m_sizeInBytes	.\MetaAllocator.h	/^        size_t m_sizeInBytes;$/;"	m	class:WTF::MetaAllocator::FreeSpaceNode	access:public
m_sizeInBytes	.\MetaAllocatorHandle.h	/^    size_t m_sizeInBytes;$/;"	m	class:WTF::MetaAllocatorHandle	access:private
m_sizeOfParameter	.\ParallelJobsGeneric.h	/^    size_t m_sizeOfParameter;$/;"	m	class:WTF::ParallelEnvironment	access:private
m_sizeOfParameter	.\ParallelJobsLibdispatch.h	/^    size_t m_sizeOfParameter;$/;"	m	class:WTF::ParallelEnvironment	access:private
m_sizeOfParameter	.\ParallelJobsOpenMP.h	/^    size_t m_sizeOfParameter;$/;"	m	class:WTF::ParallelEnvironment	access:private
m_spanAllocator	.\FastMalloc.cpp	/^    PageHeapAllocator<Span>* m_spanAllocator;$/;"	m	class:WTF::FastMallocZone	file:	access:private
m_spareBlock	.\BlockStack.h	/^    T* m_spareBlock; \/\/ Used to avoid thrash at block boundaries.$/;"	m	class:WTF::BlockStack	access:private
m_spec	.\url\api\ParsedURL.h	/^    URLString m_spec;$/;"	m	class:WTF::ParsedURL	access:private
m_stackBounds	.\WTFThreadData.h	/^    StackBounds m_stackBounds;$/;"	m	class:WTF::WTFThreadData	access:private
m_start	.\BumpPointerAllocator.h	/^    void* m_start;$/;"	m	class:WTF::BumpPointerPool	access:private
m_start	.\Deque.h	/^        size_t m_start;$/;"	m	class:WTF::Deque	access:private
m_start	.\MetaAllocator.h	/^        void* m_start;$/;"	m	class:WTF::MetaAllocator::FreeSpaceNode	access:public
m_start	.\MetaAllocatorHandle.h	/^    void* m_start;$/;"	m	class:WTF::MetaAllocatorHandle	access:private
m_stream	.\CryptographicallyRandomNumber.cpp	/^    ARC4Stream m_stream;$/;"	m	class:WTF::__anon3::ARC4RandomNumberGenerator	file:	access:private
m_string	.\text\AtomicString.h	/^    String m_string;$/;"	m	class:WTF::AtomicString	access:private
m_string	.\text\StringBuilder.h	/^    mutable String m_string;$/;"	m	class:WTF::StringBuilder	access:private
m_string	.\url\api\URLString.h	/^    String m_string;$/;"	m	class:WTF::URLString	access:private
m_string1	.\text\StringOperators.h	/^    StringType1 m_string1;$/;"	m	class:WTF::StringAppend	access:private
m_string2	.\text\StringOperators.h	/^    StringType2 m_string2;$/;"	m	class:WTF::StringAppend	access:private
m_substringBuffer	.\text\StringImpl.h	/^        StringImpl* m_substringBuffer;$/;"	m	union:WTF::StringImpl::__anon12	access:public
m_sum	.\SimpleStats.h	/^    double m_sum;$/;"	m	class:WTF::SimpleStats	access:private
m_sumOfSquares	.\SimpleStats.h	/^    double m_sumOfSquares;$/;"	m	class:WTF::SimpleStats	access:private
m_table	.\BloomFilter.h	/^    uint8_t m_table[tableSize];$/;"	m	class:WTF::BloomFilter	access:private
m_table	.\HashTable.h	/^        ValueType* m_table;$/;"	m	class:WTF::HashTable	access:private
m_table	.\HashTable.h	/^        mutable const HashTableType* m_table;$/;"	m	class:WTF::HashTableConstIterator	access:public
m_table	.\WTFThreadData.h	/^    HashSet<StringImpl*> m_table;$/;"	m	class:JSC::IdentifierTable	access:private
m_table	.\text\AtomicString.cpp	/^    HashSet<StringImpl*> m_table;$/;"	m	class:WTF::AtomicStringTable	file:	access:private
m_tableSize	.\HashTable.h	/^        int m_tableSize;$/;"	m	class:WTF::HashTable	access:private
m_tableSizeMask	.\HashTable.h	/^        int m_tableSizeMask;$/;"	m	class:WTF::HashTable	access:private
m_tail	.\DoublyLinkedList.h	/^    T* m_tail;$/;"	m	class:WTF::DoublyLinkedList	access:private
m_tail	.\ListHashSet.h	/^        Node* m_tail;$/;"	m	class:WTF::ListHashSet	access:private
m_tailSentinel	.\SentinelLinkedList.h	/^    RawNode m_tailSentinel;$/;"	m	class:WTF::SentinelLinkedList	access:private
m_task	.\FastMalloc.cpp	/^    task_t m_task;$/;"	m	class:WTF::AdminRegionRecorder	file:	access:private
m_task	.\FastMalloc.cpp	/^    task_t m_task;$/;"	m	class:WTF::PageMapMemoryUsageRecorder	file:	access:private
m_task	.\MallocZoneSupport.h	/^    task_t m_task;$/;"	m	class:WTF::RemoteMemoryReader	access:private
m_threadCondition	.\ParallelJobsGeneric.h	/^        ThreadCondition m_threadCondition;$/;"	m	class:WTF::ParallelEnvironment::ThreadPrivate	access:private
m_threadFunction	.\ParallelJobsGeneric.h	/^        ThreadFunction m_threadFunction;$/;"	m	class:WTF::ParallelEnvironment::ThreadPrivate	access:private
m_threadFunction	.\ParallelJobsGeneric.h	/^    ThreadFunction m_threadFunction;$/;"	m	class:WTF::ParallelEnvironment	access:private
m_threadFunction	.\ParallelJobsLibdispatch.h	/^    ThreadFunction m_threadFunction;$/;"	m	class:WTF::ParallelEnvironment	access:private
m_threadFunction	.\ParallelJobsOpenMP.h	/^    ThreadFunction m_threadFunction;$/;"	m	class:WTF::ParallelEnvironment	access:private
m_threadHeaps	.\FastMalloc.cpp	/^    TCMalloc_ThreadCache** m_threadHeaps;$/;"	m	class:WTF::FastMallocZone	file:	access:private
m_threadID	.\ParallelJobsGeneric.h	/^        ThreadIdentifier m_threadID;$/;"	m	class:WTF::ParallelEnvironment::ThreadPrivate	access:private
m_threads	.\ParallelJobsGeneric.h	/^    Vector< RefPtr<ThreadPrivate> > m_threads;$/;"	m	class:WTF::ParallelEnvironment	access:private
m_totalBytes	.\SHA1.h	/^    uint64_t m_totalBytes; \/\/ Number of bytes added so far.$/;"	m	class:WTF::SHA1	access:private
m_tracker	.\MetaAllocator.h	/^    MetaAllocatorTracker* m_tracker;$/;"	m	class:WTF::MetaAllocator	access:private
m_type	.\FastMalloc.h	/^            AllocType m_type;$/;"	m	struct:WTF::Internal::ValidationHeader	access:public
m_typeMask	.\FastMalloc.cpp	/^    unsigned m_typeMask;$/;"	m	class:WTF::AdminRegionRecorder	file:	access:private
m_typeMask	.\FastMalloc.cpp	/^    unsigned m_typeMask;$/;"	m	class:WTF::PageMapMemoryUsageRecorder	file:	access:private
m_valid16BitShadowLength	.\text\StringBuilder.h	/^    mutable unsigned m_valid16BitShadowLength;$/;"	m	class:WTF::StringBuilder	access:private
m_value	.\CheckedArithmetic.h	/^    T m_value;$/;"	m	class:WTF::Checked	access:private
m_value	.\CheckedBoolean.h	/^    bool m_value;$/;"	m	class:CheckedBoolean	access:private
m_value	.\ListHashSet.h	/^        ValueArg m_value;$/;"	m	struct:WTF::ListHashSetNode	access:public
m_vector	.\SegmentedVector.h	/^        SegmentedVector<T, SegmentSize>& m_vector;$/;"	m	class:WTF::SegmentedVectorIterator	access:private
m_vector	.\text\CString.h	/^    Vector<char> m_vector;$/;"	m	class:WTF::CStringBuffer	access:private
m_verifier	.\RefCounted.h	/^    ThreadRestrictionVerifier m_verifier;$/;"	m	class:WTF::RefCountedBase	access:private
m_words	.\dtoa.cpp	/^    Vector<uint32_t, 16> m_words;$/;"	m	struct:WTF::BigInt	file:	access:public
m_writable	.\PageReservation.h	/^    bool m_writable;$/;"	m	class:WTF::PageReservation	access:private
m_zeroBasedValue	.\text\TextPosition.h	/^    int m_zeroBasedValue;$/;"	m	class:WTF::OrdinalNumber	access:private
m_zone	.\FastMalloc.cpp	/^    malloc_zone_t m_zone;$/;"	m	class:WTF::FastMallocZone	file:	access:private
machineWordAlignmentMask	.\text\ASCIIFastPath.h	/^const uintptr_t machineWordAlignmentMask = sizeof(MachineWord) - 1;$/;"	v
mainThreadFunctionQueueMutex	.\MainThread.cpp	/^static Mutex& mainThreadFunctionQueueMutex()$/;"	f	namespace:WTF	file:	signature:()
mainThreadIdentifier	.\MainThread.cpp	/^static ThreadIdentifier mainThreadIdentifier;$/;"	v	file:
mainThreadIdentifier	.\chromium\MainThreadChromium.cpp	/^static ThreadIdentifier mainThreadIdentifier;$/;"	v	file:
makeConstIterator	.\HashTable.h	/^        const_iterator makeConstIterator(ValueType* pos) const { return const_iterator(this, pos, m_table + m_tableSize); }$/;"	f	class:WTF::HashTable	access:private	signature:(ValueType* pos) const
makeConstIterator	.\ListHashSet.h	/^        const_iterator makeConstIterator(Node*) const;$/;"	p	class:WTF::ListHashSet	access:private	signature:(Node*) const
makeConstIterator	.\ListHashSet.h	/^    inline ListHashSetConstIterator<T, inlineCapacity, U> ListHashSet<T, inlineCapacity, U>::makeConstIterator(Node* position) const$/;"	f	class:WTF::ListHashSet	signature:(Node* position) const
makeConstReverseIterator	.\ListHashSet.h	/^        const_reverse_iterator makeConstReverseIterator(Node*) const;$/;"	p	class:WTF::ListHashSet	access:private	signature:(Node*) const
makeConstReverseIterator	.\ListHashSet.h	/^    inline ListHashSetConstReverseIterator<T, inlineCapacity, U> ListHashSet<T, inlineCapacity, U>::makeConstReverseIterator(Node* position) const$/;"	f	class:WTF::ListHashSet	signature:(Node* position) const
makeInlineBits	.\BitVector.h	/^    static uintptr_t makeInlineBits(uintptr_t bits)$/;"	f	class:WTF::BitVector	access:private	signature:(uintptr_t bits)
makeIterator	.\HashTable.h	/^        iterator makeIterator(ValueType* pos) { return iterator(this, pos, m_table + m_tableSize); }$/;"	f	class:WTF::HashTable	access:private	signature:(ValueType* pos)
makeIterator	.\ListHashSet.h	/^        iterator makeIterator(Node*);$/;"	p	class:WTF::ListHashSet	access:private	signature:(Node*)
makeIterator	.\ListHashSet.h	/^    inline ListHashSetIterator<T, inlineCapacity, U> ListHashSet<T, inlineCapacity, U>::makeIterator(Node* position) $/;"	f	class:WTF::ListHashSet	signature:(Node* position)
makeKnownGoodConstIterator	.\HashTable.h	/^        const_iterator makeKnownGoodConstIterator(ValueType* pos) const { return const_iterator(this, pos, m_table + m_tableSize, HashItemKnownGood); }$/;"	f	class:WTF::HashTable	access:private	signature:(ValueType* pos) const
makeKnownGoodIterator	.\HashTable.h	/^        iterator makeKnownGoodIterator(ValueType* pos) { return iterator(this, pos, m_table + m_tableSize, HashItemKnownGood); }$/;"	f	class:WTF::HashTable	access:private	signature:(ValueType* pos)
makeLookupResult	.\HashTable.h	/^        FullLookupType makeLookupResult(ValueType* position, bool found, unsigned hash)$/;"	f	class:WTF::HashTable	access:private	signature:(ValueType* position, bool found, unsigned hash)
makeLower	.\text\WTFString.h	/^    void makeLower() { if (m_impl) m_impl = m_impl->lower(); }$/;"	f	class:WTF::String	access:public	signature:()
makeRFC2822DateString	.\DateMath.cpp	/^String makeRFC2822DateString(unsigned dayOfWeek, unsigned day, unsigned month, unsigned year, unsigned hours, unsigned minutes, unsigned seconds, int utcOffset)$/;"	f	namespace:WTF	signature:(unsigned dayOfWeek, unsigned day, unsigned month, unsigned year, unsigned hours, unsigned minutes, unsigned seconds, int utcOffset)
makeRFC2822DateString	.\DateMath.h	/^String makeRFC2822DateString(unsigned dayOfWeek, unsigned day, unsigned month, unsigned year, unsigned hours, unsigned minutes, unsigned seconds, int utcOffset);$/;"	p	namespace:WTF	signature:(unsigned dayOfWeek, unsigned day, unsigned month, unsigned year, unsigned hours, unsigned minutes, unsigned seconds, int utcOffset)
makeReverseIterator	.\ListHashSet.h	/^        reverse_iterator makeReverseIterator(Node*);$/;"	p	class:WTF::ListHashSet	access:private	signature:(Node*)
makeReverseIterator	.\ListHashSet.h	/^    inline ListHashSetReverseIterator<T, inlineCapacity, U> ListHashSet<T, inlineCapacity, U>::makeReverseIterator(Node* position) $/;"	f	class:WTF::ListHashSet	signature:(Node* position)
makeString	.\text\StringConcatenate.h	/^String makeString(StringType1 string1)$/;"	f	namespace:WTF	signature:(StringType1 string1)
makeString	.\text\StringConcatenate.h	/^String makeString(StringType1 string1, StringType2 string2)$/;"	f	namespace:WTF	signature:(StringType1 string1, StringType2 string2)
makeString	.\text\StringConcatenate.h	/^String makeString(StringType1 string1, StringType2 string2, StringType3 string3)$/;"	f	namespace:WTF	signature:(StringType1 string1, StringType2 string2, StringType3 string3)
makeString	.\text\StringConcatenate.h	/^String makeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4)$/;"	f	namespace:WTF	signature:(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4)
makeString	.\text\StringConcatenate.h	/^String makeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5)$/;"	f	namespace:WTF	signature:(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5)
makeString	.\text\StringConcatenate.h	/^String makeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6)$/;"	f	namespace:WTF	signature:(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6)
makeString	.\text\StringConcatenate.h	/^String makeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6, StringType7 string7)$/;"	f	namespace:WTF	signature:(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6, StringType7 string7)
makeString	.\text\StringConcatenate.h	/^String makeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6, StringType7 string7, StringType8 string8)$/;"	f	namespace:WTF	signature:(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6, StringType7 string7, StringType8 string8)
makeString	.\text\StringConcatenate.h	/^String makeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6, StringType7 string7, StringType8 string8, StringType9 string9)$/;"	f	namespace:WTF	signature:(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6, StringType7 string7, StringType8 string8, StringType9 string9)
makeUpper	.\text\WTFString.h	/^    void makeUpper() { if (m_impl) m_impl = m_impl->upper(); }$/;"	f	class:WTF::String	access:public	signature:()
mallinfo	.\FastMalloc.cpp	/^extern "C" struct mallinfo mallinfo(void) {$/;"	f	namespace:WTF	signature:(void)
malloc	.\FastMalloc.cpp	/^ALWAYS_INLINE void* malloc(size_t);$/;"	p	namespace:WTF	file:	signature:(size_t)
malloc	.\FastMalloc.cpp	/^void* malloc(size_t size) {$/;"	f	namespace:WTF	signature:(size_t size)
malloc	.\FastMalloc.cpp	4657;"	d	file:
malloc	.\FastMalloc.cpp	498;"	d	file:
malloc	.\wince\FastMallocWinCE.h	52;"	d
malloc	.\wince\MemoryManager.cpp	23;"	d	file:
malloc_stats	.\FastMalloc.cpp	/^extern "C" void malloc_stats(void) {$/;"	f	namespace:WTF	signature:(void)
mallopt	.\FastMalloc.cpp	/^extern "C" int mallopt(int cmd, int value) {$/;"	f	namespace:WTF	signature:(int cmd, int value)
mask	.\Assertions.h	/^    unsigned mask;$/;"	m	struct:__anon2	access:public
mask	.\PackedIntVector.h	/^    static uintptr_t mask() { return (static_cast<uintptr_t>(2) << (bitCount - 1)) - 1; }$/;"	f	class:WTF::PackedIntVector	access:private	signature:()
max	.\Assertions.h	219;"	d
maxCollisions	.\HashTable.cpp	/^int HashTableStats::maxCollisions;$/;"	m	class:WTF::HashTableStats	file:
maxCollisions	.\HashTable.h	/^        static int maxCollisions;$/;"	m	struct:WTF::HashTableStats	access:public
maxECMAScriptTime	.\DateMath.cpp	/^static const double maxECMAScriptTime = 8.64E15;$/;"	v	file:
maxInlineBits	.\BitVector.h	/^    static unsigned maxInlineBits()$/;"	f	class:WTF::BitVector	access:private	signature:()
maxRunLoopSuspensionTime	.\MainThread.cpp	/^static const double maxRunLoopSuspensionTime = 0.05;$/;"	v	file:
maxUnixTime	.\DateMath.cpp	/^static const double maxUnixTime = 2145859200.0; \/\/ 12\/31\/2037$/;"	v	file:
max_leading_padding_zeroes_in_precision_mode_	.\dtoa\double-conversion.h	/^        const int max_leading_padding_zeroes_in_precision_mode_;$/;"	m	class:WTF::double_conversion::DoubleToStringConverter	access:private
max_trailing_padding_zeroes_in_precision_mode_	.\dtoa\double-conversion.h	/^        const int max_trailing_padding_zeroes_in_precision_mode_;$/;"	m	class:WTF::double_conversion::DoubleToStringConverter	access:private
maximumCount	.\BloomFilter.h	/^    static uint8_t maximumCount() { return std::numeric_limits<uint8_t>::max(); }$/;"	f	class:WTF::BloomFilter	access:public	signature:()
maximumYearForDST	.\DateMath.cpp	/^static inline int maximumYearForDST()$/;"	f	namespace:WTF	file:	signature:()
mayContain	.\BloomFilter.h	/^    bool mayContain(const AtomicString& string) const { return mayContain(string.impl()->existingHash()); }$/;"	f	class:WTF::BloomFilter	access:public	signature:(const AtomicString& string) const
mayContain	.\BloomFilter.h	/^    bool mayContain(const String& string) const { return mayContain(string.impl()->hash()); }$/;"	f	class:WTF::BloomFilter	access:public	signature:(const String& string) const
mayContain	.\BloomFilter.h	/^    bool mayContain(unsigned hash) const { return firstSlot(hash) && secondSlot(hash); }$/;"	f	class:WTF::BloomFilter	access:public	signature:(unsigned hash) const
mean	.\SimpleStats.h	/^    double mean() const$/;"	f	class:WTF::SimpleStats	access:public	signature:() const
memoryManager	.\wince\MemoryManager.cpp	/^MemoryManager* memoryManager()$/;"	f	namespace:WTF	signature:()
memoryManager	.\wince\MemoryManager.h	/^        friend MemoryManager* memoryManager();$/;"	p	class:WTF::MemoryManager	access:friend	signature:()
memoryManager	.\wince\MemoryManager.h	/^    MemoryManager* memoryManager();$/;"	p	namespace:WTF	signature:()
mergeDecommittedStates	.\FastMalloc.cpp	/^static ALWAYS_INLINE void mergeDecommittedStates(Span* destination, Span* other)$/;"	f	namespace:WTF	file:	signature:(Span* destination, Span* other)
metadata_bytes	.\FastMalloc.cpp	/^  uint64_t metadata_bytes;      \/\/ Bytes alloced for metadata$/;"	m	struct:WTF::TCMallocStats	file:	access:public
metadata_system_bytes	.\FastMalloc.cpp	/^static uint64_t metadata_system_bytes = 0;$/;"	v	file:
min	.\Assertions.h	218;"	d
min_free_committed_pages_since_last_scavenge_	.\FastMalloc.cpp	/^  Length min_free_committed_pages_since_last_scavenge_;$/;"	m	class:WTF::TCMalloc_PageHeap	file:	access:private
minimumCapacity	.\text\StringBuilder.cpp	/^static const unsigned minimumCapacity = 16;$/;"	v	file:
minimumPosition	.\text\TextPosition.h	/^    static TextPosition minimumPosition() { return TextPosition(OrdinalNumber::first(), OrdinalNumber::first()); }$/;"	f	class:WTF::TextPosition	access:public	signature:()
minimumTableSize	.\HashTraits.h	/^        static const int minimumTableSize = 64;$/;"	m	struct:WTF::GenericHashTraitsBase	access:public
minimumTableSize	.\HashTraits.h	/^        static const int minimumTableSize = FirstTraits::minimumTableSize;$/;"	m	struct:WTF::PairHashTraits	access:public
minimumYearForDST	.\DateMath.cpp	/^static inline int minimumYearForDST()$/;"	f	namespace:WTF	file:	signature:()
minusSign	.\unicode\CharacterNames.h	/^const UChar minusSign = 0x2212;$/;"	v
minutesPerDay	.\DateMath.cpp	/^static const double minutesPerDay = 24.0 * 60.0;$/;"	v	file:
minutesPerHour	.\DateMath.h	/^const double minutesPerHour = 60.0;$/;"	v
mirrorDiff	.\unicode\qt4\UnicodeQt4.h	/^        signed short mirrorDiff : 16;$/;"	m	struct:QUnicodeTables::Properties	access:public
mirroredChar	.\unicode\glib\UnicodeGLib.h	/^inline UChar32 mirroredChar(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
mirroredChar	.\unicode\icu\UnicodeIcu.h	/^inline UChar32 mirroredChar(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
mirroredChar	.\unicode\qt4\UnicodeQt4.h	/^inline UChar32 mirroredChar(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
mirroredChar	.\unicode\wince\UnicodeWinCE.cpp	/^UChar mirroredChar(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
mirroredChar	.\unicode\wince\UnicodeWinCE.h	/^UChar mirroredChar(UChar32);$/;"	p	namespace:WTF::Unicode	signature:(UChar32)
mmap_failure	.\TCSystemAlloc.cpp	/^static bool mmap_failure = false;$/;"	v	file:
module_enter_exit_hook	.\FastMalloc.cpp	/^static TCMallocGuard module_enter_exit_hook;$/;"	v	file:
monitorDispatchFunctions	.\efl\MainThreadEfl.cpp	/^static void monitorDispatchFunctions(void*, void*, unsigned int)$/;"	f	namespace:WTF	file:	signature:(void*, void*, unsigned int)
monotonicallyIncreasingTime	.\CurrentTime.cpp	/^double monotonicallyIncreasingTime()$/;"	f	namespace:WTF	signature:()
monotonicallyIncreasingTime	.\CurrentTime.h	/^WTF_EXPORT_PRIVATE double monotonicallyIncreasingTime();$/;"	p	namespace:WTF	signature:()
monthFromDayInYear	.\DateMath.cpp	/^int monthFromDayInYear(int dayInYear, bool leapYear)$/;"	f	namespace:WTF	signature:(int dayInYear, bool leapYear)
monthFromDayInYear	.\DateMath.h	/^WTF_EXPORT_PRIVATE int monthFromDayInYear(int dayInYear, bool leapYear);$/;"	p	namespace:WTF	signature:(int dayInYear, bool leapYear)
monthName	.\DateMath.h	/^const char* const monthName[12] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };$/;"	v
monthToDayInYear	.\DateMath.cpp	/^static inline int monthToDayInYear(int month, bool isLeapYear)$/;"	f	namespace:WTF	file:	signature:(int month, bool isLeapYear)
move	.\HashTable.h	/^    template<typename T> struct Mover<T, false> { static void move(T& from, T& to) { to = from; } };$/;"	f	struct:WTF::Mover	access:public	signature:(T& from, T& to)
move	.\HashTable.h	/^    template<typename T> struct Mover<T, true> { static void move(T& from, T& to) { hashTableSwap(from, to); } };$/;"	f	struct:WTF::Mover	access:public	signature:(T& from, T& to)
move	.\Vector.h	/^        static void move(const T* src, const T* srcEnd, T* dst) $/;"	f	struct:WTF::VectorMover	access:public	signature:(const T* src, const T* srcEnd, T* dst)
move	.\Vector.h	/^        static void move(const T* src, const T* srcEnd, T* dst)$/;"	f	struct:WTF::VectorMover	access:public	signature:(const T* src, const T* srcEnd, T* dst)
move	.\Vector.h	/^        static void move(const T* src, const T* srcEnd, T* dst)$/;"	f	struct:WTF::VectorTypeOperations	access:public	signature:(const T* src, const T* srcEnd, T* dst)
moveOverlapping	.\Vector.h	/^        static void moveOverlapping(const T* src, const T* srcEnd, T* dst) $/;"	f	struct:WTF::VectorMover	access:public	signature:(const T* src, const T* srcEnd, T* dst)
moveOverlapping	.\Vector.h	/^        static void moveOverlapping(const T* src, const T* srcEnd, T* dst)$/;"	f	struct:WTF::VectorMover	access:public	signature:(const T* src, const T* srcEnd, T* dst)
moveOverlapping	.\Vector.h	/^        static void moveOverlapping(const T* src, const T* srcEnd, T* dst)$/;"	f	struct:WTF::VectorTypeOperations	access:public	signature:(const T* src, const T* srcEnd, T* dst)
msPerDay	.\DateMath.h	/^const double msPerDay = 24.0 * 60.0 * 60.0 * 1000.0;$/;"	v
msPerHour	.\DateMath.h	/^const double msPerHour = 60.0 * 60.0 * 1000.0;$/;"	v
msPerMinute	.\DateMath.h	/^const double msPerMinute = 60.0 * 1000.0;$/;"	v
msPerMonth	.\DateMath.h	/^const double msPerMonth = 2592000000.0;$/;"	v
msPerSecond	.\CurrentTime.cpp	/^const double msPerSecond = 1000.0;$/;"	v
msPerSecond	.\DateMath.h	/^const double msPerSecond = 1000.0;$/;"	v
msToDays	.\DateMath.cpp	/^double msToDays(double ms)$/;"	f	namespace:WTF	signature:(double ms)
msToDays	.\DateMath.h	/^double msToDays(double ms);$/;"	p	namespace:WTF	signature:(double ms)
msToHours	.\DateMath.cpp	/^int msToHours(double ms)$/;"	f	namespace:WTF	signature:(double ms)
msToHours	.\DateMath.h	/^int msToHours(double ms);$/;"	p	namespace:WTF	signature:(double ms)
msToMilliseconds	.\DateMath.cpp	/^static inline double msToMilliseconds(double ms)$/;"	f	namespace:WTF	file:	signature:(double ms)
msToMinutes	.\DateMath.cpp	/^int msToMinutes(double ms)$/;"	f	namespace:WTF	signature:(double ms)
msToMinutes	.\DateMath.h	/^int msToMinutes(double ms);$/;"	p	namespace:WTF	signature:(double ms)
msToYear	.\DateMath.cpp	/^int msToYear(double ms)$/;"	f	namespace:WTF	signature:(double ms)
msToYear	.\DateMath.h	/^WTF_EXPORT_PRIVATE int msToYear(double ms);$/;"	p	namespace:WTF	signature:(double ms)
mult	.\dtoa.cpp	/^static void mult(BigInt& aRef, const BigInt& bRef)$/;"	f	namespace:WTF	file:	signature:(BigInt& aRef, const BigInt& bRef)
multadd	.\dtoa.cpp	/^static void multadd(BigInt& b, int m, int a)    \/* multiply by m and add a *\/$/;"	f	namespace:WTF	file:	signature:(BigInt& b, int m, int a)
multiply	.\CheckedArithmetic.h	/^    static inline bool multiply(int64_t lhs, int64_t rhs, ResultType& result)$/;"	f	struct:WTF::ArithmeticOperations	access:public	signature:(int64_t lhs, int64_t rhs, ResultType& result)
mustRehashInPlace	.\HashTable.h	/^        bool mustRehashInPlace() const { return m_keyCount * m_minLoad < m_tableSize * 2; }$/;"	f	class:WTF::HashTable	access:private	signature:() const
mutableData	.\text\CString.cpp	/^char* CString::mutableData()$/;"	f	class:WTF::CString	signature:()
mutableData	.\text\CString.h	/^    WTF_EXPORT_PRIVATE char* mutableData();$/;"	p	class:WTF::CString	access:public	signature:()
mutableData	.\text\CString.h	/^    char* mutableData() { return m_vector.data(); }$/;"	f	class:WTF::CStringBuffer	access:private	signature:()
n_bigtens	.\dtoa.cpp	649;"	d	file:
name	.\Threading.cpp	/^    const char* name;$/;"	m	struct:WTF::NewThreadContext	file:	access:public
nan_symbol_	.\dtoa\double-conversion.h	/^        const char* const nan_symbol_;$/;"	m	class:WTF::double_conversion::DoubleToStringConverter	access:private
nan_symbol_	.\dtoa\double-conversion.h	/^        const char* const nan_symbol_;$/;"	m	class:WTF::double_conversion::StringToDoubleConverter	access:private
needsDestruction	.\HashTraits.h	/^        static const bool needsDestruction = FirstTraits::needsDestruction || SecondTraits::needsDestruction;$/;"	m	struct:WTF::PairHashTraits	access:public
needsDestruction	.\HashTraits.h	/^        static const bool needsDestruction = false;$/;"	m	struct:WTF::FloatHashTraits	access:public
needsDestruction	.\HashTraits.h	/^        static const bool needsDestruction = false;$/;"	m	struct:WTF::GenericHashTraitsBase	access:public
needsDestruction	.\HashTraits.h	/^        static const bool needsDestruction = false;$/;"	m	struct:WTF::HashTraits	access:public
needsDestruction	.\HashTraits.h	/^        static const bool needsDestruction = false;$/;"	m	struct:WTF::UnsignedWithZeroKeyHashTraits	access:public
needsDestruction	.\HashTraits.h	/^        static const bool needsDestruction = true;$/;"	m	struct:WTF::GenericHashTraitsBase	access:public
needsDestruction	.\VectorTraits.h	/^        static const bool needsDestruction = FirstTraits::needsDestruction || SecondTraits::needsDestruction;$/;"	m	struct:WTF::VectorTraits	access:public
needsDestruction	.\VectorTraits.h	/^        static const bool needsDestruction = false;$/;"	m	struct:WTF::VectorTraitsBase	access:public
needsDestruction	.\VectorTraits.h	/^        static const bool needsDestruction = true;$/;"	m	struct:WTF::VectorTraitsBase	access:public
needsInitialization	.\VectorTraits.h	/^        static const bool needsInitialization = FirstTraits::needsInitialization || SecondTraits::needsInitialization;$/;"	m	struct:WTF::VectorTraits	access:public
needsInitialization	.\VectorTraits.h	/^        static const bool needsInitialization = false;$/;"	m	struct:WTF::VectorTraitsBase	access:public
needsInitialization	.\VectorTraits.h	/^        static const bool needsInitialization = true;$/;"	m	struct:WTF::VectorTraitsBase	access:public
neuter	.\ArrayBufferView.cpp	/^void ArrayBufferView::neuter()$/;"	f	class:WTF::ArrayBufferView	signature:()
neuter	.\ArrayBufferView.h	/^    WTF_EXPORT_PRIVATE virtual void neuter();$/;"	p	class:WTF::ArrayBufferView	access:protected	signature:()
neuter	.\TypedArrayBase.h	/^    virtual void neuter()$/;"	f	class:WTF::TypedArrayBase	access:protected	signature:()
newUninitialized	.\text\CString.cpp	/^CString CString::newUninitialized(size_t length, char*& characterBuffer)$/;"	f	class:WTF::CString	signature:(size_t length, char*& characterBuffer)
newUninitialized	.\text\CString.h	/^    WTF_EXPORT_PRIVATE static CString newUninitialized(size_t length, char*& characterBuffer);$/;"	p	class:WTF::CString	access:public	signature:(size_t length, char*& characterBuffer)
newlineCharacter	.\unicode\CharacterNames.h	/^const UChar newlineCharacter = 0x000A;$/;"	v
next	.\DoublyLinkedList.h	/^    T* next() const;$/;"	p	class:WTF::DoublyLinkedListNode	access:public	signature:() const
next	.\DoublyLinkedList.h	/^template<typename T> inline T* DoublyLinkedListNode<T>::next() const$/;"	f	class:WTF::DoublyLinkedListNode	signature:() const
next	.\FastMalloc.cpp	/^  Span*         next;           \/\/ Used when in link list$/;"	m	struct:WTF::Span	file:	access:public
next	.\SentinelLinkedList.h	/^    T* next() { return static_cast<T*>(m_next); }$/;"	f	class:WTF::BasicRawSentinelNode	access:public	signature:()
next	.\dtoa.cpp	/^    P5Node* next;$/;"	m	struct:WTF::P5Node	file:	access:public
nextAuthorityTerminator	.\url\src\URLParser.h	/^    static int nextAuthorityTerminator(const CharacterType* spec, int startOffset, int specLength)$/;"	f	class:WTF::URLParser	access:private	signature:(const CharacterType* spec, int startOffset, int specLength)
nextEntryInLinkedList	.\MallocZoneSupport.h	/^    T* nextEntryInLinkedList(T** address) const$/;"	f	class:WTF::RemoteMemoryReader	access:public	signature:(T** address) const
nextPossiblyUnset	.\Bitmap.h	/^    size_t nextPossiblyUnset(size_t) const;$/;"	p	class:WTF::Bitmap	access:public	signature:(size_t) const
nextPossiblyUnset	.\Bitmap.h	/^inline size_t Bitmap<size, atomicMode>::nextPossiblyUnset(size_t start) const$/;"	f	class:WTF::Bitmap	signature:(size_t start) const
next_	.\FastMalloc.cpp	/^  TCMalloc_ThreadCache* next_;$/;"	m	class:WTF::TCMalloc_ThreadCache	file:	access:public
nextafter	.\MathExtras.h	/^inline double nextafter(double x, double y) { return _nextafter(x, y); }$/;"	f	signature:(double x, double y)
nextafterf	.\MathExtras.h	/^inline float nextafterf(float x, float y) { return x > y ? x - FLT_EPSILON : x + FLT_EPSILON; }$/;"	f	signature:(float x, float y)
nexthistory	.\FastMalloc.cpp	/^  int nexthistory;$/;"	m	struct:WTF::Span	file:	access:public
noBreakSpace	.\unicode\CharacterNames.h	/^const UChar noBreakSpace = 0x00A0;$/;"	v
node	.\ListHashSet.h	/^        Node* node() { return m_iterator.node(); }$/;"	f	class:WTF::ListHashSetIterator	access:private	signature:()
node	.\ListHashSet.h	/^        Node* node() { return m_iterator.node(); }$/;"	f	class:WTF::ListHashSetReverseIterator	access:private	signature:()
node	.\ListHashSet.h	/^        Node* node() { return m_position; }$/;"	f	class:WTF::ListHashSetConstIterator	access:private	signature:()
node	.\ListHashSet.h	/^        Node* node() { return m_position; }$/;"	f	class:WTF::ListHashSetConstReverseIterator	access:private	signature:()
nonCopyingSort	.\NonCopyingSort.h	/^inline void nonCopyingSort(RandomAccessIterator start, RandomAccessIterator end, Predicate compareLess)$/;"	f	namespace:WTF	signature:(RandomAccessIterator start, RandomAccessIterator end, Predicate compareLess)
nonempty_	.\FastMalloc.cpp	/^  Span     nonempty_;       \/\/ Dummy header for list of non-empty spans$/;"	m	class:WTF::TCMalloc_Central_FreeList	file:	access:private
normal	.\FastMalloc.cpp	/^    Span        normal;$/;"	m	struct:WTF::TCMalloc_PageHeap::SpanList	file:	access:public
notFound	.\NotFound.h	/^    const size_t notFound = static_cast<size_t>(-1);$/;"	v
notify	.\MetaAllocator.cpp	/^void MetaAllocatorTracker::notify(MetaAllocatorHandle* handle)$/;"	f	class:WTF::MetaAllocatorTracker	signature:(MetaAllocatorHandle* handle)
notify	.\MetaAllocator.h	/^    void notify(MetaAllocatorHandle*);$/;"	p	class:WTF::MetaAllocatorTracker	access:public	signature:(MetaAllocatorHandle*)
notifyNeedPage	.\MetaAllocator.h	/^    virtual void notifyNeedPage(void* page) = 0;$/;"	p	class:WTF::MetaAllocator	access:protected	signature:(void* page)
notifyPageIsFree	.\MetaAllocator.h	/^    virtual void notifyPageIsFree(void* page) = 0;$/;"	p	class:WTF::MetaAllocator	access:protected	signature:(void* page)
nsStringNilIfEmpty	.\text\WTFString.h	/^inline NSString* nsStringNilIfEmpty(const String& str) {  return str.isEmpty() ? nil : (NSString*)str; }$/;"	f	namespace:WTF	signature:(const String& str)
null	.\AVLTree.h	/^        handle null() { return tree_->abs.null(); }$/;"	f	class:WTF::AVLTree::Iterator	access:protected	signature:()
null	.\AVLTree.h	/^    handle null() { return abs.null(); }$/;"	f	class:WTF::AVLTree	access:protected	signature:()
nullptr	.\NullPtr.cpp	/^std::nullptr_t nullptr;$/;"	v
nullptr_t	.\NullPtr.h	/^    class nullptr_t { };$/;"	c	namespace:std
numAccesses	.\HashTable.cpp	/^int HashTableStats::numAccesses;$/;"	m	class:WTF::HashTableStats	file:
numAccesses	.\HashTable.h	/^        static int numAccesses;$/;"	m	struct:WTF::HashTableStats	access:public
numBits	.\BitVector.h	/^        size_t numBits() const { return m_numBits; }$/;"	f	class:WTF::BitVector::OutOfLineBits	access:public	signature:() const
numCollisions	.\HashTable.cpp	/^int HashTableStats::numCollisions;$/;"	m	class:WTF::HashTableStats	file:
numCollisions	.\HashTable.h	/^        static int numCollisions;$/;"	m	struct:WTF::HashTableStats	access:public
numRehashes	.\HashTable.cpp	/^int HashTableStats::numRehashes;$/;"	m	class:WTF::HashTableStats	file:
numRehashes	.\HashTable.h	/^        static int numRehashes;$/;"	m	struct:WTF::HashTableStats	access:public
numReinserts	.\HashTable.cpp	/^int HashTableStats::numReinserts;$/;"	m	class:WTF::HashTableStats	file:
numReinserts	.\HashTable.h	/^        static int numReinserts;$/;"	m	struct:WTF::HashTableStats	access:public
numRemoves	.\HashTable.cpp	/^int HashTableStats::numRemoves;$/;"	m	class:WTF::HashTableStats	file:
numRemoves	.\HashTable.h	/^        static int numRemoves;$/;"	m	struct:WTF::HashTableStats	access:public
numWords	.\BitVector.h	/^        size_t numWords() const { return (m_numBits + bitsInPointer() - 1) \/ bitsInPointer(); }$/;"	f	class:WTF::BitVector::OutOfLineBits	access:public	signature:() const
num_objects_to_move	.\FastMalloc.cpp	/^static int num_objects_to_move[kNumClasses];$/;"	v	file:
number	.\text\WTFString.cpp	/^String String::number(double number, unsigned flags, unsigned precision)$/;"	f	class:WTF::String	signature:(double number, unsigned flags, unsigned precision)
number	.\text\WTFString.cpp	/^String String::number(int n)$/;"	f	class:WTF::String	signature:(int n)
number	.\text\WTFString.cpp	/^String String::number(long long n)$/;"	f	class:WTF::String	signature:(long long n)
number	.\text\WTFString.cpp	/^String String::number(long n)$/;"	f	class:WTF::String	signature:(long n)
number	.\text\WTFString.cpp	/^String String::number(short n)$/;"	f	class:WTF::String	signature:(short n)
number	.\text\WTFString.cpp	/^String String::number(unsigned long long n)$/;"	f	class:WTF::String	signature:(unsigned long long n)
number	.\text\WTFString.cpp	/^String String::number(unsigned long n)$/;"	f	class:WTF::String	signature:(unsigned long n)
number	.\text\WTFString.cpp	/^String String::number(unsigned n)$/;"	f	class:WTF::String	signature:(unsigned n)
number	.\text\WTFString.cpp	/^String String::number(unsigned short n)$/;"	f	class:WTF::String	signature:(unsigned short n)
number	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE static String number(double, unsigned = ShouldRoundSignificantFigures | ShouldTruncateTrailingZeros, unsigned precision = 6);$/;"	p	class:WTF::String	access:public	signature:(double, unsigned = ShouldRoundSignificantFigures | ShouldTruncateTrailingZeros, unsigned precision = 6)
number	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE static String number(int);$/;"	p	class:WTF::String	access:public	signature:(int)
number	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE static String number(long long);$/;"	p	class:WTF::String	access:public	signature:(long long)
number	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE static String number(long);$/;"	p	class:WTF::String	access:public	signature:(long)
number	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE static String number(unsigned long long);$/;"	p	class:WTF::String	access:public	signature:(unsigned long long)
number	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE static String number(unsigned long);$/;"	p	class:WTF::String	access:public	signature:(unsigned long)
number	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE static String number(unsigned short);$/;"	p	class:WTF::String	access:public	signature:(unsigned short)
number	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE static String number(unsigned);$/;"	p	class:WTF::String	access:public	signature:(unsigned)
number	.\text\WTFString.h	/^    static String number(short);$/;"	p	class:WTF::String	access:public	signature:(short)
numberOfJobs	.\ParallelJobs.h	/^    size_t numberOfJobs()$/;"	f	class:WTF::ParallelJobs	access:public	signature:()
numberOfJobs	.\ParallelJobsGeneric.h	/^    int numberOfJobs()$/;"	f	class:WTF::ParallelEnvironment	access:public	signature:()
numberOfJobs	.\ParallelJobsLibdispatch.h	/^    int numberOfJobs()$/;"	f	class:WTF::ParallelEnvironment	access:public	signature:()
numberOfJobs	.\ParallelJobsOpenMP.h	/^    int numberOfJobs()$/;"	f	class:WTF::ParallelEnvironment	access:public	signature:()
numberOfProcessorCores	.\NumberOfCores.cpp	/^int numberOfProcessorCores()$/;"	f	namespace:WTF	signature:()
numberOfProcessorCores	.\NumberOfCores.h	/^int numberOfProcessorCores();$/;"	p	namespace:WTF	signature:()
numberToFixedPrecisionString	.\dtoa.cpp	/^const char* numberToFixedPrecisionString(double d, unsigned significantFigures, NumberToStringBuffer buffer, bool truncateTrailingZeros)$/;"	f	namespace:WTF	signature:(double d, unsigned significantFigures, NumberToStringBuffer buffer, bool truncateTrailingZeros)
numberToFixedPrecisionString	.\dtoa.h	/^const char* numberToFixedPrecisionString(double, unsigned significantFigures, NumberToStringBuffer, bool truncateTrailingZeros = false);$/;"	p	namespace:WTF	signature:(double, unsigned significantFigures, NumberToStringBuffer, bool truncateTrailingZeros = false)
numberToFixedWidthString	.\dtoa.cpp	/^const char* numberToFixedWidthString(double d, unsigned decimalPlaces, NumberToStringBuffer buffer)$/;"	f	namespace:WTF	signature:(double d, unsigned decimalPlaces, NumberToStringBuffer buffer)
numberToFixedWidthString	.\dtoa.h	/^const char* numberToFixedWidthString(double, unsigned decimalPlaces, NumberToStringBuffer);$/;"	p	namespace:WTF	signature:(double, unsigned decimalPlaces, NumberToStringBuffer)
numberToString	.\dtoa.cpp	/^const char* numberToString(double d, NumberToStringBuffer buffer)$/;"	f	namespace:WTF	signature:(double d, NumberToStringBuffer buffer)
numberToString	.\dtoa.h	/^WTF_EXPORT_PRIVATE const char* numberToString(double, NumberToStringBuffer);$/;"	p	namespace:WTF	signature:(double, NumberToStringBuffer)
objectReplacementCharacter	.\unicode\CharacterNames.h	/^const UChar objectReplacementCharacter = 0xFFFC;$/;"	v
objects	.\FastMalloc.cpp	/^  void*         objects;        \/\/ Linked list of free objects$/;"	m	struct:WTF::Span	file:	access:public
offsetOfData	.\ByteArray.h	/^        static size_t offsetOfData() { return OBJECT_OFFSETOF(ByteArray, m_data); }$/;"	f	class:WTF::ByteArray	access:public	signature:()
offsetOfSize	.\ByteArray.h	/^        static size_t offsetOfSize() { return OBJECT_OFFSETOF(ByteArray, m_size); }$/;"	f	class:WTF::ByteArray	access:public	signature:()
offsetsFromUTF8	.\unicode\UTF8.cpp	/^static const UChar32 offsetsFromUTF8[6] = { 0x00000000UL, 0x00003080UL, 0x000E2080UL, $/;"	v	file:
onIdle	.\wince\MemoryManager.cpp	/^bool MemoryManager::onIdle(DWORD& timeLimitMs)$/;"	f	class:WTF::MemoryManager	signature:(DWORD& timeLimitMs)
onIdle	.\wince\MemoryManager.h	/^        static bool onIdle(DWORD& timeLimitMs);$/;"	p	class:WTF::MemoryManager	access:public	signature:(DWORD& timeLimitMs)
one	.\Bitmap.h	/^    static const WordType one = 1;$/;"	m	class:WTF::Bitmap	access:private
oneBasedInt	.\text\TextPosition.h	/^    int oneBasedInt() const { return m_zeroBasedValue + 1; }$/;"	f	class:WTF::OrdinalNumber	access:public	signature:() const
operator !	.\BoundsCheckedPointer.h	/^    BoundsCheckedPointer operator!()$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:()
operator !	.\CheckedArithmetic.h	/^    bool operator!() const$/;"	f	class:WTF::Checked	access:public	signature:() const
operator !	.\OwnArrayPtr.h	/^    bool operator!() const { return !m_ptr; }$/;"	f	class:WTF::OwnArrayPtr	access:public	signature:() const
operator !	.\OwnPtr.h	/^        bool operator!() const { return !m_ptr; }$/;"	f	class:WTF::OwnPtr	access:public	signature:() const
operator !	.\PassOwnArrayPtr.h	/^    bool operator!() const { return !m_ptr; }$/;"	f	class:WTF::PassOwnArrayPtr	access:public	signature:() const
operator !	.\PassOwnPtr.h	/^        bool operator!() const { return !m_ptr; }$/;"	f	class:WTF::PassOwnPtr	access:public	signature:() const
operator !	.\PassRefPtr.h	/^        bool operator!() const { return !m_ptr; }$/;"	f	class:WTF::PassRefPtr	access:public	signature:() const
operator !	.\RefPtr.h	/^        bool operator!() const { return !m_ptr; }$/;"	f	class:WTF::RefPtr	access:public	signature:() const
operator !	.\RetainPtr.h	/^        bool operator!() const { return !m_ptr; }$/;"	f	class:WTF::RetainPtr	access:public	signature:() const
operator !	.\SimpleStats.h	/^    bool operator!() const$/;"	f	class:WTF::SimpleStats	access:public	signature:() const
operator !	.\gobject\GOwnPtr.h	/^    bool operator!() const { return !m_ptr; }$/;"	f	class:WTF::GOwnPtr	access:public	signature:() const
operator !	.\gobject\GRefPtr.h	/^    bool operator!() const { return !m_ptr; }$/;"	f	class:WTF::GRefPtr	access:public	signature:() const
operator !	.\text\WTFString.h	/^inline bool operator!(const String& str) { return str.isNull(); }$/;"	f	namespace:WTF	signature:(const String& str)
operator !=	.\BoundsCheckedPointer.h	/^    bool operator!=(BoundsCheckedPointer other) const$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(BoundsCheckedPointer other) const
operator !=	.\BoundsCheckedPointer.h	/^    bool operator!=(T* other) const$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(T* other) const
operator !=	.\CheckedArithmetic.h	/^    template <typename U> bool operator!=(U rhs)$/;"	f	class:WTF::Checked	access:public	signature:(U rhs)
operator !=	.\Deque.h	/^        bool operator!=(const Iterator& other) const { return !Base::isEqual(other); }$/;"	f	class:WTF::DequeConstIterator	access:public	signature:(const Iterator& other) const
operator !=	.\Deque.h	/^        bool operator!=(const Iterator& other) const { return !Base::isEqual(other); }$/;"	f	class:WTF::DequeConstReverseIterator	access:public	signature:(const Iterator& other) const
operator !=	.\Deque.h	/^        bool operator!=(const Iterator& other) const { return !Base::isEqual(other); }$/;"	f	class:WTF::DequeIterator	access:public	signature:(const Iterator& other) const
operator !=	.\Deque.h	/^        bool operator!=(const Iterator& other) const { return !Base::isEqual(other); }$/;"	f	class:WTF::DequeReverseIterator	access:public	signature:(const Iterator& other) const
operator !=	.\HashIterators.h	/^        inline bool operator!=(const HashTableConstKeysIterator<T, U, V>& a, const HashTableConstKeysIterator<T, U, V>& b)$/;"	f	namespace:WTF	signature:(const HashTableConstKeysIterator<T, U, V>& a, const HashTableConstKeysIterator<T, U, V>& b)
operator !=	.\HashIterators.h	/^        inline bool operator!=(const HashTableConstValuesIterator<T, U, V>& a, const HashTableConstValuesIterator<T, U, V>& b)$/;"	f	namespace:WTF	signature:(const HashTableConstValuesIterator<T, U, V>& a, const HashTableConstValuesIterator<T, U, V>& b)
operator !=	.\HashIterators.h	/^        inline bool operator!=(const HashTableKeysIterator<T, U, V>& a, const HashTableKeysIterator<T, U, V>& b)$/;"	f	namespace:WTF	signature:(const HashTableKeysIterator<T, U, V>& a, const HashTableKeysIterator<T, U, V>& b)
operator !=	.\HashIterators.h	/^        inline bool operator!=(const HashTableValuesIterator<T, U, V>& a, const HashTableValuesIterator<T, U, V>& b)$/;"	f	namespace:WTF	signature:(const HashTableValuesIterator<T, U, V>& a, const HashTableValuesIterator<T, U, V>& b)
operator !=	.\HashMap.h	/^    inline bool operator!=(const HashMap<T, U, V, W, X>& a, const HashMap<T, U, V, W, X>& b)$/;"	f	namespace:WTF	signature:(const HashMap<T, U, V, W, X>& a, const HashMap<T, U, V, W, X>& b)
operator !=	.\HashTable.h	/^        bool operator!=(const const_iterator& other) const { return m_iterator != other; }$/;"	f	class:WTF::HashTableIterator	access:public	signature:(const const_iterator& other) const
operator !=	.\HashTable.h	/^        bool operator!=(const const_iterator& other) const$/;"	f	class:WTF::HashTableConstIterator	access:public	signature:(const const_iterator& other) const
operator !=	.\HashTable.h	/^        bool operator!=(const iterator& other) const { return m_iterator != other.m_iterator; }$/;"	f	class:WTF::HashTableIterator	access:public	signature:(const iterator& other) const
operator !=	.\HashTable.h	/^        bool operator!=(const iterator& other) const$/;"	f	class:WTF::HashTableConstIterator	access:public	signature:(const iterator& other) const
operator !=	.\HashTable.h	/^    inline bool operator!=(const HashTableConstIteratorAdapter<T, U>& a, const HashTableConstIteratorAdapter<T, U>& b)$/;"	f	namespace:WTF	signature:(const HashTableConstIteratorAdapter<T, U>& a, const HashTableConstIteratorAdapter<T, U>& b)
operator !=	.\HashTable.h	/^    inline bool operator!=(const HashTableConstIteratorAdapter<T, U>& a, const HashTableIteratorAdapter<T, U>& b)$/;"	f	namespace:WTF	signature:(const HashTableConstIteratorAdapter<T, U>& a, const HashTableIteratorAdapter<T, U>& b)
operator !=	.\HashTable.h	/^    inline bool operator!=(const HashTableIteratorAdapter<T, U>& a, const HashTableConstIteratorAdapter<T, U>& b)$/;"	f	namespace:WTF	signature:(const HashTableIteratorAdapter<T, U>& a, const HashTableConstIteratorAdapter<T, U>& b)
operator !=	.\HashTable.h	/^    inline bool operator!=(const HashTableIteratorAdapter<T, U>& a, const HashTableIteratorAdapter<T, U>& b)$/;"	f	namespace:WTF	signature:(const HashTableIteratorAdapter<T, U>& a, const HashTableIteratorAdapter<T, U>& b)
operator !=	.\ListHashSet.h	/^        bool operator!=(const const_iterator& other) const$/;"	f	class:WTF::ListHashSetConstIterator	access:public	signature:(const const_iterator& other) const
operator !=	.\ListHashSet.h	/^        bool operator!=(const const_reverse_iterator& other) const$/;"	f	class:WTF::ListHashSetConstReverseIterator	access:public	signature:(const const_reverse_iterator& other) const
operator !=	.\ListHashSet.h	/^        bool operator!=(const iterator& other) const { return m_iterator != other.m_iterator; }$/;"	f	class:WTF::ListHashSetIterator	access:public	signature:(const iterator& other) const
operator !=	.\ListHashSet.h	/^        bool operator!=(const reverse_iterator& other) const { return m_iterator != other.m_iterator; }$/;"	f	class:WTF::ListHashSetReverseIterator	access:public	signature:(const reverse_iterator& other) const
operator !=	.\OwnArrayPtr.h	/^template<typename T, typename U> inline bool operator!=(T* a, const OwnArrayPtr<U>& b)$/;"	f	namespace:WTF	signature:(T* a, const OwnArrayPtr<U>& b)
operator !=	.\OwnArrayPtr.h	/^template<typename T, typename U> inline bool operator!=(const OwnArrayPtr<T>& a, U* b)$/;"	f	namespace:WTF	signature:(const OwnArrayPtr<T>& a, U* b)
operator !=	.\OwnPtr.h	/^        template<typename U> bool operator!=(const OwnPtr<U>&) { COMPILE_ASSERT(!sizeof(U*), OwnPtrs_should_never_be_equal); return false; }$/;"	f	class:WTF::OwnPtr	access:private	signature:(const OwnPtr<U>&)
operator !=	.\OwnPtr.h	/^        template<typename U> bool operator!=(const PassOwnPtr<U>&) { COMPILE_ASSERT(!sizeof(U*), OwnPtrs_should_never_be_equal); return false; }$/;"	f	class:WTF::OwnPtr	access:private	signature:(const PassOwnPtr<U>&)
operator !=	.\OwnPtr.h	/^    template<typename T, typename U> inline bool operator!=(T* a, const OwnPtr<U>& b)$/;"	f	namespace:WTF	signature:(T* a, const OwnPtr<U>& b)
operator !=	.\OwnPtr.h	/^    template<typename T, typename U> inline bool operator!=(const OwnPtr<T>& a, U* b)$/;"	f	namespace:WTF	signature:(const OwnPtr<T>& a, U* b)
operator !=	.\PassOwnArrayPtr.h	/^template<typename T, typename U> inline bool operator!=(T* a, const PassOwnArrayPtr<U>& b) $/;"	f	namespace:WTF	signature:(T* a, const PassOwnArrayPtr<U>& b)
operator !=	.\PassOwnArrayPtr.h	/^template<typename T, typename U> inline bool operator!=(const OwnArrayPtr<T>& a, const PassOwnArrayPtr<U>& b) $/;"	f	namespace:WTF	signature:(const OwnArrayPtr<T>& a, const PassOwnArrayPtr<U>& b)
operator !=	.\PassOwnArrayPtr.h	/^template<typename T, typename U> inline bool operator!=(const PassOwnArrayPtr<T>& a, U* b)$/;"	f	namespace:WTF	signature:(const PassOwnArrayPtr<T>& a, U* b)
operator !=	.\PassOwnArrayPtr.h	/^template<typename T, typename U> inline bool operator!=(const PassOwnArrayPtr<T>& a, const OwnArrayPtr<U>& b) $/;"	f	namespace:WTF	signature:(const PassOwnArrayPtr<T>& a, const OwnArrayPtr<U>& b)
operator !=	.\PassOwnArrayPtr.h	/^template<typename T, typename U> inline bool operator!=(const PassOwnArrayPtr<T>& a, const PassOwnArrayPtr<U>& b) $/;"	f	namespace:WTF	signature:(const PassOwnArrayPtr<T>& a, const PassOwnArrayPtr<U>& b)
operator !=	.\PassOwnPtr.h	/^        template<typename U> bool operator!=(const OwnPtr<U>&) { COMPILE_ASSERT(!sizeof(U*), OwnPtrs_should_never_be_equal); return false; }$/;"	f	class:WTF::PassOwnPtr	access:private	signature:(const OwnPtr<U>&)
operator !=	.\PassOwnPtr.h	/^        template<typename U> bool operator!=(const PassOwnPtr<U>&) { COMPILE_ASSERT(!sizeof(U*), OwnPtrs_should_never_be_equal); return false; }$/;"	f	class:WTF::PassOwnPtr	access:private	signature:(const PassOwnPtr<U>&)
operator !=	.\PassOwnPtr.h	/^    template<typename T, typename U> inline bool operator!=(T* a, const PassOwnPtr<U>& b) $/;"	f	namespace:WTF	signature:(T* a, const PassOwnPtr<U>& b)
operator !=	.\PassOwnPtr.h	/^    template<typename T, typename U> inline bool operator!=(const OwnPtr<T>& a, const PassOwnPtr<U>& b) $/;"	f	namespace:WTF	signature:(const OwnPtr<T>& a, const PassOwnPtr<U>& b)
operator !=	.\PassOwnPtr.h	/^    template<typename T, typename U> inline bool operator!=(const PassOwnPtr<T>& a, U* b)$/;"	f	namespace:WTF	signature:(const PassOwnPtr<T>& a, U* b)
operator !=	.\PassOwnPtr.h	/^    template<typename T, typename U> inline bool operator!=(const PassOwnPtr<T>& a, const OwnPtr<U>& b) $/;"	f	namespace:WTF	signature:(const PassOwnPtr<T>& a, const OwnPtr<U>& b)
operator !=	.\PassOwnPtr.h	/^    template<typename T, typename U> inline bool operator!=(const PassOwnPtr<T>& a, const PassOwnPtr<U>& b) $/;"	f	namespace:WTF	signature:(const PassOwnPtr<T>& a, const PassOwnPtr<U>& b)
operator !=	.\PassRefPtr.h	/^    template<typename T, typename U> inline bool operator!=(T* a, const PassRefPtr<U>& b) $/;"	f	namespace:WTF	signature:(T* a, const PassRefPtr<U>& b)
operator !=	.\PassRefPtr.h	/^    template<typename T, typename U> inline bool operator!=(const PassRefPtr<T>& a, U* b)$/;"	f	namespace:WTF	signature:(const PassRefPtr<T>& a, U* b)
operator !=	.\PassRefPtr.h	/^    template<typename T, typename U> inline bool operator!=(const PassRefPtr<T>& a, const PassRefPtr<U>& b) $/;"	f	namespace:WTF	signature:(const PassRefPtr<T>& a, const PassRefPtr<U>& b)
operator !=	.\PassRefPtr.h	/^    template<typename T, typename U> inline bool operator!=(const PassRefPtr<T>& a, const RefPtr<U>& b) $/;"	f	namespace:WTF	signature:(const PassRefPtr<T>& a, const RefPtr<U>& b)
operator !=	.\PassRefPtr.h	/^    template<typename T, typename U> inline bool operator!=(const RefPtr<T>& a, const PassRefPtr<U>& b) $/;"	f	namespace:WTF	signature:(const RefPtr<T>& a, const PassRefPtr<U>& b)
operator !=	.\RefPtr.h	/^    template<typename T, typename U> inline bool operator!=(T* a, const RefPtr<U>& b)$/;"	f	namespace:WTF	signature:(T* a, const RefPtr<U>& b)
operator !=	.\RefPtr.h	/^    template<typename T, typename U> inline bool operator!=(const RefPtr<T>& a, U* b)$/;"	f	namespace:WTF	signature:(const RefPtr<T>& a, U* b)
operator !=	.\RefPtr.h	/^    template<typename T, typename U> inline bool operator!=(const RefPtr<T>& a, const RefPtr<U>& b)$/;"	f	namespace:WTF	signature:(const RefPtr<T>& a, const RefPtr<U>& b)
operator !=	.\RetainPtr.h	/^    template<typename T, typename U> inline bool operator!=(T* a, const RetainPtr<U>& b)$/;"	f	namespace:WTF	signature:(T* a, const RetainPtr<U>& b)
operator !=	.\RetainPtr.h	/^    template<typename T, typename U> inline bool operator!=(const RetainPtr<T>& a, U* b)$/;"	f	namespace:WTF	signature:(const RetainPtr<T>& a, U* b)
operator !=	.\RetainPtr.h	/^    template<typename T, typename U> inline bool operator!=(const RetainPtr<T>& a, const RetainPtr<U>& b)$/;"	f	namespace:WTF	signature:(const RetainPtr<T>& a, const RetainPtr<U>& b)
operator !=	.\SegmentedVector.h	/^        bool operator!=(const Iterator& other) const$/;"	f	class:WTF::SegmentedVectorIterator	access:public	signature:(const Iterator& other) const
operator !=	.\Vector.h	/^    inline bool operator!=(const Vector<T, inlineCapacity>& a, const Vector<T, inlineCapacity>& b)$/;"	f	namespace:WTF	signature:(const Vector<T, inlineCapacity>& a, const Vector<T, inlineCapacity>& b)
operator !=	.\gobject\GOwnPtr.h	/^template <typename T, typename U> inline bool operator!=(T* a, const GOwnPtr<U>& b)$/;"	f	namespace:WTF	signature:(T* a, const GOwnPtr<U>& b)
operator !=	.\gobject\GOwnPtr.h	/^template <typename T, typename U> inline bool operator!=(const GOwnPtr<T>& a, U* b)$/;"	f	namespace:WTF	signature:(const GOwnPtr<T>& a, U* b)
operator !=	.\gobject\GRefPtr.h	/^template <typename T, typename U> inline bool operator!=(T* a, const GRefPtr<U>& b)$/;"	f	namespace:WTF	signature:(T* a, const GRefPtr<U>& b)
operator !=	.\gobject\GRefPtr.h	/^template <typename T, typename U> inline bool operator!=(const GRefPtr<T>& a, U* b)$/;"	f	namespace:WTF	signature:(const GRefPtr<T>& a, U* b)
operator !=	.\gobject\GRefPtr.h	/^template <typename T, typename U> inline bool operator!=(const GRefPtr<T>& a, const GRefPtr<U>& b)$/;"	f	namespace:WTF	signature:(const GRefPtr<T>& a, const GRefPtr<U>& b)
operator !=	.\text\AtomicString.h	/^inline bool operator!=(const AtomicString& a, const AtomicString& b) { return a.impl() != b.impl(); }$/;"	f	namespace:WTF	signature:(const AtomicString& a, const AtomicString& b)
operator !=	.\text\AtomicString.h	/^inline bool operator!=(const AtomicString& a, const LChar* b) { return !(a == b); }$/;"	f	namespace:WTF	signature:(const AtomicString& a, const LChar* b)
operator !=	.\text\AtomicString.h	/^inline bool operator!=(const AtomicString& a, const String& b) { return !equal(a.impl(), b.impl()); }$/;"	f	namespace:WTF	signature:(const AtomicString& a, const String& b)
operator !=	.\text\AtomicString.h	/^inline bool operator!=(const AtomicString& a, const Vector<UChar>& b) { return !(a == b); }$/;"	f	namespace:WTF	signature:(const AtomicString& a, const Vector<UChar>& b)
operator !=	.\text\AtomicString.h	/^inline bool operator!=(const AtomicString& a, const char* b) { return !(a == b); }$/;"	f	namespace:WTF	signature:(const AtomicString& a, const char* b)
operator !=	.\text\AtomicString.h	/^inline bool operator!=(const LChar* a, const AtomicString& b) { return !(b == a); }$/;"	f	namespace:WTF	signature:(const LChar* a, const AtomicString& b)
operator !=	.\text\AtomicString.h	/^inline bool operator!=(const String& a, const AtomicString& b) { return !equal(a.impl(), b.impl()); }$/;"	f	namespace:WTF	signature:(const String& a, const AtomicString& b)
operator !=	.\text\AtomicString.h	/^inline bool operator!=(const Vector<UChar>& a, const AtomicString& b) { return !(a == b); }$/;"	f	namespace:WTF	signature:(const Vector<UChar>& a, const AtomicString& b)
operator !=	.\text\CString.h	/^inline bool operator!=(const CString& a, const CString& b) { return !(a == b); }$/;"	f	namespace:WTF	signature:(const CString& a, const CString& b)
operator !=	.\text\StringBuilder.h	/^inline bool operator!=(const String& a, const StringBuilder& b) { return !equal(b, a); }$/;"	f	namespace:WTF	signature:(const String& a, const StringBuilder& b)
operator !=	.\text\StringBuilder.h	/^inline bool operator!=(const StringBuilder& a, const String& b) { return !equal(a, b); }$/;"	f	namespace:WTF	signature:(const StringBuilder& a, const String& b)
operator !=	.\text\StringBuilder.h	/^inline bool operator!=(const StringBuilder& a, const StringBuilder& b) { return !equal(a, b); }$/;"	f	namespace:WTF	signature:(const StringBuilder& a, const StringBuilder& b)
operator !=	.\text\TextPosition.h	/^    bool operator!=(OrdinalNumber other) { return !((*this) == other); }$/;"	f	class:WTF::OrdinalNumber	access:public	signature:(OrdinalNumber other)
operator !=	.\text\TextPosition.h	/^    bool operator!=(const TextPosition& other) { return !((*this) == other); }$/;"	f	class:WTF::TextPosition	access:public	signature:(const TextPosition& other)
operator !=	.\text\WTFString.h	/^inline bool operator!=(const LChar* a, const String& b) { return !equal(a, b.impl()); }$/;"	f	namespace:WTF	signature:(const LChar* a, const String& b)
operator !=	.\text\WTFString.h	/^inline bool operator!=(const String& a, const LChar* b) { return !equal(a.impl(), b); }$/;"	f	namespace:WTF	signature:(const String& a, const LChar* b)
operator !=	.\text\WTFString.h	/^inline bool operator!=(const String& a, const String& b) { return !equal(a.impl(), b.impl()); }$/;"	f	namespace:WTF	signature:(const String& a, const String& b)
operator !=	.\text\WTFString.h	/^inline bool operator!=(const String& a, const Vector<char, inlineCapacity>& b) { return b != a; }$/;"	f	namespace:WTF	signature:(const String& a, const Vector<char, inlineCapacity>& b)
operator !=	.\text\WTFString.h	/^inline bool operator!=(const String& a, const char* b) { return !equal(a.impl(), reinterpret_cast<const LChar*>(b)); }$/;"	f	namespace:WTF	signature:(const String& a, const char* b)
operator !=	.\text\WTFString.h	/^inline bool operator!=(const Vector<char, inlineCapacity>& a, const String& b) { return !(a == b); }$/;"	f	namespace:WTF	signature:(const Vector<char, inlineCapacity>& a, const String& b)
operator !=	.\text\WTFString.h	/^inline bool operator!=(const char* a, const String& b) { return !equal(reinterpret_cast<const LChar*>(a), b.impl()); }$/;"	f	namespace:WTF	signature:(const char* a, const String& b)
operator ()	.\Functional.h	/^    R operator()() const$/;"	f	class:WTF::Function	access:public	signature:() const
operator ()	.\Functional.h	/^    R operator()()$/;"	f	class:WTF::FunctionWrapper	access:public	signature:()
operator ()	.\Functional.h	/^    R operator()(C* c)$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(C* c)
operator ()	.\Functional.h	/^    R operator()(C* c, P1 p1)$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(C* c, P1 p1)
operator ()	.\Functional.h	/^    R operator()(C* c, P1 p1, P2 p2)$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(C* c, P1 p1, P2 p2)
operator ()	.\Functional.h	/^    R operator()(C* c, P1 p1, P2 p2, P3 p3)$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(C* c, P1 p1, P2 p2, P3 p3)
operator ()	.\Functional.h	/^    R operator()(C* c, P1 p1, P2 p2, P3 p3, P4 p4)$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(C* c, P1 p1, P2 p2, P3 p3, P4 p4)
operator ()	.\Functional.h	/^    R operator()(C* c, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(C* c, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
operator ()	.\Functional.h	/^    R operator()(P1 p1)$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(P1 p1)
operator ()	.\Functional.h	/^    R operator()(P1 p1, P2 p2)$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(P1 p1, P2 p2)
operator ()	.\Functional.h	/^    R operator()(P1 p1, P2 p2, P3 p3)$/;"	f	class:WTF::FunctionWrapper	access:public	signature:(P1 p1, P2 p2, P3 p3)
operator ()	.\Functional.h	/^    virtual R operator()() = 0;$/;"	p	class:WTF::FunctionImpl	access:public	signature:()
operator ()	.\Functional.h	/^    virtual R operator()()$/;"	f	class:WTF::BoundFunctionImpl	access:public	signature:()
operator ()	.\Functional.h	/^    virtual typename FunctionWrapper::ResultType operator()()$/;"	f	class:WTF::BoundFunctionImpl	access:public	signature:()
operator ()	.\MainThread.cpp	/^    bool operator() (FunctionWithContext& o) { return o == m; }$/;"	f	class:WTF::FunctionWithContextFinder	access:public	signature:(FunctionWithContext& o)
operator ()	.\MallocZoneSupport.h	/^    T* operator()(T* address, size_t size=sizeof(T)) const$/;"	f	class:WTF::RemoteMemoryReader	access:public	signature:(T* address, size_t size=sizeof(T)) const
operator ()	.\MallocZoneSupport.h	/^    void* operator()(vm_address_t address, size_t size) const$/;"	f	class:WTF::RemoteMemoryReader	access:public	signature:(vm_address_t address, size_t size) const
operator ()	.\text\StringImpl.cpp	/^    inline bool operator()(UChar ch) const$/;"	f	class:WTF::SpaceOrNewlinePredicate	access:public	signature:(UChar ch) const
operator ()	.\text\StringImpl.cpp	/^    inline bool operator()(UChar ch) const$/;"	f	class:WTF::UCharPredicate	access:public	signature:(UChar ch) const
operator *	.\AVLTree.h	/^        handle operator*()$/;"	f	class:WTF::AVLTree::Iterator	access:public	signature:()
operator *	.\BoundsCheckedPointer.h	/^    T& operator*()$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:()
operator *	.\BoundsCheckedPointer.h	/^    const T& operator*() const$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:() const
operator *	.\CheckedArithmetic.h	/^template <typename U, typename V, typename OverflowHandler> static inline Checked<typename Result<U, V>::ResultType, OverflowHandler> operator*(Checked<U, OverflowHandler> lhs, Checked<V, OverflowHandler> rhs)$/;"	f	namespace:WTF	signature:(Checked<U, OverflowHandler> lhs, Checked<V, OverflowHandler> rhs)
operator *	.\CheckedArithmetic.h	/^template <typename U, typename V, typename OverflowHandler> static inline Checked<typename Result<U, V>::ResultType, OverflowHandler> operator*(Checked<U, OverflowHandler> lhs, V rhs)$/;"	f	namespace:WTF	signature:(Checked<U, OverflowHandler> lhs, V rhs)
operator *	.\CheckedArithmetic.h	/^template <typename U, typename V, typename OverflowHandler> static inline Checked<typename Result<U, V>::ResultType, OverflowHandler> operator*(U lhs, Checked<V, OverflowHandler> rhs)$/;"	f	namespace:WTF	signature:(U lhs, Checked<V, OverflowHandler> rhs)
operator *	.\Deque.h	/^        T& operator*() const { return *Base::after(); }$/;"	f	class:WTF::DequeIterator	access:public	signature:() const
operator *	.\Deque.h	/^        T& operator*() const { return *Base::before(); }$/;"	f	class:WTF::DequeReverseIterator	access:public	signature:() const
operator *	.\Deque.h	/^        const T& operator*() const { return *Base::after(); }$/;"	f	class:WTF::DequeConstIterator	access:public	signature:() const
operator *	.\Deque.h	/^        const T& operator*() const { return *Base::before(); }$/;"	f	class:WTF::DequeConstReverseIterator	access:public	signature:() const
operator *	.\HashIterators.h	/^        KeyType& operator*() const { return *get(); }$/;"	f	struct:WTF::HashTableKeysIterator	access:public	signature:() const
operator *	.\HashIterators.h	/^        MappedType& operator*() const { return *get(); }$/;"	f	struct:WTF::HashTableValuesIterator	access:public	signature:() const
operator *	.\HashIterators.h	/^        ValueType& operator*() const { return *get(); }$/;"	f	struct:WTF::HashTableIteratorAdapter	access:public	signature:() const
operator *	.\HashIterators.h	/^        const KeyType& operator*() const { return *get(); }$/;"	f	struct:WTF::HashTableConstKeysIterator	access:public	signature:() const
operator *	.\HashIterators.h	/^        const MappedType& operator*() const { return *get(); }$/;"	f	struct:WTF::HashTableConstValuesIterator	access:public	signature:() const
operator *	.\HashIterators.h	/^        const ValueType& operator*() const { return *get(); }$/;"	f	struct:WTF::HashTableConstIteratorAdapter	access:public	signature:() const
operator *	.\HashTable.h	/^        ReferenceType operator*() const { return *get(); }$/;"	f	class:WTF::HashTableConstIterator	access:public	signature:() const
operator *	.\HashTable.h	/^        ReferenceType operator*() const { return *get(); }$/;"	f	class:WTF::HashTableIterator	access:public	signature:() const
operator *	.\HashTable.h	/^        ValueType& operator*() const { return *get(); }$/;"	f	struct:WTF::HashTableIteratorAdapter	access:public	signature:() const
operator *	.\HashTable.h	/^        const ValueType& operator*() const { return *get(); }$/;"	f	struct:WTF::HashTableConstIteratorAdapter	access:public	signature:() const
operator *	.\ListHashSet.h	/^        ReferenceType operator*() const { return *get(); }$/;"	f	class:WTF::ListHashSetConstIterator	access:public	signature:() const
operator *	.\ListHashSet.h	/^        ReferenceType operator*() const { return *get(); }$/;"	f	class:WTF::ListHashSetConstReverseIterator	access:public	signature:() const
operator *	.\ListHashSet.h	/^        ReferenceType operator*() const { return *get(); }$/;"	f	class:WTF::ListHashSetIterator	access:public	signature:() const
operator *	.\ListHashSet.h	/^        ReferenceType operator*() const { return *get(); }$/;"	f	class:WTF::ListHashSetReverseIterator	access:public	signature:() const
operator *	.\OwnArrayPtr.h	/^    T& operator*() const { ASSERT(m_ptr); return *m_ptr; }$/;"	f	class:WTF::OwnArrayPtr	access:public	signature:() const
operator *	.\OwnPtr.h	/^        ValueType& operator*() const { ASSERT(m_ptr); return *m_ptr; }$/;"	f	class:WTF::OwnPtr	access:public	signature:() const
operator *	.\PassOwnArrayPtr.h	/^    T& operator*() const { ASSERT(m_ptr); return *m_ptr; }$/;"	f	class:WTF::PassOwnArrayPtr	access:public	signature:() const
operator *	.\PassOwnPtr.h	/^        ValueType& operator*() const { ASSERT(m_ptr); return *m_ptr; }$/;"	f	class:WTF::PassOwnPtr	access:public	signature:() const
operator *	.\PassRefPtr.h	/^        T& operator*() const { return *m_ptr; }$/;"	f	class:WTF::NonNullPassRefPtr	access:public	signature:() const
operator *	.\PassRefPtr.h	/^        T& operator*() const { return *m_ptr; }$/;"	f	class:WTF::PassRefPtr	access:public	signature:() const
operator *	.\RefPtr.h	/^        T& operator*() const { return *m_ptr; }$/;"	f	class:WTF::RefPtr	access:public	signature:() const
operator *	.\SegmentedVector.h	/^        T& operator*() const { return m_vector.m_segments.at(m_segment)->at(m_index); }$/;"	f	class:WTF::SegmentedVectorIterator	access:public	signature:() const
operator *	.\ThreadSpecific.h	/^    T& operator*();$/;"	p	class:WTF::ThreadSpecific	access:public	signature:()
operator *	.\ThreadSpecific.h	/^inline T& ThreadSpecific<T>::operator*()$/;"	f	class:WTF::ThreadSpecific	signature:()
operator *	.\gobject\GOwnPtr.h	/^    T& operator*() const$/;"	f	class:WTF::GOwnPtr	access:public	signature:() const
operator *	.\gobject\GRefPtr.h	/^    T& operator*() const { return *m_ptr; }$/;"	f	class:WTF::GRefPtr	access:public	signature:() const
operator *=	.\CheckedArithmetic.h	/^    template <typename U, typename V> const Checked operator*=(Checked<U, V> rhs)$/;"	f	class:WTF::Checked	access:public	signature:(Checked<U, V> rhs)
operator *=	.\CheckedArithmetic.h	/^    template <typename U> const Checked operator*=(U rhs)$/;"	f	class:WTF::Checked	access:public	signature:(U rhs)
operator +	.\BoundsCheckedPointer.h	/^    BoundsCheckedPointer operator+(ptrdiff_t amount) const$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(ptrdiff_t amount) const
operator +	.\CheckedArithmetic.h	/^template <typename U, typename V, typename OverflowHandler> static inline Checked<typename Result<U, V>::ResultType, OverflowHandler> operator+(Checked<U, OverflowHandler> lhs, Checked<V, OverflowHandler> rhs)$/;"	f	namespace:WTF	signature:(Checked<U, OverflowHandler> lhs, Checked<V, OverflowHandler> rhs)
operator +	.\CheckedArithmetic.h	/^template <typename U, typename V, typename OverflowHandler> static inline Checked<typename Result<U, V>::ResultType, OverflowHandler> operator+(Checked<U, OverflowHandler> lhs, V rhs)$/;"	f	namespace:WTF	signature:(Checked<U, OverflowHandler> lhs, V rhs)
operator +	.\CheckedArithmetic.h	/^template <typename U, typename V, typename OverflowHandler> static inline Checked<typename Result<U, V>::ResultType, OverflowHandler> operator+(U lhs, Checked<V, OverflowHandler> rhs)$/;"	f	namespace:WTF	signature:(U lhs, Checked<V, OverflowHandler> rhs)
operator +	.\text\StringOperators.h	/^StringAppend<String, T> operator+(const String& string1, T string2)$/;"	f	namespace:WTF	signature:(const String& string1, T string2)
operator +	.\text\StringOperators.h	/^StringAppend<StringAppend<U, V>, W> operator+(const StringAppend<U, V>& string1, W string2)$/;"	f	namespace:WTF	signature:(const StringAppend<U, V>& string1, W string2)
operator +	.\text\StringOperators.h	/^StringAppend<const UChar*, StringAppend<U, V> > operator+(const UChar* string1, const StringAppend<U, V>& string2)$/;"	f	namespace:WTF	signature:(const UChar* string1, const StringAppend<U, V>& string2)
operator +	.\text\StringOperators.h	/^StringAppend<const char*, StringAppend<U, V> > operator+(const char* string1, const StringAppend<U, V>& string2)$/;"	f	namespace:WTF	signature:(const char* string1, const StringAppend<U, V>& string2)
operator +	.\text\StringOperators.h	/^inline StringAppend<const UChar*, AtomicString> operator+(const UChar* string1, const AtomicString& string2)$/;"	f	namespace:WTF	signature:(const UChar* string1, const AtomicString& string2)
operator +	.\text\StringOperators.h	/^inline StringAppend<const UChar*, String> operator+(const UChar* string1, const String& string2)$/;"	f	namespace:WTF	signature:(const UChar* string1, const String& string2)
operator +	.\text\StringOperators.h	/^inline StringAppend<const char*, AtomicString> operator+(const char* string1, const AtomicString& string2)$/;"	f	namespace:WTF	signature:(const char* string1, const AtomicString& string2)
operator +	.\text\StringOperators.h	/^inline StringAppend<const char*, String> operator+(const char* string1, const String& string2)$/;"	f	namespace:WTF	signature:(const char* string1, const String& string2)
operator ++	.\AVLTree.h	/^        void operator++()$/;"	f	class:WTF::AVLTree::Iterator	access:public	signature:()
operator ++	.\AVLTree.h	/^        void operator++(int) { ++(*this); }$/;"	f	class:WTF::AVLTree::Iterator	access:public	signature:(int)
operator ++	.\BoundsCheckedPointer.h	/^    BoundsCheckedPointer operator++() \/\/ prefix$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:()
operator ++	.\BoundsCheckedPointer.h	/^    BoundsCheckedPointer operator++(int) \/\/ postfix$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(int)
operator ++	.\CheckedArithmetic.h	/^    const Checked operator++(int)$/;"	f	class:WTF::Checked	access:public	signature:(int)
operator ++	.\CheckedArithmetic.h	/^    const Checked& operator++()$/;"	f	class:WTF::Checked	access:public	signature:()
operator ++	.\Deque.h	/^        Iterator& operator++() { Base::decrement(); return *this; }$/;"	f	class:WTF::DequeConstReverseIterator	access:public	signature:()
operator ++	.\Deque.h	/^        Iterator& operator++() { Base::decrement(); return *this; }$/;"	f	class:WTF::DequeReverseIterator	access:public	signature:()
operator ++	.\Deque.h	/^        Iterator& operator++() { Base::increment(); return *this; }$/;"	f	class:WTF::DequeConstIterator	access:public	signature:()
operator ++	.\Deque.h	/^        Iterator& operator++() { Base::increment(); return *this; }$/;"	f	class:WTF::DequeIterator	access:public	signature:()
operator ++	.\HashIterators.h	/^        HashTableConstIteratorAdapter& operator++() { ++m_impl; return *this; }$/;"	f	struct:WTF::HashTableConstIteratorAdapter	access:public	signature:()
operator ++	.\HashIterators.h	/^        HashTableConstKeysIterator& operator++() { ++m_impl; return *this; }$/;"	f	struct:WTF::HashTableConstKeysIterator	access:public	signature:()
operator ++	.\HashIterators.h	/^        HashTableConstValuesIterator& operator++() { ++m_impl; return *this; }$/;"	f	struct:WTF::HashTableConstValuesIterator	access:public	signature:()
operator ++	.\HashIterators.h	/^        HashTableIteratorAdapter& operator++() { ++m_impl; return *this; }$/;"	f	struct:WTF::HashTableIteratorAdapter	access:public	signature:()
operator ++	.\HashIterators.h	/^        HashTableKeysIterator& operator++() { ++m_impl; return *this; }$/;"	f	struct:WTF::HashTableKeysIterator	access:public	signature:()
operator ++	.\HashIterators.h	/^        HashTableValuesIterator& operator++() { ++m_impl; return *this; }$/;"	f	struct:WTF::HashTableValuesIterator	access:public	signature:()
operator ++	.\HashTable.h	/^        HashTableConstIteratorAdapter& operator++() { ++m_impl; return *this; }$/;"	f	struct:WTF::HashTableConstIteratorAdapter	access:public	signature:()
operator ++	.\HashTable.h	/^        HashTableIteratorAdapter& operator++() { ++m_impl; return *this; }$/;"	f	struct:WTF::HashTableIteratorAdapter	access:public	signature:()
operator ++	.\HashTable.h	/^        const_iterator& operator++()$/;"	f	class:WTF::HashTableConstIterator	access:public	signature:()
operator ++	.\HashTable.h	/^        iterator& operator++() { ++m_iterator; return *this; }$/;"	f	class:WTF::HashTableIterator	access:public	signature:()
operator ++	.\ListHashSet.h	/^        const_iterator& operator++()$/;"	f	class:WTF::ListHashSetConstIterator	access:public	signature:()
operator ++	.\ListHashSet.h	/^        const_reverse_iterator& operator++()$/;"	f	class:WTF::ListHashSetConstReverseIterator	access:public	signature:()
operator ++	.\ListHashSet.h	/^        iterator& operator++() { ++m_iterator; return *this; }$/;"	f	class:WTF::ListHashSetIterator	access:public	signature:()
operator ++	.\ListHashSet.h	/^        reverse_iterator& operator++() { ++m_iterator; return *this; }$/;"	f	class:WTF::ListHashSetReverseIterator	access:public	signature:()
operator ++	.\SegmentedVector.h	/^        Iterator& operator++()$/;"	f	class:WTF::SegmentedVectorIterator	access:public	signature:()
operator +=	.\BoundsCheckedPointer.h	/^    BoundsCheckedPointer& operator+=(ptrdiff_t amount)$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(ptrdiff_t amount)
operator +=	.\CheckedArithmetic.h	/^    template <typename U, typename V> const Checked operator+=(Checked<U, V> rhs)$/;"	f	class:WTF::Checked	access:public	signature:(Checked<U, V> rhs)
operator +=	.\CheckedArithmetic.h	/^    template <typename U> const Checked operator+=(U rhs)$/;"	f	class:WTF::Checked	access:public	signature:(U rhs)
operator +=	.\CheckedArithmetic.h	/^    void operator+=(double);$/;"	p	class:WTF::Checked	access:private	signature:(double)
operator +=	.\CheckedArithmetic.h	/^    void operator+=(float);$/;"	p	class:WTF::Checked	access:private	signature:(float)
operator +=	.\text\WTFString.h	/^inline String& operator+=(String& a, const String& b) { a.append(b); return a; }$/;"	f	namespace:WTF	signature:(String& a, const String& b)
operator -	.\BoundsCheckedPointer.h	/^    BoundsCheckedPointer operator-(ptrdiff_t amount) const$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(ptrdiff_t amount) const
operator -	.\CheckedArithmetic.h	/^template <typename U, typename V, typename OverflowHandler> static inline Checked<typename Result<U, V>::ResultType, OverflowHandler> operator-(Checked<U, OverflowHandler> lhs, Checked<V, OverflowHandler> rhs)$/;"	f	namespace:WTF	signature:(Checked<U, OverflowHandler> lhs, Checked<V, OverflowHandler> rhs)
operator -	.\CheckedArithmetic.h	/^template <typename U, typename V, typename OverflowHandler> static inline Checked<typename Result<U, V>::ResultType, OverflowHandler> operator-(Checked<U, OverflowHandler> lhs, V rhs)$/;"	f	namespace:WTF	signature:(Checked<U, OverflowHandler> lhs, V rhs)
operator -	.\CheckedArithmetic.h	/^template <typename U, typename V, typename OverflowHandler> static inline Checked<typename Result<U, V>::ResultType, OverflowHandler> operator-(U lhs, Checked<V, OverflowHandler> rhs)$/;"	f	namespace:WTF	signature:(U lhs, Checked<V, OverflowHandler> rhs)
operator --	.\AVLTree.h	/^        void operator--()$/;"	f	class:WTF::AVLTree::Iterator	access:public	signature:()
operator --	.\AVLTree.h	/^        void operator--(int) { --(*this); }$/;"	f	class:WTF::AVLTree::Iterator	access:public	signature:(int)
operator --	.\BoundsCheckedPointer.h	/^    BoundsCheckedPointer operator--() \/\/ prefix$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:()
operator --	.\BoundsCheckedPointer.h	/^    BoundsCheckedPointer operator--(int) \/\/ postfix$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(int)
operator --	.\CheckedArithmetic.h	/^    const Checked operator--(int)$/;"	f	class:WTF::Checked	access:public	signature:(int)
operator --	.\CheckedArithmetic.h	/^    const Checked& operator--()$/;"	f	class:WTF::Checked	access:public	signature:()
operator --	.\Deque.h	/^        Iterator& operator--() { Base::decrement(); return *this; }$/;"	f	class:WTF::DequeConstIterator	access:public	signature:()
operator --	.\Deque.h	/^        Iterator& operator--() { Base::decrement(); return *this; }$/;"	f	class:WTF::DequeIterator	access:public	signature:()
operator --	.\Deque.h	/^        Iterator& operator--() { Base::increment(); return *this; }$/;"	f	class:WTF::DequeConstReverseIterator	access:public	signature:()
operator --	.\Deque.h	/^        Iterator& operator--() { Base::increment(); return *this; }$/;"	f	class:WTF::DequeReverseIterator	access:public	signature:()
operator --	.\ListHashSet.h	/^        const_iterator& operator--()$/;"	f	class:WTF::ListHashSetConstIterator	access:public	signature:()
operator --	.\ListHashSet.h	/^        const_reverse_iterator& operator--()$/;"	f	class:WTF::ListHashSetConstReverseIterator	access:public	signature:()
operator --	.\ListHashSet.h	/^        iterator& operator--() { --m_iterator; return *this; }$/;"	f	class:WTF::ListHashSetIterator	access:public	signature:()
operator --	.\ListHashSet.h	/^        reverse_iterator& operator--() { --m_iterator; return *this; }$/;"	f	class:WTF::ListHashSetReverseIterator	access:public	signature:()
operator -=	.\BoundsCheckedPointer.h	/^    BoundsCheckedPointer& operator-=(ptrdiff_t amount)$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(ptrdiff_t amount)
operator -=	.\CheckedArithmetic.h	/^    template <typename U, typename V> const Checked operator-=(Checked<U, V> rhs)$/;"	f	class:WTF::Checked	access:public	signature:(Checked<U, V> rhs)
operator -=	.\CheckedArithmetic.h	/^    template <typename U> const Checked operator-=(U rhs)$/;"	f	class:WTF::Checked	access:public	signature:(U rhs)
operator -=	.\CheckedArithmetic.h	/^    void operator-=(double);$/;"	p	class:WTF::Checked	access:private	signature:(double)
operator -=	.\CheckedArithmetic.h	/^    void operator-=(float);$/;"	p	class:WTF::Checked	access:private	signature:(float)
operator ->	.\Deque.h	/^        T* operator->() const { return Base::after(); }$/;"	f	class:WTF::DequeIterator	access:public	signature:() const
operator ->	.\Deque.h	/^        T* operator->() const { return Base::before(); }$/;"	f	class:WTF::DequeReverseIterator	access:public	signature:() const
operator ->	.\Deque.h	/^        const T* operator->() const { return Base::after(); }$/;"	f	class:WTF::DequeConstIterator	access:public	signature:() const
operator ->	.\Deque.h	/^        const T* operator->() const { return Base::before(); }$/;"	f	class:WTF::DequeConstReverseIterator	access:public	signature:() const
operator ->	.\HashIterators.h	/^        KeyType* operator->() const { return get(); }$/;"	f	struct:WTF::HashTableKeysIterator	access:public	signature:() const
operator ->	.\HashIterators.h	/^        MappedType* operator->() const { return get(); }$/;"	f	struct:WTF::HashTableValuesIterator	access:public	signature:() const
operator ->	.\HashIterators.h	/^        ValueType* operator->() const { return get(); }$/;"	f	struct:WTF::HashTableIteratorAdapter	access:public	signature:() const
operator ->	.\HashIterators.h	/^        const KeyType* operator->() const { return get(); }$/;"	f	struct:WTF::HashTableConstKeysIterator	access:public	signature:() const
operator ->	.\HashIterators.h	/^        const MappedType* operator->() const { return get(); }$/;"	f	struct:WTF::HashTableConstValuesIterator	access:public	signature:() const
operator ->	.\HashIterators.h	/^        const ValueType* operator->() const { return get(); }$/;"	f	struct:WTF::HashTableConstIteratorAdapter	access:public	signature:() const
operator ->	.\HashTable.h	/^        PointerType operator->() const { return get(); }$/;"	f	class:WTF::HashTableConstIterator	access:public	signature:() const
operator ->	.\HashTable.h	/^        PointerType operator->() const { return get(); }$/;"	f	class:WTF::HashTableIterator	access:public	signature:() const
operator ->	.\HashTable.h	/^        ValueType* operator->() const { return get(); }$/;"	f	struct:WTF::HashTableIteratorAdapter	access:public	signature:() const
operator ->	.\HashTable.h	/^        const ValueType* operator->() const { return get(); }$/;"	f	struct:WTF::HashTableConstIteratorAdapter	access:public	signature:() const
operator ->	.\ListHashSet.h	/^        PointerType operator->() const { return get(); }$/;"	f	class:WTF::ListHashSetConstIterator	access:public	signature:() const
operator ->	.\ListHashSet.h	/^        PointerType operator->() const { return get(); }$/;"	f	class:WTF::ListHashSetConstReverseIterator	access:public	signature:() const
operator ->	.\ListHashSet.h	/^        PointerType operator->() const { return get(); }$/;"	f	class:WTF::ListHashSetIterator	access:public	signature:() const
operator ->	.\ListHashSet.h	/^        PointerType operator->() const { return get(); }$/;"	f	class:WTF::ListHashSetReverseIterator	access:public	signature:() const
operator ->	.\OwnArrayPtr.h	/^    PtrType operator->() const { ASSERT(m_ptr); return m_ptr; }$/;"	f	class:WTF::OwnArrayPtr	access:public	signature:() const
operator ->	.\OwnPtr.h	/^        PtrType operator->() const { ASSERT(m_ptr); return m_ptr; }$/;"	f	class:WTF::OwnPtr	access:public	signature:() const
operator ->	.\PassOwnArrayPtr.h	/^    PtrType operator->() const { ASSERT(m_ptr); return m_ptr; }$/;"	f	class:WTF::PassOwnArrayPtr	access:public	signature:() const
operator ->	.\PassOwnPtr.h	/^        PtrType operator->() const { ASSERT(m_ptr); return m_ptr; }$/;"	f	class:WTF::PassOwnPtr	access:public	signature:() const
operator ->	.\PassRefPtr.h	/^        T* operator->() const { return m_ptr; }$/;"	f	class:WTF::NonNullPassRefPtr	access:public	signature:() const
operator ->	.\PassRefPtr.h	/^        T* operator->() const { return m_ptr; }$/;"	f	class:WTF::PassRefPtr	access:public	signature:() const
operator ->	.\RefPtr.h	/^        ALWAYS_INLINE T* operator->() const { return m_ptr; }$/;"	f	class:WTF::RefPtr	access:public	signature:() const
operator ->	.\RetainPtr.h	/^        PtrType operator->() const { return m_ptr; }$/;"	f	class:WTF::RetainPtr	access:public	signature:() const
operator ->	.\SegmentedVector.h	/^        T* operator->() const { return &m_vector.m_segments.at(m_segment)->at(m_index); }$/;"	f	class:WTF::SegmentedVectorIterator	access:public	signature:() const
operator ->	.\ThreadSpecific.h	/^    T* operator->();$/;"	p	class:WTF::ThreadSpecific	access:public	signature:()
operator ->	.\ThreadSpecific.h	/^inline T* ThreadSpecific<T>::operator->()$/;"	f	class:WTF::ThreadSpecific	signature:()
operator ->	.\gobject\GOwnPtr.h	/^    T* operator->() const$/;"	f	class:WTF::GOwnPtr	access:public	signature:() const
operator ->	.\gobject\GRefPtr.h	/^    ALWAYS_INLINE T* operator->() const { return m_ptr; }$/;"	f	class:WTF::GRefPtr	access:public	signature:() const
operator <	.\BoundsCheckedPointer.h	/^    bool operator<(BoundsCheckedPointer other) const$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(BoundsCheckedPointer other) const
operator <	.\BoundsCheckedPointer.h	/^    bool operator<(T* other) const$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(T* other) const
operator <	.\Spectrum.h	/^        bool operator<(const KeyAndCount& other) const$/;"	f	struct:WTF::Spectrum::KeyAndCount	access:public	signature:(const KeyAndCount& other) const
operator <<	.\Vector.h	/^    QDataStream& operator<<(QDataStream& stream, const Vector<T>& data)$/;"	f	namespace:WTF	signature:(QDataStream& stream, const Vector<T>& data)
operator <<	.\qt\StringQt.cpp	/^QDataStream& operator<<(QDataStream& stream, const String& str)$/;"	f	namespace:WTF	signature:(QDataStream& stream, const String& str)
operator <<	.\text\WTFString.h	/^QDataStream& operator<<(QDataStream& stream, const String& str);$/;"	p	namespace:WTF	signature:(QDataStream& stream, const String& str)
operator <=	.\BoundsCheckedPointer.h	/^    bool operator<=(BoundsCheckedPointer other) const$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(BoundsCheckedPointer other) const
operator <=	.\BoundsCheckedPointer.h	/^    bool operator<=(T* other) const$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(T* other) const
operator =	.\BitVector.h	/^    BitVector& operator=(const BitVector& other)$/;"	f	class:WTF::BitVector	access:public	signature:(const BitVector& other)
operator =	.\BoundsCheckedPointer.h	/^    BoundsCheckedPointer& operator=(T* value)$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(T* value)
operator =	.\CheckedArithmetic.h	/^    const Checked& operator=(Checked rhs)$/;"	f	class:WTF::Checked	access:public	signature:(Checked rhs)
operator =	.\CheckedArithmetic.h	/^    template <typename U, typename V> const Checked& operator=(const Checked<U, V>& rhs)$/;"	f	class:WTF::Checked	access:public	signature:(const Checked<U, V>& rhs)
operator =	.\CheckedArithmetic.h	/^    template <typename U> const Checked& operator=(U value)$/;"	f	class:WTF::Checked	access:public	signature:(U value)
operator =	.\CheckedArithmetic.h	/^    void operator=(double);$/;"	p	class:WTF::Checked	access:private	signature:(double)
operator =	.\CheckedArithmetic.h	/^    void operator=(float);$/;"	p	class:WTF::Checked	access:private	signature:(float)
operator =	.\Deque.h	/^        Base& operator=(const Base&);$/;"	p	class:WTF::DequeIteratorBase	access:protected	signature:(const Base&)
operator =	.\Deque.h	/^        Deque& operator=(const Deque<T, inlineCapacity>&);$/;"	p	class:WTF::Deque	access:public	signature:(const Deque<T, inlineCapacity>&)
operator =	.\Deque.h	/^        DequeConstIterator& operator=(const Iterator& other) { Base::assign(other); return *this; }$/;"	f	class:WTF::DequeConstIterator	access:public	signature:(const Iterator& other)
operator =	.\Deque.h	/^        DequeConstIterator& operator=(const NonConstIterator& other) { Base::assign(other); return *this; }$/;"	f	class:WTF::DequeConstIterator	access:public	signature:(const NonConstIterator& other)
operator =	.\Deque.h	/^        DequeConstReverseIterator& operator=(const Iterator& other) { Base::assign(other); return *this; }$/;"	f	class:WTF::DequeConstReverseIterator	access:public	signature:(const Iterator& other)
operator =	.\Deque.h	/^        DequeConstReverseIterator& operator=(const NonConstIterator& other) { Base::assign(other); return *this; }$/;"	f	class:WTF::DequeConstReverseIterator	access:public	signature:(const NonConstIterator& other)
operator =	.\Deque.h	/^        DequeIterator& operator=(const Iterator& other) { Base::assign(other); return *this; }$/;"	f	class:WTF::DequeIterator	access:public	signature:(const Iterator& other)
operator =	.\Deque.h	/^        DequeReverseIterator& operator=(const Iterator& other) { Base::assign(other); return *this; }$/;"	f	class:WTF::DequeReverseIterator	access:public	signature:(const Iterator& other)
operator =	.\Deque.h	/^    inline Deque<T, inlineCapacity>& Deque<T, inlineCapacity>::operator=(const Deque<T, inlineCapacity>& other)$/;"	f	class:WTF::Deque	signature:(const Deque<T, inlineCapacity>& other)
operator =	.\Deque.h	/^    inline DequeIteratorBase<T, inlineCapacity>& DequeIteratorBase<T, inlineCapacity>::operator=(const Base& other)$/;"	f	class:WTF::DequeIteratorBase	signature:(const Base& other)
operator =	.\HashMap.h	/^            HashMapKeysProxy& operator=(const HashMapKeysProxy&);$/;"	p	class:WTF::HashMap::HashMapKeysProxy	access:private	signature:(const HashMapKeysProxy&)
operator =	.\HashMap.h	/^            HashMapValuesProxy& operator=(const HashMapValuesProxy&);$/;"	p	class:WTF::HashMap::HashMapValuesProxy	access:private	signature:(const HashMapValuesProxy&)
operator =	.\HashTable.h	/^        HashTable& operator=(const HashTable&);$/;"	p	class:WTF::HashTable	access:public	signature:(const HashTable&)
operator =	.\HashTable.h	/^        const_iterator& operator=(const const_iterator& other)$/;"	f	class:WTF::HashTableConstIterator	access:public	signature:(const const_iterator& other)
operator =	.\HashTable.h	/^    HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>& HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::operator=(const HashTable& other)$/;"	f	class:WTF::HashTable	signature:(const HashTable& other)
operator =	.\ListHashSet.h	/^        ListHashSet& operator=(const ListHashSet&);$/;"	p	class:WTF::ListHashSet	access:public	signature:(const ListHashSet&)
operator =	.\ListHashSet.h	/^    inline ListHashSet<T, inlineCapacity, U>& ListHashSet<T, inlineCapacity, U>::operator=(const ListHashSet& other)$/;"	f	class:WTF::ListHashSet	signature:(const ListHashSet& other)
operator =	.\ListRefPtr.h	/^        ListRefPtr& operator=(T* optr) { RefPtr<T>::operator=(optr); return *this; }$/;"	f	class:WTF::ListRefPtr	access:public	signature:(T* optr)
operator =	.\ListRefPtr.h	/^        ListRefPtr& operator=(const PassRefPtr<T>& o) { RefPtr<T>::operator=(o); return *this; }$/;"	f	class:WTF::ListRefPtr	access:public	signature:(const PassRefPtr<T>& o)
operator =	.\ListRefPtr.h	/^        ListRefPtr& operator=(const RefPtr<T>& o) { RefPtr<T>::operator=(o); return *this; }$/;"	f	class:WTF::ListRefPtr	access:public	signature:(const RefPtr<T>& o)
operator =	.\ListRefPtr.h	/^        template <typename U> ListRefPtr& operator=(const PassRefPtr<U>& o) { RefPtr<T>::operator=(o); return *this; }$/;"	f	class:WTF::ListRefPtr	access:public	signature:(const PassRefPtr<U>& o)
operator =	.\ListRefPtr.h	/^        template <typename U> ListRefPtr& operator=(const RefPtr<U>& o) { RefPtr<T>::operator=(o); return *this; }$/;"	f	class:WTF::ListRefPtr	access:public	signature:(const RefPtr<U>& o)
operator =	.\OwnArrayPtr.h	/^    OwnArrayPtr& operator=(const PassOwnArrayPtr<T>&);$/;"	p	class:WTF::OwnArrayPtr	access:public	signature:(const PassOwnArrayPtr<T>&)
operator =	.\OwnArrayPtr.h	/^    OwnArrayPtr& operator=(std::nullptr_t) { clear(); return *this; }$/;"	f	class:WTF::OwnArrayPtr	access:public	signature:(std::nullptr_t)
operator =	.\OwnArrayPtr.h	/^    template<typename U> OwnArrayPtr& operator=(const PassOwnArrayPtr<U>&);$/;"	p	class:WTF::OwnArrayPtr	access:public	signature:(const PassOwnArrayPtr<U>&)
operator =	.\OwnArrayPtr.h	/^template<typename T> inline OwnArrayPtr<T>& OwnArrayPtr<T>::operator=(const PassOwnArrayPtr<T>& o)$/;"	f	class:WTF::OwnArrayPtr	signature:(const PassOwnArrayPtr<T>& o)
operator =	.\OwnArrayPtr.h	/^template<typename T> template<typename U> inline OwnArrayPtr<T>& OwnArrayPtr<T>::operator=(const PassOwnArrayPtr<U>& o)$/;"	f	class:WTF::OwnArrayPtr	signature:(const PassOwnArrayPtr<U>& o)
operator =	.\OwnPtr.h	/^        OwnPtr& operator=(const OwnPtr<T>&);$/;"	p	class:WTF::OwnPtr	access:private	signature:(const OwnPtr<T>&)
operator =	.\OwnPtr.h	/^        OwnPtr& operator=(const PassOwnPtr<T>&);$/;"	p	class:WTF::OwnPtr	access:public	signature:(const PassOwnPtr<T>&)
operator =	.\OwnPtr.h	/^        OwnPtr& operator=(std::nullptr_t) { clear(); return *this; }$/;"	f	class:WTF::OwnPtr	access:public	signature:(std::nullptr_t)
operator =	.\OwnPtr.h	/^        template<typename U> OwnPtr& operator=(const PassOwnPtr<U>&);$/;"	p	class:WTF::OwnPtr	access:public	signature:(const PassOwnPtr<U>&)
operator =	.\OwnPtr.h	/^    template<typename T> inline OwnPtr<T>& OwnPtr<T>::operator=(const PassOwnPtr<T>& o)$/;"	f	class:WTF::OwnPtr	signature:(const PassOwnPtr<T>& o)
operator =	.\OwnPtr.h	/^    template<typename T> template<typename U> inline OwnPtr<T>& OwnPtr<T>::operator=(const PassOwnPtr<U>& o)$/;"	f	class:WTF::OwnPtr	signature:(const PassOwnPtr<U>& o)
operator =	.\PackedIntVector.h	/^    PackedIntVector& operator=(const PackedIntVector& other)$/;"	f	class:WTF::PackedIntVector	access:public	signature:(const PackedIntVector& other)
operator =	.\PassOwnArrayPtr.h	/^    PassOwnArrayPtr& operator=(const PassOwnArrayPtr&) { COMPILE_ASSERT(!sizeof(T*), PassOwnArrayPtr_should_never_be_assigned_to); return *this; }$/;"	f	class:WTF::PassOwnArrayPtr	access:public	signature:(const PassOwnArrayPtr&)
operator =	.\PassOwnPtr.h	/^        PassOwnPtr& operator=(const PassOwnPtr&) { COMPILE_ASSERT(!sizeof(T*), PassOwnPtr_should_never_be_assigned_to); return *this; }$/;"	f	class:WTF::PassOwnPtr	access:public	signature:(const PassOwnPtr&)
operator =	.\PassRefPtr.h	/^        NonNullPassRefPtr& operator=(const NonNullPassRefPtr&) { COMPILE_ASSERT(!sizeof(T*), NonNullPassRefPtr_should_never_be_assigned_to); return *this; }$/;"	f	class:WTF::NonNullPassRefPtr	access:public	signature:(const NonNullPassRefPtr&)
operator =	.\PassRefPtr.h	/^        PassRefPtr& operator=(const PassRefPtr&) { COMPILE_ASSERT(!sizeof(T*), PassRefPtr_should_never_be_assigned_to); return *this; }$/;"	f	class:WTF::PassRefPtr	access:public	signature:(const PassRefPtr&)
operator =	.\RefCountedArray.h	/^    RefCountedArray& operator=(const RefCountedArray& other)$/;"	f	class:WTF::RefCountedArray	access:public	signature:(const RefCountedArray& other)
operator =	.\RefPtr.h	/^        RefPtr& operator=(T*);$/;"	p	class:WTF::RefPtr	access:public	signature:(T*)
operator =	.\RefPtr.h	/^        RefPtr& operator=(const NonNullPassRefPtr<T>&);$/;"	p	class:WTF::RefPtr	access:public	signature:(const NonNullPassRefPtr<T>&)
operator =	.\RefPtr.h	/^        RefPtr& operator=(const PassRefPtr<T>&);$/;"	p	class:WTF::RefPtr	access:public	signature:(const PassRefPtr<T>&)
operator =	.\RefPtr.h	/^        RefPtr& operator=(const RefPtr&);$/;"	p	class:WTF::RefPtr	access:public	signature:(const RefPtr&)
operator =	.\RefPtr.h	/^        RefPtr& operator=(std::nullptr_t) { clear(); return *this; }$/;"	f	class:WTF::RefPtr	access:public	signature:(std::nullptr_t)
operator =	.\RefPtr.h	/^        template<typename U> RefPtr& operator=(const NonNullPassRefPtr<U>&);$/;"	p	class:WTF::RefPtr	access:public	signature:(const NonNullPassRefPtr<U>&)
operator =	.\RefPtr.h	/^        template<typename U> RefPtr& operator=(const PassRefPtr<U>&);$/;"	p	class:WTF::RefPtr	access:public	signature:(const PassRefPtr<U>&)
operator =	.\RefPtr.h	/^        template<typename U> RefPtr& operator=(const RefPtr<U>&);$/;"	p	class:WTF::RefPtr	access:public	signature:(const RefPtr<U>&)
operator =	.\RefPtr.h	/^    template<typename T> inline RefPtr<T>& RefPtr<T>::operator=(T* optr)$/;"	f	class:WTF::RefPtr	signature:(T* optr)
operator =	.\RefPtr.h	/^    template<typename T> inline RefPtr<T>& RefPtr<T>::operator=(const NonNullPassRefPtr<T>& o)$/;"	f	class:WTF::RefPtr	signature:(const NonNullPassRefPtr<T>& o)
operator =	.\RefPtr.h	/^    template<typename T> inline RefPtr<T>& RefPtr<T>::operator=(const PassRefPtr<T>& o)$/;"	f	class:WTF::RefPtr	signature:(const PassRefPtr<T>& o)
operator =	.\RefPtr.h	/^    template<typename T> inline RefPtr<T>& RefPtr<T>::operator=(const RefPtr<T>& o)$/;"	f	class:WTF::RefPtr	signature:(const RefPtr<T>& o)
operator =	.\RefPtr.h	/^    template<typename T> template<typename U> inline RefPtr<T>& RefPtr<T>::operator=(const NonNullPassRefPtr<U>& o)$/;"	f	class:WTF::RefPtr	signature:(const NonNullPassRefPtr<U>& o)
operator =	.\RefPtr.h	/^    template<typename T> template<typename U> inline RefPtr<T>& RefPtr<T>::operator=(const PassRefPtr<U>& o)$/;"	f	class:WTF::RefPtr	signature:(const PassRefPtr<U>& o)
operator =	.\RefPtr.h	/^    template<typename T> template<typename U> inline RefPtr<T>& RefPtr<T>::operator=(const RefPtr<U>& o)$/;"	f	class:WTF::RefPtr	signature:(const RefPtr<U>& o)
operator =	.\RetainPtr.h	/^        RetainPtr& operator=(PtrType);$/;"	p	class:WTF::RetainPtr	access:public	signature:(PtrType)
operator =	.\RetainPtr.h	/^        RetainPtr& operator=(RetainPtr&&);$/;"	p	class:WTF::RetainPtr	access:public	signature:(RetainPtr&&)
operator =	.\RetainPtr.h	/^        RetainPtr& operator=(const RetainPtr&);$/;"	p	class:WTF::RetainPtr	access:public	signature:(const RetainPtr&)
operator =	.\RetainPtr.h	/^        RetainPtr& operator=(std::nullptr_t) { clear(); return *this; }$/;"	f	class:WTF::RetainPtr	access:public	signature:(std::nullptr_t)
operator =	.\RetainPtr.h	/^        template<typename U> RetainPtr& operator=(RetainPtr<U>&&);$/;"	p	class:WTF::RetainPtr	access:public	signature:(RetainPtr<U>&&)
operator =	.\RetainPtr.h	/^        template<typename U> RetainPtr& operator=(U*);$/;"	p	class:WTF::RetainPtr	access:public	signature:(U*)
operator =	.\RetainPtr.h	/^        template<typename U> RetainPtr& operator=(const RetainPtr<U>&);$/;"	p	class:WTF::RetainPtr	access:public	signature:(const RetainPtr<U>&)
operator =	.\RetainPtr.h	/^    template<typename T> inline RetainPtr<T>& RetainPtr<T>::operator=(PtrType optr)$/;"	f	class:WTF::RetainPtr	signature:(PtrType optr)
operator =	.\RetainPtr.h	/^    template<typename T> inline RetainPtr<T>& RetainPtr<T>::operator=(RetainPtr<T>&& o)$/;"	f	class:WTF::RetainPtr	signature:(RetainPtr<T>&& o)
operator =	.\RetainPtr.h	/^    template<typename T> inline RetainPtr<T>& RetainPtr<T>::operator=(const RetainPtr<T>& o)$/;"	f	class:WTF::RetainPtr	signature:(const RetainPtr<T>& o)
operator =	.\RetainPtr.h	/^    template<typename T> template<typename U> inline RetainPtr<T>& RetainPtr<T>::operator=(RetainPtr<U>&& o)$/;"	f	class:WTF::RetainPtr	signature:(RetainPtr<U>&& o)
operator =	.\RetainPtr.h	/^    template<typename T> template<typename U> inline RetainPtr<T>& RetainPtr<T>::operator=(U* optr)$/;"	f	class:WTF::RetainPtr	signature:(U* optr)
operator =	.\RetainPtr.h	/^    template<typename T> template<typename U> inline RetainPtr<T>& RetainPtr<T>::operator=(const RetainPtr<U>& o)$/;"	f	class:WTF::RetainPtr	signature:(const RetainPtr<U>& o)
operator =	.\SegmentedVector.h	/^        SegmentedVectorIterator& operator=(const SegmentedVectorIterator<T, SegmentSize>& other)$/;"	f	class:WTF::SegmentedVectorIterator	access:public	signature:(const SegmentedVectorIterator<T, SegmentSize>& other)
operator =	.\Vector.h	/^            VectorReverseProxy& operator=(const VectorReverseProxy&);$/;"	p	class:WTF::Vector::VectorReverseProxy	access:private	signature:(const VectorReverseProxy&)
operator =	.\Vector.h	/^        Vector& operator=(const Vector&);$/;"	p	class:WTF::Vector	access:public	signature:(const Vector&)
operator =	.\Vector.h	/^        Vector& operator=(const Vector<T, otherCapacity>&);$/;"	p	class:WTF::Vector	access:public	signature:(const Vector<T, otherCapacity>&)
operator =	.\Vector.h	/^    Vector<T, inlineCapacity>& Vector<T, inlineCapacity>::operator=(const Vector<T, inlineCapacity>& other)$/;"	f	class:WTF::Vector	signature:(const Vector<T, inlineCapacity>& other)
operator =	.\Vector.h	/^    Vector<T, inlineCapacity>& Vector<T, inlineCapacity>::operator=(const Vector<T, otherCapacity>& other)$/;"	f	class:WTF::Vector	signature:(const Vector<T, otherCapacity>& other)
operator =	.\gobject\GRefPtr.h	/^    GRefPtr& operator=(T*);$/;"	p	class:WTF::GRefPtr	access:public	signature:(T*)
operator =	.\gobject\GRefPtr.h	/^    GRefPtr& operator=(const GRefPtr&);$/;"	p	class:WTF::GRefPtr	access:public	signature:(const GRefPtr&)
operator =	.\gobject\GRefPtr.h	/^    template <typename U> GRefPtr& operator=(const GRefPtr<U>&);$/;"	p	class:WTF::GRefPtr	access:public	signature:(const GRefPtr<U>&)
operator =	.\gobject\GRefPtr.h	/^template <typename T> inline GRefPtr<T>& GRefPtr<T>::operator=(T* optr)$/;"	f	class:WTF::GRefPtr	signature:(T* optr)
operator =	.\gobject\GRefPtr.h	/^template <typename T> inline GRefPtr<T>& GRefPtr<T>::operator=(const GRefPtr<T>& o)$/;"	f	class:WTF::GRefPtr	signature:(const GRefPtr<T>& o)
operator ==	.\BoundsCheckedPointer.h	/^    bool operator==(BoundsCheckedPointer other) const$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(BoundsCheckedPointer other) const
operator ==	.\BoundsCheckedPointer.h	/^    bool operator==(T* other) const$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(T* other) const
operator ==	.\CheckedArithmetic.h	/^    template <typename U, typename V> const Checked operator==(Checked<U, V> rhs)$/;"	f	class:WTF::Checked	access:public	signature:(Checked<U, V> rhs)
operator ==	.\CheckedArithmetic.h	/^    template <typename U> bool operator==(U rhs)$/;"	f	class:WTF::Checked	access:public	signature:(U rhs)
operator ==	.\CheckedArithmetic.h	/^    template <typename V> bool operator==(Checked<T, V> rhs)$/;"	f	class:WTF::Checked	access:public	signature:(Checked<T, V> rhs)
operator ==	.\Deque.h	/^        bool operator==(const Iterator& other) const { return Base::isEqual(other); }$/;"	f	class:WTF::DequeConstIterator	access:public	signature:(const Iterator& other) const
operator ==	.\Deque.h	/^        bool operator==(const Iterator& other) const { return Base::isEqual(other); }$/;"	f	class:WTF::DequeConstReverseIterator	access:public	signature:(const Iterator& other) const
operator ==	.\Deque.h	/^        bool operator==(const Iterator& other) const { return Base::isEqual(other); }$/;"	f	class:WTF::DequeIterator	access:public	signature:(const Iterator& other) const
operator ==	.\Deque.h	/^        bool operator==(const Iterator& other) const { return Base::isEqual(other); }$/;"	f	class:WTF::DequeReverseIterator	access:public	signature:(const Iterator& other) const
operator ==	.\HashIterators.h	/^        inline bool operator==(const HashTableConstKeysIterator<T, U, V>& a, const HashTableConstKeysIterator<T, U, V>& b)$/;"	f	namespace:WTF	signature:(const HashTableConstKeysIterator<T, U, V>& a, const HashTableConstKeysIterator<T, U, V>& b)
operator ==	.\HashIterators.h	/^        inline bool operator==(const HashTableConstValuesIterator<T, U, V>& a, const HashTableConstValuesIterator<T, U, V>& b)$/;"	f	namespace:WTF	signature:(const HashTableConstValuesIterator<T, U, V>& a, const HashTableConstValuesIterator<T, U, V>& b)
operator ==	.\HashIterators.h	/^        inline bool operator==(const HashTableKeysIterator<T, U, V>& a, const HashTableKeysIterator<T, U, V>& b)$/;"	f	namespace:WTF	signature:(const HashTableKeysIterator<T, U, V>& a, const HashTableKeysIterator<T, U, V>& b)
operator ==	.\HashIterators.h	/^        inline bool operator==(const HashTableValuesIterator<T, U, V>& a, const HashTableValuesIterator<T, U, V>& b)$/;"	f	namespace:WTF	signature:(const HashTableValuesIterator<T, U, V>& a, const HashTableValuesIterator<T, U, V>& b)
operator ==	.\HashMap.h	/^    bool operator==(const HashMap<T, U, V, W, X>& a, const HashMap<T, U, V, W, X>& b)$/;"	f	namespace:WTF	signature:(const HashMap<T, U, V, W, X>& a, const HashMap<T, U, V, W, X>& b)
operator ==	.\HashTable.h	/^        bool operator==(const const_iterator& other) const { return m_iterator == other; }$/;"	f	class:WTF::HashTableIterator	access:public	signature:(const const_iterator& other) const
operator ==	.\HashTable.h	/^        bool operator==(const const_iterator& other) const$/;"	f	class:WTF::HashTableConstIterator	access:public	signature:(const const_iterator& other) const
operator ==	.\HashTable.h	/^        bool operator==(const iterator& other) const { return m_iterator == other.m_iterator; }$/;"	f	class:WTF::HashTableIterator	access:public	signature:(const iterator& other) const
operator ==	.\HashTable.h	/^        bool operator==(const iterator& other) const$/;"	f	class:WTF::HashTableConstIterator	access:public	signature:(const iterator& other) const
operator ==	.\HashTable.h	/^    inline bool operator==(const HashTableConstIteratorAdapter<T, U>& a, const HashTableConstIteratorAdapter<T, U>& b)$/;"	f	namespace:WTF	signature:(const HashTableConstIteratorAdapter<T, U>& a, const HashTableConstIteratorAdapter<T, U>& b)
operator ==	.\HashTable.h	/^    inline bool operator==(const HashTableConstIteratorAdapter<T, U>& a, const HashTableIteratorAdapter<T, U>& b)$/;"	f	namespace:WTF	signature:(const HashTableConstIteratorAdapter<T, U>& a, const HashTableIteratorAdapter<T, U>& b)
operator ==	.\HashTable.h	/^    inline bool operator==(const HashTableIteratorAdapter<T, U>& a, const HashTableConstIteratorAdapter<T, U>& b)$/;"	f	namespace:WTF	signature:(const HashTableIteratorAdapter<T, U>& a, const HashTableConstIteratorAdapter<T, U>& b)
operator ==	.\HashTable.h	/^    inline bool operator==(const HashTableIteratorAdapter<T, U>& a, const HashTableIteratorAdapter<T, U>& b)$/;"	f	namespace:WTF	signature:(const HashTableIteratorAdapter<T, U>& a, const HashTableIteratorAdapter<T, U>& b)
operator ==	.\ListHashSet.h	/^        bool operator==(const const_iterator& other) const$/;"	f	class:WTF::ListHashSetConstIterator	access:public	signature:(const const_iterator& other) const
operator ==	.\ListHashSet.h	/^        bool operator==(const const_reverse_iterator& other) const$/;"	f	class:WTF::ListHashSetConstReverseIterator	access:public	signature:(const const_reverse_iterator& other) const
operator ==	.\ListHashSet.h	/^        bool operator==(const iterator& other) const { return m_iterator == other.m_iterator; }$/;"	f	class:WTF::ListHashSetIterator	access:public	signature:(const iterator& other) const
operator ==	.\ListHashSet.h	/^        bool operator==(const reverse_iterator& other) const { return m_iterator == other.m_iterator; }$/;"	f	class:WTF::ListHashSetReverseIterator	access:public	signature:(const reverse_iterator& other) const
operator ==	.\MainThread.cpp	/^    bool operator == (const FunctionWithContext& o)$/;"	f	struct:WTF::FunctionWithContext	access:public	signature:(const FunctionWithContext& o)
operator ==	.\OwnArrayPtr.h	/^template<typename T, typename U> inline bool operator==(T* a, const OwnArrayPtr<U>& b) $/;"	f	namespace:WTF	signature:(T* a, const OwnArrayPtr<U>& b)
operator ==	.\OwnArrayPtr.h	/^template<typename T, typename U> inline bool operator==(const OwnArrayPtr<T>& a, U* b)$/;"	f	namespace:WTF	signature:(const OwnArrayPtr<T>& a, U* b)
operator ==	.\OwnPtr.h	/^        template<typename U> bool operator==(const OwnPtr<U>&) { COMPILE_ASSERT(!sizeof(U*), OwnPtrs_should_never_be_equal); return false; }$/;"	f	class:WTF::OwnPtr	access:private	signature:(const OwnPtr<U>&)
operator ==	.\OwnPtr.h	/^        template<typename U> bool operator==(const PassOwnPtr<U>&) { COMPILE_ASSERT(!sizeof(U*), OwnPtrs_should_never_be_equal); return false; }$/;"	f	class:WTF::OwnPtr	access:private	signature:(const PassOwnPtr<U>&)
operator ==	.\OwnPtr.h	/^    template<typename T, typename U> inline bool operator==(T* a, const OwnPtr<U>& b) $/;"	f	namespace:WTF	signature:(T* a, const OwnPtr<U>& b)
operator ==	.\OwnPtr.h	/^    template<typename T, typename U> inline bool operator==(const OwnPtr<T>& a, U* b)$/;"	f	namespace:WTF	signature:(const OwnPtr<T>& a, U* b)
operator ==	.\PassOwnArrayPtr.h	/^template<typename T, typename U> inline bool operator==(T* a, const PassOwnArrayPtr<U>& b) $/;"	f	namespace:WTF	signature:(T* a, const PassOwnArrayPtr<U>& b)
operator ==	.\PassOwnArrayPtr.h	/^template<typename T, typename U> inline bool operator==(const OwnArrayPtr<T>& a, const PassOwnArrayPtr<U>& b) $/;"	f	namespace:WTF	signature:(const OwnArrayPtr<T>& a, const PassOwnArrayPtr<U>& b)
operator ==	.\PassOwnArrayPtr.h	/^template<typename T, typename U> inline bool operator==(const PassOwnArrayPtr<T>& a, U* b) $/;"	f	namespace:WTF	signature:(const PassOwnArrayPtr<T>& a, U* b)
operator ==	.\PassOwnArrayPtr.h	/^template<typename T, typename U> inline bool operator==(const PassOwnArrayPtr<T>& a, const OwnArrayPtr<U>& b) $/;"	f	namespace:WTF	signature:(const PassOwnArrayPtr<T>& a, const OwnArrayPtr<U>& b)
operator ==	.\PassOwnArrayPtr.h	/^template<typename T, typename U> inline bool operator==(const PassOwnArrayPtr<T>& a, const PassOwnArrayPtr<U>& b) $/;"	f	namespace:WTF	signature:(const PassOwnArrayPtr<T>& a, const PassOwnArrayPtr<U>& b)
operator ==	.\PassOwnPtr.h	/^        template<typename U> bool operator==(const OwnPtr<U>&) { COMPILE_ASSERT(!sizeof(U*), OwnPtrs_should_never_be_equal); return false; }$/;"	f	class:WTF::PassOwnPtr	access:private	signature:(const OwnPtr<U>&)
operator ==	.\PassOwnPtr.h	/^        template<typename U> bool operator==(const PassOwnPtr<U>&) { COMPILE_ASSERT(!sizeof(U*), OwnPtrs_should_never_be_equal); return false; }$/;"	f	class:WTF::PassOwnPtr	access:private	signature:(const PassOwnPtr<U>&)
operator ==	.\PassOwnPtr.h	/^    template<typename T, typename U> inline bool operator==(T* a, const PassOwnPtr<U>& b) $/;"	f	namespace:WTF	signature:(T* a, const PassOwnPtr<U>& b)
operator ==	.\PassOwnPtr.h	/^    template<typename T, typename U> inline bool operator==(const OwnPtr<T>& a, const PassOwnPtr<U>& b) $/;"	f	namespace:WTF	signature:(const OwnPtr<T>& a, const PassOwnPtr<U>& b)
operator ==	.\PassOwnPtr.h	/^    template<typename T, typename U> inline bool operator==(const PassOwnPtr<T>& a, U* b) $/;"	f	namespace:WTF	signature:(const PassOwnPtr<T>& a, U* b)
operator ==	.\PassOwnPtr.h	/^    template<typename T, typename U> inline bool operator==(const PassOwnPtr<T>& a, const OwnPtr<U>& b) $/;"	f	namespace:WTF	signature:(const PassOwnPtr<T>& a, const OwnPtr<U>& b)
operator ==	.\PassOwnPtr.h	/^    template<typename T, typename U> inline bool operator==(const PassOwnPtr<T>& a, const PassOwnPtr<U>& b) $/;"	f	namespace:WTF	signature:(const PassOwnPtr<T>& a, const PassOwnPtr<U>& b)
operator ==	.\PassRefPtr.h	/^    template<typename T, typename U> inline bool operator==(T* a, const PassRefPtr<U>& b) $/;"	f	namespace:WTF	signature:(T* a, const PassRefPtr<U>& b)
operator ==	.\PassRefPtr.h	/^    template<typename T, typename U> inline bool operator==(const PassRefPtr<T>& a, U* b) $/;"	f	namespace:WTF	signature:(const PassRefPtr<T>& a, U* b)
operator ==	.\PassRefPtr.h	/^    template<typename T, typename U> inline bool operator==(const PassRefPtr<T>& a, const PassRefPtr<U>& b) $/;"	f	namespace:WTF	signature:(const PassRefPtr<T>& a, const PassRefPtr<U>& b)
operator ==	.\PassRefPtr.h	/^    template<typename T, typename U> inline bool operator==(const PassRefPtr<T>& a, const RefPtr<U>& b) $/;"	f	namespace:WTF	signature:(const PassRefPtr<T>& a, const RefPtr<U>& b)
operator ==	.\PassRefPtr.h	/^    template<typename T, typename U> inline bool operator==(const RefPtr<T>& a, const PassRefPtr<U>& b) $/;"	f	namespace:WTF	signature:(const RefPtr<T>& a, const PassRefPtr<U>& b)
operator ==	.\RefPtr.h	/^    template<typename T, typename U> inline bool operator==(T* a, const RefPtr<U>& b) $/;"	f	namespace:WTF	signature:(T* a, const RefPtr<U>& b)
operator ==	.\RefPtr.h	/^    template<typename T, typename U> inline bool operator==(const RefPtr<T>& a, U* b)$/;"	f	namespace:WTF	signature:(const RefPtr<T>& a, U* b)
operator ==	.\RefPtr.h	/^    template<typename T, typename U> inline bool operator==(const RefPtr<T>& a, const RefPtr<U>& b)$/;"	f	namespace:WTF	signature:(const RefPtr<T>& a, const RefPtr<U>& b)
operator ==	.\RetainPtr.h	/^    template<typename T, typename U> inline bool operator==(T* a, const RetainPtr<U>& b) $/;"	f	namespace:WTF	signature:(T* a, const RetainPtr<U>& b)
operator ==	.\RetainPtr.h	/^    template<typename T, typename U> inline bool operator==(const RetainPtr<T>& a, U* b)$/;"	f	namespace:WTF	signature:(const RetainPtr<T>& a, U* b)
operator ==	.\RetainPtr.h	/^    template<typename T, typename U> inline bool operator==(const RetainPtr<T>& a, const RetainPtr<U>& b)$/;"	f	namespace:WTF	signature:(const RetainPtr<T>& a, const RetainPtr<U>& b)
operator ==	.\SegmentedVector.h	/^        bool operator==(const Iterator& other) const$/;"	f	class:WTF::SegmentedVectorIterator	access:public	signature:(const Iterator& other) const
operator ==	.\Vector.h	/^    bool operator==(const Vector<T, inlineCapacity>& a, const Vector<T, inlineCapacity>& b)$/;"	f	namespace:WTF	signature:(const Vector<T, inlineCapacity>& a, const Vector<T, inlineCapacity>& b)
operator ==	.\gobject\GOwnPtr.h	/^template <typename T, typename U> inline bool operator==(T* a, const GOwnPtr<U>& b) $/;"	f	namespace:WTF	signature:(T* a, const GOwnPtr<U>& b)
operator ==	.\gobject\GOwnPtr.h	/^template <typename T, typename U> inline bool operator==(const GOwnPtr<T>& a, U* b)$/;"	f	namespace:WTF	signature:(const GOwnPtr<T>& a, U* b)
operator ==	.\gobject\GRefPtr.h	/^template <typename T, typename U> inline bool operator==(T* a, const GRefPtr<U>& b)$/;"	f	namespace:WTF	signature:(T* a, const GRefPtr<U>& b)
operator ==	.\gobject\GRefPtr.h	/^template <typename T, typename U> inline bool operator==(const GRefPtr<T>& a, U* b)$/;"	f	namespace:WTF	signature:(const GRefPtr<T>& a, U* b)
operator ==	.\gobject\GRefPtr.h	/^template <typename T, typename U> inline bool operator==(const GRefPtr<T>& a, const GRefPtr<U>& b)$/;"	f	namespace:WTF	signature:(const GRefPtr<T>& a, const GRefPtr<U>& b)
operator ==	.\text\AtomicString.h	/^bool operator==(const AtomicString&, const LChar*);$/;"	p	namespace:WTF	signature:(const AtomicString&, const LChar*)
operator ==	.\text\AtomicString.h	/^inline bool operator==(const AtomicString& a, const AtomicString& b) { return a.impl() == b.impl(); }$/;"	f	namespace:WTF	signature:(const AtomicString& a, const AtomicString& b)
operator ==	.\text\AtomicString.h	/^inline bool operator==(const AtomicString& a, const String& b) { return equal(a.impl(), b.impl()); }$/;"	f	namespace:WTF	signature:(const AtomicString& a, const String& b)
operator ==	.\text\AtomicString.h	/^inline bool operator==(const AtomicString& a, const Vector<UChar>& b) { return a.impl() && equal(a.impl(), b.data(), b.size()); }    $/;"	f	namespace:WTF	signature:(const AtomicString& a, const Vector<UChar>& b)
operator ==	.\text\AtomicString.h	/^inline bool operator==(const AtomicString& a, const char* b) { return WTF::equal(a.impl(), reinterpret_cast<const LChar*>(b)); }$/;"	f	namespace:WTF	signature:(const AtomicString& a, const char* b)
operator ==	.\text\AtomicString.h	/^inline bool operator==(const LChar* a, const AtomicString& b) { return b == a; }$/;"	f	namespace:WTF	signature:(const LChar* a, const AtomicString& b)
operator ==	.\text\AtomicString.h	/^inline bool operator==(const String& a, const AtomicString& b) { return equal(a.impl(), b.impl()); }$/;"	f	namespace:WTF	signature:(const String& a, const AtomicString& b)
operator ==	.\text\AtomicString.h	/^inline bool operator==(const Vector<UChar>& a, const AtomicString& b) { return b == a; }$/;"	f	namespace:WTF	signature:(const Vector<UChar>& a, const AtomicString& b)
operator ==	.\text\CString.cpp	/^bool operator==(const CString& a, const CString& b)$/;"	f	namespace:WTF	signature:(const CString& a, const CString& b)
operator ==	.\text\CString.h	/^WTF_EXPORT_PRIVATE bool operator==(const CString& a, const CString& b);$/;"	p	namespace:WTF	signature:(const CString& a, const CString& b)
operator ==	.\text\StringBuilder.h	/^inline bool operator==(const String& a, const StringBuilder& b) { return equal(b, a); }$/;"	f	namespace:WTF	signature:(const String& a, const StringBuilder& b)
operator ==	.\text\StringBuilder.h	/^inline bool operator==(const StringBuilder& a, const String& b) { return equal(a, b); }$/;"	f	namespace:WTF	signature:(const StringBuilder& a, const String& b)
operator ==	.\text\StringBuilder.h	/^inline bool operator==(const StringBuilder& a, const StringBuilder& b) { return equal(a, b); }$/;"	f	namespace:WTF	signature:(const StringBuilder& a, const StringBuilder& b)
operator ==	.\text\TextPosition.h	/^    bool operator==(OrdinalNumber other) { return m_zeroBasedValue == other.m_zeroBasedValue; }$/;"	f	class:WTF::OrdinalNumber	access:public	signature:(OrdinalNumber other)
operator ==	.\text\TextPosition.h	/^    bool operator==(const TextPosition& other) { return m_line == other.m_line && m_column == other.m_column; }$/;"	f	class:WTF::TextPosition	access:public	signature:(const TextPosition& other)
operator ==	.\text\WTFString.h	/^inline bool operator==(const LChar* a, const String& b) { return equal(a, b.impl()); }$/;"	f	namespace:WTF	signature:(const LChar* a, const String& b)
operator ==	.\text\WTFString.h	/^inline bool operator==(const String& a, const LChar* b) { return equal(a.impl(), b); }$/;"	f	namespace:WTF	signature:(const String& a, const LChar* b)
operator ==	.\text\WTFString.h	/^inline bool operator==(const String& a, const String& b) { return equal(a.impl(), b.impl()); }$/;"	f	namespace:WTF	signature:(const String& a, const String& b)
operator ==	.\text\WTFString.h	/^inline bool operator==(const String& a, const Vector<char, inlineCapacity>& b) { return b == a; }$/;"	f	namespace:WTF	signature:(const String& a, const Vector<char, inlineCapacity>& b)
operator ==	.\text\WTFString.h	/^inline bool operator==(const String& a, const char* b) { return equal(a.impl(), reinterpret_cast<const LChar*>(b)); }$/;"	f	namespace:WTF	signature:(const String& a, const char* b)
operator ==	.\text\WTFString.h	/^inline bool operator==(const Vector<char, inlineCapacity>& a, const String& b) { return equal(b.impl(), a.data(), a.size()); }$/;"	f	namespace:WTF	signature:(const Vector<char, inlineCapacity>& a, const String& b)
operator ==	.\text\WTFString.h	/^inline bool operator==(const char* a, const String& b) { return equal(reinterpret_cast<const LChar*>(a), b.impl()); }$/;"	f	namespace:WTF	signature:(const char* a, const String& b)
operator ==	.\url\src\URLComponent.h	/^    bool operator==(const URLComponent& other) const { return m_begin == other.m_begin && m_length == other.m_length; }$/;"	f	class:WTF::URLComponent	access:public	signature:(const URLComponent& other) const
operator >	.\BoundsCheckedPointer.h	/^    bool operator>(BoundsCheckedPointer other) const$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(BoundsCheckedPointer other) const
operator >	.\BoundsCheckedPointer.h	/^    bool operator>(T* other) const$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(T* other) const
operator >=	.\BoundsCheckedPointer.h	/^    bool operator>=(BoundsCheckedPointer other) const$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(BoundsCheckedPointer other) const
operator >=	.\BoundsCheckedPointer.h	/^    bool operator>=(T* other) const$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(T* other) const
operator >>	.\Vector.h	/^    QDataStream& operator>>(QDataStream& stream, Vector<T>& data)$/;"	f	namespace:WTF	signature:(QDataStream& stream, Vector<T>& data)
operator >>	.\qt\StringQt.cpp	/^QDataStream& operator>>(QDataStream& stream, String& str)$/;"	f	namespace:WTF	signature:(QDataStream& stream, String& str)
operator >>	.\text\WTFString.h	/^QDataStream& operator>>(QDataStream& stream, String& str);$/;"	p	namespace:WTF	signature:(QDataStream& stream, String& str)
operator AtomicString	.\text\StringOperators.h	/^    operator AtomicString() const$/;"	f	class:WTF::StringAppend	access:public	signature:() const
operator BlackBerry::WebKit::WebString	.\text\WTFString.h	/^    operator BlackBerry::WebKit::WebString() const;$/;"	p	class:WTF::String	access:public	signature:() const
operator BlockType	.\Functional.h	/^    operator BlockType() const$/;"	f	class:WTF::Function	access:public	signature:() const
operator HashTableConstIteratorAdapter<HashTableType, ValueType>	.\HashIterators.h	/^        operator HashTableConstIteratorAdapter<HashTableType, ValueType>() {$/;"	f	struct:WTF::HashTableIteratorAdapter	access:public	signature:()
operator HashTableConstIteratorAdapter<HashTableType, ValueType>	.\HashTable.h	/^        operator HashTableConstIteratorAdapter<HashTableType, ValueType>() {$/;"	f	struct:WTF::HashTableIteratorAdapter	access:public	signature:()
operator HashTableConstKeysIterator<HashTableType, KeyType, MappedType>	.\HashIterators.h	/^        operator HashTableConstKeysIterator<HashTableType, KeyType, MappedType>() {$/;"	f	struct:WTF::HashTableKeysIterator	access:public	signature:()
operator HashTableConstValuesIterator<HashTableType, KeyType, MappedType>	.\HashIterators.h	/^        operator HashTableConstValuesIterator<HashTableType, KeyType, MappedType>() {$/;"	f	struct:WTF::HashTableValuesIterator	access:public	signature:()
operator NSString*	.\text\AtomicString.h	/^    operator NSString*() const { return m_string; }$/;"	f	class:WTF::AtomicString	access:public	signature:() const
operator NSString*	.\text\StringImpl.h	/^    operator NSString*();$/;"	p	class:WTF::StringImpl	access:public	signature:()
operator NSString*	.\text\WTFString.h	/^    operator NSString*() const { if (!m_impl) return @""; return *m_impl; }$/;"	f	class:WTF::String	access:public	signature:() const
operator PossiblyNull<T>	.\FastMalloc.h	/^        template <typename T> operator PossiblyNull<T>()$/;"	f	struct:WTF::TryMallocReturnValue	access:public	signature:()
operator QString	.\qt\StringQt.cpp	/^String::operator QString() const$/;"	f	class:WTF::String	signature:() const
operator QString	.\text\AtomicString.h	/^    operator QString() const { return m_string; }$/;"	f	class:WTF::AtomicString	access:public	signature:() const
operator QString	.\text\WTFString.h	/^    operator QString() const;$/;"	p	class:WTF::String	access:public	signature:() const
operator String	.\text\StringOperators.h	/^    operator String() const$/;"	f	class:WTF::StringAppend	access:public	signature:() const
operator T*	.\ThreadSpecific.h	/^    operator T*();$/;"	p	class:WTF::ThreadSpecific	access:public	signature:()
operator T*	.\ThreadSpecific.h	/^inline ThreadSpecific<T>::operator T*()$/;"	f	class:WTF::ThreadSpecific	signature:()
operator UnspecifiedBoolType	.\OwnArrayPtr.h	/^    operator UnspecifiedBoolType() const { return m_ptr ? &OwnArrayPtr::m_ptr : 0; }$/;"	f	class:WTF::OwnArrayPtr	access:public	signature:() const
operator UnspecifiedBoolType	.\OwnPtr.h	/^        operator UnspecifiedBoolType() const { return m_ptr ? &OwnPtr::m_ptr : 0; }$/;"	f	class:WTF::OwnPtr	access:public	signature:() const
operator UnspecifiedBoolType	.\PassOwnArrayPtr.h	/^    operator UnspecifiedBoolType() const { return m_ptr ? &PassOwnArrayPtr::m_ptr : 0; }$/;"	f	class:WTF::PassOwnArrayPtr	access:public	signature:() const
operator UnspecifiedBoolType	.\PassOwnPtr.h	/^        operator UnspecifiedBoolType() const { return m_ptr ? &PassOwnPtr::m_ptr : 0; }$/;"	f	class:WTF::PassOwnPtr	access:public	signature:() const
operator UnspecifiedBoolType	.\PassRefPtr.h	/^        operator UnspecifiedBoolType() const { return m_ptr ? &PassRefPtr::m_ptr : 0; }$/;"	f	class:WTF::PassRefPtr	access:public	signature:() const
operator UnspecifiedBoolType	.\RefPtr.h	/^        operator UnspecifiedBoolType() const { return m_ptr ? &RefPtr::m_ptr : 0; }$/;"	f	class:WTF::RefPtr	access:public	signature:() const
operator UnspecifiedBoolType	.\RetainPtr.h	/^        operator UnspecifiedBoolType() const { return m_ptr ? &RetainPtr::m_ptr : 0; }$/;"	f	class:WTF::RetainPtr	access:public	signature:() const
operator UnspecifiedBoolType	.\gobject\GOwnPtr.h	/^    operator UnspecifiedBoolType() const { return m_ptr ? &GOwnPtr::m_ptr : 0; }$/;"	f	class:WTF::GOwnPtr	access:public	signature:() const
operator UnspecifiedBoolType	.\gobject\GRefPtr.h	/^    operator UnspecifiedBoolType() const { return m_ptr ? &GRefPtr::m_ptr : 0; }$/;"	f	class:WTF::GRefPtr	access:public	signature:() const
operator UnspecifiedBoolType*	.\CheckedArithmetic.h	/^    operator UnspecifiedBoolType*() const$/;"	f	class:WTF::Checked	access:public	signature:() const
operator UnspecifiedBoolTypeA	.\text\WTFString.h	/^    operator UnspecifiedBoolTypeA() const;$/;"	p	class:WTF::String	access:public	signature:() const
operator UnspecifiedBoolTypeB	.\text\WTFString.h	/^    operator UnspecifiedBoolTypeB() const;$/;"	p	class:WTF::String	access:public	signature:() const
operator []	.\AVLTree.h	/^    bool& operator[](unsigned i) { ASSERT(i < maxDepth); return m_data[i]; }$/;"	f	class:WTF::AVLTreeDefaultBSet	access:public	signature:(unsigned i)
operator []	.\BoundsCheckedPointer.h	/^    T& operator[](ptrdiff_t index)$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(ptrdiff_t index)
operator []	.\BoundsCheckedPointer.h	/^    const T& operator[](ptrdiff_t index) const$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(ptrdiff_t index) const
operator []	.\FixedArray.h	/^    T& operator[](size_t i)$/;"	f	class:WTF::FixedArray	access:public	signature:(size_t i)
operator []	.\FixedArray.h	/^    const T& operator[](size_t i) const$/;"	f	class:WTF::FixedArray	access:public	signature:(size_t i) const
operator []	.\OwnArrayPtr.h	/^    T& operator[](std::ptrdiff_t i) const { ASSERT(m_ptr); ASSERT(i >= 0); return m_ptr[i]; }$/;"	f	class:WTF::OwnArrayPtr	access:public	signature:(std::ptrdiff_t i) const
operator []	.\RefCountedArray.h	/^    T& operator[](size_t i) { return at(i); }$/;"	f	class:WTF::RefCountedArray	access:public	signature:(size_t i)
operator []	.\RefCountedArray.h	/^    const T& operator[](size_t i) const { return at(i); }$/;"	f	class:WTF::RefCountedArray	access:public	signature:(size_t i) const
operator []	.\SegmentedVector.h	/^        T& operator[](size_t index)$/;"	f	class:WTF::SegmentedVector	access:public	signature:(size_t index)
operator []	.\Vector.h	/^        T& operator[](size_t i) { return at(i); }$/;"	f	class:WTF::Vector	access:public	signature:(size_t i)
operator []	.\Vector.h	/^        const T& operator[](size_t i) const { return at(i); }$/;"	f	class:WTF::Vector	access:public	signature:(size_t i) const
operator []	.\dtoa\utils.h	/^        T& operator[](int index) const {$/;"	f	class:WTF::double_conversion::Vector	access:public	signature:(int index) const
operator []	.\text\AtomicString.h	/^    UChar operator[](unsigned int i) const { return m_string[i]; }$/;"	f	class:WTF::AtomicString	access:public	signature:(unsigned int i) const
operator []	.\text\StringBuffer.h	/^    UChar& operator[](unsigned i) { ASSERT(i < m_length); return m_data[i]; }$/;"	f	class:WTF::StringBuffer	access:public	signature:(unsigned i)
operator []	.\text\StringBuilder.h	/^    UChar operator[](unsigned i) const$/;"	f	class:WTF::StringBuilder	access:public	signature:(unsigned i) const
operator []	.\text\StringImpl.h	/^    UChar operator[](unsigned i) const$/;"	f	class:WTF::StringImpl	access:public	signature:(unsigned i) const
operator []	.\text\WTFString.h	/^    UChar operator[](unsigned index) const$/;"	f	class:WTF::String	access:public	signature:(unsigned index) const
operator bool	.\CheckedBoolean.h	/^    operator bool()$/;"	f	class:CheckedBoolean	access:public	signature:()
operator bool	.\PageBlock.h	/^    operator bool() const { return !!m_realBase; }$/;"	f	class:WTF::PageBlock	access:public	signature:() const
operator const String&	.\text\AtomicString.h	/^    operator const String&() const { return m_string; }$/;"	f	class:WTF::AtomicString	access:public	signature:() const
operator const_iterator	.\HashTable.h	/^        operator const_iterator() const { return m_iterator; }$/;"	f	class:WTF::HashTableIterator	access:public	signature:() const
operator const_iterator	.\ListHashSet.h	/^        operator const_iterator() const { return m_iterator; }$/;"	f	class:WTF::ListHashSetIterator	access:public	signature:() const
operator const_reverse_iterator	.\ListHashSet.h	/^        operator const_reverse_iterator() const { return m_iterator; }$/;"	f	class:WTF::ListHashSetReverseIterator	access:public	signature:() const
operator delete	.\FastMalloc.h	/^WTF_PRIVATE_INLINE void operator delete(void* p) throw() { fastFree(p); }$/;"	f	signature:(void* p)
operator delete	.\FastMalloc.h	/^WTF_PRIVATE_INLINE void operator delete(void* p, const std::nothrow_t&) throw() { fastFree(p); }$/;"	f	signature:(void* p, const std::nothrow_t&)
operator delete	.\wince\FastMallocWinCE.h	/^static inline void __cdecl operator delete(void* p) { fastFree(p); }$/;"	f	signature:(void* p)
operator delete	.\wince\FastMallocWinCE.h	/^static inline void operator delete(void* p, const std::nothrow_t&) throw() { fastFree(p); }$/;"	f	signature:(void* p, const std::nothrow_t&)
operator delete[]	.\FastMalloc.h	/^WTF_PRIVATE_INLINE void operator delete[](void* p) throw() { fastFree(p); }$/;"	f	signature:(void* p)
operator delete[]	.\FastMalloc.h	/^WTF_PRIVATE_INLINE void operator delete[](void* p, const std::nothrow_t&) throw() { fastFree(p); }$/;"	f	signature:(void* p, const std::nothrow_t&)
operator delete[]	.\wince\FastMallocWinCE.h	/^static inline void __cdecl operator delete[](void* p) { fastFree(p); }$/;"	f	signature:(void* p)
operator delete[]	.\wince\FastMallocWinCE.h	/^static inline void operator delete[](void* p, const std::nothrow_t&) throw() { fastFree(p); }$/;"	f	signature:(void* p, const std::nothrow_t&)
operator new	.\BumpPointerAllocator.h	/^    void* operator new(size_t size, const PageAllocation& allocation)$/;"	f	class:WTF::BumpPointerPool	access:private	signature:(size_t size, const PageAllocation& allocation)
operator new	.\FastMalloc.cpp	/^void* operator new(size_t size) {$/;"	f	namespace:WTF	signature:(size_t size)
operator new	.\FastMalloc.h	/^WTF_PRIVATE_INLINE void* operator new(size_t size) throw (std::bad_alloc) { return fastMalloc(size); }$/;"	f	signature:(size_t size)
operator new	.\FastMalloc.h	/^WTF_PRIVATE_INLINE void* operator new(size_t size, const std::nothrow_t&) throw() { return fastMalloc(size); }$/;"	f	signature:(size_t size, const std::nothrow_t&)
operator new	.\ListHashSet.h	/^        void* operator new(size_t, NodeAllocator* allocator)$/;"	f	struct:WTF::ListHashSetNode	access:public	signature:(size_t, NodeAllocator* allocator)
operator new	.\StdLibExtras.h	/^inline void* operator new(size_t, NotNullTag, void* location)$/;"	f	signature:(size_t, NotNullTag, void* location)
operator new	.\wince\FastMallocWinCE.h	/^static inline void* __cdecl operator new(size_t s) { return fastMalloc(s); }$/;"	f	signature:(size_t s)
operator new	.\wince\FastMallocWinCE.h	/^static inline void* operator new(size_t s, const std::nothrow_t&) throw() { return fastMalloc(s); }$/;"	f	signature:(size_t s, const std::nothrow_t&)
operator new[]	.\FastMalloc.cpp	/^void* operator new[](size_t size) {$/;"	f	namespace:WTF	signature:(size_t size)
operator new[]	.\FastMalloc.h	/^WTF_PRIVATE_INLINE void* operator new[](size_t size) throw (std::bad_alloc) { return fastMalloc(size); }$/;"	f	signature:(size_t size)
operator new[]	.\FastMalloc.h	/^WTF_PRIVATE_INLINE void* operator new[](size_t size, const std::nothrow_t&) throw() { return fastMalloc(size); }$/;"	f	signature:(size_t size, const std::nothrow_t&)
operator new[]	.\wince\FastMallocWinCE.h	/^static inline void* __cdecl operator new[](size_t s) { return fastMalloc(s); }$/;"	f	signature:(size_t s)
operator new[]	.\wince\FastMallocWinCE.h	/^static inline void* operator new[](size_t s, const std::nothrow_t&) throw() { return fastMalloc(s); }$/;"	f	signature:(size_t s, const std::nothrow_t&)
operator wxString	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE operator wxString() const;$/;"	p	class:WTF::String	access:public	signature:() const
operator wxString	.\wx\StringWx.cpp	/^String::operator wxString() const$/;"	f	class:WTF::String	signature:() const
origin	.\StackBounds.h	/^    void* origin() const$/;"	f	class:WTF::StackBounds	access:public	signature:() const
outOfLineBits	.\BitVector.h	/^    OutOfLineBits* outOfLineBits() { return bitwise_cast<OutOfLineBits*>(m_bitsOrPointer << 1); }$/;"	f	class:WTF::BitVector	access:private	signature:()
outOfLineBits	.\BitVector.h	/^    const OutOfLineBits* outOfLineBits() const { return bitwise_cast<const OutOfLineBits*>(m_bitsOrPointer << 1); }$/;"	f	class:WTF::BitVector	access:private	signature:() const
outPtr	.\gobject\GOwnPtr.h	/^    T*& outPtr()$/;"	f	class:WTF::GOwnPtr	access:public	signature:()
overall_thread_cache_size	.\FastMalloc.cpp	/^static size_t overall_thread_cache_size = kDefaultOverallThreadCacheSize;$/;"	v	file:
overflowed	.\CheckedArithmetic.h	/^    NO_RETURN_DUE_TO_CRASH void overflowed()$/;"	f	class:WTF::CrashOnOverflow	access:protected	signature:()
overflowed	.\CheckedArithmetic.h	/^    void overflowed()$/;"	f	class:WTF::RecordOverflow	access:protected	signature:()
owner	.\ThreadSpecific.h	/^        ThreadSpecific<T>* owner;$/;"	m	struct:WTF::ThreadSpecific::Data	access:public
ownerUID	.\MetaAllocatorHandle.h	/^    void* ownerUID()$/;"	f	class:WTF::MetaAllocatorHandle	access:public	signature:()
p	.\TCSystemAlloc.cpp	/^  void*  p;$/;"	m	union:MemoryAligner	file:	access:public
p5s	.\dtoa.cpp	/^static P5Node* p5s;$/;"	v	file:
p5sCount	.\dtoa.cpp	/^static int p5sCount;$/;"	v	file:
pad_	.\FastMalloc.cpp	/^  char pad_[(64 - (sizeof(TCMalloc_Central_FreeList) % 64)) % 64];$/;"	m	class:WTF::TCMalloc_Central_FreeListPadded	file:	access:private
padding	.\Functional.h	/^        char padding[8];$/;"	m	struct:WTF::HasRefAndDeref::NoType	access:public
padding	.\TypeTraits.h	/^                char padding[8];$/;"	m	struct:WTF::IsConvertibleToInteger::IsConvertibleToDouble::NoType	access:public
padding	.\TypeTraits.h	/^            char padding[8];$/;"	m	struct:WTF::IsSubclass::NoType	access:public
padding	.\TypeTraits.h	/^            char padding[8];$/;"	m	struct:WTF::IsSubclassOfTemplate::NoType	access:public
pageMask	.\PageBlock.cpp	/^size_t pageMask()$/;"	f	namespace:WTF	signature:()
pageMask	.\PageBlock.h	/^WTF_EXPORT_PRIVATE size_t pageMask();$/;"	p	namespace:WTF	signature:()
pageSize	.\PageBlock.cpp	/^size_t pageSize()$/;"	f	namespace:WTF	signature:()
pageSize	.\PageBlock.h	/^WTF_EXPORT_PRIVATE size_t pageSize();$/;"	p	namespace:WTF	signature:()
pageheap	.\FastMalloc.cpp	2512;"	d	file:
pageheap_bytes	.\FastMalloc.cpp	/^  uint64_t pageheap_bytes;      \/\/ Bytes in page heap$/;"	m	struct:WTF::TCMallocStats	file:	access:public
pageheap_lock	.\FastMalloc.cpp	/^static SpinLock pageheap_lock = SPINLOCK_INITIALIZER;$/;"	v	file:
pageheap_memory	.\FastMalloc.cpp	/^static AllocAlignmentInteger pageheap_memory[(sizeof(TCMalloc_PageHeap) + sizeof(AllocAlignmentInteger) - 1) \/ sizeof(AllocAlignmentInteger)];$/;"	v	file:
pagemap_	.\FastMalloc.cpp	/^  PageMap pagemap_;$/;"	m	class:WTF::TCMalloc_PageHeap	file:	access:private
pagemap_cache_	.\FastMalloc.cpp	/^  mutable PageMapCache pagemap_cache_;$/;"	m	class:WTF::TCMalloc_PageHeap	file:	access:private
pages	.\FastMalloc.cpp	/^static inline Length pages(size_t bytes) {$/;"	f	namespace:WTF	file:	signature:(size_t bytes)
pagesize	.\FastMalloc.cpp	/^static size_t pagesize = 0;$/;"	v	file:
pagesize	.\TCSystemAlloc.cpp	/^static size_t pagesize = 0;$/;"	v	file:
parameter	.\ParallelJobs.h	/^    Type& parameter(size_t i)$/;"	f	class:WTF::ParallelJobs	access:public	signature:(size_t i)
parent	.\RedBlackTree.h	/^        NodeType* parent() const$/;"	f	class:WTF::RedBlackTree::Node	access:private	signature:() const
parseAfterScheme	.\url\src\URLParser.h	/^    static void parseAfterScheme(const CharacterType* spec, int specLength, int afterScheme, URLSegments& parsed)$/;"	f	class:WTF::URLParser	access:public	signature:(const CharacterType* spec, int specLength, int afterScheme, URLSegments& parsed)
parseAuthority	.\url\src\URLParser.h	/^    static void parseAuthority(const CharacterType* spec, const URLComponent& auth, URLComponent& username, URLComponent& password, URLComponent& host, URLComponent& port)$/;"	f	class:WTF::URLParser	access:public	signature:(const CharacterType* spec, const URLComponent& auth, URLComponent& username, URLComponent& password, URLComponent& host, URLComponent& port)
parseDateFromNullTerminatedCharacters	.\DateMath.cpp	/^double parseDateFromNullTerminatedCharacters(const char* dateString)$/;"	f	namespace:WTF	signature:(const char* dateString)
parseDateFromNullTerminatedCharacters	.\DateMath.cpp	/^double parseDateFromNullTerminatedCharacters(const char* dateString, bool& haveTZ, int& offset)$/;"	f	namespace:WTF	signature:(const char* dateString, bool& haveTZ, int& offset)
parseDateFromNullTerminatedCharacters	.\DateMath.h	/^WTF_EXPORT_PRIVATE double parseDateFromNullTerminatedCharacters(const char* dateString);$/;"	p	namespace:WTF	signature:(const char* dateString)
parseDateFromNullTerminatedCharacters	.\DateMath.h	/^double parseDateFromNullTerminatedCharacters(const char* dateString, bool& haveTZ, int& offset);$/;"	p	namespace:WTF	signature:(const char* dateString, bool& haveTZ, int& offset)
parseES5DateFromNullTerminatedCharacters	.\DateMath.cpp	/^double parseES5DateFromNullTerminatedCharacters(const char* dateString)$/;"	f	namespace:WTF	signature:(const char* dateString)
parseES5DateFromNullTerminatedCharacters	.\DateMath.h	/^double parseES5DateFromNullTerminatedCharacters(const char* dateString);$/;"	p	namespace:WTF	signature:(const char* dateString)
parseES5DatePortion	.\DateMath.cpp	/^static char* parseES5DatePortion(const char* currentPosition, long& year, long& month, long& day)$/;"	f	namespace:WTF	file:	signature:(const char* currentPosition, long& year, long& month, long& day)
parseES5TimePortion	.\DateMath.cpp	/^static char* parseES5TimePortion(char* currentPosition, long& hours, long& minutes, double& seconds, long& timeZoneSeconds)$/;"	f	namespace:WTF	file:	signature:(char* currentPosition, long& hours, long& minutes, double& seconds, long& timeZoneSeconds)
parseLong	.\DateMath.cpp	/^static bool parseLong(const char* string, char** stopPosition, int base, long* result)$/;"	f	namespace:WTF	file:	signature:(const char* string, char** stopPosition, int base, long* result)
parseMailtoURL	.\url\src\URLParser.h	/^    static void parseMailtoURL(const CharacterType* spec, int specLength, URLSegments& parsed)$/;"	f	class:WTF::URLParser	access:public	signature:(const CharacterType* spec, int specLength, URLSegments& parsed)
parsePath	.\url\src\URLParser.h	/^    static void parsePath(const CharacterType* spec, const URLComponent& path, URLComponent& filepath, URLComponent& query, URLComponent& fragment)$/;"	f	class:WTF::URLParser	access:public	signature:(const CharacterType* spec, const URLComponent& path, URLComponent& filepath, URLComponent& query, URLComponent& fragment)
parsePathURL	.\url\src\URLParser.h	/^    static void parsePathURL(const CharacterType* spec, int specLength, URLSegments& parsed)$/;"	f	class:WTF::URLParser	access:public	signature:(const CharacterType* spec, int specLength, URLSegments& parsed)
parsePort	.\url\src\URLParser.h	/^    static int parsePort(const CharacterType* spec, const URLComponent& component)$/;"	f	class:WTF::URLParser	access:public	signature:(const CharacterType* spec, const URLComponent& component)
parseServerInfo	.\url\src\URLParser.h	/^    static void parseServerInfo(const CharacterType* spec, const URLComponent& serverInfo, URLComponent& host, URLComponent& port)$/;"	f	class:WTF::URLParser	access:private	signature:(const CharacterType* spec, const URLComponent& serverInfo, URLComponent& host, URLComponent& port)
parseStandardURL	.\url\src\URLParser.h	/^    static void parseStandardURL(const CharacterType* spec, int specLength, URLSegments& parsed)$/;"	f	class:WTF::URLParser	access:public	signature:(const CharacterType* spec, int specLength, URLSegments& parsed)
parseUserInfo	.\url\src\URLParser.h	/^    static void parseUserInfo(const CharacterType* spec, const URLComponent& user, URLComponent& username, URLComponent& password)$/;"	f	class:WTF::URLParser	access:private	signature:(const CharacterType* spec, const URLComponent& user, URLComponent& username, URLComponent& password)
passOut	.\HashTraits.h	/^        static PassOutType passOut(const T& value) { return value; }$/;"	f	struct:WTF::GenericHashTraits	access:public	signature:(const T& value)
passOut	.\HashTraits.h	/^        static PassOwnPtr<P> passOut(OwnPtr<P>& value) { return value.release(); }$/;"	f	struct:WTF::HashTraits	access:public	signature:(OwnPtr<P>& value)
passOut	.\HashTraits.h	/^        static PassOwnPtr<P> passOut(std::nullptr_t) { return nullptr; }$/;"	f	struct:WTF::HashTraits	access:public	signature:(std::nullptr_t)
password	.\url\api\ParsedURL.cpp	/^String ParsedURL::password() const$/;"	f	class:WTF::ParsedURL	signature:() const
password	.\url\api\ParsedURL.h	/^    WTF_EXPORT_PRIVATE String password() const;$/;"	p	class:WTF::ParsedURL	access:public	signature:() const
password	.\url\src\URLSegments.h	/^    URLComponent password;$/;"	m	class:WTF::URLSegments	access:public
pastPool	.\ListHashSet.h	/^        Node* pastPool() { return pool() + m_poolSize; }$/;"	f	struct:WTF::ListHashSetNodeAllocator	access:private	signature:()
path	.\url\api\ParsedURL.cpp	/^String ParsedURL::path() const$/;"	f	class:WTF::ParsedURL	signature:() const
path	.\url\api\ParsedURL.h	/^    WTF_EXPORT_PRIVATE String path() const;$/;"	p	class:WTF::ParsedURL	access:public	signature:() const
path	.\url\src\URLSegments.h	/^    URLComponent path;$/;"	m	class:WTF::URLSegments	access:public
path_h	.\AVLTree.h	/^        handle path_h[maxDepth - 1];$/;"	m	class:WTF::AVLTree::Iterator	access:protected
payload	.\RefCountedArray.h	/^        T* payload()$/;"	f	struct:WTF::RefCountedArray::Header	access:public	signature:()
peek	.\HashTraits.h	/^        static PeekType peek(const OwnPtr<P>& value) { return value.get(); }$/;"	f	struct:WTF::HashTraits	access:public	signature:(const OwnPtr<P>& value)
peek	.\HashTraits.h	/^        static PeekType peek(const T& value) { return value; }$/;"	f	struct:WTF::GenericHashTraits	access:public	signature:(const T& value)
peek	.\HashTraits.h	/^        static PeekType peek(std::nullptr_t) { return 0; }$/;"	f	struct:WTF::HashTraits	access:public	signature:(std::nullptr_t)
per_thread_cache_size	.\FastMalloc.cpp	/^static volatile size_t per_thread_cache_size = kMaxThreadCacheSize;$/;"	v	file:
percentage	.\text\AtomicString.h	/^    bool percentage(int& p) const { return m_string.percentage(p); }$/;"	f	class:WTF::AtomicString	access:public	signature:(int& p) const
percentage	.\text\WTFString.cpp	/^bool String::percentage(int& result) const$/;"	f	class:WTF::String	signature:(int& result) const
percentage	.\text\WTFString.h	/^    bool percentage(int& percentage) const;$/;"	p	class:WTF::String	access:public	signature:(int& percentage) const
periodicScavenge	.\FastMalloc.cpp	/^  void periodicScavenge();$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:private	signature:()
periodicScavenge	.\FastMalloc.cpp	/^void TCMalloc_PageHeap::periodicScavenge()$/;"	f	class:WTF::TCMalloc_PageHeap	signature:()
phinited	.\FastMalloc.cpp	/^static bool phinited = false;$/;"	v	file:
piDouble	.\MathExtras.h	/^const double piDouble = 3.14159265358979323846;$/;"	v
piDouble	.\MathExtras.h	/^const double piDouble = M_PI;$/;"	v
piFloat	.\MathExtras.h	/^const float piFloat = 3.14159265358979323846f;$/;"	v
piFloat	.\MathExtras.h	/^const float piFloat = static_cast<float>(M_PI);$/;"	v
piOverFourDouble	.\MathExtras.h	/^const double piOverFourDouble = 0.785398163397448309616;$/;"	v
piOverFourDouble	.\MathExtras.h	/^const double piOverFourDouble = M_PI_4;$/;"	v
piOverFourFloat	.\MathExtras.h	/^const float piOverFourFloat = 0.785398163397448309616f;$/;"	v
piOverFourFloat	.\MathExtras.h	/^const float piOverFourFloat = static_cast<float>(M_PI_4);$/;"	v
piOverTwoDouble	.\MathExtras.h	/^const double piOverTwoDouble = 1.57079632679489661923;$/;"	v
piOverTwoDouble	.\MathExtras.h	/^const double piOverTwoDouble = M_PI_2;$/;"	v
piOverTwoFloat	.\MathExtras.h	/^const float piOverTwoFloat = 1.57079632679489661923f;$/;"	v
piOverTwoFloat	.\MathExtras.h	/^const float piOverTwoFloat = static_cast<float>(M_PI_2);$/;"	v
pipeObject	.\efl\MainThreadEfl.cpp	/^static OwnPtr<Ecore_Pipe>& pipeObject()$/;"	f	namespace:WTF	file:	signature:()
placeByteAsHex	.\HexNumber.h	/^inline void placeByteAsHex(unsigned char byte, T& destination, HexConversionMode mode = Uppercase)$/;"	f	namespace:WTF	signature:(unsigned char byte, T& destination, HexConversionMode mode = Uppercase)
placeByteAsHexCompressIfPossible	.\HexNumber.h	/^inline void placeByteAsHexCompressIfPossible(unsigned char byte, T& destination, unsigned& index, HexConversionMode mode = Uppercase)$/;"	f	namespace:WTF	signature:(unsigned char byte, T& destination, unsigned& index, HexConversionMode mode = Uppercase)
pool	.\ListHashSet.h	/^            char pool[sizeof(Node) * m_poolSize];$/;"	m	union:WTF::ListHashSetNodeAllocator::__anon9	access:public
pool	.\ListHashSet.h	/^        Node* pool() { return reinterpret_cast_ptr<Node*>(m_pool.pool); }$/;"	f	struct:WTF::ListHashSetNodeAllocator	access:private	signature:()
pop	.\SinglyLinkedList.h	/^    Node* pop();$/;"	p	class:WTF::SinglyLinkedList	access:public	signature:()
pop	.\SinglyLinkedList.h	/^template <typename Node> inline Node* SinglyLinkedList<Node>::pop()$/;"	f	class:WTF::SinglyLinkedList	signature:()
popDirectionalFormatting	.\unicode\CharacterNames.h	/^const UChar popDirectionalFormatting = 0x202C;$/;"	v
port	.\url\api\ParsedURL.cpp	/^String ParsedURL::port() const$/;"	f	class:WTF::ParsedURL	signature:() const
port	.\url\api\ParsedURL.h	/^    WTF_EXPORT_PRIVATE String port() const;$/;"	p	class:WTF::ParsedURL	access:public	signature:() const
port	.\url\src\URLSegments.h	/^    URLComponent port;$/;"	m	class:WTF::URLSegments	access:public
position	.\dtoa\utils.h	/^        int position() const {$/;"	f	class:WTF::double_conversion::StringBuilder	access:public	signature:() const
position_	.\dtoa\utils.h	/^        int position_;$/;"	m	class:WTF::double_conversion::StringBuilder	access:private
pow	.\MathExtras.h	208;"	d
pow5mult	.\dtoa.cpp	/^static ALWAYS_INLINE void pow5mult(BigInt& b, int k)$/;"	f	namespace:WTF	file:	signature:(BigInt& b, int k)
precision	.\DecimalNumber.h	/^    unsigned precision() const { return m_precision; }$/;"	f	class:WTF::DecimalNumber	access:public	signature:() const
predecessor	.\RedBlackTree.h	/^        NodeType* predecessor()$/;"	f	class:WTF::RedBlackTree::Node	access:public	signature:()
predecessor	.\RedBlackTree.h	/^        const NodeType* predecessor() const$/;"	f	class:WTF::RedBlackTree::Node	access:public	signature:() const
prepend	.\Deque.h	/^        template<typename U> void prepend(const U&);$/;"	p	class:WTF::Deque	access:public	signature:(const U&)
prepend	.\Deque.h	/^    inline void Deque<T, inlineCapacity>::prepend(const U& value)$/;"	f	class:WTF::Deque	signature:(const U& value)
prepend	.\MessageQueue.h	/^        void prepend(PassOwnPtr<DataType>);$/;"	p	class:WTF::MessageQueue	access:public	signature:(PassOwnPtr<DataType>)
prepend	.\MessageQueue.h	/^    inline void MessageQueue<DataType>::prepend(PassOwnPtr<DataType> message)$/;"	f	class:WTF::MessageQueue	signature:(PassOwnPtr<DataType> message)
prepend	.\Vector.h	/^        template<typename U, size_t c> void prepend(const Vector<U, c>&);$/;"	p	class:WTF::Vector	access:public	signature:(const Vector<U, c>&)
prepend	.\Vector.h	/^        template<typename U> void prepend(const U&);$/;"	p	class:WTF::Vector	access:public	signature:(const U&)
prepend	.\Vector.h	/^        template<typename U> void prepend(const U*, size_t);$/;"	p	class:WTF::Vector	access:public	signature:(const U*, size_t)
prepend	.\Vector.h	/^    inline void Vector<T, inlineCapacity>::prepend(const U& val)$/;"	f	class:WTF::Vector	signature:(const U& val)
prepend	.\Vector.h	/^    inline void Vector<T, inlineCapacity>::prepend(const Vector<U, c>& val)$/;"	f	class:WTF::Vector	signature:(const Vector<U, c>& val)
prepend	.\Vector.h	/^    void Vector<T, inlineCapacity>::prepend(const U* data, size_t dataSize)$/;"	f	class:WTF::Vector	signature:(const U* data, size_t dataSize)
prev	.\DoublyLinkedList.h	/^    T* prev() const;$/;"	p	class:WTF::DoublyLinkedListNode	access:public	signature:() const
prev	.\DoublyLinkedList.h	/^template<typename T> inline T* DoublyLinkedListNode<T>::prev() const$/;"	f	class:WTF::DoublyLinkedListNode	signature:() const
prev	.\FastMalloc.cpp	/^  Span*         prev;           \/\/ Used when in link list$/;"	m	struct:WTF::Span	file:	access:public
prev	.\SentinelLinkedList.h	/^    T* prev() { return static_cast<T*>(m_prev); }$/;"	f	class:WTF::BasicRawSentinelNode	access:public	signature:()
prev_	.\FastMalloc.cpp	/^  TCMalloc_ThreadCache* prev_;$/;"	m	class:WTF::TCMalloc_ThreadCache	file:	access:public
primes_list	.\FastMalloc.cpp	/^static int primes_list[] = {$/;"	v	file:
print	.\FastMalloc.cpp	/^    static void  print(malloc_zone_t*, boolean_t) { }$/;"	f	class:WTF::FastMallocZone	access:public	signature:(malloc_zone_t*, boolean_t)
printCallSite	.\Assertions.cpp	/^static void printCallSite(const char* file, int line, const char* function)$/;"	f	file:	signature:(const char* file, int line, const char* function)
printf_stderr_common	.\Assertions.cpp	/^static void printf_stderr_common(const char* format, ...)$/;"	f	file:	signature:(const char* format, ...)
private_lock_	.\TCSpinLock.h	/^  pthread_mutex_t private_lock_;$/;"	m	struct:TCMalloc_SpinLock	access:public
processBlock	.\SHA1.cpp	/^void SHA1::processBlock()$/;"	f	class:WTF::SHA1	signature:()
processBlock	.\SHA1.h	/^    void processBlock();$/;"	p	class:WTF::SHA1	access:private	signature:()
properties	.\unicode\qt4\UnicodeQt4.h	/^    Q_CORE_EXPORT const Properties * QT_FASTCALL properties(uint ucs4);$/;"	p	namespace:QUnicodeTables	signature:(uint ucs4)
properties	.\unicode\qt4\UnicodeQt4.h	/^    Q_CORE_EXPORT const Properties * QT_FASTCALL properties(ushort ucs2);$/;"	p	namespace:QUnicodeTables	signature:(ushort ucs2)
protection	.\OSAllocatorWin.cpp	/^static inline DWORD protection(bool writable, bool executable)$/;"	f	namespace:WTF	file:	signature:(bool writable, bool executable)
pthreadHandleForIdentifier	.\ThreadingPthreads.cpp	/^static pthread_t pthreadHandleForIdentifier(ThreadIdentifier id)$/;"	f	namespace:WTF	file:	signature:(ThreadIdentifier id)
pthread_getspecific	.\FastMalloc.cpp	476;"	d	file:
pthread_getspecific	.\FastMalloc.cpp	478;"	d	file:
pthread_getspecific_function_pointer	.\FastMalloc.cpp	/^static void* (*pthread_getspecific_function_pointer)(pthread_key_t) = pthread_getspecific;$/;"	v	file:
pthread_setspecific	.\FastMalloc.cpp	479;"	d	file:
ptrs	.\TCPageMap.h	/^    Node* ptrs[INTERIOR_LENGTH];$/;"	m	struct:TCMalloc_PageMap3::Node	access:public
purge	.\AVLTree.h	/^    void purge() { abs.root = null(); }$/;"	f	class:WTF::AVLTree	access:public	signature:()
push	.\DoublyLinkedList.h	/^    void push(T*);$/;"	p	class:WTF::DoublyLinkedList	access:public	signature:(T*)
push	.\DoublyLinkedList.h	/^template<typename T> inline void DoublyLinkedList<T>::push(T* node)$/;"	f	class:WTF::DoublyLinkedList	signature:(T* node)
push	.\SentinelLinkedList.h	/^    void push(T*);$/;"	p	class:WTF::SentinelLinkedList	access:public	signature:(T*)
push	.\SentinelLinkedList.h	/^template <typename T, typename RawNode> inline void SentinelLinkedList<T, RawNode>::push(T* node)$/;"	f	class:WTF::SentinelLinkedList	signature:(T* node)
push	.\SinglyLinkedList.h	/^    void push(Node*);$/;"	p	class:WTF::SinglyLinkedList	access:public	signature:(Node*)
push	.\SinglyLinkedList.h	/^template <typename Node> inline void SinglyLinkedList<Node>::push(Node* node)$/;"	f	class:WTF::SinglyLinkedList	signature:(Node* node)
putUTF8Triple	.\text\WTFString.cpp	/^static inline void putUTF8Triple(char*& buffer, UChar ch)$/;"	f	namespace:WTF	file:	signature:(char*& buffer, UChar ch)
qguiapplication_h	.\qt\compat\qguiapplication.h	21;"	d
qpcAvailable	.\CurrentTime.cpp	/^static bool qpcAvailable()$/;"	f	namespace:WTF	file:	signature:()
qpcFrequency	.\CurrentTime.cpp	/^static LARGE_INTEGER qpcFrequency;$/;"	v	file:
query	.\url\api\ParsedURL.cpp	/^String ParsedURL::query() const$/;"	f	class:WTF::ParsedURL	signature:() const
query	.\url\api\ParsedURL.h	/^    WTF_EXPORT_PRIVATE String query() const;$/;"	p	class:WTF::ParsedURL	access:public	signature:() const
query	.\url\src\URLSegments.h	/^    URLComponent query;$/;"	m	class:WTF::URLSegments	access:public
quickClear	.\BitVector.h	/^    void quickClear(size_t bit)$/;"	f	class:WTF::BitVector	access:public	signature:(size_t bit)
quickGet	.\BitVector.h	/^    bool quickGet(size_t bit) const$/;"	f	class:WTF::BitVector	access:public	signature:(size_t bit) const
quickSet	.\BitVector.h	/^    void quickSet(size_t bit)$/;"	f	class:WTF::BitVector	access:public	signature:(size_t bit)
quickSet	.\BitVector.h	/^    void quickSet(size_t bit, bool value)$/;"	f	class:WTF::BitVector	access:public	signature:(size_t bit, bool value)
quorem	.\dtoa.cpp	/^static ALWAYS_INLINE int quorem(BigInt& b, BigInt& S)$/;"	f	namespace:WTF	file:	signature:(BigInt& b, BigInt& S)
rad2deg	.\MathExtras.h	/^inline double rad2deg(double r)  { return r * 180.0 \/ piDouble; }$/;"	f	signature:(double r)
rad2deg	.\MathExtras.h	/^inline float rad2deg(float r)  { return r * 180.0f \/ piFloat; }$/;"	f	signature:(float r)
rad2grad	.\MathExtras.h	/^inline double rad2grad(double r) { return r * 200.0 \/ piDouble; }$/;"	f	signature:(double r)
rad2grad	.\MathExtras.h	/^inline float rad2grad(float r) { return r * 200.0f \/ piFloat; }$/;"	f	signature:(float r)
randomNumber	.\CryptographicallyRandomNumber.cpp	/^    uint32_t randomNumber();$/;"	p	class:WTF::__anon3::ARC4RandomNumberGenerator	file:	access:public	signature:()
randomNumber	.\CryptographicallyRandomNumber.cpp	/^uint32_t ARC4RandomNumberGenerator::randomNumber()$/;"	f	class:WTF::__anon3::ARC4RandomNumberGenerator	signature:()
randomNumber	.\RandomNumber.cpp	/^double randomNumber()$/;"	f	namespace:WTF	signature:()
randomNumber	.\RandomNumber.h	/^    WTF_EXPORT_PRIVATE double randomNumber();$/;"	p	namespace:WTF	signature:()
randomValues	.\CryptographicallyRandomNumber.cpp	/^    void randomValues(void* buffer, size_t length);$/;"	p	class:WTF::__anon3::ARC4RandomNumberGenerator	file:	access:public	signature:(void* buffer, size_t length)
randomValues	.\CryptographicallyRandomNumber.cpp	/^void ARC4RandomNumberGenerator::randomValues(void* buffer, size_t length)$/;"	f	class:WTF::__anon3::ARC4RandomNumberGenerator	signature:(void* buffer, size_t length)
rawHash	.\text\StringImpl.h	/^    unsigned rawHash() const$/;"	f	class:WTF::StringImpl	access:private	signature:() const
rbegin	.\Deque.h	/^        const_reverse_iterator rbegin() const { return const_reverse_iterator(this, m_end); }$/;"	f	class:WTF::Deque	access:public	signature:() const
rbegin	.\Deque.h	/^        reverse_iterator rbegin() { return reverse_iterator(this, m_end); }$/;"	f	class:WTF::Deque	access:public	signature:()
rbegin	.\ListHashSet.h	/^        const_reverse_iterator rbegin() const;$/;"	p	class:WTF::ListHashSet	access:public	signature:() const
rbegin	.\ListHashSet.h	/^        reverse_iterator rbegin();$/;"	p	class:WTF::ListHashSet	access:public	signature:()
rbegin	.\ListHashSet.h	/^    inline typename ListHashSet<T, inlineCapacity, U>::const_reverse_iterator ListHashSet<T, inlineCapacity, U>::rbegin() const$/;"	f	class:WTF::ListHashSet	signature:() const
rbegin	.\ListHashSet.h	/^    inline typename ListHashSet<T, inlineCapacity, U>::reverse_iterator ListHashSet<T, inlineCapacity, U>::rbegin()$/;"	f	class:WTF::ListHashSet	signature:()
rbegin	.\Vector.h	/^        const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); }$/;"	f	class:WTF::Vector	access:public	signature:() const
rbegin	.\Vector.h	/^        reverse_iterator rbegin() { return reverse_iterator(end()); }$/;"	f	class:WTF::Vector	access:public	signature:()
readLock	.\ThreadingPrimitives.h	/^    void readLock();$/;"	p	class:WTF::ReadWriteLock	access:public	signature:()
readLock	.\ThreadingPthreads.cpp	/^void ReadWriteLock::readLock()$/;"	f	class:WTF::ReadWriteLock	signature:()
readUTF8Sequence	.\unicode\UTF8.cpp	/^static inline UChar32 readUTF8Sequence(const char*& sequence, unsigned length)$/;"	f	namespace:WTF::Unicode	file:	signature:(const char*& sequence, unsigned length)
realloc	.\FastMalloc.cpp	/^ALWAYS_INLINE void* realloc(void*, size_t);$/;"	p	namespace:WTF	file:	signature:(void*, size_t)
realloc	.\FastMalloc.cpp	/^void* realloc(void* old_ptr, size_t new_size) {$/;"	f	namespace:WTF	signature:(void* old_ptr, size_t new_size)
realloc	.\FastMalloc.cpp	4659;"	d	file:
realloc	.\FastMalloc.cpp	501;"	d	file:
realloc	.\wince\FastMallocWinCE.h	54;"	d
realloc	.\wince\MemoryManager.cpp	25;"	d	file:
reallocate	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::reallocate(PassRefPtr<StringImpl> originalString, unsigned length, LChar*& data)$/;"	f	class:WTF::StringImpl	signature:(PassRefPtr<StringImpl> originalString, unsigned length, LChar*& data)
reallocate	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::reallocate(PassRefPtr<StringImpl> originalString, unsigned length, UChar*& data)$/;"	f	class:WTF::StringImpl	signature:(PassRefPtr<StringImpl> originalString, unsigned length, UChar*& data)
reallocate	.\text\StringImpl.h	/^    static PassRefPtr<StringImpl> reallocate(PassRefPtr<StringImpl> originalString, unsigned length, LChar*& data);$/;"	p	class:WTF::StringImpl	access:public	signature:(PassRefPtr<StringImpl> originalString, unsigned length, LChar*& data)
reallocate	.\text\StringImpl.h	/^    static PassRefPtr<StringImpl> reallocate(PassRefPtr<StringImpl> originalString, unsigned length, UChar*& data);$/;"	p	class:WTF::StringImpl	access:public	signature:(PassRefPtr<StringImpl> originalString, unsigned length, UChar*& data)
reallocateBuffer	.\text\StringBuilder.cpp	/^void StringBuilder::reallocateBuffer<LChar>(unsigned requiredLength)$/;"	f	class:WTF::StringBuilder	signature:(unsigned requiredLength)
reallocateBuffer	.\text\StringBuilder.cpp	/^void StringBuilder::reallocateBuffer<UChar>(unsigned requiredLength)$/;"	f	class:WTF::StringBuilder	signature:(unsigned requiredLength)
reallocateBuffer	.\text\StringBuilder.h	/^    void reallocateBuffer(unsigned requiredLength);$/;"	p	class:WTF::StringBuilder	access:private	signature:(unsigned requiredLength)
reallocateCommitted	.\OSAllocator.h	/^    static T* reallocateCommitted(T*, size_t oldSize, size_t newSize, Usage = UnknownUsage, bool writable = true, bool executable = false);$/;"	p	class:WTF::OSAllocator	access:public	signature:(T*, size_t oldSize, size_t newSize, Usage = UnknownUsage, bool writable = true, bool executable = false)
reallocateCommitted	.\OSAllocator.h	/^inline T* OSAllocator::reallocateCommitted(T* oldBase, size_t oldSize, size_t newSize, Usage usage, bool writable, bool executable)$/;"	f	class:WTF::OSAllocator	signature:(T* oldBase, size_t oldSize, size_t newSize, Usage usage, bool writable, bool executable)
recordAdministrativeRegions	.\FastMalloc.cpp	/^  void recordAdministrativeRegions(Recorder& recorder, const RemoteMemoryReader& reader)$/;"	f	class:WTF::PageHeapAllocator	access:public	signature:(Recorder& recorder, const RemoteMemoryReader& reader)
recordCollisionAtCount	.\HashTable.cpp	/^void HashTableStats::recordCollisionAtCount(int count)$/;"	f	class:WTF::HashTableStats	signature:(int count)
recordCollisionAtCount	.\HashTable.h	/^        static void recordCollisionAtCount(int count);$/;"	p	struct:WTF::HashTableStats	access:public	signature:(int count)
recordPendingRegions	.\FastMalloc.cpp	/^    void recordPendingRegions()$/;"	f	class:WTF::AdminRegionRecorder	access:public	signature:()
recordPendingRegions	.\FastMalloc.cpp	/^    void recordPendingRegions()$/;"	f	class:WTF::PageMapMemoryUsageRecorder	access:public	signature:()
recordRegion	.\FastMalloc.cpp	/^    void recordRegion(vm_address_t ptr, size_t size)$/;"	f	class:WTF::AdminRegionRecorder	access:public	signature:(vm_address_t ptr, size_t size)
recursionCheck	.\StackBounds.h	/^    bool recursionCheck(size_t minAvailableDelta = s_defaultAvailabilityDelta) const$/;"	f	class:WTF::StackBounds	access:public	signature:(size_t minAvailableDelta = s_defaultAvailabilityDelta) const
recursionLimit	.\StackBounds.h	/^    void* recursionLimit(size_t minAvailableDelta = s_defaultAvailabilityDelta) const$/;"	f	class:WTF::StackBounds	access:public	signature:(size_t minAvailableDelta = s_defaultAvailabilityDelta) const
ref	.\Functional.h	/^        void ref();$/;"	p	struct:WTF::HasRefAndDeref::BaseMixin	access:public	signature:()
ref	.\Functional.h	/^    static void ref(T) { }$/;"	f	struct:WTF::RefAndDeref	access:public	signature:(T)
ref	.\Functional.h	/^    static void ref(T* t) { t->ref(); }$/;"	f	struct:WTF::RefAndDeref	access:public	signature:(T* t)
ref	.\RefCounted.h	/^    void ref()$/;"	f	class:WTF::RefCountedBase	access:public	signature:()
ref	.\ThreadSafeRefCounted.h	/^    void ref()$/;"	f	class:WTF::ThreadSafeRefCountedBase	access:public	signature:()
ref	.\text\StringImpl.h	/^    inline void ref()$/;"	f	class:WTF::StringImpl	access:public	signature:()
refCheck	.\Functional.h	/^    static NoType refCheck(U*, TypeChecker<void (BaseMixin::*)(), &U::ref>* = 0);$/;"	p	class:WTF::HasRefAndDeref	access:private	signature:(U*, TypeChecker<void (BaseMixin::*)(), &U::ref>* = 0)
refCheck	.\Functional.h	/^    static YesType refCheck(...);$/;"	p	class:WTF::HasRefAndDeref	access:private	signature:(....)
refCount	.\RefCounted.h	/^    int refCount() const$/;"	f	class:WTF::RefCountedBase	access:public	signature:() const
refCount	.\RefCountedArray.h	/^        unsigned refCount;$/;"	m	struct:WTF::RefCountedArray::Header	access:public
refCount	.\ThreadSafeRefCounted.h	/^    int refCount() const$/;"	f	class:WTF::ThreadSafeRefCountedBase	access:public	signature:() const
refGPtr	.\gobject\GRefPtr.cpp	/^template <> GHashTable* refGPtr(GHashTable* ptr)$/;"	f	namespace:WTF	signature:(GHashTable* ptr)
refGPtr	.\gobject\GRefPtr.cpp	/^template <> GMainContext* refGPtr(GMainContext* ptr)$/;"	f	namespace:WTF	signature:(GMainContext* ptr)
refGPtr	.\gobject\GRefPtr.cpp	/^template <> GMainLoop* refGPtr(GMainLoop* ptr)$/;"	f	namespace:WTF	signature:(GMainLoop* ptr)
refGPtr	.\gobject\GRefPtr.cpp	/^template <> GSource* refGPtr(GSource* ptr)$/;"	f	namespace:WTF	signature:(GSource* ptr)
refGPtr	.\gobject\GRefPtr.cpp	/^template <> GVariant* refGPtr(GVariant* ptr)$/;"	f	namespace:WTF	signature:(GVariant* ptr)
refGPtr	.\gobject\GRefPtr.h	/^template <> GHashTable* refGPtr(GHashTable* ptr);$/;"	p	namespace:WTF	signature:(GHashTable* ptr)
refGPtr	.\gobject\GRefPtr.h	/^template <> GMainContext* refGPtr(GMainContext* ptr);$/;"	p	namespace:WTF	signature:(GMainContext* ptr)
refGPtr	.\gobject\GRefPtr.h	/^template <> GMainLoop* refGPtr(GMainLoop* ptr);$/;"	p	namespace:WTF	signature:(GMainLoop* ptr)
refGPtr	.\gobject\GRefPtr.h	/^template <> GSource* refGPtr(GSource* ptr);$/;"	p	namespace:WTF	signature:(GSource* ptr)
refGPtr	.\gobject\GRefPtr.h	/^template <> GVariant* refGPtr(GVariant* ptr);$/;"	p	namespace:WTF	signature:(GVariant* ptr)
refGPtr	.\gobject\GRefPtr.h	/^template <typename T> inline T* refGPtr(T* ptr)$/;"	f	namespace:WTF	signature:(T* ptr)
refGPtr	.\gobject\GRefPtr.h	/^template <typename T> inline T* refGPtr(T*);$/;"	p	namespace:WTF	signature:(T*)
refIfNotNull	.\PassRefPtr.h	/^    template<typename T> REF_DEREF_INLINE void refIfNotNull(T* ptr)$/;"	f	namespace:WTF	signature:(T* ptr)
refcount	.\FastMalloc.cpp	/^  unsigned int  refcount : 11;  \/\/ Number of non-free objects$/;"	m	struct:WTF::Span	file:	access:public
registerGCThread	.\MainThread.cpp	/^void registerGCThread()$/;"	f	namespace:WTF	signature:()
registerGCThread	.\MainThread.h	/^void registerGCThread();$/;"	p	namespace:WTF	signature:()
rehash	.\HashTable.h	/^        void rehash(int newTableSize);$/;"	p	class:WTF::HashTable	access:private	signature:(int newTableSize)
rehash	.\HashTable.h	/^    void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::rehash(int newTableSize)$/;"	f	class:WTF::HashTable	signature:(int newTableSize)
reifyString	.\text\StringBuilder.cpp	/^void StringBuilder::reifyString() const$/;"	f	class:WTF::StringBuilder	signature:() const
reifyString	.\text\StringBuilder.h	/^    WTF_EXPORT_PRIVATE void reifyString() const;$/;"	p	class:WTF::StringBuilder	access:private	signature:() const
reinsert	.\HashTable.h	/^        void reinsert(ValueType&);$/;"	p	class:WTF::HashTable	access:private	signature:(ValueType&)
reinsert	.\HashTable.h	/^    inline void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::reinsert(ValueType& entry)$/;"	f	class:WTF::HashTable	signature:(ValueType& entry)
reinterpret_cast_ptr	.\StdLibExtras.h	/^TypePtr reinterpret_cast_ptr(const void* ptr)$/;"	f	signature:(const void* ptr)
reinterpret_cast_ptr	.\StdLibExtras.h	/^TypePtr reinterpret_cast_ptr(void* ptr)$/;"	f	signature:(void* ptr)
reinterpret_cast_ptr	.\StdLibExtras.h	105;"	d
relaxAdoptionRequirement	.\RefCounted.h	/^    void relaxAdoptionRequirement()$/;"	f	class:WTF::RefCountedBase	access:public	signature:()
release	.\MetaAllocator.cpp	/^ALWAYS_INLINE void MetaAllocator::release(MetaAllocatorHandle* handle)$/;"	f	class:WTF::MetaAllocator	signature:(MetaAllocatorHandle* handle)
release	.\MetaAllocator.cpp	/^void MetaAllocatorTracker::release(MetaAllocatorHandle* handle)$/;"	f	class:WTF::MetaAllocatorTracker	signature:(MetaAllocatorHandle* handle)
release	.\MetaAllocator.h	/^    void release(MetaAllocatorHandle*);$/;"	p	class:WTF::MetaAllocator	access:private	signature:(MetaAllocatorHandle*)
release	.\MetaAllocator.h	/^    void release(MetaAllocatorHandle*);$/;"	p	class:WTF::MetaAllocatorTracker	access:public	signature:(MetaAllocatorHandle*)
release	.\OwnArrayPtr.h	/^    PassOwnArrayPtr<T> release();$/;"	p	class:WTF::OwnArrayPtr	access:public	signature:()
release	.\OwnArrayPtr.h	/^template<typename T> inline PassOwnArrayPtr<T> OwnArrayPtr<T>::release()$/;"	f	class:WTF::OwnArrayPtr	signature:()
release	.\OwnPtr.h	/^        PassOwnPtr<T> release();$/;"	p	class:WTF::OwnPtr	access:public	signature:()
release	.\OwnPtr.h	/^    template<typename T> inline PassOwnPtr<T> OwnPtr<T>::release()$/;"	f	class:WTF::OwnPtr	signature:()
release	.\RefPtr.h	/^        PassRefPtr<T> release() { PassRefPtr<T> tmp = adoptRef(m_ptr); m_ptr = 0; return tmp; }$/;"	f	class:WTF::RefPtr	access:public	signature:()
release	.\gobject\GOwnPtr.h	/^    T* release()$/;"	f	class:WTF::GOwnPtr	access:public	signature:()
release	.\text\StringBuffer.h	/^    CharType* release() { CharType* data = m_data; m_data = 0; return data; }$/;"	f	class:WTF::StringBuffer	access:public	signature:()
releaseBuffer	.\Vector.h	/^        T* releaseBuffer()$/;"	f	class:WTF::VectorBuffer	access:public	signature:()
releaseBuffer	.\Vector.h	/^        T* releaseBuffer()$/;"	f	class:WTF::VectorBufferBase	access:public	signature:()
releaseBuffer	.\Vector.h	/^        T* releaseBuffer();$/;"	p	class:WTF::Vector	access:public	signature:()
releaseBuffer	.\Vector.h	/^    inline T* Vector<T, inlineCapacity>::releaseBuffer()$/;"	f	class:WTF::Vector	signature:()
releaseCollator	.\unicode\Collator.h	/^        void releaseCollator();$/;"	p	class:WTF::Collator	access:private	signature:()
releaseCollator	.\unicode\icu\CollatorICU.cpp	/^void Collator::releaseCollator()$/;"	f	class:WTF::Collator	signature:()
releaseDecommitted	.\OSAllocator.h	/^    WTF_EXPORT_PRIVATE static void releaseDecommitted(void*, size_t);$/;"	p	class:WTF::OSAllocator	access:public	signature:(void*, size_t)
releaseDecommitted	.\OSAllocatorPosix.cpp	/^void OSAllocator::releaseDecommitted(void* address, size_t bytes)$/;"	f	class:WTF::OSAllocator	signature:(void* address, size_t bytes)
releaseDecommitted	.\OSAllocatorWin.cpp	/^void OSAllocator::releaseDecommitted(void* address, size_t bytes)$/;"	f	class:WTF::OSAllocator	signature:(void* address, size_t bytes)
releaseFastMallocFreeMemory	.\FastMalloc.cpp	/^void releaseFastMallocFreeMemory() { }$/;"	f	namespace:WTF	signature:()
releaseFastMallocFreeMemory	.\FastMalloc.cpp	/^void releaseFastMallocFreeMemory()$/;"	f	namespace:WTF	signature:()
releaseFastMallocFreeMemory	.\FastMalloc.h	/^    WTF_EXPORT_PRIVATE void releaseFastMallocFreeMemory();$/;"	p	namespace:WTF	signature:()
remove	.\AVLTree.h	/^    inline handle remove(key k);$/;"	p	class:WTF::AVLTree	access:public	signature:(key k)
remove	.\AVLTree.h	/^AVLTree<Abstractor, maxDepth, BSet>::remove(key k)$/;"	f	class:WTF::AVLTree	signature:(key k)
remove	.\BloomFilter.h	/^    void remove(const AtomicString& string) { remove(string.impl()->existingHash()); }$/;"	f	class:WTF::BloomFilter	access:public	signature:(const AtomicString& string)
remove	.\BloomFilter.h	/^    void remove(const String& string) { remove(string.impl()->hash()); }$/;"	f	class:WTF::BloomFilter	access:public	signature:(const String& string)
remove	.\BloomFilter.h	/^    void remove(unsigned hash);$/;"	p	class:WTF::BloomFilter	access:public	signature:(unsigned hash)
remove	.\BloomFilter.h	/^inline void BloomFilter<keyBits>::remove(unsigned hash)$/;"	f	class:WTF::BloomFilter	signature:(unsigned hash)
remove	.\Deque.h	/^        void remove(const_iterator&);$/;"	p	class:WTF::Deque	access:public	signature:(const_iterator&)
remove	.\Deque.h	/^        void remove(iterator&);$/;"	p	class:WTF::Deque	access:public	signature:(iterator&)
remove	.\Deque.h	/^        void remove(size_t position);$/;"	p	class:WTF::Deque	access:private	signature:(size_t position)
remove	.\Deque.h	/^    inline void Deque<T, inlineCapacity>::remove(const_iterator& it)$/;"	f	class:WTF::Deque	signature:(const_iterator& it)
remove	.\Deque.h	/^    inline void Deque<T, inlineCapacity>::remove(iterator& it)$/;"	f	class:WTF::Deque	signature:(iterator& it)
remove	.\Deque.h	/^    inline void Deque<T, inlineCapacity>::remove(size_t position)$/;"	f	class:WTF::Deque	signature:(size_t position)
remove	.\DoublyLinkedList.h	/^    void remove(T*);$/;"	p	class:WTF::DoublyLinkedList	access:public	signature:(T*)
remove	.\DoublyLinkedList.h	/^template<typename T> inline void DoublyLinkedList<T>::remove(T* node)$/;"	f	class:WTF::DoublyLinkedList	signature:(T* node)
remove	.\HashCountedSet.h	/^        bool remove(const ValueType&);$/;"	p	class:WTF::HashCountedSet	access:public	signature:(const ValueType&)
remove	.\HashCountedSet.h	/^        bool remove(iterator);$/;"	p	class:WTF::HashCountedSet	access:public	signature:(iterator)
remove	.\HashCountedSet.h	/^    inline bool HashCountedSet<Value, HashFunctions, Traits>::remove(const ValueType& value)$/;"	f	class:WTF::HashCountedSet	signature:(const ValueType& value)
remove	.\HashCountedSet.h	/^    inline bool HashCountedSet<Value, HashFunctions, Traits>::remove(iterator it)$/;"	f	class:WTF::HashCountedSet	signature:(iterator it)
remove	.\HashMap.h	/^        void remove(const KeyType&);$/;"	p	class:WTF::HashMap	access:public	signature:(const KeyType&)
remove	.\HashMap.h	/^        void remove(iterator);$/;"	p	class:WTF::HashMap	access:public	signature:(iterator)
remove	.\HashMap.h	/^    inline void HashMap<T, U, V, W, X>::remove(const KeyType& key)$/;"	f	class:WTF::HashMap	signature:(const KeyType& key)
remove	.\HashMap.h	/^    inline void HashMap<T, U, V, W, X>::remove(iterator it)$/;"	f	class:WTF::HashMap	signature:(iterator it)
remove	.\HashSet.h	/^        void remove(const ValueType&);$/;"	p	class:WTF::HashSet	access:public	signature:(const ValueType&)
remove	.\HashSet.h	/^        void remove(iterator);$/;"	p	class:WTF::HashSet	access:public	signature:(iterator)
remove	.\HashSet.h	/^    inline void HashSet<T, U, V>::remove(const ValueType& value)$/;"	f	class:WTF::HashSet	signature:(const ValueType& value)
remove	.\HashSet.h	/^    inline void HashSet<T, U, V>::remove(iterator it)$/;"	f	class:WTF::HashSet	signature:(iterator it)
remove	.\HashTable.h	/^        void remove(ValueType*);$/;"	p	class:WTF::HashTable	access:private	signature:(ValueType*)
remove	.\HashTable.h	/^        void remove(const KeyType&);$/;"	p	class:WTF::HashTable	access:public	signature:(const KeyType&)
remove	.\HashTable.h	/^        void remove(iterator);$/;"	p	class:WTF::HashTable	access:public	signature:(iterator)
remove	.\HashTable.h	/^    inline void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::remove(const KeyType& key)$/;"	f	class:WTF::HashTable	signature:(const KeyType& key)
remove	.\HashTable.h	/^    inline void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::remove(iterator it)$/;"	f	class:WTF::HashTable	signature:(iterator it)
remove	.\HashTable.h	/^    void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::remove(ValueType* pos)$/;"	f	class:WTF::HashTable	signature:(ValueType* pos)
remove	.\ListHashSet.h	/^        void remove(const ValueType&);$/;"	p	class:WTF::ListHashSet	access:public	signature:(const ValueType&)
remove	.\ListHashSet.h	/^        void remove(iterator);$/;"	p	class:WTF::ListHashSet	access:public	signature:(iterator)
remove	.\ListHashSet.h	/^    inline void ListHashSet<T, inlineCapacity, U>::remove(const ValueType& value)$/;"	f	class:WTF::ListHashSet	signature:(const ValueType& value)
remove	.\ListHashSet.h	/^    inline void ListHashSet<T, inlineCapacity, U>::remove(iterator it)$/;"	f	class:WTF::ListHashSet	signature:(iterator it)
remove	.\RedBlackTree.h	/^    NodeType* remove(NodeType* z)$/;"	f	class:WTF::RedBlackTree	access:public	signature:(NodeType* z)
remove	.\RedBlackTree.h	/^    NodeType* remove(const KeyType& key)$/;"	f	class:WTF::RedBlackTree	access:public	signature:(const KeyType& key)
remove	.\RefPtrHashMap.h	/^        void remove(RawKeyType);$/;"	p	class:WTF::HashMap	access:public	signature:(RawKeyType)
remove	.\RefPtrHashMap.h	/^        void remove(const KeyType&);$/;"	p	class:WTF::HashMap	access:public	signature:(const KeyType&)
remove	.\RefPtrHashMap.h	/^        void remove(iterator);$/;"	p	class:WTF::HashMap	access:public	signature:(iterator)
remove	.\RefPtrHashMap.h	/^    inline void HashMap<RefPtr<T>, U, V, W, X>::remove(RawKeyType key)$/;"	f	class:WTF::HashMap	signature:(RawKeyType key)
remove	.\RefPtrHashMap.h	/^    inline void HashMap<RefPtr<T>, U, V, W, X>::remove(const KeyType& key)$/;"	f	class:WTF::HashMap	signature:(const KeyType& key)
remove	.\RefPtrHashMap.h	/^    inline void HashMap<RefPtr<T>, U, V, W, X>::remove(iterator it)$/;"	f	class:WTF::HashMap	signature:(iterator it)
remove	.\SentinelLinkedList.h	/^    static void remove(T*);$/;"	p	class:WTF::SentinelLinkedList	access:public	signature:(T*)
remove	.\SentinelLinkedList.h	/^    void remove();$/;"	p	class:WTF::BasicRawSentinelNode	access:public	signature:()
remove	.\SentinelLinkedList.h	/^template <typename T, typename RawNode> inline void SentinelLinkedList<T, RawNode>::remove(T* node)$/;"	f	class:WTF::SentinelLinkedList	signature:(T* node)
remove	.\SentinelLinkedList.h	/^template <typename T> void BasicRawSentinelNode<T>::remove()$/;"	f	class:WTF::BasicRawSentinelNode	signature:()
remove	.\Vector.h	/^        void remove(size_t position);$/;"	p	class:WTF::Vector	access:public	signature:(size_t position)
remove	.\Vector.h	/^        void remove(size_t position, size_t length);$/;"	p	class:WTF::Vector	access:public	signature:(size_t position, size_t length)
remove	.\Vector.h	/^    inline void Vector<T, inlineCapacity>::remove(size_t position)$/;"	f	class:WTF::Vector	signature:(size_t position)
remove	.\Vector.h	/^    inline void Vector<T, inlineCapacity>::remove(size_t position, size_t length)$/;"	f	class:WTF::Vector	signature:(size_t position, size_t length)
remove	.\WTFThreadData.h	/^    bool remove(StringImpl* r)$/;"	f	class:JSC::IdentifierTable	access:public	signature:(StringImpl* r)
remove	.\text\AtomicString.cpp	/^void AtomicString::remove(StringImpl* r)$/;"	f	class:WTF::AtomicString	signature:(StringImpl* r)
remove	.\text\AtomicString.h	/^    static void remove(StringImpl*);$/;"	p	class:WTF::AtomicString	access:public	signature:(StringImpl*)
remove	.\text\WTFString.cpp	/^void String::remove(unsigned position, int lengthToRemove)$/;"	f	class:WTF::String	signature:(unsigned position, int lengthToRemove)
remove	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE void remove(unsigned pos, int len = 1);$/;"	p	class:WTF::String	access:public	signature:(unsigned pos, int len = 1)
removeAll	.\HashCountedSet.h	/^        void removeAll(const ValueType&);$/;"	p	class:WTF::HashCountedSet	access:public	signature:(const ValueType&)
removeAll	.\HashCountedSet.h	/^        void removeAll(iterator);$/;"	p	class:WTF::HashCountedSet	access:public	signature:(iterator)
removeAll	.\HashCountedSet.h	/^    inline void HashCountedSet<Value, HashFunctions, Traits>::removeAll(const ValueType& value)$/;"	f	class:WTF::HashCountedSet	signature:(const ValueType& value)
removeAll	.\HashCountedSet.h	/^    inline void HashCountedSet<Value, HashFunctions, Traits>::removeAll(iterator it)$/;"	f	class:WTF::HashCountedSet	signature:(iterator it)
removeAndInvalidate	.\HashTable.h	/^        void removeAndInvalidate(ValueType*);$/;"	p	class:WTF::HashTable	access:private	signature:(ValueType*)
removeAndInvalidate	.\HashTable.h	/^    void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::removeAndInvalidate(ValueType* pos)$/;"	f	class:WTF::HashTable	signature:(ValueType* pos)
removeAndInvalidateWithoutEntryConsistencyCheck	.\HashTable.h	/^        void removeAndInvalidateWithoutEntryConsistencyCheck(ValueType*);$/;"	p	class:WTF::HashTable	access:private	signature:(ValueType*)
removeAndInvalidateWithoutEntryConsistencyCheck	.\HashTable.h	/^    void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::removeAndInvalidateWithoutEntryConsistencyCheck(ValueType* pos)$/;"	f	class:WTF::HashTable	signature:(ValueType* pos)
removeCharacters	.\text\StringImpl.cpp	/^ALWAYS_INLINE PassRefPtr<StringImpl> StringImpl::removeCharacters(const CharType* characters, CharacterMatchFunctionPtr findMatch)$/;"	f	class:WTF::StringImpl	signature:(const CharType* characters, CharacterMatchFunctionPtr findMatch)
removeCharacters	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::removeCharacters(CharacterMatchFunctionPtr findMatch)$/;"	f	class:WTF::StringImpl	signature:(CharacterMatchFunctionPtr findMatch)
removeCharacters	.\text\StringImpl.h	/^    ALWAYS_INLINE PassRefPtr<StringImpl> removeCharacters(const CharType* characters, CharacterMatchFunctionPtr);$/;"	p	class:WTF::StringImpl	access:public	signature:(const CharType* characters, CharacterMatchFunctionPtr)
removeCharacters	.\text\StringImpl.h	/^    PassRefPtr<StringImpl> removeCharacters(CharacterMatchFunctionPtr);$/;"	p	class:WTF::StringImpl	access:public	signature:(CharacterMatchFunctionPtr)
removeCharacters	.\text\WTFString.cpp	/^String String::removeCharacters(CharacterMatchFunctionPtr findMatch) const$/;"	f	class:WTF::String	signature:(CharacterMatchFunctionPtr findMatch) const
removeCharacters	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE String removeCharacters(CharacterMatchFunctionPtr) const;$/;"	p	class:WTF::String	access:public	signature:(CharacterMatchFunctionPtr) const
removeFirst	.\Deque.h	/^        void removeFirst();$/;"	p	class:WTF::Deque	access:public	signature:()
removeFirst	.\Deque.h	/^    inline void Deque<T, inlineCapacity>::removeFirst()$/;"	f	class:WTF::Deque	signature:()
removeFixup	.\RedBlackTree.h	/^    void removeFixup(NodeType* x, NodeType* xParent)$/;"	f	class:WTF::RedBlackTree	access:private	signature:(NodeType* x, NodeType* xParent)
removeFromIteratorsList	.\Deque.h	/^        void removeFromIteratorsList();$/;"	p	class:WTF::DequeIteratorBase	access:private	signature:()
removeFromIteratorsList	.\Deque.h	/^    template<typename T, size_t inlineCapacity> inline void DequeIteratorBase<T, inlineCapacity>::removeFromIteratorsList() { }$/;"	f	class:WTF::DequeIteratorBase	signature:()
removeFromIteratorsList	.\Deque.h	/^    void DequeIteratorBase<T, inlineCapacity>::removeFromIteratorsList()$/;"	f	class:WTF::DequeIteratorBase	signature:()
removeHead	.\DoublyLinkedList.h	/^    T* removeHead();$/;"	p	class:WTF::DoublyLinkedList	access:public	signature:()
removeHead	.\DoublyLinkedList.h	/^template<typename T> inline T* DoublyLinkedList<T>::removeHead()$/;"	f	class:WTF::DoublyLinkedList	signature:()
removeIf	.\MessageQueue.h	/^        void removeIf(Predicate&);$/;"	p	class:WTF::MessageQueue	access:public	signature:(Predicate&)
removeIf	.\MessageQueue.h	/^    inline void MessageQueue<DataType>::removeIf(Predicate& predicate)$/;"	f	class:WTF::MessageQueue	signature:(Predicate& predicate)
removeIterator	.\HashTable.h	/^    inline void removeIterator(HashTableConstIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>*) { }$/;"	f	namespace:WTF	signature:(HashTableConstIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>*)
removeIterator	.\HashTable.h	/^    void removeIterator(HashTableConstIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>* it)$/;"	f	namespace:WTF	signature:(HashTableConstIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>* it)
removeIterator	.\HashTable.h	/^    void removeIterator(HashTableConstIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>*);$/;"	p	namespace:WTF	signature:(HashTableConstIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>*)
removeLast	.\ListHashSet.h	/^        void removeLast();$/;"	p	class:WTF::ListHashSet	access:public	signature:()
removeLast	.\ListHashSet.h	/^    inline void ListHashSet<T, inlineCapacity, U>::removeLast()$/;"	f	class:WTF::ListHashSet	signature:()
removeLast	.\SegmentedVector.h	/^        void removeLast()$/;"	f	class:WTF::SegmentedVector	access:public	signature:()
removeLast	.\Vector.h	/^        void removeLast() $/;"	f	class:WTF::Vector	access:public	signature:()
removeView	.\ArrayBuffer.cpp	/^void ArrayBuffer::removeView(ArrayBufferView* view)$/;"	f	class:WTF::ArrayBuffer	signature:(ArrayBufferView* view)
removeView	.\ArrayBuffer.h	/^    void removeView(ArrayBufferView*);$/;"	p	class:WTF::ArrayBuffer	access:public	signature:(ArrayBufferView*)
removeWithoutEntryConsistencyCheck	.\HashTable.h	/^        void removeWithoutEntryConsistencyCheck(const_iterator);$/;"	p	class:WTF::HashTable	access:public	signature:(const_iterator)
removeWithoutEntryConsistencyCheck	.\HashTable.h	/^        void removeWithoutEntryConsistencyCheck(iterator);$/;"	p	class:WTF::HashTable	access:public	signature:(iterator)
removeWithoutEntryConsistencyCheck	.\HashTable.h	/^    inline void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::removeWithoutEntryConsistencyCheck(const_iterator it)$/;"	f	class:WTF::HashTable	signature:(const_iterator it)
removeWithoutEntryConsistencyCheck	.\HashTable.h	/^    inline void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::removeWithoutEntryConsistencyCheck(iterator it)$/;"	f	class:WTF::HashTable	signature:(iterator it)
rend	.\Deque.h	/^        const_reverse_iterator rend() const { return const_reverse_iterator(this, m_start); }$/;"	f	class:WTF::Deque	access:public	signature:() const
rend	.\Deque.h	/^        reverse_iterator rend() { return reverse_iterator(this, m_start); }$/;"	f	class:WTF::Deque	access:public	signature:()
rend	.\ListHashSet.h	/^        const_reverse_iterator rend() const;$/;"	p	class:WTF::ListHashSet	access:public	signature:() const
rend	.\ListHashSet.h	/^        reverse_iterator rend();$/;"	p	class:WTF::ListHashSet	access:public	signature:()
rend	.\ListHashSet.h	/^    inline typename ListHashSet<T, inlineCapacity, U>::const_reverse_iterator ListHashSet<T, inlineCapacity, U>::rend() const$/;"	f	class:WTF::ListHashSet	signature:() const
rend	.\ListHashSet.h	/^    inline typename ListHashSet<T, inlineCapacity, U>::reverse_iterator ListHashSet<T, inlineCapacity, U>::rend()$/;"	f	class:WTF::ListHashSet	signature:()
rend	.\Vector.h	/^        const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }$/;"	f	class:WTF::Vector	access:public	signature:() const
rend	.\Vector.h	/^        reverse_iterator rend() { return reverse_iterator(begin()); }$/;"	f	class:WTF::Vector	access:public	signature:()
replace	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::replace(StringImpl* pattern, StringImpl* replacement)$/;"	f	class:WTF::StringImpl	signature:(StringImpl* pattern, StringImpl* replacement)
replace	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::replace(UChar oldC, UChar newC)$/;"	f	class:WTF::StringImpl	signature:(UChar oldC, UChar newC)
replace	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::replace(UChar pattern, StringImpl* replacement)$/;"	f	class:WTF::StringImpl	signature:(UChar pattern, StringImpl* replacement)
replace	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::replace(unsigned position, unsigned lengthToReplace, StringImpl* str)$/;"	f	class:WTF::StringImpl	signature:(unsigned position, unsigned lengthToReplace, StringImpl* str)
replace	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE PassRefPtr<StringImpl> replace(StringImpl*, StringImpl*);$/;"	p	class:WTF::StringImpl	access:public	signature:(StringImpl*, StringImpl*)
replace	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE PassRefPtr<StringImpl> replace(UChar, StringImpl*);$/;"	p	class:WTF::StringImpl	access:public	signature:(UChar, StringImpl*)
replace	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE PassRefPtr<StringImpl> replace(UChar, UChar);$/;"	p	class:WTF::StringImpl	access:public	signature:(UChar, UChar)
replace	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE PassRefPtr<StringImpl> replace(unsigned index, unsigned len, StringImpl*);$/;"	p	class:WTF::StringImpl	access:public	signature:(unsigned index, unsigned len, StringImpl*)
replace	.\text\WTFString.h	/^    String& replace(UChar a, UChar b) { if (m_impl) m_impl = m_impl->replace(a, b); return *this; }$/;"	f	class:WTF::String	access:public	signature:(UChar a, UChar b)
replace	.\text\WTFString.h	/^    String& replace(UChar a, const String& b) { if (m_impl) m_impl = m_impl->replace(a, b.impl()); return *this; }$/;"	f	class:WTF::String	access:public	signature:(UChar a, const String& b)
replace	.\text\WTFString.h	/^    String& replace(const String& a, const String& b) { if (m_impl) m_impl = m_impl->replace(a.impl(), b.impl()); return *this; }$/;"	f	class:WTF::String	access:public	signature:(const String& a, const String& b)
replace	.\text\WTFString.h	/^    String& replace(unsigned index, unsigned len, const String& b) { if (m_impl) m_impl = m_impl->replace(index, len, b.impl()); return *this; }$/;"	f	class:WTF::String	access:public	signature:(unsigned index, unsigned len, const String& b)
replacementCharacter	.\unicode\CharacterNames.h	/^const UChar replacementCharacter = 0xFFFD;$/;"	v
rescheduleScavenger	.\FastMalloc.cpp	/^  ALWAYS_INLINE void rescheduleScavenger();$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:private	signature:()
rescheduleScavenger	.\FastMalloc.cpp	/^ALWAYS_INLINE void TCMalloc_PageHeap::rescheduleScavenger()$/;"	f	class:WTF::TCMalloc_PageHeap	signature:()
reserve	.\PageReservation.h	/^    static PageReservation reserve(size_t size, OSAllocator::Usage usage = OSAllocator::UnknownUsage, bool writable = true, bool executable = false)$/;"	f	class:WTF::PageReservation	access:public	signature:(size_t size, OSAllocator::Usage usage = OSAllocator::UnknownUsage, bool writable = true, bool executable = false)
reserveAndCommit	.\OSAllocator.h	/^    WTF_EXPORT_PRIVATE static void* reserveAndCommit(size_t, Usage = UnknownUsage, bool writable = true, bool executable = false, bool includesGuardPages = false);$/;"	p	class:WTF::OSAllocator	access:public	signature:(size_t, Usage = UnknownUsage, bool writable = true, bool executable = false, bool includesGuardPages = false)
reserveAndCommit	.\OSAllocator.h	/^    static void* reserveAndCommit(size_t reserveSize, size_t commitSize, Usage = UnknownUsage, bool writable = true, bool executable = false);$/;"	p	class:WTF::OSAllocator	access:public	signature:(size_t reserveSize, size_t commitSize, Usage = UnknownUsage, bool writable = true, bool executable = false)
reserveAndCommit	.\OSAllocator.h	/^inline void* OSAllocator::reserveAndCommit(size_t reserveSize, size_t commitSize, Usage usage, bool writable, bool executable)$/;"	f	class:WTF::OSAllocator	signature:(size_t reserveSize, size_t commitSize, Usage usage, bool writable, bool executable)
reserveAndCommit	.\OSAllocatorPosix.cpp	/^void* OSAllocator::reserveAndCommit(size_t bytes, Usage usage, bool writable, bool executable, bool includesGuardPages)$/;"	f	class:WTF::OSAllocator	signature:(size_t bytes, Usage usage, bool writable, bool executable, bool includesGuardPages)
reserveAndCommit	.\OSAllocatorWin.cpp	/^void* OSAllocator::reserveAndCommit(size_t bytes, Usage, bool writable, bool executable, bool)$/;"	f	class:WTF::OSAllocator	signature:(size_t bytes, Usage, bool writable, bool executable, bool)
reserveCapacity	.\Vector.h	/^        void reserveCapacity(size_t newCapacity);$/;"	p	class:WTF::Vector	access:public	signature:(size_t newCapacity)
reserveCapacity	.\Vector.h	/^    void Vector<T, inlineCapacity>::reserveCapacity(size_t newCapacity)$/;"	f	class:WTF::Vector	signature:(size_t newCapacity)
reserveCapacity	.\text\StringBuilder.cpp	/^void StringBuilder::reserveCapacity(unsigned newCapacity)$/;"	f	class:WTF::StringBuilder	signature:(unsigned newCapacity)
reserveCapacity	.\text\StringBuilder.h	/^    WTF_EXPORT_PRIVATE void reserveCapacity(unsigned newCapacity);$/;"	p	class:WTF::StringBuilder	access:public	signature:(unsigned newCapacity)
reserveInitialCapacity	.\Vector.h	/^        void reserveInitialCapacity(size_t initialCapacity);$/;"	p	class:WTF::Vector	access:public	signature:(size_t initialCapacity)
reserveInitialCapacity	.\Vector.h	/^    inline void Vector<T, inlineCapacity>::reserveInitialCapacity(size_t initialCapacity)$/;"	f	class:WTF::Vector	signature:(size_t initialCapacity)
reserveUncommitted	.\OSAllocator.h	/^    static void* reserveUncommitted(size_t, Usage = UnknownUsage, bool writable = true, bool executable = false, bool includesGuardPages = false);$/;"	p	class:WTF::OSAllocator	access:public	signature:(size_t, Usage = UnknownUsage, bool writable = true, bool executable = false, bool includesGuardPages = false)
reserveUncommitted	.\OSAllocatorPosix.cpp	/^void* OSAllocator::reserveUncommitted(size_t bytes, Usage usage, bool writable, bool executable, bool includesGuardPages)$/;"	f	class:WTF::OSAllocator	signature:(size_t bytes, Usage usage, bool writable, bool executable, bool includesGuardPages)
reserveUncommitted	.\OSAllocatorWin.cpp	/^void* OSAllocator::reserveUncommitted(size_t bytes, Usage, bool writable, bool executable, bool)$/;"	f	class:WTF::OSAllocator	signature:(size_t bytes, Usage, bool writable, bool executable, bool)
reserveWithGuardPages	.\PageReservation.h	/^    static PageReservation reserveWithGuardPages(size_t size, OSAllocator::Usage usage = OSAllocator::UnknownUsage, bool writable = true, bool executable = false)$/;"	f	class:WTF::PageReservation	access:public	signature:(size_t size, OSAllocator::Usage usage = OSAllocator::UnknownUsage, bool writable = true, bool executable = false)
reservedVMBytes	.\FastMalloc.h	/^        size_t reservedVMBytes;$/;"	m	struct:WTF::FastMallocStatistics	access:public
reset	.\AVLTree.h	/^    void reset() { for (unsigned i = 0; i < maxDepth; ++i) m_data[i] = false; }$/;"	f	class:WTF::AVLTreeDefaultBSet	access:public	signature:()
reset	.\RedBlackTree.h	/^        void reset()$/;"	f	class:WTF::RedBlackTree::Node	access:private	signature:()
reset	.\SHA1.cpp	/^void SHA1::reset()$/;"	f	class:WTF::SHA1	signature:()
reset	.\SHA1.h	/^    void reset();$/;"	p	class:WTF::SHA1	access:private	signature:()
reset	.\url\src\URLComponent.h	/^    void reset()$/;"	f	class:WTF::URLComponent	access:public	signature:()
resetCurrentIdentifierTable	.\WTFThreadData.h	/^    void resetCurrentIdentifierTable()$/;"	f	class:WTF::WTFThreadData	access:public	signature:()
resize	.\BitVector.cpp	/^void BitVector::resize(size_t numBits)$/;"	f	class:WTF::BitVector	signature:(size_t numBits)
resize	.\BitVector.h	/^    void resize(size_t numBits);$/;"	p	class:WTF::BitVector	access:public	signature:(size_t numBits)
resize	.\PackedIntVector.h	/^    void resize(size_t numInts)$/;"	f	class:WTF::PackedIntVector	access:public	signature:(size_t numInts)
resize	.\Vector.h	/^        void resize(size_t size);$/;"	p	class:WTF::Vector	access:public	signature:(size_t size)
resize	.\Vector.h	/^    inline void Vector<T, inlineCapacity>::resize(size_t size)$/;"	f	class:WTF::Vector	signature:(size_t size)
resize	.\dtoa.cpp	/^    void resize(size_t s)$/;"	f	struct:WTF::BigInt	access:public	signature:(size_t s)
resize	.\text\StringBuffer.h	/^    void resize(unsigned newLength)$/;"	f	class:WTF::StringBuffer	access:public	signature:(unsigned newLength)
resize	.\text\StringBuilder.cpp	/^void StringBuilder::resize(unsigned newSize)$/;"	f	class:WTF::StringBuilder	signature:(unsigned newSize)
resize	.\text\StringBuilder.h	/^    WTF_EXPORT_PRIVATE void resize(unsigned newSize);$/;"	p	class:WTF::StringBuilder	access:public	signature:(unsigned newSize)
resize	.\url\src\RawURLBuffer.h	/^    virtual void resize(int size)$/;"	f	class:WTF::RawURLBuffer	access:public	signature:(int size)
resize	.\url\src\URLBuffer.h	/^    virtual void resize(int) = 0;$/;"	p	class:WTF::URLBuffer	access:public	signature:(int)
resizeMemory	.\wince\MemoryManager.cpp	/^bool MemoryManager::resizeMemory(void*, size_t)$/;"	f	class:WTF::MemoryManager	signature:(void*, size_t)
resizeMemory	.\wince\MemoryManager.h	/^        static bool resizeMemory(void* p, size_t newSize);$/;"	p	class:WTF::MemoryManager	access:public	signature:(void* p, size_t newSize)
resizeOutOfLine	.\BitVector.cpp	/^void BitVector::resizeOutOfLine(size_t numBits)$/;"	f	class:WTF::BitVector	signature:(size_t numBits)
resizeOutOfLine	.\BitVector.h	/^    void resizeOutOfLine(size_t numBits);$/;"	p	class:WTF::BitVector	access:private	signature:(size_t numBits)
restoreInlineBufferIfNeeded	.\Vector.h	/^        void restoreInlineBufferIfNeeded() { }$/;"	f	class:WTF::VectorBuffer	access:public	signature:()
restoreInlineBufferIfNeeded	.\Vector.h	/^        void restoreInlineBufferIfNeeded()$/;"	f	class:WTF::VectorBuffer	access:public	signature:()
retainPtr	.\RetainPtr.h	/^    template<typename T> inline RetainPtr<T> retainPtr(T o)$/;"	f	namespace:WTF	signature:(T o)
returned	.\FastMalloc.cpp	/^    Span        returned;$/;"	m	struct:WTF::TCMalloc_PageHeap::SpanList	file:	access:public
reverse	.\Vector.h	/^        void reverse();$/;"	p	class:WTF::Vector	access:public	signature:()
reverse	.\Vector.h	/^    inline void Vector<T, inlineCapacity>::reverse()$/;"	f	class:WTF::Vector	signature:()
reverseBytes	.\MD5.cpp	/^static void reverseBytes(uint8_t* buf, unsigned longs)$/;"	f	namespace:WTF	file:	signature:(uint8_t* buf, unsigned longs)
reverseFind	.\Vector.h	/^        template<typename U> size_t reverseFind(const U&) const;$/;"	p	class:WTF::Vector	access:public	signature:(const U&) const
reverseFind	.\Vector.h	/^    size_t Vector<T, inlineCapacity>::reverseFind(const U& value) const$/;"	f	class:WTF::Vector	signature:(const U& value) const
reverseFind	.\text\StringImpl.cpp	/^size_t StringImpl::reverseFind(StringImpl* matchString, unsigned index)$/;"	f	class:WTF::StringImpl	signature:(StringImpl* matchString, unsigned index)
reverseFind	.\text\StringImpl.cpp	/^size_t StringImpl::reverseFind(UChar c, unsigned index)$/;"	f	class:WTF::StringImpl	signature:(UChar c, unsigned index)
reverseFind	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE size_t reverseFind(StringImpl*, unsigned index = UINT_MAX);$/;"	p	class:WTF::StringImpl	access:public	signature:(StringImpl*, unsigned index = UINT_MAX)
reverseFind	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE size_t reverseFind(UChar, unsigned index = UINT_MAX);$/;"	p	class:WTF::StringImpl	access:public	signature:(UChar, unsigned index = UINT_MAX)
reverseFind	.\text\WTFString.h	/^    size_t reverseFind(UChar c, unsigned start = UINT_MAX) const$/;"	f	class:WTF::String	access:public	signature:(UChar c, unsigned start = UINT_MAX) const
reverseFind	.\text\WTFString.h	/^    size_t reverseFind(const String& str, unsigned start = UINT_MAX) const$/;"	f	class:WTF::String	access:public	signature:(const String& str, unsigned start = UINT_MAX) const
reverseFind	.\text\WTFString.h	/^    size_t reverseFind(const String& str, unsigned start, bool caseSensitive) const$/;"	f	class:WTF::String	access:public	signature:(const String& str, unsigned start, bool caseSensitive) const
reverseFind	.\text\WTFString.h	/^inline size_t reverseFind(const LChar* characters, unsigned length, LChar matchCharacter, unsigned index = UINT_MAX)$/;"	f	namespace:WTF	signature:(const LChar* characters, unsigned length, LChar matchCharacter, unsigned index = UINT_MAX)
reverseFind	.\text\WTFString.h	/^inline size_t reverseFind(const UChar* characters, unsigned length, UChar matchCharacter, unsigned index = UINT_MAX)$/;"	f	namespace:WTF	signature:(const UChar* characters, unsigned length, UChar matchCharacter, unsigned index = UINT_MAX)
reverseFindIgnoringCase	.\text\StringImpl.cpp	/^size_t StringImpl::reverseFindIgnoringCase(StringImpl* matchString, unsigned index)$/;"	f	class:WTF::StringImpl	signature:(StringImpl* matchString, unsigned index)
reverseFindIgnoringCase	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE size_t reverseFindIgnoringCase(StringImpl*, unsigned index = UINT_MAX);$/;"	p	class:WTF::StringImpl	access:public	signature:(StringImpl*, unsigned index = UINT_MAX)
reverseFindIgnoringCase	.\text\WTFString.h	/^    size_t reverseFindIgnoringCase(const String& str, unsigned start = UINT_MAX) const$/;"	f	class:WTF::String	access:public	signature:(const String& str, unsigned start = UINT_MAX) const
reverseFindInner	.\text\StringImpl.cpp	/^ALWAYS_INLINE static size_t reverseFindInner(const CharType* searchCharacters, const CharType* matchCharacters, unsigned index, unsigned length, unsigned matchLength)$/;"	f	namespace:WTF	file:	signature:(const CharType* searchCharacters, const CharType* matchCharacters, unsigned index, unsigned length, unsigned matchLength)
reverse_iterator	.\Deque.h	/^        typedef DequeReverseIterator<T, inlineCapacity> reverse_iterator;$/;"	t	class:WTF::Deque	access:public
reverse_iterator	.\ListHashSet.h	/^        typedef ListHashSetReverseIterator<ValueArg, inlineCapacity, HashArg> reverse_iterator;$/;"	t	class:WTF::ListHashSetConstReverseIterator	access:private
reverse_iterator	.\ListHashSet.h	/^        typedef ListHashSetReverseIterator<ValueArg, inlineCapacity, HashArg> reverse_iterator;$/;"	t	class:WTF::ListHashSetReverseIterator	access:private
reverse_iterator	.\ListHashSet.h	/^        typedef ListHashSetReverseIterator<ValueType, inlineCapacity, HashArg> reverse_iterator;$/;"	t	class:WTF::ListHashSet	access:public
reverse_iterator	.\Vector.h	/^        typedef std::reverse_iterator<iterator> reverse_iterator;$/;"	t	class:WTF::Vector	access:public
reversed	.\Vector.h	/^        VectorReverseProxy& reversed() { return static_cast<VectorReverseProxy&>(*this); }$/;"	f	class:WTF::Vector	access:public	signature:()
reversed	.\Vector.h	/^        const VectorReverseProxy& reversed() const { return static_cast<const VectorReverseProxy&>(*this); }$/;"	f	class:WTF::Vector	access:public	signature:() const
right	.\RedBlackTree.h	/^        NodeType* right() const$/;"	f	class:WTF::RedBlackTree::Node	access:private	signature:() const
right	.\text\WTFString.h	/^    String right(unsigned len) const { return substring(length() - len, len); }$/;"	f	class:WTF::String	access:public	signature:(unsigned len) const
rightDoubleQuotationMark	.\unicode\CharacterNames.h	/^const UChar rightDoubleQuotationMark = 0x201D;$/;"	v
rightRotate	.\RedBlackTree.h	/^    NodeType* rightRotate(NodeType* y)$/;"	f	class:WTF::RedBlackTree	access:private	signature:(NodeType* y)
rightSingleQuotationMark	.\unicode\CharacterNames.h	/^const UChar rightSingleQuotationMark = 0x2019;$/;"	v
rightToLeftEmbed	.\unicode\CharacterNames.h	/^const UChar rightToLeftEmbed = 0x202B;$/;"	v
rightToLeftMark	.\unicode\CharacterNames.h	/^const UChar rightToLeftMark = 0x200F;$/;"	v
rightToLeftOverride	.\unicode\CharacterNames.h	/^const UChar rightToLeftOverride = 0x202E;$/;"	v
rnd_	.\FastMalloc.cpp	/^  uint32_t      rnd_;                   \/\/ Cheap random number generator$/;"	m	class:WTF::TCMalloc_ThreadCache	file:	access:private
root	.\AVLTree.h	/^        handle root;$/;"	m	struct:WTF::AVLTree::abs_plus_root	access:public
root_	.\TCPageMap.h	/^  Leaf* root_[ROOT_LENGTH];             \/\/ Pointers to 32 child nodes$/;"	m	class:TCMalloc_PageMap2	access:private
root_	.\TCPageMap.h	/^  Node* root_;                          \/\/ Root of radix tree$/;"	m	class:TCMalloc_PageMap3	access:private
rotateLeft	.\SHA1.cpp	/^static inline uint32_t rotateLeft(int n, uint32_t x)$/;"	f	namespace:WTF	file:	signature:(int n, uint32_t x)
round	.\MathExtras.h	/^static double round(double num)$/;"	f	signature:(double num)
roundUp	.\MetaAllocator.cpp	/^size_t MetaAllocator::roundUp(size_t sizeInBytes)$/;"	f	class:WTF::MetaAllocator	signature:(size_t sizeInBytes)
roundUp	.\MetaAllocator.h	/^    size_t roundUp(size_t sizeInBytes);$/;"	p	class:WTF::MetaAllocator	access:private	signature:(size_t sizeInBytes)
roundUpToMultipleOf	.\StdLibExtras.h	/^inline size_t roundUpToMultipleOf(size_t divisor, size_t x)$/;"	f	namespace:WTF	signature:(size_t divisor, size_t x)
roundUpToMultipleOf	.\StdLibExtras.h	/^template<size_t divisor> inline size_t roundUpToMultipleOf(size_t x)$/;"	f	namespace:WTF	signature:(size_t x)
rounded_product	.\dtoa.cpp	151;"	d	file:
rounded_quotient	.\dtoa.cpp	152;"	d	file:
roundf	.\MathExtras.h	/^static float roundf(float num)$/;"	f	signature:(float num)
runScavengerThread	.\FastMalloc.cpp	/^  static NO_RETURN_WITH_VALUE void* runScavengerThread(void*);$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:private	signature:(void*)
runScavengerThread	.\FastMalloc.cpp	/^void* TCMalloc_PageHeap::runScavengerThread(void* context)$/;"	f	class:WTF::TCMalloc_PageHeap	signature:(void* context)
s	.\CryptographicallyRandomNumber.cpp	/^    uint8_t s[256];$/;"	m	class:WTF::__anon3::ARC4Stream	file:	access:public
s	.\TCSystemAlloc.cpp	/^  size_t s;$/;"	m	union:MemoryAligner	file:	access:public
s	.\text\AtomicString.cpp	/^    const UChar* s;$/;"	m	struct:WTF::UCharBuffer	file:	access:public
s_copyCharsInlineCutOff	.\text\StringImpl.h	/^    static const unsigned s_copyCharsInlineCutOff = 20;$/;"	m	class:WTF::StringImpl	access:private
s_defaultAvailabilityDelta	.\StackBounds.h	/^    const static size_t s_defaultAvailabilityDelta = 4096;$/;"	m	class:WTF::StackBounds	access:private
s_dtoaP5Mutex	.\dtoa.cpp	/^Mutex* s_dtoaP5Mutex;$/;"	v
s_flagCount	.\text\StringImpl.h	/^    static const unsigned s_flagCount = 8;$/;"	m	class:WTF::StringImpl	access:private
s_flagMask	.\text\StringImpl.h	/^    static const unsigned s_flagMask = (1u << s_flagCount) - 1;$/;"	m	class:WTF::StringImpl	access:private
s_hashFlag8BitBuffer	.\text\StringImpl.h	/^    static const unsigned s_hashFlag8BitBuffer = 1u << 6;$/;"	m	class:WTF::StringImpl	access:private
s_hashFlagDidReportCost	.\text\StringImpl.h	/^    static const unsigned s_hashFlagDidReportCost = 1u << 3;$/;"	m	class:WTF::StringImpl	access:private
s_hashFlagHas16BitShadow	.\text\StringImpl.h	/^    static const unsigned s_hashFlagHas16BitShadow = 1u << 7;$/;"	m	class:WTF::StringImpl	access:private
s_hashFlagHasTerminatingNullCharacter	.\text\StringImpl.h	/^    static const unsigned s_hashFlagHasTerminatingNullCharacter = 1u << 5;$/;"	m	class:WTF::StringImpl	access:private
s_hashFlagIsAtomic	.\text\StringImpl.h	/^    static const unsigned s_hashFlagIsAtomic = 1u << 4;$/;"	m	class:WTF::StringImpl	access:private
s_hashFlagIsIdentifier	.\text\StringImpl.h	/^    static const unsigned s_hashFlagIsIdentifier = 1u << 2;$/;"	m	class:WTF::StringImpl	access:private
s_hashMaskBufferOwnership	.\text\StringImpl.h	/^    static const unsigned s_hashMaskBufferOwnership = 1u | (1u << 1);$/;"	m	class:WTF::StringImpl	access:private
s_mainThreadInvokerEventType	.\qt\MainThreadQt.cpp	/^static int s_mainThreadInvokerEventType;$/;"	v	file:
s_pageMask	.\PageBlock.cpp	/^static size_t s_pageMask;$/;"	v	file:
s_pageSize	.\PageBlock.cpp	/^static size_t s_pageSize;$/;"	v	file:
s_refCountFlagIsStaticString	.\text\StringImpl.h	/^    static const unsigned s_refCountFlagIsStaticString = 0x1;$/;"	m	class:WTF::StringImpl	access:private
s_refCountIncrement	.\text\StringImpl.h	/^    static const unsigned s_refCountIncrement = 0x2; \/\/ This allows us to ref \/ deref without disturbing the static string flag.$/;"	m	class:WTF::StringImpl	access:private
s_threadPool	.\ParallelJobsGeneric.cpp	/^Vector< RefPtr<ParallelEnvironment::ThreadPrivate> >* ParallelEnvironment::s_threadPool = 0;$/;"	m	class:WTF::ParallelEnvironment	file:
s_threadPool	.\ParallelJobsGeneric.h	/^    static Vector< RefPtr<ThreadPrivate> >* s_threadPool;$/;"	m	class:WTF::ParallelEnvironment	access:private
safeAdd	.\CheckedArithmetic.h	/^template <typename U, typename V, typename R> static inline bool safeAdd(U lhs, V rhs, R& result)$/;"	f	namespace:WTF	signature:(U lhs, V rhs, R& result)
safeCast	.\StdLibExtras.h	/^inline To safeCast(From value)$/;"	f	namespace:WTF	signature:(From value)
safeEquals	.\CheckedArithmetic.h	/^template <typename U, typename V> static inline bool safeEquals(U lhs, V rhs)$/;"	f	namespace:WTF	signature:(U lhs, V rhs)
safeMultiply	.\CheckedArithmetic.h	/^template <typename U, typename V, typename R> static inline bool safeMultiply(U lhs, V rhs, R& result)$/;"	f	namespace:WTF	signature:(U lhs, V rhs, R& result)
safeSub	.\CheckedArithmetic.h	/^template <typename U, typename V, typename R> static inline bool safeSub(U lhs, V rhs, R& result)$/;"	f	namespace:WTF	signature:(U lhs, V rhs, R& result)
safeToCompareToEmptyOrDeleted	.\HashFunctions.h	/^        static const bool safeToCompareToEmptyOrDeleted = DefaultHash<T>::Hash::safeToCompareToEmptyOrDeleted $/;"	m	struct:WTF::PairHash	access:public
safeToCompareToEmptyOrDeleted	.\HashFunctions.h	/^        static const bool safeToCompareToEmptyOrDeleted = true;$/;"	m	struct:WTF::FloatHash	access:public
safeToCompareToEmptyOrDeleted	.\HashFunctions.h	/^        static const bool safeToCompareToEmptyOrDeleted = true;$/;"	m	struct:WTF::IntHash	access:public
safeToCompareToEmptyOrDeleted	.\HashFunctions.h	/^        static const bool safeToCompareToEmptyOrDeleted = true;$/;"	m	struct:WTF::PtrHash	access:public
safeToCompareToEmptyOrDeleted	.\ListHashSet.h	/^        static const bool safeToCompareToEmptyOrDeleted = false;$/;"	m	struct:WTF::ListHashSetNodeHashFunctions	access:public
safeToCompareToEmptyOrDeleted	.\text\AtomicStringHash.h	/^        static const bool safeToCompareToEmptyOrDeleted = false;$/;"	m	struct:WTF::AtomicStringHash	access:public
safeToCompareToEmptyOrDeleted	.\text\StringHash.h	/^        static const bool safeToCompareToEmptyOrDeleted = false;$/;"	m	class:WTF::CaseFoldingHash	access:public
safeToCompareToEmptyOrDeleted	.\text\StringHash.h	/^        static const bool safeToCompareToEmptyOrDeleted = false;$/;"	m	struct:WTF::StringHash	access:public
sameSize	.\CheckedArithmetic.h	/^template <typename U, typename V, bool uIsBigger = (sizeof(U) > sizeof(V)), bool sameSize = (sizeof(U) == sizeof(V))> struct ResultBase;$/;"	v
sample	.\FastMalloc.cpp	/^  unsigned int  sample : 1;     \/\/ Sampled object?$/;"	m	struct:WTF::Span	file:	access:public
sample_period	.\FastMalloc.cpp	/^static size_t sample_period = 0;$/;"	v	file:
sample_period	.\FastMalloc.cpp	/^static size_t sample_period = 262147;$/;"	v	file:
sample_period_lock	.\FastMalloc.cpp	/^static SpinLock sample_period_lock = SPINLOCK_INITIALIZER;$/;"	v	file:
sampled_objects	.\FastMalloc.cpp	/^static Span sampled_objects;$/;"	v	file:
sbrk_failure	.\TCSystemAlloc.cpp	/^static bool sbrk_failure = false;$/;"	v	file:
scavenge	.\FastMalloc.cpp	/^  void scavenge();$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:private	signature:()
scavenge	.\FastMalloc.cpp	/^void TCMalloc_PageHeap::scavenge()$/;"	f	class:WTF::TCMalloc_PageHeap	signature:()
scavenge_counter_	.\FastMalloc.cpp	/^  int64_t scavenge_counter_;$/;"	m	class:WTF::TCMalloc_PageHeap	file:	access:private
scavenge_index_	.\FastMalloc.cpp	/^  size_t scavenge_index_;$/;"	m	class:WTF::TCMalloc_PageHeap	file:	access:private
scavengerThread	.\FastMalloc.cpp	/^  NO_RETURN void scavengerThread();$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:private	signature:()
scavengerThread	.\FastMalloc.cpp	/^void TCMalloc_PageHeap::scavengerThread()$/;"	f	class:WTF::TCMalloc_PageHeap	signature:()
scavengerTimerFired	.\FastMalloc.cpp	/^  static void CALLBACK scavengerTimerFired(void*, BOOLEAN);$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:private	signature:(void*, BOOLEAN)
scavengerTimerFired	.\FastMalloc.cpp	/^void TCMalloc_PageHeap::scavengerTimerFired(void* context, BOOLEAN)$/;"	f	class:WTF::TCMalloc_PageHeap	signature:(void* context, BOOLEAN)
scheduleDispatchFunctionsOnMainThread	.\MainThread.h	/^void scheduleDispatchFunctionsOnMainThread();$/;"	p	namespace:WTF	signature:()
scheduleDispatchFunctionsOnMainThread	.\blackberry\MainThreadBlackBerry.cpp	/^void scheduleDispatchFunctionsOnMainThread()$/;"	f	namespace:WTF	signature:()
scheduleDispatchFunctionsOnMainThread	.\efl\MainThreadEfl.cpp	/^void scheduleDispatchFunctionsOnMainThread()$/;"	f	namespace:WTF	signature:()
scheduleDispatchFunctionsOnMainThread	.\gtk\MainThreadGtk.cpp	/^void scheduleDispatchFunctionsOnMainThread()$/;"	f	namespace:WTF	signature:()
scheduleDispatchFunctionsOnMainThread	.\qt\MainThreadQt.cpp	/^void scheduleDispatchFunctionsOnMainThread()$/;"	f	namespace:WTF	signature:()
scheduleDispatchFunctionsOnMainThread	.\win\MainThreadWin.cpp	/^void scheduleDispatchFunctionsOnMainThread()$/;"	f	namespace:WTF	signature:()
scheduleDispatchFunctionsOnMainThread	.\wx\MainThreadWx.cpp	/^void scheduleDispatchFunctionsOnMainThread()$/;"	f	namespace:WTF	signature:()
scheduleScavenger	.\FastMalloc.cpp	/^  ALWAYS_INLINE void scheduleScavenger();$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:private	signature:()
scheduleScavenger	.\FastMalloc.cpp	/^ALWAYS_INLINE void TCMalloc_PageHeap::scheduleScavenger()$/;"	f	class:WTF::TCMalloc_PageHeap	signature:()
scheme	.\url\api\ParsedURL.cpp	/^String ParsedURL::scheme() const$/;"	f	class:WTF::ParsedURL	signature:() const
scheme	.\url\api\ParsedURL.h	/^    WTF_EXPORT_PRIVATE String scheme() const;$/;"	p	class:WTF::ParsedURL	access:public	signature:() const
scheme	.\url\src\URLSegments.h	/^    URLComponent scheme;$/;"	m	class:WTF::URLSegments	access:public
search	.\AVLTree.h	/^    inline handle search(key k, SearchType st = EQUAL);$/;"	p	class:WTF::AVLTree	access:public	signature:(key k, SearchType st = EQUAL)
search	.\AVLTree.h	/^AVLTree<Abstractor, maxDepth, BSet>::search(key k, typename AVLTree<Abstractor, maxDepth, BSet>::SearchType st)$/;"	f	class:WTF::AVLTree	signature:(key k, typename AVLTree<Abstractor, maxDepth, BSet>::SearchType st)
search_greatest	.\AVLTree.h	/^    inline handle search_greatest();$/;"	p	class:WTF::AVLTree	access:public	signature:()
search_greatest	.\AVLTree.h	/^AVLTree<Abstractor, maxDepth, BSet>::search_greatest()$/;"	f	class:WTF::AVLTree	signature:()
search_least	.\AVLTree.h	/^    inline handle search_least();$/;"	p	class:WTF::AVLTree	access:public	signature:()
search_least	.\AVLTree.h	/^AVLTree<Abstractor, maxDepth, BSet>::search_least()$/;"	f	class:WTF::AVLTree	signature:()
secondSlot	.\BloomFilter.h	/^    const uint8_t& secondSlot(unsigned hash) const { return m_table[(hash >> 16) & keyMask]; }$/;"	f	class:WTF::BloomFilter	access:private	signature:(unsigned hash) const
secondSlot	.\BloomFilter.h	/^    uint8_t& secondSlot(unsigned hash) { return m_table[(hash >> 16) & keyMask]; }$/;"	f	class:WTF::BloomFilter	access:private	signature:(unsigned hash)
secondsPerDay	.\DateMath.cpp	/^static const double secondsPerDay = 24.0 * 60.0 * 60.0;$/;"	v	file:
secondsPerHour	.\DateMath.h	/^const double secondsPerHour = 60.0 * 60.0;$/;"	v
secondsPerMinute	.\DateMath.h	/^const double secondsPerMinute = 60.0;$/;"	v
secondsPerYear	.\DateMath.cpp	/^static const double secondsPerYear = 24.0 * 60.0 * 60.0 * 365.0;$/;"	v	file:
segment	.\url\api\ParsedURL.cpp	/^String ParsedURL::segment(const URLComponent& component) const$/;"	f	class:WTF::ParsedURL	signature:(const URLComponent& component) const
segment	.\url\api\ParsedURL.h	/^    inline String segment(const URLComponent&) const;$/;"	p	class:WTF::ParsedURL	access:private	signature:(const URLComponent&) const
segmentExistsFor	.\SegmentedVector.h	/^        bool segmentExistsFor(size_t index)$/;"	f	class:WTF::SegmentedVector	access:private	signature:(size_t index)
segmentFor	.\SegmentedVector.h	/^        Segment* segmentFor(size_t index)$/;"	f	class:WTF::SegmentedVector	access:private	signature:(size_t index)
sesameDot	.\unicode\CharacterNames.h	/^const UChar sesameDot = 0xFE45;$/;"	v
set	.\AVLTree.h	/^    void set() { for (unsigned i = 0; i < maxDepth; ++i) m_data[i] = true; }$/;"	f	class:WTF::AVLTreeDefaultBSet	access:public	signature:()
set	.\BitVector.h	/^    void set(size_t bit)$/;"	f	class:WTF::BitVector	access:public	signature:(size_t bit)
set	.\BitVector.h	/^    void set(size_t bit, bool value)$/;"	f	class:WTF::BitVector	access:public	signature:(size_t bit, bool value)
set	.\Bitmap.h	/^    void set(size_t);$/;"	p	class:WTF::Bitmap	access:public	signature:(size_t)
set	.\Bitmap.h	/^inline void Bitmap<size, atomicMode>::set(size_t n)$/;"	f	class:WTF::Bitmap	signature:(size_t n)
set	.\ByteArray.h	/^        void set(unsigned index, double value)$/;"	f	class:WTF::ByteArray	access:public	signature:(unsigned index, double value)
set	.\ByteArray.h	/^        void set(unsigned index, unsigned char value)$/;"	f	class:WTF::ByteArray	access:public	signature:(unsigned index, unsigned char value)
set	.\Float32Array.h	/^    bool set(TypedArrayBase<float>* array, unsigned offset) { return TypedArrayBase<float>::set(array, offset); }$/;"	f	class:WTF::Float32Array	access:public	signature:(TypedArrayBase<float>* array, unsigned offset)
set	.\Float32Array.h	/^    void set(unsigned index, double value)$/;"	f	class:WTF::Float32Array	access:public	signature:(unsigned index, double value)
set	.\Float64Array.h	/^    bool set(TypedArrayBase<double>* array, unsigned offset) { return TypedArrayBase<double>::set(array, offset); }$/;"	f	class:WTF::Float64Array	access:public	signature:(TypedArrayBase<double>* array, unsigned offset)
set	.\Float64Array.h	/^    void set(unsigned index, double value)$/;"	f	class:WTF::Float64Array	access:public	signature:(unsigned index, double value)
set	.\HashMap.h	/^        pair<iterator, bool> set(const KeyType&, MappedPassInType); $/;"	p	class:WTF::HashMap	access:public	signature:(const KeyType&, MappedPassInType)
set	.\HashMap.h	/^    HashMap<T, U, V, W, X>::set(const KeyType& key, MappedPassInType mapped) $/;"	f	class:WTF::HashMap	signature:(const KeyType& key, MappedPassInType mapped)
set	.\Int16Array.h	/^    bool set(TypedArrayBase<short>* array, unsigned offset) { return TypedArrayBase<short>::set(array, offset); }$/;"	f	class:WTF::Int16Array	access:public	signature:(TypedArrayBase<short>* array, unsigned offset)
set	.\Int16Array.h	/^    void set(unsigned index, double value) { IntegralTypedArrayBase<short>::set(index, value); }$/;"	f	class:WTF::Int16Array	access:public	signature:(unsigned index, double value)
set	.\Int32Array.h	/^    bool set(TypedArrayBase<int>* array, unsigned offset) { return TypedArrayBase<int>::set(array, offset); }$/;"	f	class:WTF::Int32Array	access:public	signature:(TypedArrayBase<int>* array, unsigned offset)
set	.\Int32Array.h	/^    void set(unsigned index, double value) { IntegralTypedArrayBase<int>::set(index, value); }$/;"	f	class:WTF::Int32Array	access:public	signature:(unsigned index, double value)
set	.\Int8Array.h	/^    bool set(TypedArrayBase<signed char>* array, unsigned offset) { return TypedArrayBase<signed char>::set(array, offset); }$/;"	f	class:WTF::Int8Array	access:public	signature:(TypedArrayBase<signed char>* array, unsigned offset)
set	.\Int8Array.h	/^    void set(unsigned index, double value) { IntegralTypedArrayBase<signed char>::set(index, value); }$/;"	f	class:WTF::Int8Array	access:public	signature:(unsigned index, double value)
set	.\IntegralTypedArrayBase.h	/^    void set(unsigned index, double value)$/;"	f	class:WTF::IntegralTypedArrayBase	access:public	signature:(unsigned index, double value)
set	.\PackedIntVector.h	/^    void set(size_t index, T value)$/;"	f	class:WTF::PackedIntVector	access:public	signature:(size_t index, T value)
set	.\RefPtrHashMap.h	/^        pair<iterator, bool> set(RawKeyType, MappedPassInType); $/;"	p	class:WTF::HashMap	access:public	signature:(RawKeyType, MappedPassInType)
set	.\RefPtrHashMap.h	/^        pair<iterator, bool> set(const KeyType&, MappedPassInType); $/;"	p	class:WTF::HashMap	access:public	signature:(const KeyType&, MappedPassInType)
set	.\RefPtrHashMap.h	/^    HashMap<RefPtr<T>, U, V, W, X>::set(RawKeyType key, MappedPassInType mapped) $/;"	f	class:WTF::HashMap	signature:(RawKeyType key, MappedPassInType mapped)
set	.\RefPtrHashMap.h	/^    HashMap<RefPtr<T>, U, V, W, X>::set(const KeyType& key, MappedPassInType mapped) $/;"	f	class:WTF::HashMap	signature:(const KeyType& key, MappedPassInType mapped)
set	.\TCPageMap.h	/^  void set(Number k, void* v) {$/;"	f	class:TCMalloc_PageMap1	access:public	signature:(Number k, void* v)
set	.\TCPageMap.h	/^  void set(Number k, void* v) {$/;"	f	class:TCMalloc_PageMap2	access:public	signature:(Number k, void* v)
set	.\TCPageMap.h	/^  void set(Number k, void* v) {$/;"	f	class:TCMalloc_PageMap3	access:public	signature:(Number k, void* v)
set	.\ThreadSpecific.h	/^    void set(T*);$/;"	p	class:WTF::ThreadSpecific	access:private	signature:(T*)
set	.\ThreadSpecific.h	/^inline void ThreadSpecific<T>::set(T* ptr)$/;"	f	class:WTF::ThreadSpecific	signature:(T* ptr)
set	.\TypedArrayBase.h	/^    bool set(TypedArrayBase<T>* array, unsigned offset)$/;"	f	class:WTF::TypedArrayBase	access:public	signature:(TypedArrayBase<T>* array, unsigned offset)
set	.\Uint16Array.h	/^    bool set(TypedArrayBase<unsigned short>* array, unsigned offset) { return TypedArrayBase<unsigned short>::set(array, offset); }$/;"	f	class:WTF::Uint16Array	access:public	signature:(TypedArrayBase<unsigned short>* array, unsigned offset)
set	.\Uint16Array.h	/^    void set(unsigned index, double value) { IntegralTypedArrayBase<unsigned short>::set(index, value); }$/;"	f	class:WTF::Uint16Array	access:public	signature:(unsigned index, double value)
set	.\Uint32Array.h	/^    bool set(TypedArrayBase<unsigned int>* array, unsigned offset) { return TypedArrayBase<unsigned int>::set(array, offset); }$/;"	f	class:WTF::Uint32Array	access:public	signature:(TypedArrayBase<unsigned int>* array, unsigned offset)
set	.\Uint32Array.h	/^    void set(unsigned index, double value) { IntegralTypedArrayBase<unsigned int>::set(index, value); }$/;"	f	class:WTF::Uint32Array	access:public	signature:(unsigned index, double value)
set	.\Uint8Array.h	/^    bool set(TypedArrayBase<unsigned char>* array, unsigned offset) { return TypedArrayBase<unsigned char>::set(array, offset); }$/;"	f	class:WTF::Uint8Array	access:public	signature:(TypedArrayBase<unsigned char>* array, unsigned offset)
set	.\Uint8Array.h	/^    void set(unsigned index, double value) { IntegralTypedArrayBase<unsigned char>::set(index, value); }$/;"	f	class:WTF::Uint8Array	access:public	signature:(unsigned index, double value)
set	.\Uint8ClampedArray.h	/^    bool set(TypedArrayBase<unsigned char>* array, unsigned offset) { return TypedArrayBase<unsigned char>::set(array, offset); }$/;"	f	class:WTF::Uint8ClampedArray	access:public	signature:(TypedArrayBase<unsigned char>* array, unsigned offset)
set	.\Uint8ClampedArray.h	/^    inline void set(unsigned index, double value);$/;"	p	class:WTF::Uint8ClampedArray	access:public	signature:(unsigned index, double value)
set	.\Uint8ClampedArray.h	/^void Uint8ClampedArray::set(unsigned index, double value)$/;"	f	class:WTF::Uint8ClampedArray	signature:(unsigned index, double value)
set	.\gobject\GOwnPtr.h	/^    void set(T* ptr)$/;"	f	class:WTF::GOwnPtr	access:public	signature:(T* ptr)
set	.\url\src\URLBuffer.h	/^    inline void set(int offset, CharacterType ch)$/;"	f	class:WTF::URLBuffer	access:public	signature:(int offset, CharacterType ch)
setAllocationCanFail	.\wince\MemoryManager.h	/^        void setAllocationCanFail(bool c) { m_allocationCanFail = c; }$/;"	f	class:WTF::MemoryManager	access:public	signature:(bool c)
setBegin	.\url\src\URLComponent.h	/^    void setBegin(int begin) { m_begin = begin; }$/;"	f	class:WTF::URLComponent	access:public	signature:(int begin)
setColor	.\RedBlackTree.h	/^        void setColor(Color value)$/;"	f	class:WTF::RedBlackTree::Node	access:private	signature:(Color value)
setCurrentIdentifierTable	.\WTFThreadData.h	/^    JSC::IdentifierTable* setCurrentIdentifierTable(JSC::IdentifierTable* identifierTable)$/;"	f	class:WTF::WTFThreadData	access:public	signature:(JSC::IdentifierTable* identifierTable)
setDispatchQueueForVerifier	.\RefCounted.h	/^    void setDispatchQueueForVerifier(dispatch_queue_t);$/;"	p	class:WTF::RefCountedBase	access:public	signature:(dispatch_queue_t)
setDispatchQueueForVerifier	.\RefCounted.h	/^inline void RefCountedBase::setDispatchQueueForVerifier(dispatch_queue_t queue)$/;"	f	class:WTF::RefCountedBase	signature:(dispatch_queue_t queue)
setDispatchQueueForVerifier	.\RefCounted.h	/^inline void RefCountedBase::setDispatchQueueForVerifier(dispatch_queue_t) { }$/;"	f	class:WTF::RefCountedBase	signature:(dispatch_queue_t)
setDispatchQueueMode	.\ThreadRestrictionVerifier.h	/^    void setDispatchQueueMode(dispatch_queue_t queue)$/;"	f	class:WTF::ThreadRestrictionVerifier	access:public	signature:(dispatch_queue_t queue)
setFastMallocMatchValidationType	.\FastMalloc.h	/^        inline void setFastMallocMatchValidationType(void* p, AllocType allocType)$/;"	f	namespace:WTF::Internal	signature:(void* p, AllocType allocType)
setFastMallocMatchValidationType	.\wince\FastMallocWinCE.h	/^        inline void setFastMallocMatchValidationType(void* p, AllocType allocType)$/;"	f	namespace:WTF::Internal	signature:(void* p, AllocType allocType)
setHash	.\text\StringImpl.h	/^    void setHash(unsigned hash) const$/;"	f	class:WTF::StringImpl	access:private	signature:(unsigned hash) const
setImpl	.\ArrayBufferView.h	/^    inline bool setImpl(ArrayBufferView*, unsigned byteOffset);$/;"	p	class:WTF::ArrayBufferView	access:protected	signature:(ArrayBufferView*, unsigned byteOffset)
setImpl	.\ArrayBufferView.h	/^bool ArrayBufferView::setImpl(ArrayBufferView* array, unsigned byteOffset)$/;"	f	class:WTF::ArrayBufferView	signature:(ArrayBufferView* array, unsigned byteOffset)
setIsAtomic	.\text\StringImpl.h	/^    void setIsAtomic(bool isIdentifier)$/;"	f	class:WTF::StringImpl	access:public	signature:(bool isIdentifier)
setIsIdentifier	.\text\StringImpl.h	/^    void setIsIdentifier(bool isIdentifier)$/;"	f	class:WTF::StringImpl	access:public	signature:(bool isIdentifier)
setLeft	.\RedBlackTree.h	/^        void setLeft(NodeType* node)$/;"	f	class:WTF::RedBlackTree::Node	access:private	signature:(NodeType* node)
setLength	.\url\src\URLBuffer.h	/^    void setLength(int length)$/;"	f	class:WTF::URLBuffer	access:public	signature:(int length)
setLength	.\url\src\URLComponent.h	/^    void setLength(int length) { m_length = length; }$/;"	f	class:WTF::URLComponent	access:public	signature:(int length)
setMainThreadCallbacksPaused	.\MainThread.cpp	/^void setMainThreadCallbacksPaused(bool paused)$/;"	f	namespace:WTF	signature:(bool paused)
setMainThreadCallbacksPaused	.\MainThread.h	/^WTF_EXPORT_PRIVATE void setMainThreadCallbacksPaused(bool paused);$/;"	p	namespace:WTF	signature:(bool paused)
setMainThreadCallbacksPaused	.\chromium\MainThreadChromium.cpp	/^void setMainThreadCallbacksPaused(bool)$/;"	f	namespace:WTF	signature:(bool)
setMutexForVerifier	.\RefCounted.h	/^    void setMutexForVerifier(Mutex&);$/;"	p	class:WTF::RefCountedBase	access:public	signature:(Mutex&)
setMutexForVerifier	.\RefCounted.h	/^inline void RefCountedBase::setMutexForVerifier(Mutex& mutex)$/;"	f	class:WTF::RefCountedBase	signature:(Mutex& mutex)
setMutexForVerifier	.\RefCounted.h	/^inline void RefCountedBase::setMutexForVerifier(Mutex&) { }$/;"	f	class:WTF::RefCountedBase	signature:(Mutex&)
setMutexMode	.\ThreadRestrictionVerifier.h	/^    void setMutexMode(Mutex& mutex)$/;"	f	class:WTF::ThreadRestrictionVerifier	access:public	signature:(Mutex& mutex)
setNext	.\DoublyLinkedList.h	/^    void setNext(T*);$/;"	p	class:WTF::DoublyLinkedListNode	access:public	signature:(T*)
setNext	.\DoublyLinkedList.h	/^template<typename T> inline void DoublyLinkedListNode<T>::setNext(T* next)$/;"	f	class:WTF::DoublyLinkedListNode	signature:(T* next)
setNext	.\SentinelLinkedList.h	/^    void setNext(BasicRawSentinelNode* next) { m_next = next; }$/;"	f	class:WTF::BasicRawSentinelNode	access:public	signature:(BasicRawSentinelNode* next)
setOrderLowerFirst	.\unicode\Collator.h	/^        WTF_EXPORT_PRIVATE void setOrderLowerFirst(bool);$/;"	p	class:WTF::Collator	access:public	signature:(bool)
setOrderLowerFirst	.\unicode\CollatorDefault.cpp	/^void Collator::setOrderLowerFirst(bool)$/;"	f	class:WTF::Collator	signature:(bool)
setOrderLowerFirst	.\unicode\icu\CollatorICU.cpp	/^void Collator::setOrderLowerFirst(bool lowerFirst)$/;"	f	class:WTF::Collator	signature:(bool lowerFirst)
setParent	.\RedBlackTree.h	/^        void setParent(NodeType* newParent)$/;"	f	class:WTF::RedBlackTree::Node	access:private	signature:(NodeType* newParent)
setPrev	.\DoublyLinkedList.h	/^    void setPrev(T*);$/;"	p	class:WTF::DoublyLinkedListNode	access:public	signature:(T*)
setPrev	.\DoublyLinkedList.h	/^template<typename T> inline void DoublyLinkedListNode<T>::setPrev(T* prev)$/;"	f	class:WTF::DoublyLinkedListNode	signature:(T* prev)
setPrev	.\SentinelLinkedList.h	/^    void setPrev(BasicRawSentinelNode* prev) { m_prev = prev; }$/;"	f	class:WTF::BasicRawSentinelNode	access:public	signature:(BasicRawSentinelNode* prev)
setRange	.\TypedArrayBase.h	/^    bool setRange(const T* data, size_t dataLength, unsigned offset)$/;"	f	class:WTF::TypedArrayBase	access:public	signature:(const T* data, size_t dataLength, unsigned offset)
setRangeImpl	.\ArrayBufferView.h	/^    inline bool setRangeImpl(const char* data, size_t dataByteLength, unsigned byteOffset);$/;"	p	class:WTF::ArrayBufferView	access:protected	signature:(const char* data, size_t dataByteLength, unsigned byteOffset)
setRangeImpl	.\ArrayBufferView.h	/^bool ArrayBufferView::setRangeImpl(const char* data, size_t dataByteLength, unsigned byteOffset)$/;"	f	class:WTF::ArrayBufferView	signature:(const char* data, size_t dataByteLength, unsigned byteOffset)
setRight	.\RedBlackTree.h	/^        void setRight(NodeType* node)$/;"	f	class:WTF::RedBlackTree::Node	access:private	signature:(NodeType* node)
setShared	.\ThreadRestrictionVerifier.h	/^    void setShared(bool shared)$/;"	f	class:WTF::ThreadRestrictionVerifier	access:public	signature:(bool shared)
setSlow	.\BitVector.cpp	/^void BitVector::setSlow(const BitVector& other)$/;"	f	class:WTF::BitVector	signature:(const BitVector& other)
setSlow	.\BitVector.h	/^    void setSlow(const BitVector& other);$/;"	p	class:WTF::BitVector	access:private	signature:(const BitVector& other)
setThreadHeap	.\FastMalloc.cpp	/^static ALWAYS_INLINE void setThreadHeap(TCMalloc_ThreadCache* heap)$/;"	f	namespace:WTF	file:	signature:(TCMalloc_ThreadCache* heap)
set_bf	.\AVLTree.h	/^    void set_bf(handle h, int bf) { abs.set_balance_factor(h, bf); }$/;"	f	class:WTF::AVLTree	access:protected	signature:(handle h, int bf)
set_e	.\dtoa\diy-fp.h	/^        void set_e(int new_value) { e_ = new_value; }$/;"	f	class:WTF::double_conversion::DiyFp	access:public	signature:(int new_value)
set_f	.\dtoa\diy-fp.h	/^        void set_f(uint64_t new_value) { f_ = new_value; }$/;"	f	class:WTF::double_conversion::DiyFp	access:public	signature:(uint64_t new_value)
set_gt	.\AVLTree.h	/^    void set_gt(handle h, handle gh) { abs.set_greater(h, gh); }$/;"	f	class:WTF::AVLTree	access:protected	signature:(handle h, handle gh)
set_lt	.\AVLTree.h	/^    void set_lt(handle h, handle lh) { abs.set_less(h, lh); }$/;"	f	class:WTF::AVLTree	access:protected	signature:(handle h, handle lh)
set_new_handler_lock	.\FastMalloc.cpp	/^static SpinLock set_new_handler_lock = SPINLOCK_INITIALIZER;$/;"	v	file:
sharedRandomNumberGenerator	.\CryptographicallyRandomNumber.cpp	/^ARC4RandomNumberGenerator& sharedRandomNumberGenerator()$/;"	f	namespace:WTF::__anon3	signature:()
shift_amount	.\FastMalloc.cpp	/^static const int shift_amount[2] = { 3, 7 };  \/\/ For divides by 8 or 128$/;"	v	file:
shouldExpand	.\HashTable.h	/^        bool shouldExpand() const { return (m_keyCount + m_deletedCount) * m_maxLoad >= m_tableSize; }$/;"	f	class:WTF::HashTable	access:private	signature:() const
shouldRefFirstParameter	.\Functional.h	/^    static const bool shouldRefFirstParameter = HasRefAndDeref<C>::value;$/;"	m	class:WTF::FunctionWrapper	access:public
shouldRefFirstParameter	.\Functional.h	/^    static const bool shouldRefFirstParameter = false;$/;"	m	class:WTF::FunctionWrapper	access:public
shouldScavenge	.\FastMalloc.cpp	/^  ALWAYS_INLINE bool shouldScavenge() const;$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:private	signature:() const
shouldScavenge	.\FastMalloc.cpp	/^ALWAYS_INLINE bool TCMalloc_PageHeap::shouldScavenge() const $/;"	f	class:WTF::TCMalloc_PageHeap	signature:() const
shouldShrink	.\HashTable.h	/^        bool shouldShrink() const { return m_keyCount * m_minLoad < m_tableSize && m_tableSize > KeyTraits::minimumTableSize; }$/;"	f	class:WTF::HashTable	access:private	signature:() const
shouldTrimFromURL	.\url\src\URLParser.h	/^    static inline bool shouldTrimFromURL(CharacterType ch)$/;"	f	class:WTF::URLParser	access:public	signature:(CharacterType ch)
show	.\text\AtomicString.cpp	/^void AtomicString::show() const$/;"	f	class:WTF::AtomicString	signature:() const
show	.\text\AtomicString.h	/^    void show() const;$/;"	p	class:WTF::AtomicString	access:public	signature:() const
show	.\text\WTFString.cpp	/^void String::show() const$/;"	f	class:String	signature:() const
show	.\text\WTFString.h	/^    void show() const;$/;"	p	class:WTF::String	access:public	signature:() const
shrink	.\BlockStack.h	/^    void shrink(T*);$/;"	p	class:WTF::BlockStack	access:public	signature:(T*)
shrink	.\BlockStack.h	/^template <typename T> void BlockStack<T>::shrink(T* newEnd)$/;"	f	class:WTF::BlockStack	signature:(T* newEnd)
shrink	.\BumpPointerAllocator.h	/^    void shrink()$/;"	f	class:WTF::BumpPointerPool	access:private	signature:()
shrink	.\HashTable.h	/^        void shrink() { rehash(m_tableSize \/ 2); }$/;"	f	class:WTF::HashTable	access:private	signature:()
shrink	.\MetaAllocator.cpp	/^void MetaAllocatorHandle::shrink(size_t newSizeInBytes)$/;"	f	class:WTF::MetaAllocatorHandle	signature:(size_t newSizeInBytes)
shrink	.\MetaAllocatorHandle.h	/^    WTF_EXPORT_PRIVATE void shrink(size_t newSizeInBytes);$/;"	p	class:WTF::MetaAllocatorHandle	access:public	signature:(size_t newSizeInBytes)
shrink	.\Vector.h	/^        void shrink(size_t size);$/;"	p	class:WTF::Vector	access:public	signature:(size_t size)
shrink	.\Vector.h	/^    void Vector<T, inlineCapacity>::shrink(size_t size)$/;"	f	class:WTF::Vector	signature:(size_t size)
shrink	.\text\StringBuffer.h	/^    void shrink(unsigned newLength)$/;"	f	class:WTF::StringBuffer	access:public	signature:(unsigned newLength)
shrinkCapacity	.\Vector.h	/^        void shrinkCapacity(size_t newCapacity);$/;"	p	class:WTF::Vector	access:public	signature:(size_t newCapacity)
shrinkCapacity	.\Vector.h	/^    void Vector<T, inlineCapacity>::shrinkCapacity(size_t newCapacity)$/;"	f	class:WTF::Vector	signature:(size_t newCapacity)
shrinkToFit	.\Vector.h	/^        void shrinkToFit() { shrinkCapacity(size()); }$/;"	f	class:WTF::Vector	access:public	signature:()
shrinkToFit	.\text\StringBuilder.cpp	/^void StringBuilder::shrinkToFit()$/;"	f	class:WTF::StringBuilder	signature:()
shrinkToFit	.\text\StringBuilder.h	/^    WTF_EXPORT_PRIVATE void shrinkToFit();$/;"	p	class:WTF::StringBuilder	access:public	signature:()
siftDown	.\NonCopyingSort.h	/^inline void siftDown(RandomAccessIterator array, ptrdiff_t start, ptrdiff_t end, Predicate compareLess) $/;"	f	namespace:WTF	signature:(RandomAccessIterator array, ptrdiff_t start, ptrdiff_t end, Predicate compareLess)
sign	.\DecimalNumber.h	/^    bool sign() const { return m_sign; }$/;"	f	class:WTF::DecimalNumber	access:public	signature:() const
sign	.\dtoa.cpp	/^    int sign;$/;"	m	struct:WTF::BigInt	file:	access:public
signal	.\ThreadingPrimitives.h	/^    WTF_EXPORT_PRIVATE void signal();$/;"	p	class:WTF::ThreadCondition	access:public	signature:()
signal	.\ThreadingPthreads.cpp	/^void ThreadCondition::signal()$/;"	f	class:WTF::ThreadCondition	signature:()
signal	.\ThreadingWin.cpp	/^void PlatformCondition::signal(bool unblockAll)$/;"	f	class:WTF::PlatformCondition	signature:(bool unblockAll)
signal	.\ThreadingWin.cpp	/^void ThreadCondition::signal()$/;"	f	class:WTF::ThreadCondition	signature:()
signal	.\threads\BinarySemaphore.cpp	/^void BinarySemaphore::signal()$/;"	f	class:WTF::BinarySemaphore	signature:()
signal	.\threads\BinarySemaphore.h	/^    void signal();$/;"	p	class:WTF::BinarySemaphore	access:public	signature:()
signal	.\threads\win\BinarySemaphoreWin.cpp	/^void BinarySemaphore::signal()$/;"	f	class:WTF::BinarySemaphore	signature:()
signalScavenger	.\FastMalloc.cpp	/^  ALWAYS_INLINE void signalScavenger();$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:private	signature:()
signalScavenger	.\FastMalloc.cpp	/^ALWAYS_INLINE void TCMalloc_PageHeap::signalScavenger()$/;"	f	class:WTF::TCMalloc_PageHeap	signature:()
signbit	.\MathExtras.h	/^inline bool signbit(double num) { return _copysign(1.0, num) < 0; }$/;"	f	signature:(double num)
signbit	.\MathExtras.h	/^inline bool signbit(double x) { return copysign(1.0, x) < 0; }$/;"	f	signature:(double x)
signbit	.\MathExtras.h	/^inline bool signbit(double x) { struct ieee_double *p = (struct ieee_double *)&x; return p->dbl_sign; }$/;"	f	signature:(double x)
significand	.\DecimalNumber.h	/^    const char* significand() const { return m_significand; } \/\/ significand contains precision characters, is not null-terminated.$/;"	f	class:WTF::DecimalNumber	access:public	signature:() const
significand	.\dtoa\cached-powers.cc	/^        uint64_t significand;$/;"	m	struct:WTF::double_conversion::CachedPower	file:	access:public
signsMatch	.\CheckedArithmetic.h	/^    static inline bool signsMatch(LHS lhs, RHS rhs)$/;"	f	struct:WTF::ArithmeticOperations	access:public	signature:(LHS lhs, RHS rhs)
simplifyMatchedCharactersToSpace	.\text\StringImpl.cpp	/^inline PassRefPtr<StringImpl> StringImpl::simplifyMatchedCharactersToSpace(UCharPredicate predicate)$/;"	f	class:WTF::StringImpl	signature:(UCharPredicate predicate)
simplifyMatchedCharactersToSpace	.\text\StringImpl.h	/^    template <typename CharType, class UCharPredicate> PassRefPtr<StringImpl> simplifyMatchedCharactersToSpace(UCharPredicate);$/;"	p	class:WTF::StringImpl	access:private	signature:(UCharPredicate)
simplifyWhiteSpace	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::simplifyWhiteSpace()$/;"	f	class:WTF::StringImpl	signature:()
simplifyWhiteSpace	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::simplifyWhiteSpace(IsWhiteSpaceFunctionPtr isWhiteSpace)$/;"	f	class:WTF::StringImpl	signature:(IsWhiteSpaceFunctionPtr isWhiteSpace)
simplifyWhiteSpace	.\text\StringImpl.h	/^    PassRefPtr<StringImpl> simplifyWhiteSpace(IsWhiteSpaceFunctionPtr);$/;"	p	class:WTF::StringImpl	access:public	signature:(IsWhiteSpaceFunctionPtr)
simplifyWhiteSpace	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE PassRefPtr<StringImpl> simplifyWhiteSpace();$/;"	p	class:WTF::StringImpl	access:public	signature:()
simplifyWhiteSpace	.\text\WTFString.cpp	/^String String::simplifyWhiteSpace() const$/;"	f	class:WTF::String	signature:() const
simplifyWhiteSpace	.\text\WTFString.cpp	/^String String::simplifyWhiteSpace(IsWhiteSpaceFunctionPtr isWhiteSpace) const$/;"	f	class:WTF::String	signature:(IsWhiteSpaceFunctionPtr isWhiteSpace) const
simplifyWhiteSpace	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE String simplifyWhiteSpace() const;$/;"	p	class:WTF::String	access:public	signature:() const
simplifyWhiteSpace	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE String simplifyWhiteSpace(IsWhiteSpaceFunctionPtr) const;$/;"	p	class:WTF::String	access:public	signature:(IsWhiteSpaceFunctionPtr) const
size	.\AVLTree.h	/^    typedef typename Abstractor::size size;$/;"	t	class:WTF::AVLTree	access:public
size	.\BitVector.h	/^    size_t size() const$/;"	f	class:WTF::BitVector	access:public	signature:() const
size	.\Deque.h	/^        size_t size() const { return m_start <= m_end ? m_end - m_start : m_end + m_buffer.capacity() - m_start; }$/;"	f	class:WTF::Deque	access:public	signature:() const
size	.\DoublyLinkedList.h	/^    size_t size() const; \/\/ This is O(n).$/;"	p	class:WTF::DoublyLinkedList	access:public	signature:() const
size	.\DoublyLinkedList.h	/^template<typename T> inline size_t DoublyLinkedList<T>::size() const$/;"	f	class:WTF::DoublyLinkedList	signature:() const
size	.\FastAllocBase.h	/^            AllocAlignmentInteger* size;$/;"	m	union:WTF::Internal::ArraySize	access:public
size	.\FastMalloc.cpp	/^    static size_t size(malloc_zone_t*, const void*);$/;"	p	class:WTF::FastMallocZone	file:	access:private	signature:(malloc_zone_t*, const void*)
size	.\FastMalloc.cpp	/^  uintptr_t size;          \/\/ Size of object$/;"	m	struct:WTF::StackTrace	file:	access:public
size	.\FastMalloc.cpp	/^size_t FastMallocZone::size(malloc_zone_t*, const void*)$/;"	f	class:WTF::FastMallocZone	signature:(malloc_zone_t*, const void*)
size	.\FixedArray.h	/^    size_t size() const { return Size; }$/;"	f	class:WTF::FixedArray	access:public	signature:() const
size	.\HashCountedSet.h	/^        int size() const;$/;"	p	class:WTF::HashCountedSet	access:public	signature:() const
size	.\HashCountedSet.h	/^    inline int HashCountedSet<Value, HashFunctions, Traits>::size() const$/;"	f	class:WTF::HashCountedSet	signature:() const
size	.\HashMap.h	/^        int size() const;$/;"	p	class:WTF::HashMap	access:public	signature:() const
size	.\HashMap.h	/^    inline int HashMap<T, U, V, W, X>::size() const$/;"	f	class:WTF::HashMap	signature:() const
size	.\HashSet.h	/^        int size() const;$/;"	p	class:WTF::HashSet	access:public	signature:() const
size	.\HashSet.h	/^    inline int HashSet<T, U, V>::size() const$/;"	f	class:WTF::HashSet	signature:() const
size	.\HashTable.h	/^        int size() const { return m_keyCount; }$/;"	f	class:WTF::HashTable	access:public	signature:() const
size	.\ListHashSet.h	/^        int size() const;$/;"	p	class:WTF::ListHashSet	access:public	signature:() const
size	.\ListHashSet.h	/^    inline int ListHashSet<T, inlineCapacity, U>::size() const$/;"	f	class:WTF::ListHashSet	signature:() const
size	.\PackedIntVector.h	/^    size_t size() const$/;"	f	class:WTF::PackedIntVector	access:public	signature:() const
size	.\PageBlock.h	/^    size_t size() const { return m_size; }$/;"	f	class:WTF::PageBlock	access:public	signature:() const
size	.\RedBlackTree.h	/^    size_t size()$/;"	f	class:WTF::RedBlackTree	access:public	signature:()
size	.\RefCountedArray.h	/^        static size_t size()$/;"	f	struct:WTF::RefCountedArray::Header	access:public	signature:()
size	.\RefCountedArray.h	/^    size_t size() const$/;"	f	class:WTF::RefCountedArray	access:public	signature:() const
size	.\RefPtrHashMap.h	/^        int size() const;$/;"	p	class:WTF::HashMap	access:public	signature:() const
size	.\RefPtrHashMap.h	/^    inline int HashMap<RefPtr<T>, U, V, W, X>::size() const$/;"	f	class:WTF::HashMap	signature:() const
size	.\SegmentedVector.h	/^        size_t size() const { return m_size; }$/;"	f	class:WTF::SegmentedVector	access:public	signature:() const
size	.\Vector.h	/^        size_t size() const { return m_size; }$/;"	f	class:WTF::Vector	access:public	signature:() const
size	.\dtoa.cpp	/^    size_t size() const$/;"	f	struct:WTF::BigInt	access:public	signature:() const
size	.\dtoa\utils.h	/^        int size() const { return buffer_.length(); }$/;"	f	class:WTF::double_conversion::StringBuilder	access:public	signature:() const
sizeInBytes	.\ArrayBuffer.h	/^    unsigned sizeInBytes() { return m_sizeInBytes; }$/;"	f	class:WTF::ArrayBufferContents	access:public	signature:()
sizeInBytes	.\MetaAllocatorHandle.h	/^    size_t sizeInBytes()$/;"	f	class:WTF::MetaAllocatorHandle	access:public	signature:()
size_	.\FastMalloc.cpp	/^  size_t        size_;                  \/\/ Combined size of data$/;"	m	class:WTF::TCMalloc_ThreadCache	file:	access:private
size_class_	.\FastMalloc.cpp	/^  size_t   size_class_;     \/\/ My size class$/;"	m	class:WTF::TCMalloc_Central_FreeList	file:	access:private
sizeclass	.\FastMalloc.cpp	/^  unsigned int  sizeclass : 8;  \/\/ Size-class for small objects (or 0)$/;"	m	struct:WTF::Span	file:	access:public
sizeof	.\SizeLimits.cpp	/^COMPILE_ASSERT(sizeof(OwnPtr<int>) == sizeof(int*), OwnPtr_should_stay_small);$/;"	v
sizeof	.\SizeLimits.cpp	/^COMPILE_ASSERT(sizeof(PassRefPtr<RefCounted<int> >) == sizeof(int*), PassRefPtr_should_stay_small);$/;"	v
sizeof	.\SizeLimits.cpp	/^COMPILE_ASSERT(sizeof(RefCounted<int>) == sizeof(SameSizeAsRefCounted), RefCounted_should_stay_small);$/;"	v
sizeof	.\SizeLimits.cpp	/^COMPILE_ASSERT(sizeof(RefCountedCustomAllocated<int>) == sizeof(SameSizeAsRefCounted), RefCountedCustomAllocated_should_stay_small);$/;"	v
sizeof	.\SizeLimits.cpp	/^COMPILE_ASSERT(sizeof(RefPtr<RefCounted<int> >) == sizeof(int*), RefPtr_should_stay_small);$/;"	v
sizeof	.\SizeLimits.cpp	/^COMPILE_ASSERT(sizeof(Vector<int>) == 3 * sizeof(int*), Vector_should_stay_small);$/;"	v
sizeof	.\unicode\Unicode.h	/^COMPILE_ASSERT(sizeof(UChar) == 2, UCharIsTwoBytes);$/;"	p	signature:(UChar)
skipEmptyBuckets	.\HashTable.h	/^        void skipEmptyBuckets()$/;"	f	class:WTF::HashTableConstIterator	access:private	signature:()
skipSpacesAndComments	.\DateMath.cpp	/^inline static void skipSpacesAndComments(const char*& s)$/;"	f	namespace:WTF	file:	signature:(const char*& s)
slice	.\ArrayBuffer.h	/^    inline PassRefPtr<ArrayBuffer> slice(int begin) const;$/;"	p	class:WTF::ArrayBuffer	access:public	signature:(int begin) const
slice	.\ArrayBuffer.h	/^    inline PassRefPtr<ArrayBuffer> slice(int begin, int end) const;$/;"	p	class:WTF::ArrayBuffer	access:public	signature:(int begin, int end) const
slice	.\ArrayBuffer.h	/^PassRefPtr<ArrayBuffer> ArrayBuffer::slice(int begin) const$/;"	f	class:WTF::ArrayBuffer	signature:(int begin) const
slice	.\ArrayBuffer.h	/^PassRefPtr<ArrayBuffer> ArrayBuffer::slice(int begin, int end) const$/;"	f	class:WTF::ArrayBuffer	signature:(int begin, int end) const
sliceImpl	.\ArrayBuffer.h	/^    inline PassRefPtr<ArrayBuffer> sliceImpl(unsigned begin, unsigned end) const;$/;"	p	class:WTF::ArrayBuffer	access:private	signature:(unsigned begin, unsigned end) const
sliceImpl	.\ArrayBuffer.h	/^PassRefPtr<ArrayBuffer> ArrayBuffer::sliceImpl(unsigned begin, unsigned end) const$/;"	f	class:WTF::ArrayBuffer	signature:(unsigned begin, unsigned end) const
smallLetterSharpS	.\unicode\CharacterNames.h	/^const UChar smallLetterSharpS = 0x00DF;$/;"	v
snprintf	.\StringExtras.h	/^inline int snprintf(char* buffer, size_t count, const char* format, ...) $/;"	f	signature:(char* buffer, size_t count, const char* format, ...)
softHyphen	.\unicode\CharacterNames.h	/^const UChar softHyphen = 0x00AD;$/;"	v
sourceExhausted	.\unicode\UTF8.h	/^            sourceExhausted,    \/\/ partial character in source, but hit end$/;"	e	enum:WTF::Unicode::__anon13
sourceIllegal	.\unicode\UTF8.h	/^            sourceIllegal       \/\/ source sequence is illegal\/malformed$/;"	e	enum:WTF::Unicode::__anon13
space	.\unicode\CharacterNames.h	/^const UChar space = 0x0020;$/;"	v
span_allocator	.\FastMalloc.cpp	/^static PageHeapAllocator<Span> span_allocator;$/;"	v	file:
spec	.\url\api\ParsedURL.h	/^    URLString spec() { return m_spec; }$/;"	f	class:WTF::ParsedURL	access:public	signature:()
spinlock	.\TCSystemAlloc.cpp	/^static SpinLock spinlock = SPINLOCK_INITIALIZER;$/;"	v	file:
split	.\text\WTFString.cpp	/^void String::split(UChar separator, Vector<String>& result) const$/;"	f	class:WTF::String	signature:(UChar separator, Vector<String>& result) const
split	.\text\WTFString.cpp	/^void String::split(UChar separator, bool allowEmptyEntries, Vector<String>& result) const$/;"	f	class:WTF::String	signature:(UChar separator, bool allowEmptyEntries, Vector<String>& result) const
split	.\text\WTFString.cpp	/^void String::split(const String& separator, Vector<String>& result) const$/;"	f	class:WTF::String	signature:(const String& separator, Vector<String>& result) const
split	.\text\WTFString.cpp	/^void String::split(const String& separator, bool allowEmptyEntries, Vector<String>& result) const$/;"	f	class:WTF::String	signature:(const String& separator, bool allowEmptyEntries, Vector<String>& result) const
split	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE void split(UChar separator, Vector<String>& result) const;$/;"	p	class:WTF::String	access:public	signature:(UChar separator, Vector<String>& result) const
split	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE void split(UChar separator, bool allowEmptyEntries, Vector<String>& result) const;$/;"	p	class:WTF::String	access:public	signature:(UChar separator, bool allowEmptyEntries, Vector<String>& result) const
split	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE void split(const String& separator, Vector<String>& result) const;$/;"	p	class:WTF::String	access:public	signature:(const String& separator, Vector<String>& result) const
split	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE void split(const String& separator, bool allowEmptyEntries, Vector<String>& result) const;$/;"	p	class:WTF::String	access:public	signature:(const String& separator, bool allowEmptyEntries, Vector<String>& result) const
stack	.\FastMalloc.cpp	/^  void*     stack[kMaxStackDepth];$/;"	m	struct:WTF::StackTrace	file:	access:public
stack	.\WTFThreadData.h	/^    const StackBounds& stack() const$/;"	f	class:WTF::WTFThreadData	access:public	signature:() const
stacktrace_allocator	.\FastMalloc.cpp	/^static PageHeapAllocator<StackTrace> stacktrace_allocator;$/;"	v	file:
standardDeviation	.\SimpleStats.h	/^    double standardDeviation() const$/;"	f	class:WTF::SimpleStats	access:public	signature:() const
start	.\FastMalloc.cpp	/^  PageID        start;          \/\/ Starting page number$/;"	m	struct:WTF::Span	file:	access:public
start	.\MetaAllocatorHandle.h	/^    void* start()$/;"	f	class:WTF::MetaAllocatorHandle	access:public	signature:()
start	.\dtoa\utils.h	/^        T* start() const { return start_; }$/;"	f	class:WTF::double_conversion::Vector	access:public	signature:() const
start	.\text\AtomicString.cpp	/^    unsigned start;$/;"	m	struct:WTF::SubstringLocation	file:	access:public
startAllocator	.\BumpPointerAllocator.h	/^    BumpPointerPool* startAllocator()$/;"	f	class:WTF::BumpPointerAllocator	access:public	signature:()
start_	.\dtoa\utils.h	/^        T* start_;$/;"	m	class:WTF::double_conversion::Vector	access:private
start_iter	.\AVLTree.h	/^        void start_iter(AVLTree &tree, key k, SearchType st = EQUAL)$/;"	f	class:WTF::AVLTree::Iterator	access:public	signature:(AVLTree &tree, key k, SearchType st = EQUAL)
start_iter_greatest	.\AVLTree.h	/^        void start_iter_greatest(AVLTree &tree)$/;"	f	class:WTF::AVLTree::Iterator	access:public	signature:(AVLTree &tree)
start_iter_least	.\AVLTree.h	/^        void start_iter_least(AVLTree &tree)$/;"	f	class:WTF::AVLTree::Iterator	access:public	signature:(AVLTree &tree)
startsWith	.\text\AtomicString.h	/^    bool startsWith(const String& s, bool caseSensitive = true) const$/;"	f	class:WTF::AtomicString	access:public	signature:(const String& s, bool caseSensitive = true) const
startsWith	.\text\StringImpl.h	/^    bool startsWith(StringImpl* str, bool caseSensitive = true) { return (caseSensitive ? reverseFind(str, 0) : reverseFindIgnoringCase(str, 0)) == 0; }$/;"	f	class:WTF::StringImpl	access:public	signature:(StringImpl* str, bool caseSensitive = true)
startsWith	.\text\WTFString.h	/^    bool startsWith(const String& s, bool caseSensitive = true) const$/;"	f	class:WTF::String	access:public	signature:(const String& s, bool caseSensitive = true) const
state	.\Assertions.h	/^    WTFLogChannelState state;$/;"	m	struct:__anon2	access:public
staticData	.\WTFThreadData.cpp	/^ThreadSpecific<WTFThreadData>* WTFThreadData::staticData;$/;"	m	class:WTF::WTFThreadData	file:
staticData	.\WTFThreadData.h	/^    static WTF_EXPORTDATA ThreadSpecific<WTFThreadData>* staticData;$/;"	m	class:WTF::WTFThreadData	access:private
static_pointer_cast	.\PassOwnArrayPtr.h	/^template<typename T, typename U> inline PassOwnArrayPtr<T> static_pointer_cast(const PassOwnArrayPtr<U>& p) $/;"	f	namespace:WTF	signature:(const PassOwnArrayPtr<U>& p)
static_pointer_cast	.\PassOwnPtr.h	/^    template<typename T, typename U> inline PassOwnPtr<T> static_pointer_cast(const PassOwnPtr<U>& p) $/;"	f	namespace:WTF	signature:(const PassOwnPtr<U>& p)
static_pointer_cast	.\PassRefPtr.h	/^    template<typename T, typename U> inline PassRefPtr<T> static_pointer_cast(const PassRefPtr<U>& p) $/;"	f	namespace:WTF	signature:(const PassRefPtr<U>& p)
static_pointer_cast	.\RefPtr.h	/^    template<typename T, typename U> inline RefPtr<T> static_pointer_cast(const RefPtr<U>& p)$/;"	f	namespace:WTF	signature:(const RefPtr<U>& p)
static_pointer_cast	.\gobject\GRefPtr.h	/^template <typename T, typename U> inline GRefPtr<T> static_pointer_cast(const GRefPtr<U>& p)$/;"	f	namespace:WTF	signature:(const GRefPtr<U>& p)
statistics	.\FastMalloc.cpp	/^    static void statistics(malloc_zone_t*, malloc_statistics_t* stats) { memset(stats, 0, sizeof(malloc_statistics_t)); }$/;"	f	class:WTF::FastMallocZone	access:public	signature:(malloc_zone_t*, malloc_statistics_t* stats)
std	.\NullPtr.h	/^namespace std {$/;"	n
std::nullptr_t	.\NullPtr.h	/^    class nullptr_t { };$/;"	c	namespace:std
stir	.\CryptographicallyRandomNumber.cpp	/^    void stir();$/;"	p	class:WTF::__anon3::ARC4RandomNumberGenerator	file:	access:private	signature:()
stir	.\CryptographicallyRandomNumber.cpp	/^void ARC4RandomNumberGenerator::stir()$/;"	f	class:WTF::__anon3::ARC4RandomNumberGenerator	signature:()
stirIfNeeded	.\CryptographicallyRandomNumber.cpp	/^    void stirIfNeeded();$/;"	p	class:WTF::__anon3::ARC4RandomNumberGenerator	file:	access:private	signature:()
stirIfNeeded	.\CryptographicallyRandomNumber.cpp	/^void ARC4RandomNumberGenerator::stirIfNeeded()$/;"	f	class:WTF::__anon3::ARC4RandomNumberGenerator	signature:()
stopAllocator	.\BumpPointerAllocator.h	/^    void stopAllocator()$/;"	f	class:WTF::BumpPointerAllocator	access:public	signature:()
store	.\HashTraits.h	/^        static void store(PassOwnPtr<P> value, OwnPtr<P>& storage) { storage = value; }$/;"	f	struct:WTF::HashTraits	access:public	signature:(PassOwnPtr<P> value, OwnPtr<P>& storage)
store	.\HashTraits.h	/^        static void store(PassRefPtr<P> value, RefPtr<P>& storage) { storage = value; }$/;"	f	struct:WTF::HashTraits	access:public	signature:(PassRefPtr<P> value, RefPtr<P>& storage)
store	.\HashTraits.h	/^        static void store(const T& value, T& storage) { storage = value; }$/;"	f	struct:WTF::GenericHashTraits	access:public	signature:(const T& value, T& storage)
storeInc	.\dtoa.cpp	/^static ALWAYS_INLINE uint32_t* storeInc(uint32_t* p, uint16_t high, uint16_t low)$/;"	f	namespace:WTF	file:	signature:(uint32_t* p, uint16_t high, uint16_t low)
storeThreadHandleByIdentifier	.\ThreadingWin.cpp	/^static void storeThreadHandleByIdentifier(DWORD threadID, HANDLE threadHandle)$/;"	f	namespace:WTF	file:	signature:(DWORD threadID, HANDLE threadHandle)
strcasecmp	.\StringExtras.cpp	/^int strcasecmp(const char* s1, const char* s2)$/;"	f	signature:(const char* s1, const char* s2)
strcasecmp	.\StringExtras.h	/^inline int strcasecmp(const char* s1, const char* s2)$/;"	f	signature:(const char* s1, const char* s2)
strcasecmp	.\StringExtras.h	/^int strcasecmp(const char* s1, const char* s2);$/;"	p	signature:(const char* s1, const char* s2)
strcat	.\BoundsCheckedPointer.h	/^    BoundsCheckedPointer& strcat(const T* source)$/;"	f	class:WTF::BoundsCheckedPointer	access:public	signature:(const T* source)
strdup	.\StringExtras.h	/^inline char* strdup(const char* strSource)$/;"	f	signature:(const char* strSource)
strdup	.\wince\FastMallocWinCE.h	56;"	d
strdup	.\wince\FastMallocWinCE.h	60;"	d
strdup	.\wince\MemoryManager.cpp	27;"	d	file:
stricmp	.\StringExtras.h	/^inline int stricmp(const char* string1, const char* string2)$/;"	f	signature:(const char* string1, const char* string2)
string	.\text\AtomicString.h	/^    const String& string() const { return m_string; };$/;"	f	class:WTF::AtomicString	access:public	signature:() const
string	.\text\WTFString.cpp	/^String* string(const char* s)$/;"	f	signature:(const char* s)
string	.\text\WTFString.cpp	/^String* string(const char*);$/;"	p	file:	signature:(const char*)
string	.\url\api\URLString.h	/^    const String& string() const { return m_string;}$/;"	f	class:WTF::URLString	access:public	signature:() const
stringHashingStartValue	.\StringHasher.h	/^static const unsigned stringHashingStartValue = 0x9e3779b9U;$/;"	v
stringTable	.\text\AtomicString.cpp	/^static inline HashSet<StringImpl*>& stringTable()$/;"	f	namespace:WTF	file:	signature:()
stripMatchedCharacters	.\text\StringImpl.cpp	/^inline PassRefPtr<StringImpl> StringImpl::stripMatchedCharacters(UCharPredicate predicate)$/;"	f	class:WTF::StringImpl	signature:(UCharPredicate predicate)
stripMatchedCharacters	.\text\StringImpl.h	/^    template <class UCharPredicate> PassRefPtr<StringImpl> stripMatchedCharacters(UCharPredicate);$/;"	p	class:WTF::StringImpl	access:private	signature:(UCharPredicate)
stripWhiteSpace	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::stripWhiteSpace()$/;"	f	class:WTF::StringImpl	signature:()
stripWhiteSpace	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::stripWhiteSpace(IsWhiteSpaceFunctionPtr isWhiteSpace)$/;"	f	class:WTF::StringImpl	signature:(IsWhiteSpaceFunctionPtr isWhiteSpace)
stripWhiteSpace	.\text\StringImpl.h	/^    PassRefPtr<StringImpl> stripWhiteSpace();$/;"	p	class:WTF::StringImpl	access:public	signature:()
stripWhiteSpace	.\text\StringImpl.h	/^    PassRefPtr<StringImpl> stripWhiteSpace(IsWhiteSpaceFunctionPtr);$/;"	p	class:WTF::StringImpl	access:public	signature:(IsWhiteSpaceFunctionPtr)
stripWhiteSpace	.\text\WTFString.cpp	/^String String::stripWhiteSpace() const$/;"	f	class:WTF::String	signature:() const
stripWhiteSpace	.\text\WTFString.cpp	/^String String::stripWhiteSpace(IsWhiteSpaceFunctionPtr isWhiteSpace) const$/;"	f	class:WTF::String	signature:(IsWhiteSpaceFunctionPtr isWhiteSpace) const
stripWhiteSpace	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE String stripWhiteSpace() const;$/;"	p	class:WTF::String	access:public	signature:() const
stripWhiteSpace	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE String stripWhiteSpace(IsWhiteSpaceFunctionPtr) const;$/;"	p	class:WTF::String	access:public	signature:(IsWhiteSpaceFunctionPtr) const
strncasecmp	.\StringExtras.cpp	/^int strncasecmp(const char* s1, const char* s2, size_t len)$/;"	f	signature:(const char* s1, const char* s2, size_t len)
strncasecmp	.\StringExtras.h	/^inline int strncasecmp(const char* s1, const char* s2, size_t len)$/;"	f	signature:(const char* s1, const char* s2, size_t len)
strncasecmp	.\StringExtras.h	/^int strncasecmp(const char* s1, const char* s2, size_t len);$/;"	p	signature:(const char* s1, const char* s2, size_t len)
strnicmp	.\StringExtras.h	/^inline int strnicmp(const char* string1, const char* string2, size_t count)$/;"	f	signature:(const char* string1, const char* string2, size_t count)
strnstr	.\StringExtras.h	/^inline char* strnstr(const char* buffer, const char* target, size_t bufferLength)$/;"	f	signature:(const char* buffer, const char* target, size_t bufferLength)
strtod	.\dtoa.cpp	/^double strtod(const char* s00, char** se)$/;"	f	namespace:WTF	signature:(const char* s00, char** se)
strtod	.\dtoa.cpp	/^template double strtod<AllowTrailingJunk, AllowTrailingSpaces>(const char*, char**);$/;"	p	namespace:WTF	file:	signature:(const char*, char**)
strtod	.\dtoa.cpp	/^template double strtod<AllowTrailingJunk, DisallowTrailingSpaces>(const char*, char**);$/;"	p	namespace:WTF	file:	signature:(const char*, char**)
strtod	.\dtoa.cpp	/^template double strtod<DisallowTrailingJunk, AllowTrailingSpaces>(const char*, char**);$/;"	p	namespace:WTF	file:	signature:(const char*, char**)
strtod	.\dtoa.cpp	/^template double strtod<DisallowTrailingJunk, DisallowTrailingSpaces>(const char*, char**);$/;"	p	namespace:WTF	file:	signature:(const char*, char**)
strtod	.\dtoa.h	/^double strtod(const char* s00, char** se);$/;"	p	namespace:WTF	signature:(const char* s00, char** se)
styleHints	.\qt\compat\qguiapplication.h	/^    static QApplication* styleHints()$/;"	f	struct:QGuiApplication	access:public	signature:()
sub	.\CheckedArithmetic.h	/^    static inline bool sub(int64_t lhs, int64_t rhs, ResultType& result)$/;"	f	struct:WTF::ArithmeticOperations	access:public	signature:(int64_t lhs, int64_t rhs, ResultType& result)
subarray	.\Float32Array.h	/^    inline PassRefPtr<Float32Array> subarray(int start) const;$/;"	p	class:WTF::Float32Array	access:public	signature:(int start) const
subarray	.\Float32Array.h	/^    inline PassRefPtr<Float32Array> subarray(int start, int end) const;$/;"	p	class:WTF::Float32Array	access:public	signature:(int start, int end) const
subarray	.\Float32Array.h	/^PassRefPtr<Float32Array> Float32Array::subarray(int start) const$/;"	f	class:WTF::Float32Array	signature:(int start) const
subarray	.\Float32Array.h	/^PassRefPtr<Float32Array> Float32Array::subarray(int start, int end) const$/;"	f	class:WTF::Float32Array	signature:(int start, int end) const
subarray	.\Float64Array.h	/^    inline PassRefPtr<Float64Array> subarray(int start) const;$/;"	p	class:WTF::Float64Array	access:public	signature:(int start) const
subarray	.\Float64Array.h	/^    inline PassRefPtr<Float64Array> subarray(int start, int end) const;$/;"	p	class:WTF::Float64Array	access:public	signature:(int start, int end) const
subarray	.\Float64Array.h	/^PassRefPtr<Float64Array> Float64Array::subarray(int start) const$/;"	f	class:WTF::Float64Array	signature:(int start) const
subarray	.\Float64Array.h	/^PassRefPtr<Float64Array> Float64Array::subarray(int start, int end) const$/;"	f	class:WTF::Float64Array	signature:(int start, int end) const
subarray	.\Int16Array.h	/^    inline PassRefPtr<Int16Array> subarray(int start) const;$/;"	p	class:WTF::Int16Array	access:public	signature:(int start) const
subarray	.\Int16Array.h	/^    inline PassRefPtr<Int16Array> subarray(int start, int end) const;$/;"	p	class:WTF::Int16Array	access:public	signature:(int start, int end) const
subarray	.\Int16Array.h	/^PassRefPtr<Int16Array> Int16Array::subarray(int start) const$/;"	f	class:WTF::Int16Array	signature:(int start) const
subarray	.\Int16Array.h	/^PassRefPtr<Int16Array> Int16Array::subarray(int start, int end) const$/;"	f	class:WTF::Int16Array	signature:(int start, int end) const
subarray	.\Int32Array.h	/^    inline PassRefPtr<Int32Array> subarray(int start) const;$/;"	p	class:WTF::Int32Array	access:public	signature:(int start) const
subarray	.\Int32Array.h	/^    inline PassRefPtr<Int32Array> subarray(int start, int end) const;$/;"	p	class:WTF::Int32Array	access:public	signature:(int start, int end) const
subarray	.\Int32Array.h	/^PassRefPtr<Int32Array> Int32Array::subarray(int start) const$/;"	f	class:WTF::Int32Array	signature:(int start) const
subarray	.\Int32Array.h	/^PassRefPtr<Int32Array> Int32Array::subarray(int start, int end) const$/;"	f	class:WTF::Int32Array	signature:(int start, int end) const
subarray	.\Int8Array.h	/^    inline PassRefPtr<Int8Array> subarray(int start) const;$/;"	p	class:WTF::Int8Array	access:public	signature:(int start) const
subarray	.\Int8Array.h	/^    inline PassRefPtr<Int8Array> subarray(int start, int end) const;$/;"	p	class:WTF::Int8Array	access:public	signature:(int start, int end) const
subarray	.\Int8Array.h	/^PassRefPtr<Int8Array> Int8Array::subarray(int start) const$/;"	f	class:WTF::Int8Array	signature:(int start) const
subarray	.\Int8Array.h	/^PassRefPtr<Int8Array> Int8Array::subarray(int start, int end) const$/;"	f	class:WTF::Int8Array	signature:(int start, int end) const
subarray	.\Uint16Array.h	/^    inline PassRefPtr<Uint16Array> subarray(int start) const;$/;"	p	class:WTF::Uint16Array	access:public	signature:(int start) const
subarray	.\Uint16Array.h	/^    inline PassRefPtr<Uint16Array> subarray(int start, int end) const;$/;"	p	class:WTF::Uint16Array	access:public	signature:(int start, int end) const
subarray	.\Uint16Array.h	/^PassRefPtr<Uint16Array> Uint16Array::subarray(int start) const$/;"	f	class:WTF::Uint16Array	signature:(int start) const
subarray	.\Uint16Array.h	/^PassRefPtr<Uint16Array> Uint16Array::subarray(int start, int end) const$/;"	f	class:WTF::Uint16Array	signature:(int start, int end) const
subarray	.\Uint32Array.h	/^    inline PassRefPtr<Uint32Array> subarray(int start) const;$/;"	p	class:WTF::Uint32Array	access:public	signature:(int start) const
subarray	.\Uint32Array.h	/^    inline PassRefPtr<Uint32Array> subarray(int start, int end) const;$/;"	p	class:WTF::Uint32Array	access:public	signature:(int start, int end) const
subarray	.\Uint32Array.h	/^PassRefPtr<Uint32Array> Uint32Array::subarray(int start) const$/;"	f	class:WTF::Uint32Array	signature:(int start) const
subarray	.\Uint32Array.h	/^PassRefPtr<Uint32Array> Uint32Array::subarray(int start, int end) const$/;"	f	class:WTF::Uint32Array	signature:(int start, int end) const
subarray	.\Uint8Array.h	/^    inline PassRefPtr<Uint8Array> subarray(int start) const;$/;"	p	class:WTF::Uint8Array	access:public	signature:(int start) const
subarray	.\Uint8Array.h	/^    inline PassRefPtr<Uint8Array> subarray(int start, int end) const;$/;"	p	class:WTF::Uint8Array	access:public	signature:(int start, int end) const
subarray	.\Uint8Array.h	/^PassRefPtr<Uint8Array> Uint8Array::subarray(int start) const$/;"	f	class:WTF::Uint8Array	signature:(int start) const
subarray	.\Uint8Array.h	/^PassRefPtr<Uint8Array> Uint8Array::subarray(int start, int end) const$/;"	f	class:WTF::Uint8Array	signature:(int start, int end) const
subarray	.\Uint8ClampedArray.h	/^    inline PassRefPtr<Uint8ClampedArray> subarray(int start) const;$/;"	p	class:WTF::Uint8ClampedArray	access:public	signature:(int start) const
subarray	.\Uint8ClampedArray.h	/^    inline PassRefPtr<Uint8ClampedArray> subarray(int start, int end) const;$/;"	p	class:WTF::Uint8ClampedArray	access:public	signature:(int start, int end) const
subarray	.\Uint8ClampedArray.h	/^PassRefPtr<Uint8ClampedArray> Uint8ClampedArray::subarray(int start) const$/;"	f	class:WTF::Uint8ClampedArray	signature:(int start) const
subarray	.\Uint8ClampedArray.h	/^PassRefPtr<Uint8ClampedArray> Uint8ClampedArray::subarray(int start, int end) const$/;"	f	class:WTF::Uint8ClampedArray	signature:(int start, int end) const
subarrayImpl	.\TypedArrayBase.h	/^    PassRefPtr<Subclass> subarrayImpl(int start, int end) const$/;"	f	class:WTF::TypedArrayBase	access:protected	signature:(int start, int end) const
subclassCheck	.\TypeTraits.h	/^        static NoType subclassCheck(...);$/;"	p	class:WTF::IsSubclass	access:private	signature:(....)
subclassCheck	.\TypeTraits.h	/^        static NoType subclassCheck(...);$/;"	p	class:WTF::IsSubclassOfTemplate	access:private	signature:(....)
subclassCheck	.\TypeTraits.h	/^        static YesType subclassCheck(U*);$/;"	p	class:WTF::IsSubclass	access:private	signature:(U*)
subclassCheck	.\TypeTraits.h	/^        template<typename W> static YesType subclassCheck(U<W>*);$/;"	p	class:WTF::IsSubclassOfTemplate	access:private	signature:(U<W>*)
subscriptFor	.\SegmentedVector.h	/^        size_t subscriptFor(size_t index)$/;"	f	class:WTF::SegmentedVector	access:private	signature:(size_t index)
subst	.\AVLTree.h	/^    inline handle subst(handle new_node);$/;"	p	class:WTF::AVLTree	access:public	signature:(handle new_node)
subst	.\AVLTree.h	/^AVLTree<Abstractor, maxDepth, BSet>::subst(handle new_node)$/;"	f	class:WTF::AVLTree	signature:(handle new_node)
substring	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::substring(unsigned start, unsigned length)$/;"	f	class:WTF::StringImpl	signature:(unsigned start, unsigned length)
substring	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE PassRefPtr<StringImpl> substring(unsigned pos, unsigned len = UINT_MAX);$/;"	p	class:WTF::StringImpl	access:public	signature:(unsigned pos, unsigned len = UINT_MAX)
substring	.\text\WTFString.cpp	/^String String::substring(unsigned pos, unsigned len) const$/;"	f	class:WTF::String	signature:(unsigned pos, unsigned len) const
substring	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE String substring(unsigned pos, unsigned len = UINT_MAX) const;$/;"	p	class:WTF::String	access:public	signature:(unsigned pos, unsigned len = UINT_MAX) const
substringSharingImpl	.\text\WTFString.cpp	/^String String::substringSharingImpl(unsigned offset, unsigned length) const$/;"	f	class:WTF::String	signature:(unsigned offset, unsigned length) const
substringSharingImpl	.\text\WTFString.h	/^    String substringSharingImpl(unsigned pos, unsigned len = UINT_MAX) const;$/;"	p	class:WTF::String	access:public	signature:(unsigned pos, unsigned len = UINT_MAX) const
successor	.\RedBlackTree.h	/^        NodeType* successor()$/;"	f	class:WTF::RedBlackTree::Node	access:public	signature:()
successor	.\RedBlackTree.h	/^        const NodeType* successor() const$/;"	f	class:WTF::RedBlackTree::Node	access:public	signature:() const
sum	.\SimpleStats.h	/^    double sum() const$/;"	f	class:WTF::SimpleStats	access:public	signature:() const
sumOfSquares	.\SimpleStats.h	/^    double sumOfSquares() const$/;"	f	class:WTF::SimpleStats	access:public	signature:() const
sumWithOverflow	.\text\StringConcatenate.h	/^inline void sumWithOverflow(unsigned& total, unsigned addend, bool& overflow)$/;"	f	namespace:WTF	signature:(unsigned& total, unsigned addend, bool& overflow)
suppressMessages	.\RefCountedLeakCounter.cpp	/^void RefCountedLeakCounter::suppressMessages(const char*) { }$/;"	f	class:WTF::RefCountedLeakCounter	signature:(const char*)
suppressMessages	.\RefCountedLeakCounter.h	/^        WTF_EXPORT_PRIVATE static void suppressMessages(const char*);$/;"	p	struct:WTF::RefCountedLeakCounter	access:public	signature:(const char*)
surrogateToUcs4	.\unicode\wince\UnicodeWinCE.h	/^inline UChar32 surrogateToUcs4(UChar high, UChar low)$/;"	f	namespace:WTF::Unicode	signature:(UChar high, UChar low)
suspendScavenger	.\FastMalloc.cpp	/^  ALWAYS_INLINE void suspendScavenger();$/;"	p	class:WTF::TCMalloc_PageHeap	file:	access:private	signature:()
suspendScavenger	.\FastMalloc.cpp	/^ALWAYS_INLINE void TCMalloc_PageHeap::suspendScavenger()$/;"	f	class:WTF::TCMalloc_PageHeap	signature:()
swap	.\Alignment.h	/^    void swap(AlignedBuffer<size, alignment>& a, AlignedBuffer<size, alignment>& b)$/;"	f	namespace:WTF	signature:(AlignedBuffer<size, alignment>& a, AlignedBuffer<size, alignment>& b)
swap	.\Deque.h	/^        void swap(Deque<T, inlineCapacity>&);$/;"	p	class:WTF::Deque	access:public	signature:(Deque<T, inlineCapacity>&)
swap	.\Deque.h	/^    inline void Deque<T, inlineCapacity>::swap(Deque<T, inlineCapacity>& other)$/;"	f	class:WTF::Deque	signature:(Deque<T, inlineCapacity>& other)
swap	.\HashMap.h	/^        void swap(HashMap&);$/;"	p	class:WTF::HashMap	access:public	signature:(HashMap&)
swap	.\HashMap.h	/^    inline void HashMap<T, U, V, W, X>::swap(HashMap& other)$/;"	f	class:WTF::HashMap	signature:(HashMap& other)
swap	.\HashSet.h	/^        void swap(HashSet&);$/;"	p	class:WTF::HashSet	access:public	signature:(HashSet&)
swap	.\HashSet.h	/^    inline void HashSet<T, U, V>::swap(HashSet& other)$/;"	f	class:WTF::HashSet	signature:(HashSet& other)
swap	.\HashTable.h	/^        void swap(HashTable&);$/;"	p	class:WTF::HashTable	access:public	signature:(HashTable&)
swap	.\HashTable.h	/^    void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::swap(HashTable& other)$/;"	f	class:WTF::HashTable	signature:(HashTable& other)
swap	.\ListHashSet.h	/^        void swap(ListHashSet&);$/;"	p	class:WTF::ListHashSet	access:public	signature:(ListHashSet&)
swap	.\ListHashSet.h	/^    inline void ListHashSet<T, inlineCapacity, U>::swap(ListHashSet& other)$/;"	f	class:WTF::ListHashSet	signature:(ListHashSet& other)
swap	.\OwnArrayPtr.h	/^    void swap(OwnArrayPtr& o) { std::swap(m_ptr, o.m_ptr); }$/;"	f	class:WTF::OwnArrayPtr	access:public	signature:(OwnArrayPtr& o)
swap	.\OwnArrayPtr.h	/^template <typename T> inline void swap(OwnArrayPtr<T>& a, OwnArrayPtr<T>& b)$/;"	f	namespace:WTF	signature:(OwnArrayPtr<T>& a, OwnArrayPtr<T>& b)
swap	.\OwnPtr.h	/^        void swap(OwnPtr& o) { std::swap(m_ptr, o.m_ptr); }$/;"	f	class:WTF::OwnPtr	access:public	signature:(OwnPtr& o)
swap	.\OwnPtr.h	/^    template<typename T> inline void swap(OwnPtr<T>& a, OwnPtr<T>& b)$/;"	f	namespace:WTF	signature:(OwnPtr<T>& a, OwnPtr<T>& b)
swap	.\RefPtr.h	/^        void swap(RefPtr&);$/;"	p	class:WTF::RefPtr	access:public	signature:(RefPtr&)
swap	.\RefPtr.h	/^    template<class T> inline void RefPtr<T>::swap(RefPtr<T>& o)$/;"	f	class:WTF::RefPtr	signature:(RefPtr<T>& o)
swap	.\RefPtr.h	/^    template<class T> inline void swap(RefPtr<T>& a, RefPtr<T>& b)$/;"	f	namespace:WTF	signature:(RefPtr<T>& a, RefPtr<T>& b)
swap	.\RefPtrHashMap.h	/^        void swap(HashMap&);$/;"	p	class:WTF::HashMap	access:public	signature:(HashMap&)
swap	.\RefPtrHashMap.h	/^    inline void HashMap<RefPtr<T>, U, V, W, X>::swap(HashMap& other)$/;"	f	class:WTF::HashMap	signature:(HashMap& other)
swap	.\RetainPtr.h	/^        void swap(RetainPtr&);$/;"	p	class:WTF::RetainPtr	access:public	signature:(RetainPtr&)
swap	.\RetainPtr.h	/^    template<typename T> inline void RetainPtr<T>::swap(RetainPtr<T>& o)$/;"	f	class:WTF::RetainPtr	signature:(RetainPtr<T>& o)
swap	.\RetainPtr.h	/^    template<typename T> inline void swap(RetainPtr<T>& a, RetainPtr<T>& b)$/;"	f	namespace:WTF	signature:(RetainPtr<T>& a, RetainPtr<T>& b)
swap	.\Vector.h	/^        void swap(Vector<T, inlineCapacity>& other)$/;"	f	class:WTF::Vector	access:public	signature:(Vector<T, inlineCapacity>& other)
swap	.\Vector.h	/^        void swap(VectorBuffer<T, 0>& other)$/;"	f	class:WTF::VectorBuffer	access:public	signature:(VectorBuffer<T, 0>& other)
swap	.\Vector.h	/^        void swap(VectorBuffer<T, inlineCapacity>& other)$/;"	f	class:WTF::VectorBuffer	access:public	signature:(VectorBuffer<T, inlineCapacity>& other)
swap	.\Vector.h	/^    inline void swap(Vector<T, inlineCapacity>& a, Vector<T, inlineCapacity>& b)$/;"	f	namespace:WTF	signature:(Vector<T, inlineCapacity>& a, Vector<T, inlineCapacity>& b)
swap	.\gobject\GOwnPtr.h	/^    void swap(GOwnPtr& o) { std::swap(m_ptr, o.m_ptr); }$/;"	f	class:WTF::GOwnPtr	access:public	signature:(GOwnPtr& o)
swap	.\gobject\GOwnPtr.h	/^template <typename T> inline void swap(GOwnPtr<T>& a, GOwnPtr<T>& b)$/;"	f	namespace:WTF	signature:(GOwnPtr<T>& a, GOwnPtr<T>& b)
swap	.\gobject\GRefPtr.h	/^    void swap(GRefPtr&);$/;"	p	class:WTF::GRefPtr	access:public	signature:(GRefPtr&)
swap	.\gobject\GRefPtr.h	/^template <class T> inline void GRefPtr<T>::swap(GRefPtr<T>& o)$/;"	f	class:WTF::GRefPtr	signature:(GRefPtr<T>& o)
swap	.\gobject\GRefPtr.h	/^template <class T> inline void swap(GRefPtr<T>& a, GRefPtr<T>& b)$/;"	f	namespace:WTF	signature:(GRefPtr<T>& a, GRefPtr<T>& b)
swap	.\text\StringBuilder.h	/^    void swap(StringBuilder& stringBuilder)$/;"	f	class:WTF::StringBuilder	access:public	signature:(StringBuilder& stringBuilder)
swap	.\text\WTFString.h	/^    void swap(String& o) { m_impl.swap(o.m_impl); }$/;"	f	class:WTF::String	access:public	signature:(String& o)
swap	.\text\WTFString.h	/^inline void swap(String& a, String& b) { a.swap(b); }$/;"	f	namespace:WTF	signature:(String& a, String& b)
syncFlag	.\MainThread.cpp	/^    ThreadCondition* syncFlag;$/;"	m	struct:WTF::FunctionWithContext	file:	access:public
syncedTime	.\CurrentTime.cpp	/^static bool syncedTime;$/;"	v	file:
systemPageSize	.\PageBlock.cpp	/^inline size_t systemPageSize()$/;"	f	namespace:WTF	signature:()
system_bytes	.\FastMalloc.cpp	/^  uint64_t system_bytes;        \/\/ Bytes alloced from system$/;"	m	struct:WTF::TCMallocStats	file:	access:public
system_bytes_	.\FastMalloc.cpp	/^  uint64_t system_bytes_;$/;"	m	class:WTF::TCMalloc_PageHeap	file:	access:private
szName	.\ThreadingWin.cpp	/^    LPCSTR szName; \/\/ pointer to name (in user addr space)$/;"	m	struct:WTF::tagTHREADNAME_INFO	file:	access:public
t	.\FastAllocBase.h	/^            T* t;$/;"	m	union:WTF::Internal::ArraySize	access:public
t	.\TypeTraits.h	/^            static T& t;$/;"	m	class:WTF::IsConvertibleToInteger::IsConvertibleToDouble	access:private
t	.\TypeTraits.h	/^        static T* t;$/;"	m	class:WTF::IsSubclass	access:private
t	.\TypeTraits.h	/^        static T* t;$/;"	m	class:WTF::IsSubclassOfTemplate	access:private
table	.\text\AtomicString.cpp	/^    HashSet<StringImpl*>& table()$/;"	f	class:WTF::AtomicStringTable	access:public	signature:()
tableSize	.\BloomFilter.h	/^    static const size_t tableSize = 1 << keyBits;$/;"	m	class:WTF::BloomFilter	access:public
tagTHREADNAME_INFO	.\ThreadingWin.cpp	/^typedef struct tagTHREADNAME_INFO {$/;"	s	namespace:WTF	file:
tail	.\DoublyLinkedList.h	/^    T* tail() const;$/;"	p	class:WTF::DoublyLinkedList	access:public	signature:() const
tail	.\DoublyLinkedList.h	/^template<typename T> inline T* DoublyLinkedList<T>::tail() const$/;"	f	class:WTF::DoublyLinkedList	signature:() const
tail	.\FastMalloc.cpp	/^  void *tail;  \/\/ Tail of chain of objects.$/;"	m	struct:WTF::TCEntry	file:	access:public
take	.\HashMap.h	/^        MappedPassOutType take(const KeyType&); \/\/ efficient combination of get with remove$/;"	p	class:WTF::HashMap	access:public	signature:(const KeyType&)
take	.\HashMap.h	/^    HashMap<T, U, V, W, MappedTraits>::take(const KeyType& key)$/;"	f	class:WTF::HashMap	signature:(const KeyType& key)
take	.\RefPtrHashMap.h	/^        MappedPassOutType take(RawKeyType); \/\/ efficient combination of get with remove$/;"	p	class:WTF::HashMap	access:public	signature:(RawKeyType)
take	.\RefPtrHashMap.h	/^        MappedPassOutType take(const KeyType&); \/\/ efficient combination of get with remove$/;"	p	class:WTF::HashMap	access:public	signature:(const KeyType&)
take	.\RefPtrHashMap.h	/^    HashMap<RefPtr<T>, U, V, W, MappedTraits>::take(RawKeyType key)$/;"	f	class:WTF::HashMap	signature:(RawKeyType key)
take	.\RefPtrHashMap.h	/^    HashMap<RefPtr<T>, U, V, W, MappedTraits>::take(const KeyType& key)$/;"	f	class:WTF::HashMap	signature:(const KeyType& key)
takeFirst	.\Deque.h	/^        PassType takeFirst();$/;"	p	class:WTF::Deque	access:public	signature:()
takeFirst	.\Deque.h	/^    inline typename Deque<T, inlineCapacity>::PassType Deque<T, inlineCapacity>::takeFirst()$/;"	f	class:WTF::Deque	signature:()
targetExhausted	.\unicode\UTF8.h	/^            targetExhausted,    \/\/ insuff. room in target for conversion$/;"	e	enum:WTF::Unicode::__anon13
tc_length	.\FastMalloc.cpp	/^  int tc_length() {$/;"	f	class:WTF::TCMalloc_Central_FreeList	access:public	signature:()
tc_slots_	.\FastMalloc.cpp	/^  TCEntry tc_slots_[kNumTransferEntries];$/;"	m	class:WTF::TCMalloc_Central_FreeList	file:	access:private
temp_	.\FastMalloc.cpp	/^  SpinLock *held_, *temp_;$/;"	m	class:WTF::__anon6::LockInverter	file:	access:private
tens	.\dtoa.cpp	/^static const double tens[] = {$/;"	v	file:
testAndClear	.\Bitmap.h	/^    bool testAndClear(size_t);$/;"	p	class:WTF::Bitmap	access:public	signature:(size_t)
testAndClear	.\Bitmap.h	/^inline bool Bitmap<size, atomicMode>::testAndClear(size_t n)$/;"	f	class:WTF::Bitmap	signature:(size_t n)
testAndSet	.\Bitmap.h	/^    bool testAndSet(size_t);$/;"	p	class:WTF::Bitmap	access:public	signature:(size_t)
testAndSet	.\Bitmap.h	/^inline bool Bitmap<size, atomicMode>::testAndSet(size_t n)$/;"	f	class:WTF::Bitmap	signature:(size_t n)
testMD5	.\MD5.cpp	/^static inline void testMD5() { }$/;"	f	namespace:WTF	file:	signature:()
testSHA1	.\SHA1.cpp	/^static inline void testSHA1() { }$/;"	f	namespace:WTF	file:	signature:()
threadEntryPoint	.\Threading.cpp	/^static void threadEntryPoint(void* contextData)$/;"	f	namespace:WTF	file:	signature:(void* contextData)
threadHandleForIdentifier	.\ThreadingWin.cpp	/^static HANDLE threadHandleForIdentifier(ThreadIdentifier id)$/;"	f	namespace:WTF	file:	signature:(ThreadIdentifier id)
threadMap	.\ThreadingPthreads.cpp	/^static ThreadMap& threadMap()$/;"	f	namespace:WTF	file:	signature:()
threadMap	.\ThreadingWin.cpp	/^static HashMap<DWORD, HANDLE>& threadMap()$/;"	f	namespace:WTF	file:	signature:()
threadMapMutex	.\ThreadingPthreads.cpp	/^static Mutex& threadMapMutex()$/;"	f	namespace:WTF	file:	signature:()
threadMapMutex	.\ThreadingWin.cpp	/^static Mutex& threadMapMutex()$/;"	f	namespace:WTF	file:	signature:()
thread_bytes	.\FastMalloc.cpp	/^  uint64_t thread_bytes;        \/\/ Bytes in thread caches$/;"	m	struct:WTF::TCMallocStats	file:	access:public
thread_heap_count	.\FastMalloc.cpp	/^static int thread_heap_count = 0;$/;"	v	file:
thread_heaps	.\FastMalloc.cpp	/^static TCMalloc_ThreadCache* thread_heaps = NULL;$/;"	v	file:
threadheap_allocator	.\FastMalloc.cpp	/^static PageHeapAllocator<TCMalloc_ThreadCache> threadheap_allocator;$/;"	v	file:
threadingFiredMessage	.\win\MainThreadWin.cpp	/^static UINT threadingFiredMessage;$/;"	v	file:
threadingWindowHandle	.\win\MainThreadWin.cpp	/^static HWND threadingWindowHandle;$/;"	v	file:
threadlocal_heap	.\FastMalloc.cpp	/^static __thread TCMalloc_ThreadCache *threadlocal_heap;$/;"	v	file:
tibetanMarkDelimiterTshegBstar	.\unicode\CharacterNames.h	/^const UChar tibetanMarkDelimiterTshegBstar = 0x0F0C;$/;"	v
tibetanMarkIntersyllabicTsheg	.\unicode\CharacterNames.h	/^const UChar tibetanMarkIntersyllabicTsheg = 0x0F0B;$/;"	v
tid_	.\FastMalloc.cpp	/^  ThreadIdentifier tid_;                \/\/ Which thread owns it$/;"	m	class:WTF::TCMalloc_ThreadCache	file:	access:private
timeClip	.\DateMath.cpp	/^double timeClip(double t)$/;"	f	namespace:WTF	signature:(double t)
timeClip	.\DateMath.h	/^double timeClip(double);$/;"	p	namespace:WTF	signature:(double)
timedWait	.\ThreadingPrimitives.h	/^    WTF_EXPORT_PRIVATE bool timedWait(Mutex&, double absoluteTime);$/;"	p	class:WTF::ThreadCondition	access:public	signature:(Mutex&, double absoluteTime)
timedWait	.\ThreadingPthreads.cpp	/^bool ThreadCondition::timedWait(Mutex& mutex, double absoluteTime)$/;"	f	class:WTF::ThreadCondition	signature:(Mutex& mutex, double absoluteTime)
timedWait	.\ThreadingWin.cpp	/^bool PlatformCondition::timedWait(PlatformMutex& mutex, DWORD durationMilliseconds)$/;"	f	class:WTF::PlatformCondition	signature:(PlatformMutex& mutex, DWORD durationMilliseconds)
timedWait	.\ThreadingWin.cpp	/^bool ThreadCondition::timedWait(Mutex& mutex, double absoluteTime)$/;"	f	class:WTF::ThreadCondition	signature:(Mutex& mutex, double absoluteTime)
timeoutFired	.\gtk\MainThreadGtk.cpp	/^static gboolean timeoutFired(gpointer)$/;"	f	namespace:WTF	file:	signature:(gpointer)
tinytens	.\dtoa.cpp	/^static const double tinytens[] = { 1e-16, 1e-32, 1e-64, 1e-128,$/;"	v	file:
titleCaseDiff	.\unicode\qt4\UnicodeQt4.h	/^        signed short titleCaseDiff : 16;$/;"	m	struct:QUnicodeTables::Properties	access:public
titleCaseSpecial	.\unicode\qt4\UnicodeQt4.h	/^        ushort titleCaseSpecial : 1;$/;"	m	struct:QUnicodeTables::Properties	access:public
tlsIndex	.\FastMalloc.cpp	/^DWORD tlsIndex = TLS_OUT_OF_INDEXES;$/;"	v
tlsKeyCount	.\ThreadSpecific.h	/^long& tlsKeyCount();$/;"	p	namespace:WTF	signature:()
tlsKeyCount	.\ThreadSpecificWin.cpp	/^long& tlsKeyCount()$/;"	f	namespace:WTF	signature:()
tlsKeys	.\ThreadSpecific.h	/^DWORD* tlsKeys();$/;"	p	namespace:WTF	signature:()
tlsKeys	.\ThreadSpecificWin.cpp	/^DWORD* tlsKeys()$/;"	f	namespace:WTF	signature:()
toASCIIHexValue	.\ASCIICType.h	/^template<typename CharType> inline int toASCIIHexValue(CharType c)$/;"	f	namespace:WTF	signature:(CharType c)
toASCIIHexValue	.\ASCIICType.h	/^template<typename CharType> inline int toASCIIHexValue(CharType upperValue, CharType lowerValue)$/;"	f	namespace:WTF	signature:(CharType upperValue, CharType lowerValue)
toASCIILower	.\ASCIICType.h	/^template<typename CharType> inline CharType toASCIILower(CharType c)$/;"	f	namespace:WTF	signature:(CharType c)
toASCIILowerUnchecked	.\ASCIICType.h	/^template<typename CharType> inline CharType toASCIILowerUnchecked(CharType character)$/;"	f	namespace:WTF	signature:(CharType character)
toASCIIUpper	.\ASCIICType.h	/^template<typename CharType> inline CharType toASCIIUpper(CharType c)$/;"	f	namespace:WTF	signature:(CharType c)
toAtomicString	.\text\StringBuilder.h	/^    AtomicString toAtomicString() const$/;"	f	class:WTF::StringBuilder	access:public	signature:() const
toDouble	.\text\AtomicString.h	/^    double toDouble(bool* ok = 0) const { return m_string.toDouble(ok); }$/;"	f	class:WTF::AtomicString	access:public	signature:(bool* ok = 0) const
toDouble	.\text\StringImpl.cpp	/^double StringImpl::toDouble(bool* ok, bool* didReadNumber)$/;"	f	class:WTF::StringImpl	signature:(bool* ok, bool* didReadNumber)
toDouble	.\text\StringImpl.h	/^    double toDouble(bool* ok = 0, bool* didReadNumber = 0);$/;"	p	class:WTF::StringImpl	access:public	signature:(bool* ok = 0, bool* didReadNumber = 0)
toDouble	.\text\WTFString.cpp	/^double String::toDouble(bool* ok, bool* didReadNumber) const$/;"	f	class:WTF::String	signature:(bool* ok, bool* didReadNumber) const
toDouble	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE double toDouble(bool* ok = 0, bool* didReadNumber = 0) const;$/;"	p	class:WTF::String	access:public	signature:(bool* ok = 0, bool* didReadNumber = 0) const
toDoubleType	.\text\WTFString.cpp	/^static inline double toDoubleType(const CharType* data, size_t length, bool* ok, bool* didReadNumber)$/;"	f	namespace:WTF	file:	signature:(const CharType* data, size_t length, bool* ok, bool* didReadNumber)
toFloat	.\text\AtomicString.h	/^    float toFloat(bool* ok = 0) const { return m_string.toFloat(ok); }$/;"	f	class:WTF::AtomicString	access:public	signature:(bool* ok = 0) const
toFloat	.\text\StringImpl.cpp	/^float StringImpl::toFloat(bool* ok, bool* didReadNumber)$/;"	f	class:WTF::StringImpl	signature:(bool* ok, bool* didReadNumber)
toFloat	.\text\StringImpl.h	/^    float toFloat(bool* ok = 0, bool* didReadNumber = 0);$/;"	p	class:WTF::StringImpl	access:public	signature:(bool* ok = 0, bool* didReadNumber = 0)
toFloat	.\text\WTFString.cpp	/^float String::toFloat(bool* ok, bool* didReadNumber) const$/;"	f	class:WTF::String	signature:(bool* ok, bool* didReadNumber) const
toFloat	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE float toFloat(bool* ok = 0, bool* didReadNumber = 0) const;$/;"	p	class:WTF::String	access:public	signature:(bool* ok = 0, bool* didReadNumber = 0) const
toInt	.\text\AtomicString.h	/^    int toInt(bool* ok = 0) const { return m_string.toInt(ok); }$/;"	f	class:WTF::AtomicString	access:public	signature:(bool* ok = 0) const
toInt	.\text\StringImpl.cpp	/^int StringImpl::toInt(bool* ok)$/;"	f	class:WTF::StringImpl	signature:(bool* ok)
toInt	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE int toInt(bool* ok = 0); \/\/ ignores trailing garbage$/;"	p	class:WTF::StringImpl	access:public	signature:(bool* ok = 0)
toInt	.\text\WTFString.cpp	/^int String::toInt(bool* ok) const$/;"	f	class:WTF::String	signature:(bool* ok) const
toInt	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE int toInt(bool* ok = 0) const;$/;"	p	class:WTF::String	access:public	signature:(bool* ok = 0) const
toInt64	.\text\StringImpl.cpp	/^int64_t StringImpl::toInt64(bool* ok)$/;"	f	class:WTF::StringImpl	signature:(bool* ok)
toInt64	.\text\StringImpl.h	/^    int64_t toInt64(bool* ok = 0); \/\/ ignores trailing garbage$/;"	p	class:WTF::StringImpl	access:public	signature:(bool* ok = 0)
toInt64	.\text\WTFString.cpp	/^int64_t String::toInt64(bool* ok) const$/;"	f	class:WTF::String	signature:(bool* ok) const
toInt64	.\text\WTFString.h	/^    int64_t toInt64(bool* ok = 0) const;$/;"	p	class:WTF::String	access:public	signature:(bool* ok = 0) const
toInt64Strict	.\text\StringImpl.cpp	/^int64_t StringImpl::toInt64Strict(bool* ok, int base)$/;"	f	class:WTF::StringImpl	signature:(bool* ok, int base)
toInt64Strict	.\text\StringImpl.h	/^    int64_t toInt64Strict(bool* ok = 0, int base = 10);$/;"	p	class:WTF::StringImpl	access:public	signature:(bool* ok = 0, int base = 10)
toInt64Strict	.\text\WTFString.cpp	/^int64_t String::toInt64Strict(bool* ok, int base) const$/;"	f	class:WTF::String	signature:(bool* ok, int base) const
toInt64Strict	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE int64_t toInt64Strict(bool* ok = 0, int base = 10) const;$/;"	p	class:WTF::String	access:public	signature:(bool* ok = 0, int base = 10) const
toIntPtr	.\text\StringImpl.cpp	/^intptr_t StringImpl::toIntPtr(bool* ok)$/;"	f	class:WTF::StringImpl	signature:(bool* ok)
toIntPtr	.\text\StringImpl.h	/^    intptr_t toIntPtr(bool* ok = 0); \/\/ ignores trailing garbage$/;"	p	class:WTF::StringImpl	access:public	signature:(bool* ok = 0)
toIntPtr	.\text\WTFString.cpp	/^intptr_t String::toIntPtr(bool* ok) const$/;"	f	class:WTF::String	signature:(bool* ok) const
toIntPtr	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE intptr_t toIntPtr(bool* ok = 0) const;$/;"	p	class:WTF::String	access:public	signature:(bool* ok = 0) const
toIntPtrStrict	.\text\StringImpl.cpp	/^intptr_t StringImpl::toIntPtrStrict(bool* ok, int base)$/;"	f	class:WTF::StringImpl	signature:(bool* ok, int base)
toIntPtrStrict	.\text\StringImpl.h	/^    intptr_t toIntPtrStrict(bool* ok = 0, int base = 10);$/;"	p	class:WTF::StringImpl	access:public	signature:(bool* ok = 0, int base = 10)
toIntPtrStrict	.\text\WTFString.cpp	/^intptr_t String::toIntPtrStrict(bool* ok, int base) const$/;"	f	class:WTF::String	signature:(bool* ok, int base) const
toIntPtrStrict	.\text\WTFString.h	/^    intptr_t toIntPtrStrict(bool* ok = 0, int base = 10) const;$/;"	p	class:WTF::String	access:public	signature:(bool* ok = 0, int base = 10) const
toIntStrict	.\text\StringImpl.cpp	/^int StringImpl::toIntStrict(bool* ok, int base)$/;"	f	class:WTF::StringImpl	signature:(bool* ok, int base)
toIntStrict	.\text\StringImpl.h	/^    int toIntStrict(bool* ok = 0, int base = 10);$/;"	p	class:WTF::StringImpl	access:public	signature:(bool* ok = 0, int base = 10)
toIntStrict	.\text\WTFString.cpp	/^int String::toIntStrict(bool* ok, int base) const$/;"	f	class:WTF::String	signature:(bool* ok, int base) const
toIntStrict	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE int toIntStrict(bool* ok = 0, int base = 10) const;$/;"	p	class:WTF::String	access:public	signature:(bool* ok = 0, int base = 10) const
toIntegralType	.\text\WTFString.cpp	/^static inline IntegralType toIntegralType(const CharType* data, size_t length, bool* ok, int base)$/;"	f	namespace:WTF	file:	signature:(const CharType* data, size_t length, bool* ok, int base)
toLower	.\unicode\glib\UnicodeGLib.cpp	/^int toLower(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)$/;"	f	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)
toLower	.\unicode\glib\UnicodeGLib.h	/^inline UChar32 toLower(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
toLower	.\unicode\glib\UnicodeGLib.h	/^int toLower(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error);$/;"	p	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)
toLower	.\unicode\icu\UnicodeIcu.h	/^inline UChar32 toLower(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
toLower	.\unicode\icu\UnicodeIcu.h	/^inline int toLower(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)$/;"	f	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)
toLower	.\unicode\qt4\UnicodeQt4.h	/^inline UChar32 toLower(UChar32 ch)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 ch)
toLower	.\unicode\qt4\UnicodeQt4.h	/^inline int toLower(UChar* result, int resultLength, const UChar* src, int srcLength,  bool* error)$/;"	f	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)
toLower	.\unicode\wince\UnicodeWinCE.cpp	/^UChar toLower(UChar c)$/;"	f	namespace:WTF::Unicode	signature:(UChar c)
toLower	.\unicode\wince\UnicodeWinCE.cpp	/^int toLower(UChar* result, int resultLength, const UChar* source, int sourceLength, bool* isError)$/;"	f	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* source, int sourceLength, bool* isError)
toLower	.\unicode\wince\UnicodeWinCE.h	/^UChar toLower(UChar);$/;"	p	namespace:WTF::Unicode	signature:(UChar)
toLower	.\unicode\wince\UnicodeWinCE.h	/^int toLower(UChar* result, int resultLength, const UChar* source, int sourceLength, bool* isError);$/;"	p	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* source, int sourceLength, bool* isError)
toString	.\text\StringBuilder.h	/^    String toString()$/;"	f	class:WTF::StringBuilder	access:public	signature:()
toStringDecimal	.\DecimalNumber.cpp	/^unsigned DecimalNumber::toStringDecimal(UChar* buffer, unsigned bufferLength) const$/;"	f	class:WTF::DecimalNumber	signature:(UChar* buffer, unsigned bufferLength) const
toStringDecimal	.\DecimalNumber.h	/^    WTF_EXPORT_PRIVATE unsigned toStringDecimal(UChar* buffer, unsigned bufferLength) const;$/;"	p	class:WTF::DecimalNumber	access:public	signature:(UChar* buffer, unsigned bufferLength) const
toStringExponential	.\DecimalNumber.cpp	/^unsigned DecimalNumber::toStringExponential(UChar* buffer, unsigned bufferLength) const$/;"	f	class:WTF::DecimalNumber	signature:(UChar* buffer, unsigned bufferLength) const
toStringExponential	.\DecimalNumber.h	/^    WTF_EXPORT_PRIVATE unsigned toStringExponential(UChar* buffer, unsigned bufferLength) const;$/;"	p	class:WTF::DecimalNumber	access:public	signature:(UChar* buffer, unsigned bufferLength) const
toStringPreserveCapacity	.\text\StringBuilder.h	/^    const String& toStringPreserveCapacity() const$/;"	f	class:WTF::StringBuilder	access:public	signature:() const
toTitleCase	.\unicode\glib\UnicodeGLib.h	/^inline UChar32 toTitleCase(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
toTitleCase	.\unicode\icu\UnicodeIcu.h	/^inline UChar32 toTitleCase(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
toTitleCase	.\unicode\qt4\UnicodeQt4.h	/^inline int toTitleCase(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
toTitleCase	.\unicode\wince\UnicodeWinCE.cpp	/^UChar toTitleCase(UChar c)$/;"	f	namespace:WTF::Unicode	signature:(UChar c)
toTitleCase	.\unicode\wince\UnicodeWinCE.h	/^UChar toTitleCase(UChar);$/;"	p	namespace:WTF::Unicode	signature:(UChar)
toUInt	.\text\StringImpl.cpp	/^unsigned StringImpl::toUInt(bool* ok)$/;"	f	class:WTF::StringImpl	signature:(bool* ok)
toUInt	.\text\StringImpl.h	/^    unsigned toUInt(bool* ok = 0); \/\/ ignores trailing garbage$/;"	p	class:WTF::StringImpl	access:public	signature:(bool* ok = 0)
toUInt	.\text\WTFString.cpp	/^unsigned String::toUInt(bool* ok) const$/;"	f	class:WTF::String	signature:(bool* ok) const
toUInt	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE unsigned toUInt(bool* ok = 0) const;$/;"	p	class:WTF::String	access:public	signature:(bool* ok = 0) const
toUInt64	.\text\StringImpl.cpp	/^uint64_t StringImpl::toUInt64(bool* ok)$/;"	f	class:WTF::StringImpl	signature:(bool* ok)
toUInt64	.\text\StringImpl.h	/^    uint64_t toUInt64(bool* ok = 0); \/\/ ignores trailing garbage$/;"	p	class:WTF::StringImpl	access:public	signature:(bool* ok = 0)
toUInt64	.\text\WTFString.cpp	/^uint64_t String::toUInt64(bool* ok) const$/;"	f	class:WTF::String	signature:(bool* ok) const
toUInt64	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE uint64_t toUInt64(bool* ok = 0) const;$/;"	p	class:WTF::String	access:public	signature:(bool* ok = 0) const
toUInt64Strict	.\text\StringImpl.cpp	/^uint64_t StringImpl::toUInt64Strict(bool* ok, int base)$/;"	f	class:WTF::StringImpl	signature:(bool* ok, int base)
toUInt64Strict	.\text\StringImpl.h	/^    uint64_t toUInt64Strict(bool* ok = 0, int base = 10);$/;"	p	class:WTF::StringImpl	access:public	signature:(bool* ok = 0, int base = 10)
toUInt64Strict	.\text\WTFString.cpp	/^uint64_t String::toUInt64Strict(bool* ok, int base) const$/;"	f	class:WTF::String	signature:(bool* ok, int base) const
toUInt64Strict	.\text\WTFString.h	/^    uint64_t toUInt64Strict(bool* ok = 0, int base = 10) const;$/;"	p	class:WTF::String	access:public	signature:(bool* ok = 0, int base = 10) const
toUIntStrict	.\text\StringImpl.cpp	/^unsigned StringImpl::toUIntStrict(bool* ok, int base)$/;"	f	class:WTF::StringImpl	signature:(bool* ok, int base)
toUIntStrict	.\text\StringImpl.h	/^    unsigned toUIntStrict(bool* ok = 0, int base = 10);$/;"	p	class:WTF::StringImpl	access:public	signature:(bool* ok = 0, int base = 10)
toUIntStrict	.\text\WTFString.cpp	/^unsigned String::toUIntStrict(bool* ok, int base) const$/;"	f	class:WTF::String	signature:(bool* ok, int base) const
toUIntStrict	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE unsigned toUIntStrict(bool* ok = 0, int base = 10) const;$/;"	p	class:WTF::String	access:public	signature:(bool* ok = 0, int base = 10) const
toUpper	.\unicode\glib\UnicodeGLib.cpp	/^int toUpper(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)$/;"	f	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)
toUpper	.\unicode\glib\UnicodeGLib.h	/^inline UChar32 toUpper(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
toUpper	.\unicode\glib\UnicodeGLib.h	/^int toUpper(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error);$/;"	p	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)
toUpper	.\unicode\icu\UnicodeIcu.h	/^inline UChar32 toUpper(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
toUpper	.\unicode\icu\UnicodeIcu.h	/^inline int toUpper(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)$/;"	f	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)
toUpper	.\unicode\qt4\UnicodeQt4.h	/^inline UChar32 toUpper(UChar32 c)$/;"	f	namespace:WTF::Unicode	signature:(UChar32 c)
toUpper	.\unicode\qt4\UnicodeQt4.h	/^inline int toUpper(UChar* result, int resultLength, const UChar* src, int srcLength,  bool* error)$/;"	f	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)
toUpper	.\unicode\wince\UnicodeWinCE.cpp	/^UChar toUpper(UChar c)$/;"	f	namespace:WTF::Unicode	signature:(UChar c)
toUpper	.\unicode\wince\UnicodeWinCE.cpp	/^int toUpper(UChar* result, int resultLength, const UChar* source, int sourceLength, bool* isError)$/;"	f	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* source, int sourceLength, bool* isError)
toUpper	.\unicode\wince\UnicodeWinCE.h	/^UChar toUpper(UChar);$/;"	p	namespace:WTF::Unicode	signature:(UChar)
toUpper	.\unicode\wince\UnicodeWinCE.h	/^int toUpper(UChar* result, int resultLength, const UChar* source, int sourceLength, bool* isError);$/;"	p	namespace:WTF::Unicode	signature:(UChar* result, int resultLength, const UChar* source, int sourceLength, bool* isError)
toascii	.\DisallowCType.h	53;"	d
toascii	.\DisallowCType.h	70;"	d
tolower	.\DisallowCType.h	54;"	d
tolower	.\DisallowCType.h	71;"	d
toupper	.\DisallowCType.h	55;"	d
toupper	.\DisallowCType.h	72;"	d
trackAllocations	.\MetaAllocator.h	/^    void trackAllocations(MetaAllocatorTracker* tracker)$/;"	f	class:WTF::MetaAllocator	access:public	signature:(MetaAllocatorTracker* tracker)
transfer	.\ArrayBuffer.cpp	/^bool ArrayBuffer::transfer(ArrayBufferContents& result, Vector<RefPtr<ArrayBufferView> >& neuteredViews)$/;"	f	class:WTF::ArrayBuffer	signature:(ArrayBufferContents& result, Vector<RefPtr<ArrayBufferView> >& neuteredViews)
transfer	.\ArrayBuffer.h	/^    WTF_EXPORT_PRIVATE bool transfer(ArrayBufferContents&, Vector<RefPtr<ArrayBufferView> >& neuteredViews);$/;"	p	class:WTF::ArrayBuffer	access:public	signature:(ArrayBufferContents&, Vector<RefPtr<ArrayBufferView> >& neuteredViews)
transfer	.\ArrayBuffer.h	/^    void transfer(ArrayBufferContents& other)$/;"	f	class:WTF::ArrayBufferContents	access:private	signature:(ArrayBufferContents& other)
transfer	.\PassTraits.h	/^    static PassType transfer(Type& value) { return value.release(); }$/;"	f	struct:WTF::PassTraits	access:public	signature:(Type& value)
transfer	.\PassTraits.h	/^    static PassType transfer(Type& value) { return value; }$/;"	f	struct:WTF::PassTraits	access:public	signature:(Type& value)
transfer_bytes	.\FastMalloc.cpp	/^  uint64_t transfer_bytes;      \/\/ Bytes in central transfer cache$/;"	m	struct:WTF::TCMallocStats	file:	access:public
translate	.\HashMap.h	/^        template<typename T, typename U, typename V> static void translate(T& location, const U& key, const V& mapped)$/;"	f	struct:WTF::HashMapTranslator	access:public	signature:(T& location, const U& key, const V& mapped)
translate	.\HashMap.h	/^        template<typename T, typename U, typename V> static void translate(T& location, const U& key, const V& mapped, unsigned hashCode)$/;"	f	struct:WTF::HashMapTranslatorAdapter	access:public	signature:(T& location, const U& key, const V& mapped, unsigned hashCode)
translate	.\HashSet.h	/^        template<typename T, typename U> static void translate(T& location, const U& key, const U&, unsigned hashCode)$/;"	f	struct:WTF::HashSetTranslatorAdapter	access:public	signature:(T& location, const U& key, const U&, unsigned hashCode)
translate	.\HashTable.h	/^        template<typename T, typename U> static void translate(T& location, const U&, const T& value) { location = value; }$/;"	f	class:WTF::IdentityHashTranslator	access:public	signature:(T& location, const U&, const T& value)
translate	.\ListHashSet.h	/^        template<typename T, typename U, typename V> static void translate(T*& location, const U& key, const V& allocator)$/;"	f	struct:WTF::ListHashSetTranslator	access:public	signature:(T*& location, const U& key, const V& allocator)
translate	.\text\AtomicString.cpp	/^    static void translate(StringImpl*& location, const HashAndCharacters& buffer, unsigned hash)$/;"	f	struct:WTF::HashAndCharactersTranslator	access:public	signature:(StringImpl*& location, const HashAndCharacters& buffer, unsigned hash)
translate	.\text\AtomicString.cpp	/^    static void translate(StringImpl*& location, const HashAndUTF8Characters& buffer, unsigned hash)$/;"	f	struct:WTF::HashAndUTF8CharactersTranslator	access:public	signature:(StringImpl*& location, const HashAndUTF8Characters& buffer, unsigned hash)
translate	.\text\AtomicString.cpp	/^    static void translate(StringImpl*& location, const LChar* const& c, unsigned hash)$/;"	f	struct:WTF::CStringTranslator	access:public	signature:(StringImpl*& location, const LChar* const& c, unsigned hash)
translate	.\text\AtomicString.cpp	/^    static void translate(StringImpl*& location, const SubstringLocation& buffer, unsigned hash)$/;"	f	struct:WTF::SubstringTranslator	access:public	signature:(StringImpl*& location, const SubstringLocation& buffer, unsigned hash)
translate	.\text\AtomicString.cpp	/^    static void translate(StringImpl*& location, const UCharBuffer& buf, unsigned hash)$/;"	f	struct:WTF::UCharBufferTranslator	access:public	signature:(StringImpl*& location, const UCharBuffer& buf, unsigned hash)
treeInsert	.\RedBlackTree.h	/^    void treeInsert(NodeType* z)$/;"	f	class:WTF::RedBlackTree	access:private	signature:(NodeType* z)
treeMaximum	.\RedBlackTree.h	/^    static NodeType* treeMaximum(NodeType* x)$/;"	f	class:WTF::RedBlackTree	access:private	signature:(NodeType* x)
treeMaximum	.\RedBlackTree.h	/^    static const NodeType* treeMaximum(const NodeType* x)$/;"	f	class:WTF::RedBlackTree	access:private	signature:(const NodeType* x)
treeMinimum	.\RedBlackTree.h	/^    static NodeType* treeMinimum(NodeType* x)$/;"	f	class:WTF::RedBlackTree	access:private	signature:(NodeType* x)
treeMinimum	.\RedBlackTree.h	/^    static const NodeType* treeMinimum(const NodeType* x)$/;"	f	class:WTF::RedBlackTree	access:private	signature:(const NodeType* x)
tree_	.\AVLTree.h	/^        AVLTree *tree_;$/;"	m	class:WTF::AVLTree::Iterator	access:protected
trimURL	.\url\src\URLParser.h	/^    static inline void trimURL(const CharacterType* spec, int& begin, int& end)$/;"	f	class:WTF::URLParser	access:public	signature:(const CharacterType* spec, int& begin, int& end)
true_type	.\TypeTraits.h	/^    typedef IntegralConstant<bool, true>  true_type;$/;"	t	namespace:WTF
trunc	.\MathExtras.h	/^inline double trunc(double num) { return num > 0 ? floor(num) : ceil(num); }$/;"	f	signature:(double num)
truncate	.\text\WTFString.cpp	/^void String::truncate(unsigned position)$/;"	f	class:WTF::String	signature:(unsigned position)
truncate	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE void truncate(unsigned len);$/;"	p	class:WTF::String	access:public	signature:(unsigned len)
tryAllocate	.\ArrayBuffer.h	/^    static inline void tryAllocate(unsigned numElements, unsigned elementByteSize, ArrayBufferContents&);$/;"	p	class:WTF::ArrayBufferContents	access:private	signature:(unsigned numElements, unsigned elementByteSize, ArrayBufferContents&)
tryAllocate	.\ArrayBuffer.h	/^void ArrayBufferContents::tryAllocate(unsigned numElements, unsigned elementByteSize, ArrayBufferContents& result)$/;"	f	class:WTF::ArrayBufferContents	signature:(unsigned numElements, unsigned elementByteSize, ArrayBufferContents& result)
tryAllocateBuffer	.\Vector.h	/^        bool tryAllocateBuffer(size_t newCapacity)$/;"	f	class:WTF::VectorBuffer	access:public	signature:(size_t newCapacity)
tryAllocateBuffer	.\Vector.h	/^        bool tryAllocateBuffer(size_t newCapacity)$/;"	f	class:WTF::VectorBufferBase	access:public	signature:(size_t newCapacity)
tryAppend	.\Vector.h	/^        template<typename U> bool tryAppend(const U*, size_t);$/;"	p	class:WTF::Vector	access:public	signature:(const U*, size_t)
tryAppend	.\Vector.h	/^    bool Vector<T, inlineCapacity>::tryAppend(const U* data, size_t dataSize)$/;"	f	class:WTF::Vector	signature:(const U* data, size_t dataSize)
tryCreateUninitialized	.\text\StringImpl.h	/^    template <typename T> static ALWAYS_INLINE PassRefPtr<StringImpl> tryCreateUninitialized(unsigned length, T*& output)$/;"	f	class:WTF::StringImpl	access:public	signature:(unsigned length, T*& output)
tryExpandCapacity	.\Vector.h	/^        bool tryExpandCapacity(size_t newMinCapacity);$/;"	p	class:WTF::Vector	access:private	signature:(size_t newMinCapacity)
tryExpandCapacity	.\Vector.h	/^        const T* tryExpandCapacity(size_t newMinCapacity, const T*);$/;"	p	class:WTF::Vector	access:private	signature:(size_t newMinCapacity, const T*)
tryExpandCapacity	.\Vector.h	/^    bool Vector<T, inlineCapacity>::tryExpandCapacity(size_t newMinCapacity)$/;"	f	class:WTF::Vector	signature:(size_t newMinCapacity)
tryExpandCapacity	.\Vector.h	/^    const T* Vector<T, inlineCapacity>::tryExpandCapacity(size_t newMinCapacity, const T* ptr)$/;"	f	class:WTF::Vector	signature:(size_t newMinCapacity, const T* ptr)
tryFastCalloc	.\FastMalloc.cpp	/^TryMallocReturnValue tryFastCalloc(size_t n, size_t elem_size)$/;"	f	namespace:WTF	signature:(size_t n, size_t elem_size)
tryFastCalloc	.\FastMalloc.cpp	/^TryMallocReturnValue tryFastCalloc(size_t n_elements, size_t element_size)$/;"	f	namespace:WTF	signature:(size_t n_elements, size_t element_size)
tryFastCalloc	.\FastMalloc.h	/^    WTF_EXPORT_PRIVATE TryMallocReturnValue tryFastCalloc(size_t n_elements, size_t element_size);$/;"	p	namespace:WTF	signature:(size_t n_elements, size_t element_size)
tryFastCalloc	.\wince\FastMallocWinCE.h	/^void* tryFastCalloc(size_t n_elements, size_t element_size);$/;"	p	signature:(size_t n_elements, size_t element_size)
tryFastCalloc	.\wince\MemoryManager.cpp	/^TryMallocReturnValue tryFastCalloc(size_t n_elements, size_t element_size)$/;"	f	namespace:WTF	signature:(size_t n_elements, size_t element_size)
tryFastMalloc	.\FastMalloc.cpp	/^TryMallocReturnValue tryFastMalloc(size_t n) $/;"	f	namespace:WTF	signature:(size_t n)
tryFastMalloc	.\FastMalloc.cpp	/^TryMallocReturnValue tryFastMalloc(size_t size)$/;"	f	namespace:WTF	signature:(size_t size)
tryFastMalloc	.\FastMalloc.h	/^    WTF_EXPORT_PRIVATE TryMallocReturnValue tryFastMalloc(size_t n);$/;"	p	namespace:WTF	signature:(size_t n)
tryFastMalloc	.\wince\FastMallocWinCE.h	/^void* tryFastMalloc(size_t n);$/;"	p	signature:(size_t n)
tryFastMalloc	.\wince\MemoryManager.cpp	/^TryMallocReturnValue tryFastMalloc(size_t n)$/;"	f	namespace:WTF	signature:(size_t n)
tryFastRealloc	.\FastMalloc.cpp	/^TryMallocReturnValue tryFastRealloc(void* old_ptr, size_t new_size)$/;"	f	namespace:WTF	signature:(void* old_ptr, size_t new_size)
tryFastRealloc	.\FastMalloc.cpp	/^TryMallocReturnValue tryFastRealloc(void* p, size_t n)$/;"	f	namespace:WTF	signature:(void* p, size_t n)
tryFastRealloc	.\FastMalloc.h	/^    WTF_EXPORT_PRIVATE TryMallocReturnValue tryFastRealloc(void* p, size_t n);$/;"	p	namespace:WTF	signature:(void* p, size_t n)
tryFastRealloc	.\wince\FastMallocWinCE.h	/^void* tryFastRealloc(void* p, size_t n);$/;"	p	signature:(void* p, size_t n)
tryFastRealloc	.\wince\MemoryManager.cpp	/^TryMallocReturnValue tryFastRealloc(void* p, size_t n)$/;"	f	namespace:WTF	signature:(void* p, size_t n)
tryFastZeroedMalloc	.\FastMalloc.cpp	/^TryMallocReturnValue tryFastZeroedMalloc(size_t n) $/;"	f	namespace:WTF	signature:(size_t n)
tryFastZeroedMalloc	.\FastMalloc.h	/^    TryMallocReturnValue tryFastZeroedMalloc(size_t n);$/;"	p	namespace:WTF	signature:(size_t n)
tryFastZeroedMalloc	.\wince\FastMallocWinCE.h	/^void* tryFastZeroedMalloc(size_t n);$/;"	p	signature:(size_t n)
tryFastZeroedMalloc	.\wince\MemoryManager.cpp	/^TryMallocReturnValue tryFastZeroedMalloc(size_t n)$/;"	f	namespace:WTF	signature:(size_t n)
tryGetMessage	.\MessageQueue.h	/^        PassOwnPtr<DataType> tryGetMessage();$/;"	p	class:WTF::MessageQueue	access:public	signature:()
tryGetMessage	.\MessageQueue.h	/^    inline PassOwnPtr<DataType> MessageQueue<DataType>::tryGetMessage()$/;"	f	class:WTF::MessageQueue	signature:()
tryGetMessageIgnoringKilled	.\MessageQueue.h	/^        PassOwnPtr<DataType> tryGetMessageIgnoringKilled();$/;"	p	class:WTF::MessageQueue	access:public	signature:()
tryGetMessageIgnoringKilled	.\MessageQueue.h	/^    inline PassOwnPtr<DataType> MessageQueue<DataType>::tryGetMessageIgnoringKilled()$/;"	f	class:WTF::MessageQueue	signature:()
tryLock	.\ThreadingPrimitives.h	/^    WTF_EXPORT_PRIVATE bool tryLock();$/;"	p	class:WTF::Mutex	access:public	signature:()
tryLock	.\ThreadingPthreads.cpp	/^bool Mutex::tryLock()$/;"	f	class:WTF::Mutex	signature:()
tryLock	.\ThreadingWin.cpp	/^bool Mutex::tryLock()$/;"	f	class:WTF::Mutex	signature:()
tryLockFor	.\ParallelJobsGeneric.cpp	/^bool ParallelEnvironment::ThreadPrivate::tryLockFor(ParallelEnvironment* parent)$/;"	f	class:WTF::ParallelEnvironment::ThreadPrivate	signature:(ParallelEnvironment* parent)
tryLockFor	.\ParallelJobsGeneric.h	/^        bool tryLockFor(ParallelEnvironment*);$/;"	p	class:WTF::ParallelEnvironment::ThreadPrivate	access:public	signature:(ParallelEnvironment*)
tryMakeString	.\text\StringConcatenate.h	/^PassRefPtr<StringImpl> tryMakeString(StringType1 string1, StringType2 string2)$/;"	f	namespace:WTF	signature:(StringType1 string1, StringType2 string2)
tryMakeString	.\text\StringConcatenate.h	/^PassRefPtr<StringImpl> tryMakeString(StringType1 string1, StringType2 string2, StringType3 string3)$/;"	f	namespace:WTF	signature:(StringType1 string1, StringType2 string2, StringType3 string3)
tryMakeString	.\text\StringConcatenate.h	/^PassRefPtr<StringImpl> tryMakeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4)$/;"	f	namespace:WTF	signature:(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4)
tryMakeString	.\text\StringConcatenate.h	/^PassRefPtr<StringImpl> tryMakeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5)$/;"	f	namespace:WTF	signature:(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5)
tryMakeString	.\text\StringConcatenate.h	/^PassRefPtr<StringImpl> tryMakeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6)$/;"	f	namespace:WTF	signature:(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6)
tryMakeString	.\text\StringConcatenate.h	/^PassRefPtr<StringImpl> tryMakeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6, StringType7 string7)$/;"	f	namespace:WTF	signature:(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6, StringType7 string7)
tryMakeString	.\text\StringConcatenate.h	/^PassRefPtr<StringImpl> tryMakeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6, StringType7 string7, StringType8 string8)$/;"	f	namespace:WTF	signature:(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6, StringType7 string7, StringType8 string8)
tryMakeString	.\text\StringConcatenate.h	/^PassRefPtr<StringImpl> tryMakeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6, StringType7 string7, StringType8 string8, StringType9 string9)$/;"	f	namespace:WTF	signature:(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6, StringType7 string7, StringType8 string8, StringType9 string9)
tryReadLock	.\ThreadingPrimitives.h	/^    bool tryReadLock();$/;"	p	class:WTF::ReadWriteLock	access:public	signature:()
tryReadLock	.\ThreadingPthreads.cpp	/^bool ReadWriteLock::tryReadLock()$/;"	f	class:WTF::ReadWriteLock	signature:()
tryReserveCapacity	.\Vector.h	/^        bool tryReserveCapacity(size_t newCapacity);$/;"	p	class:WTF::Vector	access:public	signature:(size_t newCapacity)
tryReserveCapacity	.\Vector.h	/^    bool Vector<T, inlineCapacity>::tryReserveCapacity(size_t newCapacity)$/;"	f	class:WTF::Vector	signature:(size_t newCapacity)
tryWriteLock	.\ThreadingPrimitives.h	/^    bool tryWriteLock();$/;"	p	class:WTF::ReadWriteLock	access:public	signature:()
tryWriteLock	.\ThreadingPthreads.cpp	/^bool ReadWriteLock::tryWriteLock()$/;"	f	class:WTF::ReadWriteLock	signature:()
tsd_inited	.\FastMalloc.cpp	/^static bool tsd_inited = false;$/;"	v	file:
turn2deg	.\MathExtras.h	/^inline double turn2deg(double t) { return t * 360.0; }$/;"	f	signature:(double t)
turn2deg	.\MathExtras.h	/^inline float turn2deg(float t) { return t * 360.0f; }$/;"	f	signature:(float t)
turnOffVerification	.\ThreadRestrictionVerifier.h	/^    void turnOffVerification()$/;"	f	class:WTF::ThreadRestrictionVerifier	access:public	signature:()
turnOffVerifier	.\RefCounted.h	/^    void turnOffVerifier()$/;"	f	class:WTF::RefCountedBase	access:public	signature:()
twoDigitStringFromNumber	.\DateMath.cpp	/^static String twoDigitStringFromNumber(int number)$/;"	f	namespace:WTF	file:	signature:(int number)
type	.\TypeTraits.h	/^        typedef IntegralConstant<T, v> type;$/;"	t	struct:WTF::IntegralConstant	access:public
typelessPointersAreEqual	.\Vector.h	/^    inline bool typelessPointersAreEqual(const void* a, const void* b) { return a == b; }$/;"	f	namespace:WTF	signature:(const void* a, const void* b)
tzName	.\DateMath.cpp	/^        char tzName[4];$/;"	m	struct:WTF::KnownZone	file:	access:public
tzOffset	.\DateMath.cpp	/^    int tzOffset;$/;"	m	struct:WTF::KnownZone	file:	access:public
ugariticWordDivider	.\unicode\CharacterNames.h	/^const UChar32 ugariticWordDivider = 0x1039F;$/;"	v
uint16_t	.\dtoa\utils.h	/^typedef unsigned short uint16_t;  \/\/ NOLINT$/;"	t
uint32_t	.\dtoa\utils.h	/^typedef unsigned int uint32_t;$/;"	t
uint64_t	.\dtoa\utils.h	/^typedef unsigned __int64 uint64_t;$/;"	t
uint64_to_double	.\dtoa\double.h	/^    static double uint64_to_double(uint64_t d64) { return BitCast<double>(d64); }$/;"	f	namespace:WTF::double_conversion	signature:(uint64_t d64)
uint8_t	.\dtoa\utils.h	/^typedef unsigned char uint8_t;$/;"	t
umemcasecmp	.\unicode\glib\UnicodeGLib.cpp	/^int umemcasecmp(const UChar* a, const UChar* b, int len)$/;"	f	namespace:WTF::Unicode	signature:(const UChar* a, const UChar* b, int len)
umemcasecmp	.\unicode\glib\UnicodeGLib.h	/^int umemcasecmp(const UChar*, const UChar*, int len);$/;"	p	namespace:WTF::Unicode	signature:(const UChar*, const UChar*, int len)
umemcasecmp	.\unicode\icu\UnicodeIcu.h	/^inline int umemcasecmp(const UChar* a, const UChar* b, int len)$/;"	f	namespace:WTF::Unicode	signature:(const UChar* a, const UChar* b, int len)
umemcasecmp	.\unicode\qt4\UnicodeQt4.h	/^inline int umemcasecmp(const UChar* a, const UChar* b, int len)$/;"	f	namespace:WTF::Unicode	signature:(const UChar* a, const UChar* b, int len)
umemcasecmp	.\unicode\wince\UnicodeWinCE.h	/^inline int umemcasecmp(const UChar* a, const UChar* b, int len)$/;"	f	namespace:WTF::Unicode	signature:(const UChar* a, const UChar* b, int len)
uncheckedAppend	.\Vector.h	/^        template<typename U> void uncheckedAppend(const U& val);$/;"	p	class:WTF::Vector	access:public	signature:(const U& val)
uncheckedAppend	.\Vector.h	/^    inline void Vector<T, inlineCapacity>::uncheckedAppend(const U& val)$/;"	f	class:WTF::Vector	signature:(const U& val)
unicodeVersion	.\unicode\qt4\UnicodeQt4.h	/^        ushort unicodeVersion : 4;$/;"	m	struct:QUnicodeTables::Properties	access:public
unify	.\UnionFind.h	/^    void unify(T* other)$/;"	f	class:WTF::UnionFind	access:public	signature:(T* other)
uninitializedCopy	.\Vector.h	/^        static void uninitializedCopy(const T* src, const T* srcEnd, T* dst) $/;"	f	struct:WTF::VectorCopier	access:public	signature:(const T* src, const T* srcEnd, T* dst)
uninitializedCopy	.\Vector.h	/^        static void uninitializedCopy(const T* src, const T* srcEnd, T* dst)$/;"	f	struct:WTF::VectorTypeOperations	access:public	signature:(const T* src, const T* srcEnd, T* dst)
uninitializedFill	.\Vector.h	/^        static void uninitializedFill(T* dst, T* dstEnd, const T& val) $/;"	f	struct:WTF::VectorFiller	access:public	signature:(T* dst, T* dstEnd, const T& val)
uninitializedFill	.\Vector.h	/^        static void uninitializedFill(T* dst, T* dstEnd, const T& val)$/;"	f	struct:WTF::VectorTypeOperations	access:public	signature:(T* dst, T* dstEnd, const T& val)
unlinkAndDelete	.\ListHashSet.h	/^        void unlinkAndDelete(Node*);$/;"	p	class:WTF::ListHashSet	access:private	signature:(Node*)
unlinkAndDelete	.\ListHashSet.h	/^    void ListHashSet<T, inlineCapacity, U>::unlinkAndDelete(Node* node)$/;"	f	class:WTF::ListHashSet	signature:(Node* node)
unlock	.\ThreadingPrimitives.h	/^    WTF_EXPORT_PRIVATE void unlock();$/;"	p	class:WTF::Mutex	access:public	signature:()
unlock	.\ThreadingPrimitives.h	/^    void unlock();$/;"	p	class:WTF::ReadWriteLock	access:public	signature:()
unlock	.\ThreadingPthreads.cpp	/^void Mutex::unlock()$/;"	f	class:WTF::Mutex	signature:()
unlock	.\ThreadingPthreads.cpp	/^void ReadWriteLock::unlock()$/;"	f	class:WTF::ReadWriteLock	signature:()
unlock	.\ThreadingWin.cpp	/^void Mutex::unlock()$/;"	f	class:WTF::Mutex	signature:()
unlockAtomicallyInitializedStaticMutex	.\Threading.h	/^WTF_EXPORT_PRIVATE void unlockAtomicallyInitializedStaticMutex();$/;"	p	namespace:WTF	signature:()
unlockAtomicallyInitializedStaticMutex	.\ThreadingPthreads.cpp	/^void unlockAtomicallyInitializedStaticMutex()$/;"	f	namespace:WTF	signature:()
unlockAtomicallyInitializedStaticMutex	.\ThreadingWin.cpp	/^void unlockAtomicallyInitializedStaticMutex()$/;"	f	namespace:WTF	signature:()
unsafeGet	.\CheckedArithmetic.h	/^    T unsafeGet() const$/;"	f	class:WTF::Checked	access:public	signature:() const
unusedParam	.\UnusedParam.h	/^inline void unusedParam(T& x) { (void)x; }$/;"	f	signature:(T& x)
unwrap	.\Functional.h	/^    static T* unwrap(const StorageType& value) { return value.get(); }$/;"	f	struct:WTF::ParamStorageTraits	access:public	signature:(const StorageType& value)
unwrap	.\Functional.h	/^    static const T& unwrap(const StorageType& value) { return value; }$/;"	f	struct:WTF::ParamStorageTraits	access:public	signature:(const StorageType& value)
unwrap	.\Functional.h	/^    static typename RetainPtr<T>::PtrType unwrap(const StorageType& value) { return value.get(); }$/;"	f	struct:WTF::ParamStorageTraits	access:public	signature:(const StorageType& value)
upconvertCharacters	.\text\StringImpl.cpp	/^void StringImpl::upconvertCharacters(unsigned start, unsigned end) const$/;"	f	class:WTF::StringImpl	signature:(unsigned start, unsigned end) const
upconvertCharacters	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE void upconvertCharacters(unsigned, unsigned) const;$/;"	p	class:WTF::StringImpl	access:public	signature:(unsigned, unsigned) const
upper	.\text\AtomicString.h	/^    AtomicString upper() const { return AtomicString(impl()->upper()); }$/;"	f	class:WTF::AtomicString	access:public	signature:() const
upper	.\text\StringImpl.cpp	/^PassRefPtr<StringImpl> StringImpl::upper()$/;"	f	class:WTF::StringImpl	signature:()
upper	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE PassRefPtr<StringImpl> upper();$/;"	p	class:WTF::StringImpl	access:public	signature:()
upper	.\text\WTFString.cpp	/^String String::upper() const$/;"	f	class:WTF::String	signature:() const
upper	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE String upper() const;$/;"	p	class:WTF::String	access:public	signature:() const
upperCaseDiff	.\unicode\qt4\UnicodeQt4.h	/^        signed short upperCaseDiff : 16;$/;"	m	struct:QUnicodeTables::Properties	access:public
upperCaseSpecial	.\unicode\qt4\UnicodeQt4.h	/^        ushort upperCaseSpecial : 1;$/;"	m	struct:QUnicodeTables::Properties	access:public
upperNibbleToASCIIHexDigit	.\ASCIICType.h	/^inline char upperNibbleToASCIIHexDigit(char c)$/;"	f	namespace:WTF	signature:(char c)
use_VirtualAlloc	.\TCSystemAlloc.cpp	/^static bool use_VirtualAlloc = true;$/;"	v	file:
use_devmem	.\TCSystemAlloc.cpp	/^static bool use_devmem = false;$/;"	v	file:
use_mmap	.\TCSystemAlloc.cpp	/^static bool use_mmap = true;$/;"	v	file:
use_sbrk	.\TCSystemAlloc.cpp	/^static bool use_sbrk = false;$/;"	v	file:
usecPerSec	.\DateMath.cpp	/^static const double usecPerSec = 1000000.0;$/;"	v	file:
used_digits_	.\dtoa\bignum.h	/^        int used_digits_;$/;"	m	class:WTF::double_conversion::Bignum	access:private
used_slots_	.\FastMalloc.cpp	/^  int32_t used_slots_;$/;"	m	class:WTF::TCMalloc_Central_FreeList	file:	access:private
userDefault	.\unicode\Collator.h	/^        static PassOwnPtr<Collator> userDefault();$/;"	p	class:WTF::Collator	access:public	signature:()
userDefault	.\unicode\CollatorDefault.cpp	/^PassOwnPtr<Collator> Collator::userDefault()$/;"	f	class:WTF::Collator	signature:()
userDefault	.\unicode\icu\CollatorICU.cpp	/^PassOwnPtr<Collator> Collator::userDefault()$/;"	f	class:WTF::Collator	signature:()
username	.\url\api\ParsedURL.cpp	/^String ParsedURL::username() const$/;"	f	class:WTF::ParsedURL	signature:() const
username	.\url\api\ParsedURL.h	/^    WTF_EXPORT_PRIVATE String username() const;$/;"	p	class:WTF::ParsedURL	access:public	signature:() const
username	.\url\src\URLSegments.h	/^    URLComponent username;$/;"	m	class:WTF::URLSegments	access:public
utf16Length	.\text\AtomicString.cpp	/^    unsigned utf16Length;$/;"	m	struct:WTF::HashAndUTF8Characters	file:	access:public
utf8	.\text\WTFString.cpp	/^CString String::utf8(bool strict) const$/;"	f	class:WTF::String	signature:(bool strict) const
utf8	.\text\WTFString.h	/^    WTF_EXPORT_PRIVATE CString utf8(bool strict = false) const;$/;"	p	class:WTF::String	access:public	signature:(bool strict = false) const
val	.\dtoa.cpp	/^    BigInt val;$/;"	m	struct:WTF::P5Node	file:	access:public
validate	.\BoundsCheckedPointer.h	/^    void validate() const$/;"	f	class:WTF::BoundsCheckedPointer	access:private	signature:() const
validate	.\BoundsCheckedPointer.h	/^    void validate(T* pointer) const$/;"	f	class:WTF::BoundsCheckedPointer	access:private	signature:(T* pointer) const
value	.\FastMalloc.cpp	/^  int value[64];$/;"	m	struct:WTF::Span	file:	access:public
value	.\Functional.h	/^    static const bool value = sizeof(refCheck(static_cast<Base*>(0))) == sizeof(YesType) && sizeof(derefCheck(static_cast<Base*>(0))) == sizeof(YesType);$/;"	m	class:WTF::HasRefAndDeref	access:public
value	.\ThreadSpecific.h	/^        T* value;$/;"	m	struct:WTF::ThreadSpecific::Data	access:public
value	.\TypeTraits.h	/^            static const bool value = false;$/;"	m	class:WTF::IsConvertibleToInteger::IsConvertibleToDouble	access:public
value	.\TypeTraits.h	/^            static const bool value = sizeof(floatCheck(t)) == sizeof(YesType);$/;"	m	class:WTF::IsConvertibleToInteger::IsConvertibleToDouble	access:public
value	.\TypeTraits.h	/^        static const T value = v;$/;"	m	struct:WTF::IntegralConstant	access:public
value	.\TypeTraits.h	/^        static const bool value = IsInteger<T>::value || IsConvertibleToDouble<!IsInteger<T>::value, T>::value;$/;"	m	class:WTF::IsConvertibleToInteger	access:public
value	.\TypeTraits.h	/^        static const bool value = false;$/;"	m	struct:WTF::IsArray	access:public
value	.\TypeTraits.h	/^        static const bool value = false;$/;"	m	struct:WTF::IsSameType	access:public
value	.\TypeTraits.h	/^        static const bool value = sizeof(subclassCheck(t)) == sizeof(YesType);$/;"	m	class:WTF::IsSubclass	access:public
value	.\TypeTraits.h	/^        static const bool value = sizeof(subclassCheck(t)) == sizeof(YesType);$/;"	m	class:WTF::IsSubclassOfTemplate	access:public
value	.\TypeTraits.h	/^        static const bool value = true;$/;"	m	struct:WTF::IsArray	access:public
value	.\TypeTraits.h	/^        static const bool value = true;$/;"	m	struct:WTF::IsSameType	access:public
value	.\TypeTraits.h	/^    template <typename P> struct IsPod<P*>       { static const bool value = true; };$/;"	m	struct:WTF::IsPod	access:public
value	.\TypeTraits.h	/^    template <typename T> struct IsPod           { static const bool value = IsArithmetic<T>::value; };$/;"	m	struct:WTF::IsPod	access:public
value	.\TypeTraits.h	/^    template<> struct IsFloatingPoint<double>       { static const bool value = true; };$/;"	m	struct:WTF::IsFloatingPoint	access:public
value	.\TypeTraits.h	/^    template<> struct IsFloatingPoint<float>        { static const bool value = true; };$/;"	m	struct:WTF::IsFloatingPoint	access:public
value	.\TypeTraits.h	/^    template<> struct IsFloatingPoint<long double>  { static const bool value = true; };$/;"	m	struct:WTF::IsFloatingPoint	access:public
value	.\TypeTraits.h	/^    template<> struct IsInteger<bool>               { static const bool value = true; };$/;"	m	struct:WTF::IsInteger	access:public
value	.\TypeTraits.h	/^    template<> struct IsInteger<char>               { static const bool value = true; };$/;"	m	struct:WTF::IsInteger	access:public
value	.\TypeTraits.h	/^    template<> struct IsInteger<int>                { static const bool value = true; };$/;"	m	struct:WTF::IsInteger	access:public
value	.\TypeTraits.h	/^    template<> struct IsInteger<long long>          { static const bool value = true; };$/;"	m	struct:WTF::IsInteger	access:public
value	.\TypeTraits.h	/^    template<> struct IsInteger<long>               { static const bool value = true; };$/;"	m	struct:WTF::IsInteger	access:public
value	.\TypeTraits.h	/^    template<> struct IsInteger<short>              { static const bool value = true; };$/;"	m	struct:WTF::IsInteger	access:public
value	.\TypeTraits.h	/^    template<> struct IsInteger<signed char>        { static const bool value = true; };$/;"	m	struct:WTF::IsInteger	access:public
value	.\TypeTraits.h	/^    template<> struct IsInteger<unsigned char>      { static const bool value = true; };$/;"	m	struct:WTF::IsInteger	access:public
value	.\TypeTraits.h	/^    template<> struct IsInteger<unsigned int>       { static const bool value = true; };$/;"	m	struct:WTF::IsInteger	access:public
value	.\TypeTraits.h	/^    template<> struct IsInteger<unsigned long long> { static const bool value = true; };$/;"	m	struct:WTF::IsInteger	access:public
value	.\TypeTraits.h	/^    template<> struct IsInteger<unsigned long>      { static const bool value = true; };$/;"	m	struct:WTF::IsInteger	access:public
value	.\TypeTraits.h	/^    template<> struct IsInteger<unsigned short>     { static const bool value = true; };$/;"	m	struct:WTF::IsInteger	access:public
value	.\TypeTraits.h	/^    template<> struct IsInteger<wchar_t>            { static const bool value = true; };$/;"	m	struct:WTF::IsInteger	access:public
value	.\TypeTraits.h	/^    template<typename T> struct IsArithmetic     { static const bool value = IsInteger<T>::value || IsFloatingPoint<T>::value; };$/;"	m	struct:WTF::IsArithmetic	access:public
value	.\TypeTraits.h	/^    template<typename T> struct IsFloatingPoint     { static const bool value = false; };$/;"	m	struct:WTF::IsFloatingPoint	access:public
value	.\TypeTraits.h	/^    template<typename T> struct IsInteger           { static const bool value = false; };$/;"	m	struct:WTF::IsInteger	access:public
value	.\dtoa\double.h	/^        double value() const { return uint64_to_double(d64_); }$/;"	f	class:WTF::double_conversion::Double	access:public	signature:() const
value	.\text\ASCIIFastPath.h	/^    static inline uint32_t value() { return 0x80808080U; }$/;"	f	struct:WTF::NonASCIIMask	access:public	signature:()
value	.\text\ASCIIFastPath.h	/^    static inline uint32_t value() { return 0xFF80FF80U; }$/;"	f	struct:WTF::NonASCIIMask	access:public	signature:()
value	.\text\ASCIIFastPath.h	/^    static inline uint64_t value() { return 0x8080808080808080ULL; }$/;"	f	struct:WTF::NonASCIIMask	access:public	signature:()
value	.\text\ASCIIFastPath.h	/^    static inline uint64_t value() { return 0xFF80FF80FF80FF80ULL; }$/;"	f	struct:WTF::NonASCIIMask	access:public	signature:()
value_type	.\TypeTraits.h	/^        typedef T value_type;$/;"	t	struct:WTF::IntegralConstant	access:public
values	.\HashIterators.h	/^        Values values() { return Values(*this); }$/;"	f	struct:WTF::HashTableConstIteratorAdapter	access:public	signature:()
values	.\HashIterators.h	/^        Values values() { return Values(*this); }$/;"	f	struct:WTF::HashTableIteratorAdapter	access:public	signature:()
values	.\HashMap.h	/^        HashMapValuesProxy& values() { return static_cast<HashMapValuesProxy&>(*this); }$/;"	f	class:WTF::HashMap	access:public	signature:()
values	.\HashMap.h	/^        const HashMapValuesProxy& values() const { return static_cast<const HashMapValuesProxy&>(*this); }$/;"	f	class:WTF::HashMap	access:public	signature:() const
values	.\TCPageMap.h	/^    void* values[LEAF_LENGTH];$/;"	m	struct:TCMalloc_PageMap2::Leaf	access:public
values	.\TCPageMap.h	/^    void* values[LEAF_LENGTH];$/;"	m	struct:TCMalloc_PageMap3::Leaf	access:public
variance	.\SimpleStats.h	/^    double variance() const$/;"	f	class:WTF::SimpleStats	access:public	signature:() const
verifySubRange	.\ArrayBufferView.h	/^    static bool verifySubRange(PassRefPtr<ArrayBuffer> buffer,$/;"	f	class:WTF::ArrayBufferView	access:protected	signature:(PassRefPtr<ArrayBuffer> buffer, unsigned byteOffset, unsigned numElements)
virtualAlloc	.\wince\MemoryManager.cpp	/^LPVOID MemoryManager::virtualAlloc(LPVOID lpAddress, DWORD dwSize, DWORD flAllocationType, DWORD flProtect)$/;"	f	class:WTF::MemoryManager	signature:(LPVOID lpAddress, DWORD dwSize, DWORD flAllocationType, DWORD flProtect)
virtualAlloc	.\wince\MemoryManager.h	/^        static LPVOID virtualAlloc(LPVOID lpAddress, DWORD dwSize, DWORD flAllocationType, DWORD flProtect);$/;"	p	class:WTF::MemoryManager	access:public	signature:(LPVOID lpAddress, DWORD dwSize, DWORD flAllocationType, DWORD flProtect)
virtualFree	.\wince\MemoryManager.cpp	/^BOOL MemoryManager::virtualFree(LPVOID lpAddress, DWORD dwSize, DWORD dwFreeType)$/;"	f	class:WTF::MemoryManager	signature:(LPVOID lpAddress, DWORD dwSize, DWORD dwFreeType)
virtualFree	.\wince\MemoryManager.h	/^        static BOOL virtualFree(LPVOID lpAddress, DWORD dwSize, DWORD dwFreeType);$/;"	p	class:WTF::MemoryManager	access:public	signature:(LPVOID lpAddress, DWORD dwSize, DWORD dwFreeType)
visit	.\FastMalloc.cpp	/^    int visit(void* ptr) const$/;"	f	class:WTF::PageMapFreeObjectFinder	access:public	signature:(void* ptr) const
visit	.\FastMalloc.cpp	/^    int visit(void* ptr)$/;"	f	class:WTF::PageMapMemoryUsageRecorder	access:public	signature:(void* ptr)
visit	.\FastMalloc.cpp	/^    void visit(void *ptr, size_t size)$/;"	f	class:WTF::AdminRegionRecorder	access:public	signature:(void *ptr, size_t size)
visit	.\FastMalloc.cpp	/^    void visit(void* ptr) { m_freeObjects.add(ptr); }$/;"	f	class:WTF::FreeObjectFinder	access:public	signature:(void* ptr)
visitAllocations	.\TCPageMap.h	/^  void visitAllocations(Visitor& visitor, const MemoryReader& reader) {$/;"	f	class:TCMalloc_PageMap3	access:public	signature:(Visitor& visitor, const MemoryReader& reader)
visitAllocations	.\TCPageMap.h	/^  void visitAllocations(Visitor& visitor, const MemoryReader&) {$/;"	f	class:TCMalloc_PageMap2	access:public	signature:(Visitor& visitor, const MemoryReader&)
visitValues	.\TCPageMap.h	/^  void visitValues(Visitor& visitor, const MemoryReader& reader) {$/;"	f	class:TCMalloc_PageMap3	access:public	signature:(Visitor& visitor, const MemoryReader& reader)
visitValues	.\TCPageMap.h	/^  void visitValues(Visitor& visitor, const MemoryReader& reader)$/;"	f	class:TCMalloc_PageMap2	access:public	signature:(Visitor& visitor, const MemoryReader& reader)
vprintf_stderr_common	.\Assertions.cpp	/^static void vprintf_stderr_common(const char* format, va_list args)$/;"	f	file:	signature:(const char* format, va_list args)
vprintf_stderr_with_prefix	.\Assertions.cpp	/^static void vprintf_stderr_with_prefix(const char* prefix, const char* format, va_list args)$/;"	f	file:	signature:(const char* prefix, const char* format, va_list args)
vprintf_stderr_with_trailing_newline	.\Assertions.cpp	/^static void vprintf_stderr_with_trailing_newline(const char* format, va_list args)$/;"	f	file:	signature:(const char* format, va_list args)
vsnprintf	.\StringExtras.h	70;"	d
wait	.\ThreadingPrimitives.h	/^    WTF_EXPORT_PRIVATE void wait(Mutex& mutex);$/;"	p	class:WTF::ThreadCondition	access:public	signature:(Mutex& mutex)
wait	.\ThreadingPthreads.cpp	/^void ThreadCondition::wait(Mutex& mutex)$/;"	f	class:WTF::ThreadCondition	signature:(Mutex& mutex)
wait	.\ThreadingWin.cpp	/^void ThreadCondition::wait(Mutex& mutex)$/;"	f	class:WTF::ThreadCondition	signature:(Mutex& mutex)
wait	.\threads\BinarySemaphore.cpp	/^bool BinarySemaphore::wait(double absoluteTime)$/;"	f	class:WTF::BinarySemaphore	signature:(double absoluteTime)
wait	.\threads\BinarySemaphore.h	/^    bool wait(double absoluteTime);$/;"	p	class:WTF::BinarySemaphore	access:public	signature:(double absoluteTime)
wait	.\threads\win\BinarySemaphoreWin.cpp	/^bool BinarySemaphore::wait(double absoluteTime)$/;"	f	class:WTF::BinarySemaphore	signature:(double absoluteTime)
waitForFinish	.\ParallelJobsGeneric.cpp	/^void ParallelEnvironment::ThreadPrivate::waitForFinish()$/;"	f	class:WTF::ParallelEnvironment::ThreadPrivate	signature:()
waitForFinish	.\ParallelJobsGeneric.h	/^        void waitForFinish();$/;"	p	class:WTF::ParallelEnvironment::ThreadPrivate	access:public	signature:()
waitForMessage	.\MessageQueue.h	/^        PassOwnPtr<DataType> waitForMessage();$/;"	p	class:WTF::MessageQueue	access:public	signature:()
waitForMessage	.\MessageQueue.h	/^    inline PassOwnPtr<DataType> MessageQueue<DataType>::waitForMessage()$/;"	f	class:WTF::MessageQueue	signature:()
waitForMessageFilteredWithTimeout	.\MessageQueue.h	/^        PassOwnPtr<DataType> waitForMessageFilteredWithTimeout(MessageQueueWaitResult&, Predicate&, double absoluteTime);$/;"	p	class:WTF::MessageQueue	access:public	signature:(MessageQueueWaitResult&, Predicate&, double absoluteTime)
waitForMessageFilteredWithTimeout	.\MessageQueue.h	/^    inline PassOwnPtr<DataType> MessageQueue<DataType>::waitForMessageFilteredWithTimeout(MessageQueueWaitResult& result, Predicate& predicate, double absoluteTime)$/;"	f	class:WTF::MessageQueue	signature:(MessageQueueWaitResult& result, Predicate& predicate, double absoluteTime)
waitForThreadCompletion	.\Threading.cpp	/^WTF_EXPORT_PRIVATE int waitForThreadCompletion(ThreadIdentifier, void**);$/;"	p	namespace:WTF	file:	signature:(ThreadIdentifier, void**)
waitForThreadCompletion	.\Threading.cpp	/^int waitForThreadCompletion(ThreadIdentifier threadID, void**)$/;"	f	namespace:WTF	signature:(ThreadIdentifier threadID, void**)
waitForThreadCompletion	.\Threading.h	/^WTF_EXPORT_PRIVATE int waitForThreadCompletion(ThreadIdentifier);$/;"	p	namespace:WTF	signature:(ThreadIdentifier)
waitForThreadCompletion	.\ThreadingPthreads.cpp	/^int waitForThreadCompletion(ThreadIdentifier threadID)$/;"	f	namespace:WTF	signature:(ThreadIdentifier threadID)
waitForThreadCompletion	.\ThreadingWin.cpp	/^int waitForThreadCompletion(ThreadIdentifier threadID)$/;"	f	namespace:WTF	signature:(ThreadIdentifier threadID)
weakCompareAndSwap	.\Atomics.h	/^inline bool weakCompareAndSwap(void*volatile* location, void* expected, void* newValue)$/;"	f	namespace:WTF	signature:(void*volatile* location, void* expected, void* newValue)
weakCompareAndSwap	.\Atomics.h	/^inline bool weakCompareAndSwap(volatile unsigned* location, unsigned expected, unsigned newValue) $/;"	f	namespace:WTF	signature:(volatile unsigned* location, unsigned expected, unsigned newValue)
weakCompareAndSwapUIntPtr	.\Atomics.h	/^inline bool weakCompareAndSwapUIntPtr(volatile uintptr_t* location, uintptr_t expected, uintptr_t newValue)$/;"	f	namespace:WTF	signature:(volatile uintptr_t* location, uintptr_t expected, uintptr_t newValue)
weekdayName	.\DateMath.h	/^const char* const weekdayName[7] = { "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun" };$/;"	v
whiteBullet	.\unicode\CharacterNames.h	/^const UChar whiteBullet = 0x25E6;$/;"	v
whiteCircle	.\unicode\CharacterNames.h	/^const UChar whiteCircle = 0x25CB;$/;"	v
whiteSesameDot	.\unicode\CharacterNames.h	/^const UChar whiteSesameDot = 0xFE46;$/;"	v
whiteUpPointingTriangle	.\unicode\CharacterNames.h	/^const UChar whiteUpPointingTriangle = 0x25B3;$/;"	v
word0	.\dtoa.cpp	101;"	d	file:
word0	.\dtoa.cpp	104;"	d	file:
word1	.\dtoa.cpp	102;"	d	file:
word1	.\dtoa.cpp	105;"	d	file:
wordSize	.\Bitmap.h	/^    static const WordType wordSize = sizeof(WordType) * 8;$/;"	m	class:WTF::Bitmap	access:private
words	.\Bitmap.h	/^    static const WordType words = (size + wordSize - 1) \/ wordSize;$/;"	m	class:WTF::Bitmap	access:private
words	.\dtoa.cpp	/^    const uint32_t* words() const$/;"	f	struct:WTF::BigInt	access:public	signature:() const
words	.\dtoa.cpp	/^    uint32_t* words()$/;"	f	struct:WTF::BigInt	access:public	signature:()
workAroundClangBug	.\CheckedArithmetic.h	/^static inline bool workAroundClangBug() { return true; }$/;"	f	namespace:WTF	signature:()
workerThread	.\ParallelJobsGeneric.cpp	/^void ParallelEnvironment::ThreadPrivate::workerThread(void* threadData)$/;"	f	class:WTF::ParallelEnvironment::ThreadPrivate	signature:(void* threadData)
workerThread	.\ParallelJobsGeneric.h	/^        static void workerThread(void*);$/;"	p	class:WTF::ParallelEnvironment::ThreadPrivate	access:public	signature:(void*)
wrap	.\Functional.h	/^    static StorageType wrap(PassRefPtr<T> value) { return value; }$/;"	f	struct:WTF::ParamStorageTraits	access:public	signature:(PassRefPtr<T> value)
wrap	.\Functional.h	/^    static StorageType wrap(RefPtr<T> value) { return value.release(); }$/;"	f	struct:WTF::ParamStorageTraits	access:public	signature:(RefPtr<T> value)
wrap	.\Functional.h	/^    static StorageType wrap(const RetainPtr<T>& value) { return value; }$/;"	f	struct:WTF::ParamStorageTraits	access:public	signature:(const RetainPtr<T>& value)
wrap	.\Functional.h	/^    static StorageType wrap(const T& value) { return value; }$/;"	f	struct:WTF::ParamStorageTraits	access:public	signature:(const T& value)
writeLock	.\ThreadingPrimitives.h	/^    void writeLock();$/;"	p	class:WTF::ReadWriteLock	access:public	signature:()
writeLock	.\ThreadingPthreads.cpp	/^void ReadWriteLock::writeLock()$/;"	f	class:WTF::ReadWriteLock	signature:()
writeTo	.\text\StringConcatenate.h	/^    NO_RETURN_DUE_TO_CRASH void writeTo(LChar*)$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(LChar*)
writeTo	.\text\StringConcatenate.h	/^    void writeTo(LChar* destination) { m_adapter.writeTo(destination); }$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(LChar* destination)
writeTo	.\text\StringConcatenate.h	/^    void writeTo(LChar* destination)$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(LChar* destination)
writeTo	.\text\StringConcatenate.h	/^    void writeTo(UChar* destination) { *destination = m_buffer; }$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(UChar* destination)
writeTo	.\text\StringConcatenate.h	/^    void writeTo(UChar* destination) { m_adapter.writeTo(destination); }$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(UChar* destination)
writeTo	.\text\StringConcatenate.h	/^    void writeTo(UChar* destination)$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(UChar* destination)
writeTo	.\text\StringOperators.h	/^    void writeTo(LChar* destination) { m_buffer.writeTo(destination); }$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(LChar* destination)
writeTo	.\text\StringOperators.h	/^    void writeTo(LChar* destination)$/;"	f	class:WTF::StringAppend	access:public	signature:(LChar* destination)
writeTo	.\text\StringOperators.h	/^    void writeTo(UChar* destination) { m_buffer.writeTo(destination); }$/;"	f	class:WTF::StringTypeAdapter	access:public	signature:(UChar* destination)
writeTo	.\text\StringOperators.h	/^    void writeTo(UChar* destination)$/;"	f	class:WTF::StringAppend	access:public	signature:(UChar* destination)
wtfThreadData	.\WTFThreadData.h	/^    friend WTFThreadData& wtfThreadData();$/;"	p	class:WTF::WTFThreadData	access:friend	signature:()
wtfThreadData	.\WTFThreadData.h	/^inline WTFThreadData& wtfThreadData()$/;"	f	namespace:WTF	signature:()
wtfThreadEntryPoint	.\ThreadingPthreads.cpp	/^static void* wtfThreadEntryPoint(void* param)$/;"	f	namespace:WTF	file:	signature:(void* param)
wtfThreadEntryPoint	.\ThreadingWin.cpp	/^static unsigned __stdcall wtfThreadEntryPoint(void* param)$/;"	f	namespace:WTF	file:	signature:(void* param)
wtf_atan2	.\MathExtras.h	/^inline double wtf_atan2(double x, double y)$/;"	f	signature:(double x, double y)
wtf_ceil	.\MathExtras.h	/^inline double wtf_ceil(double x) { return copysign(ceil(x), x); }$/;"	f	signature:(double x)
wtf_fmod	.\MathExtras.h	/^inline double wtf_fmod(double x, double y) { return (!isinf(x) && isinf(y)) ? x : fmod(x, y); }$/;"	f	signature:(double x, double y)
wtf_pow	.\MathExtras.h	/^inline double wtf_pow(double x, double y) { return y == 0 ? 1 : pow(x, y); }$/;"	f	signature:(double x, double y)
wtf_vsnprintf	.\StringExtras.h	/^inline double wtf_vsnprintf(char* buffer, size_t count, const char* format, va_list args)$/;"	f	signature:(char* buffer, size_t count, const char* format, va_list args)
wxCallAfter	.\wx\MainThreadWx.cpp	/^    wxCallAfter() $/;"	f	class:wxCallAfter	access:public	signature:()
wxCallAfter	.\wx\MainThreadWx.cpp	/^class wxCallAfter : public wxEvtHandler$/;"	c	file:	inherits:wxEvtHandler
wxCallAfter::OnCallback	.\wx\MainThreadWx.cpp	/^    void OnCallback(wxCommandEvent& event)$/;"	f	class:wxCallAfter	access:public	signature:(wxCommandEvent& event)
wxCallAfter::wxCallAfter	.\wx\MainThreadWx.cpp	/^    wxCallAfter() $/;"	f	class:wxCallAfter	access:public	signature:()
wxEVT_CALL_AFTER	.\wx\MainThreadWx.cpp	/^const wxEventType wxEVT_CALL_AFTER = wxNewEventType();$/;"	v
yenSign	.\unicode\CharacterNames.h	/^const UChar yenSign = 0x00A5;$/;"	v
yield	.\Threading.h	/^WTF_EXPORT_PRIVATE void yield();$/;"	p	namespace:WTF	signature:()
yield	.\ThreadingPthreads.cpp	/^void yield()$/;"	f	namespace:WTF	signature:()
yield	.\ThreadingWin.cpp	/^void yield()$/;"	f	namespace:WTF	signature:()
ymdhmsToSeconds	.\DateMath.cpp	/^static inline double ymdhmsToSeconds(long year, int mon, int day, int hour, int minute, double second)$/;"	f	namespace:WTF	file:	signature:(long year, int mon, int day, int hour, int minute, double second)
zeroBasedInt	.\text\TextPosition.h	/^    int zeroBasedInt() const { return m_zeroBasedValue; }$/;"	f	class:WTF::OrdinalNumber	access:public	signature:() const
zeroRange	.\TypedArrayBase.h	/^    bool zeroRange(unsigned offset, size_t length)$/;"	f	class:WTF::TypedArrayBase	access:public	signature:(unsigned offset, size_t length)
zeroRangeImpl	.\ArrayBufferView.h	/^    inline bool zeroRangeImpl(unsigned byteOffset, size_t rangeByteLength);$/;"	p	class:WTF::ArrayBufferView	access:protected	signature:(unsigned byteOffset, size_t rangeByteLength)
zeroRangeImpl	.\ArrayBufferView.h	/^bool ArrayBufferView::zeroRangeImpl(unsigned byteOffset, size_t rangeByteLength)$/;"	f	class:WTF::ArrayBufferView	signature:(unsigned byteOffset, size_t rangeByteLength)
zeroWidthJoiner	.\unicode\CharacterNames.h	/^const UChar zeroWidthJoiner = 0x200D;$/;"	v
zeroWidthNoBreakSpace	.\unicode\CharacterNames.h	/^const UChar zeroWidthNoBreakSpace = 0xFEFF;$/;"	v
zeroWidthNonJoiner	.\unicode\CharacterNames.h	/^const UChar zeroWidthNonJoiner = 0x200C;$/;"	v
zeroWidthSpace	.\unicode\CharacterNames.h	/^const UChar zeroWidthSpace = 0x200B;$/;"	v
zoneCalloc	.\FastMalloc.cpp	/^    static void* zoneCalloc(malloc_zone_t*, size_t numItems, size_t size);$/;"	p	class:WTF::FastMallocZone	file:	access:private	signature:(malloc_zone_t*, size_t numItems, size_t size)
zoneCalloc	.\FastMalloc.cpp	/^void* FastMallocZone::zoneCalloc(malloc_zone_t*, size_t, size_t)$/;"	f	class:WTF::FastMallocZone	signature:(malloc_zone_t*, size_t, size_t)
zoneDestroy	.\FastMalloc.cpp	/^    static void zoneDestroy(malloc_zone_t*) { }$/;"	f	class:WTF::FastMallocZone	file:	access:private	signature:(malloc_zone_t*)
zoneFree	.\FastMalloc.cpp	/^    static void zoneFree(malloc_zone_t*, void*);$/;"	p	class:WTF::FastMallocZone	file:	access:private	signature:(malloc_zone_t*, void*)
zoneFree	.\FastMalloc.cpp	/^void FastMallocZone::zoneFree(malloc_zone_t*, void* ptr)$/;"	f	class:WTF::FastMallocZone	signature:(malloc_zone_t*, void* ptr)
zoneMalloc	.\FastMalloc.cpp	/^    static void* zoneMalloc(malloc_zone_t*, size_t);$/;"	p	class:WTF::FastMallocZone	file:	access:private	signature:(malloc_zone_t*, size_t)
zoneMalloc	.\FastMalloc.cpp	/^void* FastMallocZone::zoneMalloc(malloc_zone_t*, size_t)$/;"	f	class:WTF::FastMallocZone	signature:(malloc_zone_t*, size_t)
zoneRealloc	.\FastMalloc.cpp	/^    static void* zoneRealloc(malloc_zone_t*, void*, size_t);$/;"	p	class:WTF::FastMallocZone	file:	access:private	signature:(malloc_zone_t*, void*, size_t)
zoneRealloc	.\FastMalloc.cpp	/^void* FastMallocZone::zoneRealloc(malloc_zone_t*, void*, size_t)$/;"	f	class:WTF::FastMallocZone	signature:(malloc_zone_t*, void*, size_t)
zoneValloc	.\FastMalloc.cpp	/^    static void* zoneValloc(malloc_zone_t*, size_t) { LOG_ERROR("valloc is not supported"); return 0; }$/;"	f	class:WTF::FastMallocZone	file:	access:private	signature:(malloc_zone_t*, size_t)
~AdminRegionRecorder	.\FastMalloc.cpp	/^    ~AdminRegionRecorder()$/;"	f	class:WTF::AdminRegionRecorder	access:public	signature:()
~ArrayBuffer	.\ArrayBuffer.h	/^    ~ArrayBuffer() { }$/;"	f	class:WTF::ArrayBuffer	access:public	signature:()
~ArrayBufferContents	.\ArrayBuffer.h	/^    inline ~ArrayBufferContents();$/;"	p	class:WTF::ArrayBufferContents	access:public	signature:()
~ArrayBufferContents	.\ArrayBuffer.h	/^ArrayBufferContents::~ArrayBufferContents()$/;"	f	class:WTF::ArrayBufferContents	signature:()
~ArrayBufferView	.\ArrayBufferView.cpp	/^ArrayBufferView::~ArrayBufferView()$/;"	f	class:WTF::ArrayBufferView	signature:()
~ArrayBufferView	.\ArrayBufferView.h	/^    WTF_EXPORT_PRIVATE virtual ~ArrayBufferView();$/;"	p	class:WTF::ArrayBufferView	access:public	signature:()
~BinarySemaphore	.\threads\BinarySemaphore.cpp	/^BinarySemaphore::~BinarySemaphore()$/;"	f	class:WTF::BinarySemaphore	signature:()
~BinarySemaphore	.\threads\BinarySemaphore.h	/^    ~BinarySemaphore();$/;"	p	class:WTF::BinarySemaphore	access:public	signature:()
~BinarySemaphore	.\threads\win\BinarySemaphoreWin.cpp	/^BinarySemaphore::~BinarySemaphore()$/;"	f	class:WTF::BinarySemaphore	signature:()
~BitVector	.\BitVector.h	/^    ~BitVector()$/;"	f	class:WTF::BitVector	access:public	signature:()
~BlockStack	.\BlockStack.h	/^    ~BlockStack();$/;"	p	class:WTF::BlockStack	access:public	signature:()
~BlockStack	.\BlockStack.h	/^template <typename T> BlockStack<T>::~BlockStack()$/;"	f	class:WTF::BlockStack	signature:()
~BoundFunctionImpl	.\Functional.h	/^    ~BoundFunctionImpl()$/;"	f	class:WTF::BoundFunctionImpl	access:public	signature:()
~BumpPointerAllocator	.\BumpPointerAllocator.h	/^    ~BumpPointerAllocator()$/;"	f	class:WTF::BumpPointerAllocator	access:public	signature:()
~CheckedBoolean	.\CheckedBoolean.h	/^    ~CheckedBoolean()$/;"	f	class:CheckedBoolean	access:public	signature:()
~Collator	.\unicode\Collator.h	/^        WTF_EXPORT_PRIVATE ~Collator();$/;"	p	class:WTF::Collator	access:public	signature:()
~Collator	.\unicode\CollatorDefault.cpp	/^Collator::~Collator()$/;"	f	class:WTF::Collator	signature:()
~Collator	.\unicode\icu\CollatorICU.cpp	/^Collator::~Collator()$/;"	f	class:WTF::Collator	signature:()
~Decoder	.\Decoder.h	/^    virtual ~Decoder() { }$/;"	f	class:WTF::Decoder	access:protected	signature:()
~Deque	.\Deque.h	/^        ~Deque();$/;"	p	class:WTF::Deque	access:public	signature:()
~Deque	.\Deque.h	/^    inline Deque<T, inlineCapacity>::~Deque()$/;"	f	class:WTF::Deque	signature:()
~DequeIteratorBase	.\Deque.h	/^        ~DequeIteratorBase();$/;"	p	class:WTF::DequeIteratorBase	access:protected	signature:()
~DequeIteratorBase	.\Deque.h	/^    inline DequeIteratorBase<T, inlineCapacity>::~DequeIteratorBase()$/;"	f	class:WTF::DequeIteratorBase	signature:()
~Encoder	.\Encoder.h	/^    virtual ~Encoder() { }$/;"	f	class:WTF::Encoder	access:protected	signature:()
~FunctionImplBase	.\Functional.h	/^    virtual ~FunctionImplBase() { }$/;"	f	class:WTF::FunctionImplBase	access:public	signature:()
~GOwnPtr	.\gobject\GOwnPtr.h	/^    ~GOwnPtr() { freeOwnedGPtr(m_ptr); }$/;"	f	class:WTF::GOwnPtr	access:public	signature:()
~GRefPtr	.\gobject\GRefPtr.h	/^    ~GRefPtr()$/;"	f	class:WTF::GRefPtr	access:public	signature:()
~HashMapKeysProxy	.\HashMap.h	/^            ~HashMapKeysProxy();$/;"	p	class:WTF::HashMap::HashMapKeysProxy	access:private	signature:()
~HashMapValuesProxy	.\HashMap.h	/^            ~HashMapValuesProxy();$/;"	p	class:WTF::HashMap::HashMapValuesProxy	access:private	signature:()
~HashTable	.\HashTable.h	/^        ~HashTable() $/;"	f	class:WTF::HashTable	access:public	signature:()
~HashTableConstIterator	.\HashTable.h	/^        ~HashTableConstIterator()$/;"	f	class:WTF::HashTableConstIterator	access:public	signature:()
~HashTableStats	.\HashTable.cpp	/^HashTableStats::~HashTableStats()$/;"	f	class:WTF::HashTableStats	signature:()
~HashTableStats	.\HashTable.h	/^        ~HashTableStats();$/;"	p	struct:WTF::HashTableStats	access:public	signature:()
~IdentifierTable	.\WTFThreadData.cpp	/^IdentifierTable::~IdentifierTable()$/;"	f	class:JSC::IdentifierTable	signature:()
~IdentifierTable	.\WTFThreadData.h	/^    ~IdentifierTable();$/;"	p	class:JSC::IdentifierTable	access:public	signature:()
~ListHashSet	.\ListHashSet.h	/^        ~ListHashSet();$/;"	p	class:WTF::ListHashSet	access:public	signature:()
~ListHashSet	.\ListHashSet.h	/^    inline ListHashSet<T, inlineCapacity, U>::~ListHashSet()$/;"	f	class:WTF::ListHashSet	signature:()
~ListRefPtr	.\ListRefPtr.h	/^        ~ListRefPtr()$/;"	f	class:WTF::ListRefPtr	access:public	signature:()
~LockInverter	.\FastMalloc.cpp	/^  inline ~LockInverter() { temp_->Unlock(); held_->Lock();  }$/;"	f	class:WTF::__anon6::LockInverter	access:public	signature:()
~Locker	.\Locker.h	/^    ~Locker() { m_lockable.unlock(); }$/;"	f	class:WTF::Locker	access:public	signature:()
~MemoryAllocationCanFail	.\wince\MemoryManager.h	/^        ~MemoryAllocationCanFail() { memoryManager()->setAllocationCanFail(m_old); }$/;"	f	class:WTF::MemoryAllocationCanFail	access:public	signature:()
~MemoryAllocationCannotFail	.\wince\MemoryManager.h	/^        ~MemoryAllocationCannotFail() { memoryManager()->setAllocationCanFail(m_old); }$/;"	f	class:WTF::MemoryAllocationCannotFail	access:public	signature:()
~MemoryManager	.\wince\MemoryManager.cpp	/^MemoryManager::~MemoryManager()$/;"	f	class:WTF::MemoryManager	signature:()
~MemoryManager	.\wince\MemoryManager.h	/^        ~MemoryManager();$/;"	p	class:WTF::MemoryManager	access:public	signature:()
~MessageQueue	.\MessageQueue.h	/^        ~MessageQueue();$/;"	p	class:WTF::MessageQueue	access:public	signature:()
~MessageQueue	.\MessageQueue.h	/^    MessageQueue<DataType>::~MessageQueue()$/;"	f	class:WTF::MessageQueue	signature:()
~MetaAllocator	.\MetaAllocator.h	/^    virtual ~MetaAllocator();$/;"	p	class:WTF::MetaAllocator	access:public	signature:()
~MetaAllocator	.\MetaAllocator.h	/^inline MetaAllocator::~MetaAllocator()$/;"	f	class:WTF::MetaAllocator	signature:()
~MetaAllocatorHandle	.\MetaAllocator.cpp	/^MetaAllocatorHandle::~MetaAllocatorHandle()$/;"	f	class:WTF::MetaAllocatorHandle	signature:()
~MetaAllocatorHandle	.\MetaAllocatorHandle.h	/^    WTF_EXPORT_PRIVATE ~MetaAllocatorHandle();$/;"	p	class:WTF::MetaAllocatorHandle	access:public	signature:()
~Mutex	.\ThreadingPrimitives.h	/^    WTF_EXPORT_PRIVATE ~Mutex();$/;"	p	class:WTF::Mutex	access:public	signature:()
~Mutex	.\ThreadingPthreads.cpp	/^Mutex::~Mutex()$/;"	f	class:WTF::Mutex	signature:()
~Mutex	.\ThreadingWin.cpp	/^Mutex::~Mutex()$/;"	f	class:WTF::Mutex	signature:()
~NonNullPassRefPtr	.\PassRefPtr.h	/^        ALWAYS_INLINE ~NonNullPassRefPtr() { derefIfNotNull(m_ptr); }$/;"	f	class:WTF::NonNullPassRefPtr	access:public	signature:()
~OwnArrayPtr	.\OwnArrayPtr.h	/^    ~OwnArrayPtr() { deleteOwnedArrayPtr(m_ptr); }$/;"	f	class:WTF::OwnArrayPtr	access:public	signature:()
~OwnPtr	.\OwnPtr.h	/^        ~OwnPtr() { deleteOwnedPtr(m_ptr); }$/;"	f	class:WTF::OwnPtr	access:public	signature:()
~PageMapMemoryUsageRecorder	.\FastMalloc.cpp	/^    ~PageMapMemoryUsageRecorder()$/;"	f	class:WTF::PageMapMemoryUsageRecorder	access:public	signature:()
~PassOwnArrayPtr	.\PassOwnArrayPtr.h	/^    ~PassOwnArrayPtr() { deleteOwnedArrayPtr(m_ptr); }$/;"	f	class:WTF::PassOwnArrayPtr	access:public	signature:()
~PassOwnPtr	.\PassOwnPtr.h	/^        ~PassOwnPtr() { deleteOwnedPtr(m_ptr); }$/;"	f	class:WTF::PassOwnPtr	access:public	signature:()
~PassRefPtr	.\PassRefPtr.h	/^        ALWAYS_INLINE ~PassRefPtr() { derefIfNotNull(m_ptr); }$/;"	f	class:WTF::PassRefPtr	access:public	signature:()
~PossiblyNull	.\PossiblyNull.h	/^    ~PossiblyNull() { ASSERT(!m_data); }$/;"	f	struct:WTF::PossiblyNull	access:public	signature:()
~RawURLBuffer	.\url\src\RawURLBuffer.h	/^    virtual ~RawURLBuffer()$/;"	f	class:WTF::RawURLBuffer	access:public	signature:()
~ReadWriteLock	.\ThreadingPrimitives.h	/^    ~ReadWriteLock();$/;"	p	class:WTF::ReadWriteLock	access:public	signature:()
~ReadWriteLock	.\ThreadingPthreads.cpp	/^ReadWriteLock::~ReadWriteLock()$/;"	f	class:WTF::ReadWriteLock	signature:()
~RefCounted	.\RefCounted.h	/^    ~RefCounted()$/;"	f	class:WTF::RefCounted	access:protected	signature:()
~RefCountedArray	.\RefCountedArray.h	/^    ~RefCountedArray()$/;"	f	class:WTF::RefCountedArray	access:public	signature:()
~RefCountedBase	.\RefCounted.h	/^    ~RefCountedBase()$/;"	f	class:WTF::RefCountedBase	access:protected	signature:()
~RefCountedCustomAllocated	.\RefCounted.h	/^    ~RefCountedCustomAllocated()$/;"	f	class:WTF::RefCountedCustomAllocated	access:protected	signature:()
~RefCountedLeakCounter	.\RefCountedLeakCounter.cpp	/^RefCountedLeakCounter::~RefCountedLeakCounter() { }$/;"	f	class:WTF::RefCountedLeakCounter	signature:()
~RefCountedLeakCounter	.\RefCountedLeakCounter.h	/^        WTF_EXPORT_PRIVATE ~RefCountedLeakCounter();$/;"	p	struct:WTF::RefCountedLeakCounter	access:public	signature:()
~RefPtr	.\RefPtr.h	/^        ALWAYS_INLINE ~RefPtr() { derefIfNotNull(m_ptr); }$/;"	f	class:WTF::RefPtr	access:public	signature:()
~RetainPtr	.\RetainPtr.h	/^        ~RetainPtr() { if (PtrType ptr = m_ptr) CFRelease(ptr); }$/;"	f	class:WTF::RetainPtr	access:public	signature:()
~SegmentedVector	.\SegmentedVector.h	/^        ~SegmentedVector()$/;"	f	class:WTF::SegmentedVector	access:public	signature:()
~SegmentedVectorIterator	.\SegmentedVector.h	/^        ~SegmentedVectorIterator() { }$/;"	f	class:WTF::SegmentedVectorIterator	access:public	signature:()
~String	.\text\WTFString.h	/^    ALWAYS_INLINE ~String() { }$/;"	f	class:WTF::String	access:public	signature:()
~StringBuffer	.\text\StringBuffer.h	/^    ~StringBuffer()$/;"	f	class:WTF::StringBuffer	access:public	signature:()
~StringBuilder	.\dtoa\utils.h	/^        ~StringBuilder() { if (!is_finalized()) Finalize(); }$/;"	f	class:WTF::double_conversion::StringBuilder	access:public	signature:()
~StringImpl	.\text\StringImpl.cpp	/^StringImpl::~StringImpl()$/;"	f	class:WTF::StringImpl	signature:()
~StringImpl	.\text\StringImpl.h	/^    WTF_EXPORT_PRIVATE ~StringImpl();$/;"	p	class:WTF::StringImpl	access:public	signature:()
~TCMallocGuard	.\FastMalloc.cpp	/^  ~TCMallocGuard() {$/;"	f	class:WTF::TCMallocGuard	access:public	signature:()
~TCMalloc_SpinLockHolder	.\TCSpinLock.h	/^  inline ~TCMalloc_SpinLockHolder() { lock_->Unlock(); }$/;"	f	class:TCMalloc_SpinLockHolder	access:public	signature:()
~TemporaryChange	.\TemporaryChange.h	/^    ~TemporaryChange()$/;"	f	class:WTF::TemporaryChange	access:public	signature:()
~ThreadCondition	.\ThreadingPrimitives.h	/^    WTF_EXPORT_PRIVATE ~ThreadCondition();$/;"	p	class:WTF::ThreadCondition	access:public	signature:()
~ThreadCondition	.\ThreadingPthreads.cpp	/^ThreadCondition::~ThreadCondition()$/;"	f	class:WTF::ThreadCondition	signature:()
~ThreadCondition	.\ThreadingWin.cpp	/^ThreadCondition::~ThreadCondition()$/;"	f	class:WTF::ThreadCondition	signature:()
~ThreadIdentifierData	.\ThreadIdentifierDataPthreads.cpp	/^ThreadIdentifierData::~ThreadIdentifierData()$/;"	f	class:WTF::ThreadIdentifierData	signature:()
~ThreadIdentifierData	.\ThreadIdentifierDataPthreads.h	/^    ~ThreadIdentifierData();$/;"	p	class:WTF::ThreadIdentifierData	access:public	signature:()
~ThreadRestrictionVerifier	.\ThreadRestrictionVerifier.h	/^    ~ThreadRestrictionVerifier()$/;"	f	class:WTF::ThreadRestrictionVerifier	access:public	signature:()
~ThreadSpecific	.\ThreadSpecific.h	/^    ~ThreadSpecific();$/;"	p	class:WTF::ThreadSpecific	access:private	signature:()
~ThreadSpecific	.\ThreadSpecific.h	/^inline ThreadSpecific<T>::~ThreadSpecific()$/;"	f	class:WTF::ThreadSpecific	signature:()
~TryMallocReturnValue	.\FastMalloc.h	/^        ~TryMallocReturnValue() { ASSERT(!m_data); }$/;"	f	struct:WTF::TryMallocReturnValue	access:public	signature:()
~URLBuffer	.\url\src\URLBuffer.h	/^    virtual ~URLBuffer() { }$/;"	f	class:WTF::URLBuffer	access:public	signature:()
~Vector	.\Vector.h	/^        ~Vector()$/;"	f	class:WTF::Vector	access:public	signature:()
~VectorBuffer	.\Vector.h	/^        ~VectorBuffer()$/;"	f	class:WTF::VectorBuffer	access:public	signature:()
~VectorBufferBase	.\Vector.h	/^        ~VectorBufferBase()$/;"	f	class:WTF::VectorBufferBase	access:protected	signature:()
~VectorReverseProxy	.\Vector.h	/^            ~VectorReverseProxy();$/;"	p	class:WTF::Vector::VectorReverseProxy	access:private	signature:()
~WTFLogLocker	.\Assertions.cpp	/^    ~WTFLogLocker()$/;"	f	struct:WTFLogLocker	access:public	signature:()
~WTFThreadData	.\WTFThreadData.cpp	/^WTFThreadData::~WTFThreadData()$/;"	f	class:WTF::WTFThreadData	signature:()
~WTFThreadData	.\WTFThreadData.h	/^    WTF_EXPORT_PRIVATE ~WTFThreadData();$/;"	p	class:WTF::WTFThreadData	access:public	signature:()
